unit HCNetSDK;

interface

{$A4}  //struct采用4字节对齐
{$Z4}  //enum  采用4字节对齐

uses Windows;

//SDK版本: CH-HCNetSDKV6.1.9.48_build20230410_win32
//下载地址: https://open.hikvision.com/fileserver/filesonline/CH-HCNetSDKV6.1.9.48_build20230410_win32_20230602165100.zip

const
  DLLPATH = '.\DLL'; //要把海康威视的SDK放在此目录. 如果想放到其它目录, 需要修改此值
  DLLFILENAME = 'HCNetSDK.dll';

//使用延迟加载函数方式,例如function NET_DVR_Init(): BOOL; stdcall; external DLLFILENAME Delayed;
//以实现所有函数加载前, 把.\DLL(SDK目录)这个路径动态添加到Path环境变量中, 使得程序能搜索到这个目录.
//目的是把SDK放在EXE文件所在目录的子目录, 避免把EXE文件和SDK的DLL文件混在一起
//程序在初始化时会调用函数AddSearchPath(DLLPATH), 如本单元末尾部分所示;

type
  INT    =  Integer;
//PINT   = ^Integer;
  FLOAT  =  Single ;
  PFLOAT = ^Single ;
//PVOID  =  Pointer;
//PPVOID = ^PVOID;  

//**#ifndef _HC_NET_SDK_H_
//**#define _HC_NET_SDK_H_

//**#ifndef _WINDOWS_
//**    #if (defined(_WIN32) || defined(_WIN64))
//**        #include <winsock2.h>
//**        #include <windows.h>
//**    #endif
//**#endif

//**#if defined(_WIN64)
//**    #define OS_WINDOWS64    1
//**#endif

//**#if defined(__LP64__)
//**    #define OS_POSIX64    1
//**#endif

//**#ifndef __PLAYRECT_defined
//**    #define __PLAYRECT_defined
//**    typedef struct __PLAYRECT
//**    <
//**        int x;
//**        int y;
//**        int uWidth;
//**        int uHeight;
//**    >PLAYRECT;
//**#endif

//**#if (defined(_WIN32)) //windows
//**    #define NET_DVR_API  extern "C" __declspec(dllimport)
//**    typedef  unsigned __int64   UINT64;
//**    typedef  signed   __int64   INT64;
//**#elif defined(__linux__) || defined(__APPLE__) //linux
//**    #define  BOOL  int
//**    typedef  unsigned int       DWORD;
//**    typedef  unsigned short     WORD;
//**    typedef  unsigned short     USHORT;
//**    typedef  short              SHORT;
//**    typedef  int                LONG;
//**    typedef  unsigned char      BYTE;
//**    typedef  unsigned int       UINT;
//**    typedef  void*              LPVOID;
//**    typedef  void*              HANDLE;
//**    typedef  unsigned int*      LPDWORD;
//**    typedef  unsigned long long UINT64;
//**    typedef  signed long long   INT64;

//**    #ifndef TRUE
//**        #define TRUE  1
//**    #endif
//**    #ifndef FALSE
//**        #define FALSE 0
//**    #endif
//**    #ifndef NULL
//**        #define NULL 0
//**    #endif

//**    #define __stdcall
//**    #define CALLBACK

//**    #define NET_DVR_API extern "C"
//**    typedef unsigned int   COLORKEY;
//**    typedef unsigned int   COLORREF;

//**    #ifndef __HWND_defined
//**        #define __HWND_defined
//**        #if defined(__APPLE__) || defined(ANDROID)
//**            typedef void* HWND;
//**        #elif defined(__linux__)
//**            typedef unsigned int HWND;
//**        #else
//**            typedef void* HWND;
//**        #endif
//**    #endif

//**    #ifndef __HDC_defined
//**        #define __HDC_defined
//**        #if defined(__linux__)
//**            typedef struct __DC
//**            <
//**                void*   surface;        //SDL Surface
//**                HWND    hWnd;           //HDC window handle
//**            >DC;
//**            typedef DC* HDC;
//**        #else
//**            typedef void* HDC;
//**        #endif
//**    #endif

//**    typedef struct tagInitInfo
//**    <
//**        int uWidth;
//**        int uHeight;
//**    >INITINFO;
//**#endif

//宏定义
const
  MAX_NAMELEN = 16;    //DVR本地登陆名
  MAX_RIGHT = 32;    //设备支持的权限（1-12表示本地权限，13-32表示远程权限）
  NAME_LEN = 32;    //用户名长度
  MIN_PASSWD_LEN = 8;    //最小密码长度
  PASSWD_LEN = 16;    //密码长度
  STREAM_PASSWD_LEN = 12;    //码流加密密钥最大长度
  MAX_PASSWD_LEN_EX = 64;    //密码长度64位
  GUID_LEN = 16;    //GUID长度
  DEV_TYPE_NAME_LEN = 24;    //设备类型名称长度
  SERIALNO_LEN = 48;    //序列号长度
  MACADDR_LEN = 6;    //mac地址长度
  MAC_ADDRESS_NUM = 48;    //Mac地址长度
  MAX_SENCE_NUM = 16;    //场景数
  RULE_REGION_MAX = 128;    //最大区域
  MAX_ETHERNET = 2;    //设备可配以太网络
  MAX_NETWORK_CARD = 4;    //设备可配最大网卡数目
  MAX_NETWORK_CARD_EX = 12;    //设备可配最大网卡数目扩展
  PATHNAME_LEN = 128;    //路径长度
  MAX_PRESET_V13 = 16;    //预置点
  MAX_TEST_COMMAND_NUM = 32;    //产线测试保留字段长度
  MAX_NUMBER_LEN = 32;    //号码最大长度
  MAX_NAME_LEN = 128;    //设备名称最大长度
  MAX_INDEX_LED = 8;    //LED索引最大值 2013-11-19
  MAX_CUSTOM_DIR = 64;    //自定义目录最大长度
  URL_LEN_V40 = 256;    //最大URL长度
  CLOUD_NAME_LEN = 48;    //云存储服务器用户名长度
  CLOUD_PASSWD_LEN = 48;    //云存储服务器密码长度
  MAX_SENSORNAME_LEN = 64;    //传感器名称长度
  MAX_SENSORCHAN_LEN = 32;    //传感器通道长度
  MAX_DESCRIPTION_LEN = 32;    //传感器描述长度
  MAX_DEVNAME_LEN_EX = 64;    //设备名称长度扩展
  NET_SDK_MAX_FILE_PATH = 256;    //文件路径长度
  MAX_TMEVOICE_LEN = 64;    //TME语音播报内容长度
  ISO_8601_LEN = 32;    //ISO_8601时间长度
  MODULE_INFO_LEN = 32;    //模块信息长度
  VERSION_INFO_LEN = 32;    //版本信息长度

const
  MAX_NUM_INPUT_BOARD = 512;    //输入板最大个数
  MAX_SHIPSDETE_REGION_NUM = 8;    // 船只检测区域列表最大数目

const
  MAX_RES_NUM_ONE_VS_INPUT_CHAN = 8;    //一个虚拟屏输入通道支持的分辨率的最大数量
  MAX_VS_INPUT_CHAN_NUM = 16;    //虚拟屏输入通道最大数量

const
  NET_SDK_MAX_FDID_LEN = 256;    //人脸库ID最大长度
  NET_SDK_MAX_PICID_LEN = 256;    //人脸ID最大长度
  NET_SDK_FDPIC_CUSTOM_INFO_LEN = 96;    //人脸库图片自定义信息长度
  NET_DVR_MAX_FACE_ANALYSIS_NUM = 32;    //最大支持单张图片识别出的人脸区域个数
  NET_DVR_MAX_FACE_SEARCH_NUM = 5;    //最大支持搜索人脸区域个数
  NET_SDK_SECRETKEY_LEN = 128;    //配置文件密钥长度
  NET_SDK_CUSTOM_LEN = 512;    //自定义信息最大长度
  NET_SDK_CHECK_CODE_LEN = 128;    //校验码长度
  RELATIVE_CHANNEL_LEN = 2;    //报警关联的通道号的数量
  NET_SDK_MAX_CALLEDTARGET_NAME = 32;    //呗呼叫目标的用户名
  NET_SDK_MAX_HBDID_LEN = 256;    //256 人体库ID最大长度
//小间距LED控制器
const
  MAX_LEN_TEXT_CONTENT = 128;    //字符内容长度
  MAX_NUM_INPUT_SOURCE_TEXT = 32;    //信号源可叠加的文本数量
  MAX_NUM_OUTPUT_CHANNEL = 512;    //LED区域包含的输出口个数

//子窗口解码OSD
const
  MAX_LEN_OSD_CONTENT = 256;    //OSD信息最大长度
  MAX_NUM_OSD_ONE_SUBWND = 8;    //单个子窗口支持的最大OSD数量
  MAX_NUM_SPLIT_WND = 64;    //单个窗口支持的最大分屏窗口数量（即子窗口数量）
  MAX_NUM_OSD = 8;    

//2013-11-19
const
  MAX_DEVNAME_LEN = 32;    //设备名称最大长度
  MAX_LED_INFO = 256;    //屏幕字体显示信息最大长度
  MAX_TIME_LEN = 32;    //时间最大长度
  MAX_CARD_LEN = 24;    //卡号最大长度
  MAX_OPERATORNAME_LEN = 32;    //操作人员名称最大长度

const
  THERMOMETRY_ALARMRULE_NUM = 40;    //热成像报警规则数
  MAX_THERMOMETRY_REGION_NUM = 40;    //热度图检测区域最大支持数
  MAX_THERMOMETRY_DIFFCOMPARISON_NUM = 40;    //热成像温差报警规则数
  MAX_SHIPS_NUM = 20;    //船只检测最大船只数
  MAX_SHIPIMAGE_NUM = 6;    //船只最大抓图数
  KEY_WORD_NUM = 3;    //关键字个数
  KEY_WORD_LEN = 128;    //关键字长度
//异步登录回调状态宏定义
const
  ASYN_LOGIN_SUCC = 1;    //异步登录成功
  ASYN_LOGIN_FAILED = 0;    //异步登录失败

const
  NET_SDK_MAX_VERIFICATION_CODE_LEN = 32;    //萤石云验证码长度
  NET_SDK_MAX_OPERATE_CODE_LEN = 64;    //萤石云操作码长度
  MAX_TIMESEGMENT_V30 = 8;    //9000设备最大时间段数
  MAX_TIMESEGMENT = 4;    //8000设备最大时间段数
  MAX_ICR_NUM = 8;    //抓拍机红外滤光片预置点数2013-07-09
  MAX_VEHICLEFLOW_INFO = 24;    //车流量信息最大个数
  MAX_SHELTERNUM = 4;    //8000设备最大遮挡区域数
  MAX_DAYS = 7;    //每周天数
  PHONENUMBER_LEN = 32;    //pppoe拨号号码最大长度
  MAX_ACCESSORY_CARD = 256;    //配件板信息最大长度
  MAX_DISKNUM_V30 = 33;    //9000设备最大硬盘数/* 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘) }
  NET_SDK_MAX_NET_USER_NUM = 64;    //网络用户

const
  NET_SDK_DISK_LOCATION_LEN = 16;    //硬盘位置长度
  NET_SDK_SUPPLIER_NAME_LEN = 32;    //供应商名称长度
  NET_SDK_DISK_MODEL_LEN = 64;    //硬盘型号长度
  NET_SDK_MAX_DISK_VOLUME = 33;    //最大硬盘卷个数
  NET_SDK_DISK_VOLUME_LEN = 36;    //硬盘卷名称长度

const
  MAX_DISKNUM = 16;    //8000设备最大硬盘数
  MAX_DISKNUM_V10 = 8;    //1.2版本之前版本
  CARD_READER_DESCRIPTION = 32;    //读卡器描述
  MAX_FACE_NUM = 2;    //最大人脸数

const
  MAX_WINDOW_V30 = 32;    //9000设备本地显示最大播放窗口数
  MAX_WINDOW_V40 = 64;    //Netra 2.3.1扩展
  MAX_WINDOW = 16;    //8000设备最大硬盘数
  MAX_VGA_V30 = 4;    //9000设备最大可接VGA数
  MAX_VGA = 1;    //8000设备最大可接VGA数

const
  MAX_USERNUM_V30 = 32;    //9000设备最大用户数
  MAX_USERNUM = 16;    //8000设备最大用户数
  MAX_EXCEPTIONNUM_V30 = 32;    //9000设备最大异常处理数
  MAX_EXCEPTIONNUM = 16;    //8000设备最大异常处理数
  MAX_LINK = 6;    //8000设备单通道最大视频流连接数
  MAX_ITC_EXCEPTIONOUT = 32;    //抓拍机最大报警输出
  MAX_SCREEN_DISPLAY_LEN = 512;    //屏幕显示字符长度

const
  MAX_DECPOOLNUM = 4;    //单路解码器每个解码通道最大可循环解码数
  MAX_DECNUM = 4;    //单路解码器的最大解码通道数（实际只有一个，其他三个保留）
  MAX_TRANSPARENTNUM = 2;    //单路解码器可配置最大透明通道数
  MAX_CYCLE_CHAN = 16;    //单路解码器最大轮巡通道数
  MAX_CYCLE_CHAN_V30 = 64;    //最大轮巡通道数（扩展）
  MAX_DIRNAME_LENGTH = 80;    //最大目录长度
  MAX_WINDOWS = 16;    //最大窗口数


const
  MAX_STRINGNUM_V30 = 8;    //9000设备最大OSD字符行数数
  MAX_STRINGNUM = 4;    //8000设备最大OSD字符行数数
  MAX_STRINGNUM_EX = 8;    //8000定制扩展
  MAX_AUXOUT_V30 = 16;    //9000设备最大辅助输出数
  MAX_AUXOUT = 4;    //8000设备最大辅助输出数
  MAX_HD_GROUP = 16;    //9000设备最大硬盘组数
  MAX_HD_GROUP_V40 = 32;    //设备最大硬盘组数
  MAX_NFS_DISK = 8;    //8000设备最大NFS硬盘数
  NET_SDK_VERSION_LIST_LEN = 64;    //算法库版本最大值
  IW_ESSID_MAX_SIZE = 32;    //WIFI的SSID号长度
  IW_ENCODING_TOKEN_MAX = 32;    //WIFI密锁最大字节数
  MAX_SERIAL_NUM = 64;    //最多支持的透明通道路数
  MAX_DDNS_NUMS = 10;    //9000设备最大可配ddns数
  MAX_DOMAIN_NAME = 64;    // 最大域名长度 
  MAX_EMAIL_ADDR_LEN = 48;    //最大email地址长度
  MAX_EMAIL_PWD_LEN = 32;    //最大email密码长度
  MAX_SLAVECAMERA_NUM = 8;    //从摄像机个数
  MAX_CALIB_NUM = 6;    //标定点的个数
  MAX_CALIB_NUM_EX = 20;    //扩展标定点的个数
  MAX_LEDDISPLAYINFO_LEN = 1024;    //最大LED屏显示长度
  MAX_PEOPLE_DETECTION_NUM = 8;    //最大人员检测区域数
  MAXPROGRESS = 100;    //回放时的最大百分率
  MAX_SERIALNUM = 2;    //8000设备支持的串口数 1-232， 2-485
  CARDNUM_LEN = 20;    //卡号长度
  PATIENTID_LEN = 64;    
  CARDNUM_LEN_OUT = 32;    //外部结构体卡号长度
  MAX_VIDEOOUT_V30 = 4;    //9000设备的视频输出数
  MAX_VIDEOOUT = 2;    //8000设备的视频输出数

const
  MAX_PRESET_V30 = 256;    // 9000设备支持的云台预置点数 
  MAX_TRACK_V30 = 256;    // 9000设备支持的云台数 
  MAX_CRUISE_V30 = 256;    // 9000设备支持的云台巡航数 
  MAX_PRESET = 128;    // 8000设备支持的云台预置点数 
  MAX_TRACK = 128;    // 8000设备支持的云台数 
  MAX_CRUISE = 128;    // 8000设备支持的云台巡航数 

const
  MAX_PRESET_V40 = 300;    // 云台支持的最大预置点数 
  MAX_CRUISE_POINT_NUM = 128;    // 最大支持的巡航点的个数 
  MAX_CRUISEPOINT_NUM_V50 = 256;    //最大支持的巡航点的个数扩展

const
  CRUISE_MAX_PRESET_NUMS = 32;    // 一条巡航最多的巡航点 
  MAX_FACE_PIC_NUM = 30;    //人脸子图个数
  LOCKGATE_TIME_NUM = 4;    //锁闸时间段个数

const
  MAX_SERIAL_PORT = 8;    //9000设备支持232串口数
  MAX_PREVIEW_MODE = 8;    // 设备支持最大预览模式数目 1画面,4画面,9画面,16画面.... 
  MAX_MATRIXOUT = 16;    // 最大模拟矩阵输出个数 
  LOG_INFO_LEN = 11840;    // 日志附加信息 
  DESC_LEN = 16;    // 云台描述字符串长度 
  PTZ_PROTOCOL_NUM = 200;    // 9000最大支持的云台协议数 
  IPC_PROTOCOL_NUM = 50;    //ipc 协议最大个数

const
  MAX_AUDIO = 1;    //8000语音对讲通道数
  MAX_AUDIO_V30 = 2;    //9000语音对讲通道数
  MAX_CHANNUM = 16;    //8000设备最大通道数
  MAX_ALARMIN = 16;    //8000设备最大报警输入数
  MAX_ALARMOUT = 4;    //8000设备最大报警输出数
  MAX_AUDIOCAST_CFG_TYPE = 3;    //支持广播参数配置的类型数量 MP3、MPEG2、AAC
//9000 IPC接入
const
  MAX_ANALOG_CHANNUM = 32;    //最大32个模拟通道
  MAX_ANALOG_ALARMOUT = 32;    //最大32路模拟报警输出
  MAX_ANALOG_ALARMIN = 32;    //最大32路模拟报警输入

const
  MAX_IP_DEVICE = 32;    //允许接入的最大IP设备数
  MAX_IP_DEVICE_V40 = 64;    // 允许接入的最大IP设备数 最多可添加64个 IVMS 2000等新设备
  MAX_IP_CHANNEL = 32;    //允许加入的最多IP通道数
  MAX_IP_ALARMIN = 128;    //允许加入的最多报警输入数
  MAX_IP_ALARMOUT = 64;    //允许加入的最多报警输出数
  MAX_IP_ALARMIN_V40 = 4096;    //允许加入的最多报警输入数
  MAX_IP_ALARMOUT_V40 = 4096;    //允许加入的最多报警输出数

const
  MAX_RECORD_FILE_NUM = 20;    // 每次删除或者刻录的最大文件数
//SDK_V31 ATM
const
  MAX_ACTION_TYPE = 12;    //自定义协议叠加交易行为最大行为个数
  MAX_ATM_PROTOCOL_NUM = 256;    //每种输入方式对应的ATM最大协议数
  ATM_CUSTOM_PROTO = 1025;    //自定义协议 值为1025
  ATM_PROTOCOL_SORT = 4;    //ATM协议段数
  ATM_DESC_LEN = 32;    //ATM描述字符串长度
// SDK_V31 ATM


const
  MAX_IPV6_LEN = 64;    //IPv6地址最大长度
  MAX_EVENTID_LEN = 64;    //事件ID长度

const
  INVALID_VALUE_UINT32 = $ffffffff;    //无效值
  MAX_CHANNUM_V40 = 512;    
  MAX_MULTI_AREA_NUM = 24;    

//SDK 录播主机
const
  COURSE_NAME_LEN = 32;    //课程名称
  INSTRUCTOR_NAME_LEN = 16;    //授课教师
  COURSE_DESCRIPTION_LEN = 256;    //课程信息

const
  MAX_TIMESEGMENT_V40 = 16;    //每节课信息


const
  MAX_MIX_CHAN_NUM = 16;    //目前支持的最大混音通道数，背景通道 + MIC + LINE IN + 最多4个小画面
  MAX_LINE_IN_CHAN_NUM = 16;    //最大line in通道数
  MAX_MIC_CHAN_NUM = 16;    //最大MIC通道数
  INQUEST_CASE_NO_LEN = 64;    //审讯案件编号长度
  INQUEST_CASE_NAME_LEN = 64;    //审讯案件名称长度
  CUSTOM_INFO_LEN = 64;    //自定义信息长度
  INQUEST_CASE_LEN = 64;    //审讯信息长度


const
  MAX_FILE_ID_LEN = 128;    //视图库项目中文件ID的最大长度
  MAX_PIC_NAME_LEN = 128;    //图片名称长度

// 最大支持的通道数 最大模拟加上最大IP支持 
const
  MAX_CHANNUM_V30 = ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL );    //64
  MAX_ALARMOUT_V40 = (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT);    //4128
  MAX_ALARMOUT_V30 = ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT );    //96
  MAX_ALARMIN_V30 = ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN );    //160
  MAX_ALARMIN_V40 = (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT);    //4128
  MAX_ANALOG_ALARM_WITH_VOLT_LIMIT = 16;    //受电压限定的模拟报警最大输入数

const
  MAX_ROIDETECT_NUM = 8;    //支持的ROI区域数
  MAX_LANERECT_NUM = 5;    //最大车牌识别区域数
  MAX_FORTIFY_NUM = 10;    //最大布防个数
  MAX_INTERVAL_NUM = 4;    //最大时间间隔个数
  MAX_CHJC_NUM = 3;    //最大车辆省份简称字符个数
  MAX_VL_NUM = 5;    //最大虚拟线圈个数
  MAX_DRIVECHAN_NUM = 16;    //最大车道数
  MAX_COIL_NUM = 3;    //最大线圈个数
  MAX_SIGNALLIGHT_NUM = 6;    //最大信号灯个数
  LEN_16 = 16;    
  LEN_32 = 32;    
  LEN_64 = 64;    
  LEN_31 = 31;    
  MAX_LINKAGE_CHAN_NUM = 16;    //报警联动的通道的最大数量
  MAX_CABINET_COUNT = 8;    //最大支持机柜数量
  MAX_ID_LEN = 48;    
  MAX_PARKNO_LEN = 16;    
  MAX_ALARMREASON_LEN = 32;    
  MAX_UPGRADE_INFO_LEN = 48;    //获取升级文件匹配信息(模糊升级)
  MAX_CUSTOMDIR_LEN = 32;    //自定义目录长度
  MAX_LED_INFO_LEN = 512;    //LED内容长度
  MAX_VOICE_INFO_LEN = 128;    //语音播报内容长度
  MAX_LITLE_INFO_LEN = 64;    //纸票标题内容长度
  MAX_CUSTOM_INFO_LEN = 64;    //纸票自定义信息内容长度
  MAX_PHONE_NUM_LEN = 16;    //联系电话内容长度
  MAX_APP_SERIALNUM_LEN = 32;    //应用序列号长度

const
  AUDIOTALKTYPE_G722 = 0;    
  AUDIOTALKTYPE_G711_MU = 1;    
  AUDIOTALKTYPE_G711_A = 2;    
  AUDIOTALKTYPE_MP2L2 = 5;    
  AUDIOTALKTYPE_G726 = 6;    
  AUDIOTALKTYPE_AAC = 7;    
  AUDIOTALKTYPE_PCM = 8;    
  AUDIOTALKTYPE_G722C = 9;    
  AUDIOTALKTYPE_MP3 = 15;    

//packet type
const
  FILE_HEAD = 0;    //file head
  VIDEO_I_FRAME = 1;    //video I frame
  VIDEO_B_FRAME = 2;    //video B frame
  VIDEO_P_FRAME = 3;    //video P frame
  AUDIO_PACKET = 10;    //audio packet
  PRIVT_PACKET = 11;    //private packet
//E frame
const
  HIK_H264_E_FRAME = (1 shl 6);    // 以前E帧不用了,深P帧也没用到
  MAX_TRANSPARENT_CHAN_NUM = 4;    //每个串口允许建立的最大透明通道数
  MAX_TRANSPARENT_ACCESS_NUM = 4;    //每个监听端口允许接入的最大主机数

//ITS
const
  MAX_PARKING_STATUS = 8;    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
  MAX_PARKING_NUM = 4;    //一个通道最大4个车位 (从左到右车位 数组0～3)

const
  MAX_ITS_SCENE_NUM = 16;    //最大场景数量
  MAX_SCENE_TIMESEG_NUM = 16;    //最大场景时间段数量
  MAX_IVMS_IP_CHANNEL = 128;    //最大IP通道数
  DEVICE_ID_LEN = 48;    //设备编号长度
  MONITORSITE_ID_LEN = 48;    //显示点编号长度
  MAX_AUXAREA_NUM = 16;    //辅助区域最大数目
  MAX_SLAVE_CHANNEL_NUM = 16;    //最大从通道数量
  MAX_DEVDESC_LEN = 64;    //设备描述信息最大长度
  ILLEGAL_LEN = 32;    //违法代码长度
  MAX_TRUCK_AXLE_NUM = 10;    //货车轴最大数
  MAX_CATEGORY_LEN = 8;    //车牌附加信息最大字符
  SERIAL_NO_LEN = 16;    //泊车位编号


const
  MAX_SECRETKEY_LEN = 512;    //最大秘钥长度
  MAX_INDEX_CODE_LEN = 64;    //最大序号长度
  MAX_ILLEGAL_LEN = 64;    //违法代码最大字符长度
  CODE_LEN = 64;    //授权码
  ALIAS_LEN = 32;    //别名，只读
  MAX_SCH_TASKS_NUM = 10;    

const
  MAX_SERVERID_LEN = 64;    //最大服务器ID的长度
  MAX_SERVERDOMAIN_LEN = 128;    //服务器域名最大长度
  MAX_AUTHENTICATEID_LEN = 64;    //认证ID最大长度
  MAX_AUTHENTICATEPASSWD_LEN = 32;    //认证密码最大长度
  MAX_SERVERNAME_LEN = 64;    //最大服务器用户名
  MAX_COMPRESSIONID_LEN = 64;    //编码ID的最大长度
  MAX_SIPSERVER_ADDRESS_LEN = 128;    //SIP服务器地址支持域名和IP地址
//压线报警
const
  MAX_PlATE_NO_LEN = 32;    //车牌号码最大长度 2013-09-27
  UPNP_PORT_NUM = 12;    //upnp端口映射端口数目

//  MAX_PEOPLE_DETECTION_NUM = 8;    //最大人员检测区域数

const
  MAX_NOTICE_NUMBER_LEN = 32;    //公告编号最大长度
  MAX_NOTICE_THEME_LEN = 64;    //公告主题最大长度
  MAX_NOTICE_DETAIL_LEN = 1024;    //公告详情最大长度
  MAX_NOTICE_PIC_NUM = 6;    //公告信息最大图片数量
  MAX_DEV_NUMBER_LEN = 32;    //设备编号最大长度
  LOCK_NAME_LEN = 32;    //锁名称


const
  HOLIDAY_GROUP_NAME_LEN = 32;    //假日组名称长度
  MAX_HOLIDAY_PLAN_NUM = 16;    //假日组最大假日计划数
  TEMPLATE_NAME_LEN = 32;    //计划模板名称长度
  MAX_HOLIDAY_GROUP_NUM = 16;    //计划模板最大假日组数
  DOOR_NAME_LEN = 32;    //门名称
  STRESS_PASSWORD_LEN = 8;    //胁迫密码长度
  SUPER_PASSWORD_LEN = 8;    //胁迫密码长度
  GROUP_NAME_LEN = 32;    //群组名称长度
  GROUP_COMBINATION_NUM = 8;    //群组组合数
  MULTI_CARD_GROUP_NUM = 4;    //单门最大多重卡组数
  ACS_CARD_NO_LEN = 32;    //门禁卡号长度
  NET_SDK_EMPLOYEE_NO_LEN = 32;    //工号长度
  NET_SDK_UUID_LEN = 36;    //UUID长度
  NET_SDK_EHOME_KEY_LEN = 32;    //EHome Key长度
  CARD_PASSWORD_LEN = 8;    //卡密码长度
  MAX_DOOR_NUM = 32;    //最大门数
  MAX_CARD_RIGHT_PLAN_NUM = 4;    //卡权限最大计划个数
  MAX_GROUP_NUM_128 = 128;    //最大群组数
  MAX_CARD_READER_NUM = 64;    //最大读卡器数
  MAX_SNEAK_PATH_NODE = 8;    //最大后续读卡器数
  MAX_MULTI_DOOR_INTERLOCK_GROUP = 8;    //最大多门互锁组数
  MAX_INTER_LOCK_DOOR_NUM = 8;    //一个多门互锁组中最大互锁门数
  MAX_CASE_SENSOR_NUM = 8;    //最大case sensor触发器数
  MAX_DOOR_NUM_256 = 256;    //最大门数
  MAX_READER_ROUTE_NUM = 16;    //最大刷卡循序路径
  MAX_FINGER_PRINT_NUM = 10;    //最大指纹个数
  MAX_CARD_READER_NUM_512 = 512;    //最大读卡器数
  NET_SDK_MULTI_CARD_GROUP_NUM_20 = 20;    //单门最大多重卡组数

const
  ERROR_MSG_LEN = 32;    //下发错误信息
  MAX_DOOR_CODE_LEN = 8;    //房间代码长度
  MAX_LOCK_CODE_LEN = 8;    //锁代码长度
  PER_RING_PORT_NUM = 2;    //每个环的端口数
  SENSORNAME_LEN = 32;    //传感器名称长度
  MAX_SENSORDESCR_LEN = 64;    //传感器描述长度
  MAX_DNS_SERVER_NUM = 2;    //最大DNS个数
  SENSORUNIT_LEN = 32;    //最大单位长度

const
  WEP_KEY_MAX_SIZE = 32;    //最大WEP加密密钥长度
  WEP_KEY_MAX_NUM = 4;    //最大WEP加密密钥个数
  WPA_KEY_MAX_SIZE = 64;    //最大WPA共享密钥长度

const
  MAX_SINGLE_FTPPICNAME_LEN = 20;    //最大单个FTP通道名称
  MAX_CAMNAME_LEN = 32;    //最大通道名称
  MAX_FTPNAME_NUM = 12;    //TFP名称数


const
  MAX_IDCODE_LEN = 128;    //  识别码最大长度
  MAX_VERSIIN_LEN = 64;    //版本最大长度
  MAX_IDCODE_NUM = 32;    // 识别码个数
  SDK_LEN_2048 = 2048;    
  SDK_MAX_IP_LEN = 48;    

const
  RECT_POINT_NUM = 4;    //矩形角数

const
  MAX_PUBLIC_KEY_LEN = 512;    // 最大公钥长度
  CHIP_SERIALNO_LEN = 32;    //加密芯片序列号长度
  ENCRYPT_DEV_ID_LEN = 20;    //设备ID长度

//MCU相关的
const
  MAX_SEARCH_ID_LEN = 36;    //搜索标识符最大长度
  TERMINAL_NAME_LEN = 64;    //终端名称长度
  MAX_URL_LEN = 512;    //URL长度
  REGISTER_NAME_LEN = 64;    //终端注册GK名称最大长度

//光纤
const
  MAX_PORT_NUM = 64;    //最大端口数
  MAX_SINGLE_CARD_PORT_NO = 4;    //光纤收发器单卡最大端口数
  MAX_FUNC_CARD_NUM = 32;    //光纤收发器最大功能卡数
  MAX_FC_CARD_NUM = 33;    //光纤收发器最大卡数
  MAX_REMARKS_LEN = 128;    //注释最大长度
  MAX_OUTPUT_PORT_NUM = 32;    //单路输出包含的最大输出端口数
  MAX_SINGLE_PORT_RECVCARD_NUM = 64;    //单个端口连接的最大接收卡数
  MAX_GAMMA_X_VALUE = 256;    //GAMMA表X轴取值个数
  NET_DEV_NAME_LEN = 64;    //设备名称长度
  NET_DEV_TYPE_NAME_LEN = 64;    //设备类型名称长度
  ABNORMAL_INFO_NUM = 4;    //异常时间段个数

const
  PLAYLIST_NAME_LEN = 64;    //播放表名称长度
  PLAYLIST_ITEM_NUM = 64;    //播放项数目

//后端相关
const
  NET_SDK_MAX_LOGIN_PASSWORD_LEN = 128;    //用户登录密码最大长度
  NET_SDK_MAX_ANSWER_LEN = 256;    //安全问题答案最大长度
  NET_SDK_MAX_QUESTION_LIST_LEN = 32;    //安全问题列表最大长度

const
  MAX_SCREEN_AREA_NUM = 128;    //屏幕区域最大数量
  NET_SDK_MAX_THERMOMETRYALGNAME = 128;    //测温算法库版本最大长度
  NET_SDK_MAX_SHIPSALGNAME = 128;    //船只算法库版本最大长度
  NET_SDK_MAX_FIRESALGNAME = 128;    //火点算法库版本最大长度

const
  MAX_PASSPORT_NUM_LEN = 16;    //最大护照证件号长度
  MAX_PASSPORT_INFO_LEN = 128;    //最大护照通用信息长度
  MAX_PASSPORT_NAME_LEN = 64;    //最大护照姓名长度
  MAX_PASSPORT_MONITOR_LEN = 1024;    //最大护照监护信息长度
  MAX_NATIONALITY_LEN = 16;    //最大护照国籍长度
  MAX_PASSPORT_TYPE_LEN = 4;    //最大护照证件类型长度

//******************全局错误码 begin*********************
const
  NET_DVR_NOERROR = 0;    //没有错误
  NET_DVR_PASSWORD_ERROR = 1;    //用户名密码错误
  NET_DVR_NOENOUGHPRI = 2;    //权限不足
  NET_DVR_NOINIT = 3;    //没有初始化
  NET_DVR_CHANNEL_ERROR = 4;    //通道号错误
  NET_DVR_OVER_MAXLINK = 5;    //连接到DVR的客户端个数超过最大
  NET_DVR_VERSIONNOMATCH = 6;    //版本不匹配
  NET_DVR_NETWORK_FAIL_CONNECT = 7;    //连接服务器失败
  NET_DVR_NETWORK_SEND_ERROR = 8;    //向服务器发送失败
  NET_DVR_NETWORK_RECV_ERROR = 9;    //从服务器接收数据失败
  NET_DVR_NETWORK_RECV_TIMEOUT = 10;    //从服务器接收数据超时
  NET_DVR_NETWORK_ERRORDATA = 11;    //传送的数据有误
  NET_DVR_ORDER_ERROR = 12;    //调用次序错误
  NET_DVR_OPERNOPERMIT = 13;    //无此权限
  NET_DVR_COMMANDTIMEOUT = 14;    //DVR命令执行超时
  NET_DVR_ERRORSERIALPORT = 15;    //串口号错误
  NET_DVR_ERRORALARMPORT = 16;    //报警端口错误
  NET_DVR_PARAMETER_ERROR = 17;    //参数错误
  NET_DVR_CHAN_EXCEPTION = 18;    //服务器通道处于错误状态
  NET_DVR_NODISK = 19;    //没有硬盘
  NET_DVR_ERRORDISKNUM = 20;    //硬盘号错误
  NET_DVR_DISK_FULL = 21;    //服务器硬盘满
  NET_DVR_DISK_ERROR = 22;    //服务器硬盘出错
  NET_DVR_NOSUPPORT = 23;    //服务器不支持
  NET_DVR_BUSY = 24;    //服务器忙
  NET_DVR_MODIFY_FAIL = 25;    //服务器修改不成功
  NET_DVR_PASSWORD_FORMAT_ERROR = 26;    //密码输入格式不正确
  NET_DVR_DISK_FORMATING = 27;    //硬盘正在格式化，不能启动操作
  NET_DVR_DVRNORESOURCE = 28;    //DVR资源不足
  NET_DVR_DVROPRATEFAILED = 29;    //DVR操作失败
  NET_DVR_OPENHOSTSOUND_FAIL = 30;    //打开PC声音失败
  NET_DVR_DVRVOICEOPENED = 31;    //服务器语音对讲被占用
  NET_DVR_TIMEINPUTERROR = 32;    //时间输入不正确
  NET_DVR_NOSPECFILE = 33;    //回放时服务器没有指定的文件
  NET_DVR_CREATEFILE_ERROR = 34;    //创建文件出错
  NET_DVR_FILEOPENFAIL = 35;    //打开文件出错
  NET_DVR_OPERNOTFINISH = 36;    //上次的操作还没有完成
  NET_DVR_GETPLAYTIMEFAIL = 37;    //获取当前播放的时间出错
  NET_DVR_PLAYFAIL = 38;    //播放出错
  NET_DVR_FILEFORMAT_ERROR = 39;    //文件格式不正确
  NET_DVR_DIR_ERROR = 40;    //路径错误
  NET_DVR_ALLOC_RESOURCE_ERROR = 41;    //资源分配错误
  NET_DVR_AUDIO_MODE_ERROR = 42;    //声卡模式错误
  NET_DVR_NOENOUGH_BUF = 43;    //缓冲区太小
  NET_DVR_CREATESOCKET_ERROR = 44;    //创建SOCKET出错
  NET_DVR_SETSOCKET_ERROR = 45;    //设置SOCKET出错
  NET_DVR_MAX_NUM = 46;    //个数达到最大
  NET_DVR_USERNOTEXIST = 47;    //用户不存在
  NET_DVR_WRITEFLASHERROR = 48;    //写FLASH出错
  NET_DVR_UPGRADEFAIL = 49;    //DVR升级失败
  NET_DVR_CARDHAVEINIT = 50;    //解码卡已经初始化过
  NET_DVR_PLAYERFAILED = 51;    //调用播放库中某个函数失败
  NET_DVR_MAX_USERNUM = 52;    //设备端用户数达到最大
  NET_DVR_GETLOCALIPANDMACFAIL = 53;    //获得客户端的IP地址或物理地址失败
  NET_DVR_NOENCODEING = 54;    //该通道没有编码
  NET_DVR_IPMISMATCH = 55;    //IP地址不匹配
  NET_DVR_MACMISMATCH = 56;    //MAC地址不匹配
  NET_DVR_UPGRADELANGMISMATCH = 57;    //升级文件语言不匹配
  NET_DVR_MAX_PLAYERPORT = 58;    //播放器路数达到最大
  NET_DVR_NOSPACEBACKUP = 59;    //备份设备中没有足够空间进行备份
  NET_DVR_NODEVICEBACKUP = 60;    //没有找到指定的备份设备
  NET_DVR_PICTURE_BITS_ERROR = 61;    //图像素位数不符，限24色
  NET_DVR_PICTURE_DIMENSION_ERROR = 62;    //图片高*宽超限， 限128*256
  NET_DVR_PICTURE_SIZ_ERROR = 63;    //图片大小超限，限100K
  NET_DVR_LOADPLAYERSDKFAILED = 64;    //载入当前目录下Player Sdk出错
  NET_DVR_LOADPLAYERSDKPROC_ERROR = 65;    //找不到Player Sdk中某个函数入口
  NET_DVR_LOADDSSDKFAILED = 66;    //载入当前目录下DSsdk出错
  NET_DVR_LOADDSSDKPROC_ERROR = 67;    //找不到DsSdk中某个函数入口
  NET_DVR_DSSDK_ERROR = 68;    //调用硬解码库DsSdk中某个函数失败
  NET_DVR_VOICEMONOPOLIZE = 69;    //声卡被独占
  NET_DVR_JOINMULTICASTFAILED = 70;    //加入多播组失败
  NET_DVR_CREATEDIR_ERROR = 71;    //建立日志文件目录失败
  NET_DVR_BINDSOCKET_ERROR = 72;    //绑定套接字失败
  NET_DVR_SOCKETCLOSE_ERROR = 73;    //socket连接中断，此错误通常是由于连接中断或目的地不可达
  NET_DVR_USERID_ISUSING = 74;    //注销时用户ID正在进行某操作
  NET_DVR_SOCKETLISTEN_ERROR = 75;    //监听失败
  NET_DVR_PROGRAM_EXCEPTION = 76;    //程序异常
  NET_DVR_WRITEFILE_FAILED = 77;    //写文件失败
  NET_DVR_FORMAT_READONLY = 78;    //禁止格式化只读硬盘
  NET_DVR_WITHSAMEUSERNAME = 79;    //用户配置结构中存在相同的用户名
  NET_DVR_DEVICETYPE_ERROR = 80;    //导入参数时设备型号不匹配
  NET_DVR_LANGUAGE_ERROR = 81;    //导入参数时语言不匹配
  NET_DVR_PARAVERSION_ERROR = 82;    //导入参数时软件版本不匹配
  NET_DVR_IPCHAN_NOTALIVE = 83;    //预览时外接IP通道不在线
  NET_DVR_RTSP_SDK_ERROR = 84;    //加载高清IPC通讯库StreamTransClient.dll失败
  NET_DVR_CONVERT_SDK_ERROR = 85;    //加载转码库失败
  NET_DVR_IPC_COUNT_OVERFLOW = 86;    //超出最大的ip接入通道数
  NET_DVR_MAX_ADD_NUM = 87;    //添加标签(一个文件片段64)等个数达到最大
  NET_DVR_PARAMMODE_ERROR = 88;    //图像增强仪，参数模式错误（用于硬件设置时，客户端进行软件设置时错误值）
  NET_DVR_CODESPITTER_OFFLINE = 89;    //视频综合平台，码分器不在线
  NET_DVR_BACKUP_COPYING = 90;    //设备正在备份
  NET_DVR_CHAN_NOTSUPPORT = 91;    // 通道不支持该操作
  NET_DVR_CALLINEINVALID = 92;    // 高度线位置太集中或长度线不够倾斜
  NET_DVR_CALCANCELCONFLICT = 93;    // 取消标定冲突，如果设置了规则及全局的实际大小尺寸过滤
  NET_DVR_CALPOINTOUTRANGE = 94;    // 标定点超出范围
  NET_DVR_FILTERRECTINVALID = 95;    // 尺寸过滤器不符合要求
  NET_DVR_DDNS_DEVOFFLINE = 96;    //设备没有注册到ddns上
  NET_DVR_DDNS_INTER_ERROR = 97;    //DDNS 服务器内部错误
  NET_DVR_FUNCTION_NOT_SUPPORT_OS = 98;    //此功能不支持该操作系统
  NET_DVR_DEC_CHAN_REBIND = 99;    //解码通道绑定显示输出次数受限
  NET_DVR_INTERCOM_SDK_ERROR = 100;    //加载当前目录下的语音对讲库失败
  NET_DVR_NO_CURRENT_UPDATEFILE = 101;    //没有正确的升级包
  NET_DVR_USER_NOT_SUCC_LOGIN = 102;    //用户还没登陆成功
  NET_DVR_USE_LOG_SWITCH_FILE = 103;    //正在使用日志开关文件
  NET_DVR_POOL_PORT_EXHAUST = 104;    //端口池中用于绑定的端口已耗尽
  NET_DVR_PACKET_TYPE_NOT_SUPPORT = 105;    //码流封装格式错误
  NET_DVR_IPPARA_IPID_ERROR = 106;    //IP接入配置时IPID有误

const
  NET_DVR_LOAD_HCPREVIEW_SDK_ERROR = 107;    //预览组件加载失败
  NET_DVR_LOAD_HCVOICETALK_SDK_ERROR = 108;    //语音组件加载失败
  NET_DVR_LOAD_HCALARM_SDK_ERROR = 109;    //报警组件加载失败
  NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR = 110;    //回放组件加载失败
  NET_DVR_LOAD_HCDISPLAY_SDK_ERROR = 111;    //显示组件加载失败
  NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR = 112;    //行业应用组件加载失败
  NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR = 113;    //通用配置管理组件加载失败
  NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR = 114;    //设备配置核心组件加载失败
  NET_DVR_LOAD_HCNETUTILS_SDK_ERROR = 115;    //HCNetUtils加载失败

const
  NET_DVR_CORE_VER_MISMATCH = 121;    //单独加载组件时，组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCPREVIEW = 122;    //预览组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCVOICETALK = 123;    //语音组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCALARM = 124;    //报警组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK = 125;    //回放组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCDISPLAY = 126;    //显示组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY = 127;    //行业应用组件与core版本不匹配
  NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR = 128;    //通用配置管理组件与core版本不匹配

const
  NET_DVR_COM_VER_MISMATCH_HCPREVIEW = 136;    //预览组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCVOICETALK = 137;    //语音组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCALARM = 138;    //报警组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCPLAYBACK = 139;    //回放组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCDISPLAY = 140;    //显示组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCINDUSTRY = 141;    //行业应用组件与HCNetSDK版本不匹配
  NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR = 142;    //通用配置管理组件与HCNetSDK版本不匹配

const
  NET_ERR_CONFIG_FILE_IMPORT_FAILED = 145;    //配置文件导入失败
  NET_ERR_CONFIG_FILE_EXPORT_FAILED = 146;    //配置文件导出失败
  NET_DVR_CERTIFICATE_FILE_ERROR = 147;    //证书错误
  NET_DVR_LOAD_SSL_LIB_ERROR = 148;    //加载SSL库失败（可能是版本不匹配，也可能是不存在）
  NET_DVR_SSL_VERSION_NOT_MATCH = 149;    //SSL库版本不匹配

const
  NET_DVR_ALIAS_DUPLICATE = 150;    //别名重复  //2011-08-31 通过别名或者序列号来访问设备的新版本ddns的配置
  NET_DVR_INVALID_COMMUNICATION = 151;    //无效通信
  NET_DVR_USERNAME_NOT_EXIST = 152;    //用户名不存在（用户名不存在，IPC5.1.7中发布出去了，所以删不掉。后续的产品这个错误码用不上）
  NET_DVR_USER_LOCKED = 153;    //用户被锁定
  NET_DVR_INVALID_USERID = 154;    //无效用户ID
  NET_DVR_LOW_LOGIN_VERSION = 155;    //登录版本低
  NET_DVR_LOAD_LIBEAY32_DLL_ERROR = 156;    //加载libeay32.dll库失败
  NET_DVR_LOAD_SSLEAY32_DLL_ERROR = 157;    //加载ssleay32.dll库失败
  NET_ERR_LOAD_LIBICONV = 158;    //加载libiconv库失败
  NET_ERR_SSL_CONNECT_FAILED = 159;    //SSL连接失败
  NET_ERR_MCAST_ADDRESS_ERROR = 160;    //获取多播地址错误
  NET_ERR_LOAD_ZLIB = 161;    //加载zlib.dll库失败
  NET_ERR_OPENSSL_NO_INIT = 162;    //Openssl库未初始化

const
  NET_DVR_SERVER_NOT_EXIST = 164;    //对应的服务器找不到,查找时输入的国家编号或者服务器类型错误
  NET_DVR_TEST_SERVER_FAIL_CONNECT = 165;    //连接测试服务器失败
  NET_DVR_NAS_SERVER_INVALID_DIR = 166;    //NAS服务器挂载目录失败，目录无效
  NET_DVR_NAS_SERVER_NOENOUGH_PRI = 167;    //NAS服务器挂载目录失败，没有权限
  NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS = 168;    //服务器使用域名，但是没有配置DNS，可能造成域名无效。
  NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY = 169;    //没有配置网关，可能造成发送邮件失败。
  NET_DVR_TEST_SERVER_PASSWORD_ERROR = 170;    //用户名密码不正确，测试服务器的用户名或密码错误
  NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP = 171;    //设备和smtp服务器交互异常
  NET_DVR_FTP_SERVER_FAIL_CREATE_DIR = 172;    //FTP服务器创建目录失败
  NET_DVR_FTP_SERVER_NO_WRITE_PIR = 173;    //FTP服务器没有写入权限
  NET_DVR_IP_CONFLICT = 174;    //IP冲突
  NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE = 175;    //存储池空间已满
  NET_DVR_STORAGEPOOL_INVALID = 176;    //云服务器存储池无效,没有配置存储池或者存储池ID错误
  NET_DVR_EFFECTIVENESS_REBOOT = 177;    //生效需要重启
  NET_ERR_ANR_ARMING_EXIST = 178;    //断网续传布防连接已经存在(该错误码是在私有布防连接建立的情况下，重复布防的断网续传功能时，返回。)
  NET_ERR_UPLOADLINK_EXIST = 179;    //断网续传上传连接已经存在(EHOME协议和SDK协议是不能同时支持断网续传的，当一个协议存在的时候，另外一个连接建立话，报错这个错误码。)
  NET_ERR_INCORRECT_FILE_FORMAT = 180;    //导入文件格式不正确
  NET_ERR_INCORRECT_FILE_CONTENT = 181;    //导入文件内容不正确
  NET_ERR_MAX_HRUDP_LINK = 182;    //HRUDP 连接数 超过设备限制
  NET_SDK_ERR_ACCESSKEY_SECRETKEY = 183;    // 接入秘钥或加密秘钥不正确
  NET_SDK_ERR_CREATE_PORT_MULTIPLEX = 184;    //创建端口复用失败
  NET_DVR_NONBLOCKING_CAPTURE_NOTSUPPORT = 185;    //不支持无阻塞抓图
  NET_SDK_ERR_FUNCTION_INVALID = 186;    //已开启异步，该功能无效
  NET_SDK_ERR_MAX_PORT_MULTIPLEX = 187;    //已达到端口复用最大数目
  NET_DVR_INVALID_LINK = 188;    //连接尚未建立或连接无效
  NET_DVR_ISAPI_NOT_SUPPORT = 189;    //接口不支持ISAPI协议

// 2010-5-28
// 阵列错误码
const
  RAID_ERROR_INDEX = 200;    
  NET_DVR_NAME_NOT_ONLY = (RAID_ERROR_INDEX + 0);    // 名称已存在
  NET_DVR_OVER_MAX_ARRAY = (RAID_ERROR_INDEX + 1 );    // 阵列达到上限
  NET_DVR_OVER_MAX_VD = (RAID_ERROR_INDEX + 2 );    // 虚拟磁盘达到上限
  NET_DVR_VD_SLOT_EXCEED = (RAID_ERROR_INDEX + 3 );    // 虚拟磁盘槽位已满
  NET_DVR_PD_STATUS_INVALID = (RAID_ERROR_INDEX + 4 );    // 重建阵列所需物理磁盘状态错误
  NET_DVR_PD_BE_DEDICATE_SPARE = (RAID_ERROR_INDEX + 5 );    // 重建阵列所需物理磁盘为指定热备
  NET_DVR_PD_NOT_FREE = (RAID_ERROR_INDEX + 6 );    // 重建阵列所需物理磁盘非空闲
  NET_DVR_CANNOT_MIG2NEWMODE = (RAID_ERROR_INDEX + 7 );    // 不能从当前的阵列类型迁移到新的阵列类型
  NET_DVR_MIG_PAUSE = (RAID_ERROR_INDEX + 8 );    // 迁移操作已暂停
  NET_DVR_MIG_CANCEL = (RAID_ERROR_INDEX + 9 );    // 正在执行的迁移操作已取消
  NET_DVR_EXIST_VD = (RAID_ERROR_INDEX + 10);    // 阵列上阵列上存在虚拟磁盘，无法删除阵列
  NET_DVR_TARGET_IN_LD_FUNCTIONAL = (RAID_ERROR_INDEX + 11);    // 对象物理磁盘为虚拟磁盘组成部分且工作正常
  NET_DVR_HD_IS_ASSIGNED_ALREADY = (RAID_ERROR_INDEX + 12);    // 指定的物理磁盘被分配为虚拟磁盘
  NET_DVR_INVALID_HD_COUNT = (RAID_ERROR_INDEX + 13);    // 物理磁盘数量与指定的RAID等级不匹配
  NET_DVR_LD_IS_FUNCTIONAL = (RAID_ERROR_INDEX + 14);    // 阵列正常，无法重建
  NET_DVR_BGA_RUNNING = (RAID_ERROR_INDEX + 15);    // 存在正在执行的后台任务
  NET_DVR_LD_NO_ATAPI = (RAID_ERROR_INDEX + 16);    // 无法用ATAPI盘创建虚拟磁盘
  NET_DVR_MIGRATION_NOT_NEED = (RAID_ERROR_INDEX + 17);    // 阵列无需迁移
  NET_DVR_HD_TYPE_MISMATCH = (RAID_ERROR_INDEX + 18);    // 物理磁盘不属于同意类型
  NET_DVR_NO_LD_IN_DG = (RAID_ERROR_INDEX + 19);    // 无虚拟磁盘，无法进行此项操作
  NET_DVR_NO_ROOM_FOR_SPARE = (RAID_ERROR_INDEX + 20);    // 磁盘空间过小，无法被指定为热备盘
  NET_DVR_SPARE_IS_IN_MULTI_DG = (RAID_ERROR_INDEX + 21);    // 磁盘已被分配为某阵列热备盘
  NET_DVR_DG_HAS_MISSING_PD = (RAID_ERROR_INDEX + 22);    // 阵列缺少盘

// x86 64bit nvr新增 2012-02-04
const
  NET_DVR_NAME_EMPTY = (RAID_ERROR_INDEX + 23);    //名称为空
  NET_DVR_INPUT_PARAM = (RAID_ERROR_INDEX + 24);    //输入参数有误
  NET_DVR_PD_NOT_AVAILABLE = (RAID_ERROR_INDEX + 25);    //物理磁盘不可用
  NET_DVR_ARRAY_NOT_AVAILABLE = (RAID_ERROR_INDEX + 26);    //阵列不可用
  NET_DVR_PD_COUNT = (RAID_ERROR_INDEX + 27);    //物理磁盘数不正确
  NET_DVR_VD_SMALL = (RAID_ERROR_INDEX + 28);    //虚拟磁盘太小
  NET_DVR_NO_EXIST = (RAID_ERROR_INDEX + 29);    //不存在
  NET_DVR_NOT_SUPPORT = (RAID_ERROR_INDEX + 30);    //不支持该操作
  NET_DVR_NOT_FUNCTIONAL = (RAID_ERROR_INDEX + 31);    //阵列状态不是正常状态
  NET_DVR_DEV_NODE_NOT_FOUND = (RAID_ERROR_INDEX + 32);    //虚拟磁盘设备节点不存在
  NET_DVR_SLOT_EXCEED = (RAID_ERROR_INDEX + 33);    //槽位达到上限
  NET_DVR_NO_VD_IN_ARRAY = (RAID_ERROR_INDEX + 34);    //阵列上不存在虚拟磁盘
  NET_DVR_VD_SLOT_INVALID = (RAID_ERROR_INDEX + 35);    //虚拟磁盘槽位无效
  NET_DVR_PD_NO_ENOUGH_SPACE = (RAID_ERROR_INDEX + 36);    //所需物理磁盘空间不足
  NET_DVR_ARRAY_NONFUNCTION = (RAID_ERROR_INDEX + 37);    //只有处于正常状态的阵列才能进行迁移
  NET_DVR_ARRAY_NO_ENOUGH_SPACE = (RAID_ERROR_INDEX + 38);    //阵列空间不足
  NET_DVR_STOPPING_SCANNING_ARRAY = (RAID_ERROR_INDEX + 39);    //正在执行安全拔盘或重新扫描
  NET_DVR_NOT_SUPPORT_16T = (RAID_ERROR_INDEX + 40);    //不支持创建大于16T的阵列
  NET_DVR_ARRAY_FORMATING = (RAID_ERROR_INDEX + 41);    //正在执行格式化的阵列无法删除
  NET_DVR_QUICK_SETUP_PD_COUNT = (RAID_ERROR_INDEX + 42);    //一键配置至少需要三块空闲盘

//设备未激活时，登录失败，返回错误码
const
  NET_DVR_ERROR_DEVICE_NOT_ACTIVATED = 250;    //设备未激活
//老SDK接新设备，设置用户密码或者激活的时候为风险密码时，错误码
const
  NET_DVR_ERROR_RISK_PASSWORD = 251;    //有风险的密码
//已激活的设备，再次激活时返回错误码
const
  NET_DVR_ERROR_DEVICE_HAS_ACTIVATED = 252;    //设备已激活


// 智能错误码
const
  VCA_ERROR_INDEX = 300;    // 智能错误码索引
  NET_DVR_ID_ERROR = (VCA_ERROR_INDEX + 0);    // 配置ID不合理
  NET_DVR_POLYGON_ERROR = (VCA_ERROR_INDEX + 1);    // 多边形不符合要求
  NET_DVR_RULE_PARAM_ERROR = (VCA_ERROR_INDEX + 2);    // 规则参数不合理
  NET_DVR_RULE_CFG_CONFLICT = (VCA_ERROR_INDEX + 3);    // 配置信息冲突
  NET_DVR_CALIBRATE_NOT_READY = (VCA_ERROR_INDEX + 4);    // 当前没有标定信息
  NET_DVR_CAMERA_DATA_ERROR = (VCA_ERROR_INDEX + 5);    // 摄像机参数不合理
  NET_DVR_CALIBRATE_DATA_UNFIT = (VCA_ERROR_INDEX + 6);    // 长度不够倾斜，不利于标定
  NET_DVR_CALIBRATE_DATA_CONFLICT = (VCA_ERROR_INDEX + 7);    // 标定出错，以为所有点共线或者位置太集中
  NET_DVR_CALIBRATE_CALC_FAIL = (VCA_ERROR_INDEX + 8);    // 摄像机标定参数值计算失败
  NET_DVR_CALIBRATE_LINE_OUT_RECT = (VCA_ERROR_INDEX + 9);    // 输入的样本标定线超出了样本外接矩形框
  NET_DVR_ENTER_RULE_NOT_READY = (VCA_ERROR_INDEX + 10);    // 没有设置进入区域
  NET_DVR_AID_RULE_NO_INCLUDE_LANE = (VCA_ERROR_INDEX + 11);    // 交通事件规则中没有包括车道（特值拥堵和逆行）
  NET_DVR_LANE_NOT_READY = (VCA_ERROR_INDEX + 12);    // 当前没有设置车道
  NET_DVR_RULE_INCLUDE_TWO_WAY = (VCA_ERROR_INDEX + 13);    // 事件规则中包含2种不同方向
  NET_DVR_LANE_TPS_RULE_CONFLICT = (VCA_ERROR_INDEX + 14);    // 车道和数据规则冲突
  NET_DVR_NOT_SUPPORT_EVENT_TYPE = (VCA_ERROR_INDEX + 15);    // 不支持的事件类型
  NET_DVR_LANE_NO_WAY = (VCA_ERROR_INDEX + 16);    // 车道没有方向
  NET_DVR_SIZE_FILTER_ERROR = (VCA_ERROR_INDEX + 17);    // 尺寸过滤框不合理
  NET_DVR_LIB_FFL_NO_FACE = (VCA_ERROR_INDEX + 18);    // 特征点定位时输入的图像没有人脸
  NET_DVR_LIB_FFL_IMG_TOO_SMALL = (VCA_ERROR_INDEX + 19);    // 特征点定位时输入的图像太小
  NET_DVR_LIB_FD_IMG_NO_FACE = (VCA_ERROR_INDEX + 20);    // 单张图像人脸检测时输入的图像没有人脸
  NET_DVR_LIB_FACE_TOO_SMALL = (VCA_ERROR_INDEX + 21);    // 建模时人脸太小
  NET_DVR_LIB_FACE_QUALITY_TOO_BAD = (VCA_ERROR_INDEX + 22);    // 建模时人脸图像质量太差
  NET_DVR_KEY_PARAM_ERR = (VCA_ERROR_INDEX + 23);    //高级参数设置错误
  NET_DVR_CALIBRATE_DATA_ERR = (VCA_ERROR_INDEX + 24);    //标定样本数目错误，或数据值错误，或样本点超出地平线
  NET_DVR_CALIBRATE_DISABLE_FAIL = (VCA_ERROR_INDEX + 25);    //所配置规则不允许取消标定
  NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE = (VCA_ERROR_INDEX + 26);    //最大过滤框的宽高最小值超过最小过滤框的宽高最大值两倍以上
  NET_DVR_LIB_FD_REGION_TOO_LARGE = (VCA_ERROR_INDEX + 27);    //当前检测区域范围过大。检测区最大为图像的2/3
  NET_DVR_TRIAL_OVERDUE = (VCA_ERROR_INDEX + 28);    //试用版评估期已结束
  NET_DVR_CONFIG_FILE_CONFLICT = (VCA_ERROR_INDEX + 29);    //设备类型与配置文件冲突（加密狗类型与现有分析仪配置不符错误码提示）
//算法库相关错误码
const
  NET_DVR_FR_FPL_FAIL = (VCA_ERROR_INDEX + 30);    // 人脸特征点定位失败
  NET_DVR_FR_IQA_FAIL = (VCA_ERROR_INDEX + 31);    // 人脸评分失败
  NET_DVR_FR_FEM_FAIL = (VCA_ERROR_INDEX + 32);    // 人脸特征提取失败
  NET_DVR_FPL_DT_CONF_TOO_LOW = (VCA_ERROR_INDEX + 33);    // 特征点定位时人脸检测置信度过低
  NET_DVR_FPL_CONF_TOO_LOW = (VCA_ERROR_INDEX + 34);    // 特征点定位置信度过低
  NET_DVR_E_DATA_SIZE = (VCA_ERROR_INDEX + 35);    // 数据长度不匹配
  NET_DVR_FR_MODEL_VERSION_ERR = (VCA_ERROR_INDEX + 36);    // 人脸模型数据中的模型版本错误
  NET_DVR_FR_FD_FAIL = (VCA_ERROR_INDEX + 37);    // 识别库中人脸检测失败
  NET_DVR_FA_NORMALIZE_ERR = (VCA_ERROR_INDEX + 38);    // 人脸归一化出错
//其他错误码
const
  NET_DVR_DOG_PUSTREAM_NOT_MATCH = (VCA_ERROR_INDEX + 39);    // 加密狗与前端取流设备类型不匹配
  NET_DVR_DEV_PUSTREAM_NOT_MATCH = (VCA_ERROR_INDEX + 40);    // 前端取流设备版本不匹配
  NET_DVR_PUSTREAM_ALREADY_EXISTS = (VCA_ERROR_INDEX + 41);    // 设备的其他通道已经添加过该前端设备
  NET_DVR_SEARCH_CONNECT_FAILED = (VCA_ERROR_INDEX + 42);    // 连接检索服务器失败
  NET_DVR_INSUFFICIENT_DISK_SPACE = (VCA_ERROR_INDEX + 43);    // 可存储的硬盘空间不足
  NET_DVR_DATABASE_CONNECTION_FAILED = (VCA_ERROR_INDEX + 44);    // 数据库连接失败
  NET_DVR_DATABASE_ADM_PW_ERROR = (VCA_ERROR_INDEX + 45);    // 数据库用户名、密码错误
  NET_DVR_DECODE_YUV = (VCA_ERROR_INDEX + 46);    // 解码失败
  NET_DVR_IMAGE_RESOLUTION_ERROR = (VCA_ERROR_INDEX + 47);    //
  NET_DVR_CHAN_WORKMODE_ERROR = (VCA_ERROR_INDEX + 48);    //

const
  NET_DVR_RTSP_ERROR_NOENOUGHPRI = 401;    //无权限：服务器返回401时，转成这个错误码
  NET_DVR_RTSP_ERROR_ALLOC_RESOURCE = 402;    //分配资源失败
  NET_DVR_RTSP_ERROR_PARAMETER = 403;    //参数错误
  NET_DVR_RTSP_ERROR_NO_URL = 404;    //指定的URL地址不存在：服务器返回404时，转成这个错误码
  NET_DVR_RTSP_ERROR_FORCE_STOP = 406;    //用户中途强行退出

const
  NET_DVR_RTSP_GETPORTFAILED = 407;    //rtsp 得到端口错误
  NET_DVR_RTSP_DESCRIBERROR = 410;    //rtsp decribe 交互错误
  NET_DVR_RTSP_DESCRIBESENDTIMEOUT = 411;    //rtsp decribe 发送超时
  NET_DVR_RTSP_DESCRIBESENDERROR = 412;    //rtsp decribe 发送失败
  NET_DVR_RTSP_DESCRIBERECVTIMEOUT = 413;    //rtsp decribe 接收超时
  NET_DVR_RTSP_DESCRIBERECVDATALOST = 414;    //rtsp decribe 接收数据错误
  NET_DVR_RTSP_DESCRIBERECVERROR = 415;    //rtsp decribe 接收失败
  NET_DVR_RTSP_DESCRIBESERVERERR = 416;    //rtsp decribe 服务器返回错误状态

const
  NET_DVR_RTSP_SETUPERROR = 420;    //rtsp setup 交互错误
  NET_DVR_RTSP_SETUPSENDTIMEOUT = 421;    //rtsp setup 发送超时
  NET_DVR_RTSP_SETUPSENDERROR = 422;    //rtsp setup 发送错误
  NET_DVR_RTSP_SETUPRECVTIMEOUT = 423;    //rtsp setup 接收超时
  NET_DVR_RTSP_SETUPRECVDATALOST = 424;    //rtsp setup 接收数据错误
  NET_DVR_RTSP_SETUPRECVERROR = 425;    //rtsp setup 接收失败
  NET_DVR_RTSP_OVER_MAX_CHAN = 426;    //超过服务器最大连接数，或者服务器资源不足，服务器返回453时，转成这个错误码。
  NET_DVR_RTSP_SETUPSERVERERR = 427;    //rtsp setup 服务器返回错误状态

const
  NET_DVR_RTSP_PLAYERROR = 430;    //rtsp play 交互错误
  NET_DVR_RTSP_PLAYSENDTIMEOUT = 431;    //rtsp play 发送超时
  NET_DVR_RTSP_PLAYSENDERROR = 432;    //rtsp play 发送错误
  NET_DVR_RTSP_PLAYRECVTIMEOUT = 433;    //rtsp play 接收超时
  NET_DVR_RTSP_PLAYRECVDATALOST = 434;    //rtsp play 接收数据错误
  NET_DVR_RTSP_PLAYRECVERROR = 435;    //rtsp play 接收失败
  NET_DVR_RTSP_PLAYSERVERERR = 436;    //rtsp play 服务器返回错误状态

const
  NET_DVR_RTSP_TEARDOWNERROR = 440;    //rtsp teardown 交互错误
  NET_DVR_RTSP_TEARDOWNSENDTIMEOUT = 441;    //rtsp teardown 发送超时
  NET_DVR_RTSP_TEARDOWNSENDERROR = 442;    //rtsp teardown 发送错误
  NET_DVR_RTSP_TEARDOWNRECVTIMEOUT = 443;    //rtsp teardown 接收超时
  NET_DVR_RTSP_TEARDOWNRECVDATALOST = 444;    //rtsp teardown 接收数据错误
  NET_DVR_RTSP_TEARDOWNRECVERROR = 445;    //rtsp teardown 接收失败
  NET_DVR_RTSP_TEARDOWNSERVERERR = 446;    //rtsp teardown 服务器返回错误状态

const
  NET_PLAYM4_NOERROR = 500;    //no error
  NET_PLAYM4_PARA_OVER = 501;    //input parameter is invalid;
  NET_PLAYM4_ORDER_ERROR = 502;    //The order of the function to be called is error.
  NET_PLAYM4_TIMER_ERROR = 503;    //Create multimedia clock failed;
  NET_PLAYM4_DEC_VIDEO_ERROR = 504;    //Decode video data failed.
  NET_PLAYM4_DEC_AUDIO_ERROR = 505;    //Decode audio data failed.
  NET_PLAYM4_ALLOC_MEMORY_ERROR = 506;    //Allocate memory failed.
  NET_PLAYM4_OPEN_FILE_ERROR = 507;    //Open the file failed.
  NET_PLAYM4_CREATE_OBJ_ERROR = 508;    //Create thread or event failed
  NET_PLAYM4_CREATE_DDRAW_ERROR = 509;    //Create DirectDraw object failed.
  NET_PLAYM4_CREATE_OFFSCREEN_ERROR = 510;    //failed when creating off-screen surface.
  NET_PLAYM4_BUF_OVER = 511;    //buffer is overflow
  NET_PLAYM4_CREATE_SOUND_ERROR = 512;    //failed when creating audio device.
  NET_PLAYM4_SET_VOLUME_ERROR = 513;    //Set volume failed
  NET_PLAYM4_SUPPORT_FILE_ONLY = 514;    //The function only support play file.
  NET_PLAYM4_SUPPORT_STREAM_ONLY = 515;    //The function only support play stream.
  NET_PLAYM4_SYS_NOT_SUPPORT = 516;    //System not support.
  NET_PLAYM4_FILEHEADER_UNKNOWN = 517;    //No file header.
  NET_PLAYM4_VERSION_INCORRECT = 518;    //The version of decoder and encoder is not adapted.
  NET_PALYM4_INIT_DECODER_ERROR = 519;    //Initialize decoder failed.
  NET_PLAYM4_CHECK_FILE_ERROR = 520;    //The file data is unknown.
  NET_PLAYM4_INIT_TIMER_ERROR = 521;    //Initialize multimedia clock failed.
  NET_PLAYM4_BLT_ERROR = 522;    //Blt failed.
  NET_PLAYM4_UPDATE_ERROR = 523;    //Update failed.
  NET_PLAYM4_OPEN_FILE_ERROR_MULTI = 524;    //openfile error, streamtype is multi
  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO = 525;    //openfile error, streamtype is video
  NET_PLAYM4_JPEG_COMPRESS_ERROR = 526;    //JPEG compress error
  NET_PLAYM4_EXTRACT_NOT_SUPPORT = 527;    //Don't support the version of this file.
  NET_PLAYM4_EXTRACT_DATA_ERROR = 528;    //extract video data failed.

//转封装库错误码
const
  NET_CONVERT_ERROR_NOT_SUPPORT = 581;    //convert not support

//语音对讲库错误码
const
  NET_AUDIOINTERCOM_OK = 600;    //无错误
  NET_AUDIOINTECOM_ERR_NOTSUPORT = 601;    //不支持
  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY = 602;    //内存申请错误
  NET_AUDIOINTECOM_ERR_PARAMETER = 603;    //参数错误
  NET_AUDIOINTECOM_ERR_CALL_ORDER = 604;    //调用次序错误
  NET_AUDIOINTECOM_ERR_FIND_DEVICE = 605;    //未发现设备
  NET_AUDIOINTECOM_ERR_OPEN_DEVICE = 606;    //不能打开设备诶
  NET_AUDIOINTECOM_ERR_NO_CONTEXT = 607;    //设备上下文出错
  NET_AUDIOINTECOM_ERR_NO_WAVFILE = 608;    //WAV文件出错
  NET_AUDIOINTECOM_ERR_INVALID_TYPE = 609;    //无效的WAV参数类型
  NET_AUDIOINTECOM_ERR_ENCODE_FAIL = 610;    //编码失败
  NET_AUDIOINTECOM_ERR_DECODE_FAIL = 611;    //解码失败
  NET_AUDIOINTECOM_ERR_NO_PLAYBACK = 612;    //播放失败
  NET_AUDIOINTECOM_ERR_DENOISE_FAIL = 613;    //降噪失败
  NET_AUDIOINTECOM_ERR_UNKOWN = 619;    //未知错误

const
  NET_QOS_OK = 700;    //no error
  NET_QOS_ERROR = (NET_QOS_OK - 1);    //qos error
  NET_QOS_ERR_INVALID_ARGUMENTS = (NET_QOS_OK - 2);    //invalid arguments
  NET_QOS_ERR_SESSION_NOT_FOUND = (NET_QOS_OK - 3);    //session net found
  NET_QOS_ERR_LIB_NOT_INITIALIZED = (NET_QOS_OK - 4);    //lib not initialized
  NET_QOS_ERR_OUTOFMEM = (NET_QOS_OK - 5);    //outtofmem
  NET_QOS_ERR_PACKET_UNKNOW = (NET_QOS_OK - 10);    //packet unknow
  NET_QOS_ERR_PACKET_VERSION = (NET_QOS_OK - 11);    //packet version error
  NET_QOS_ERR_PACKET_LENGTH = (NET_QOS_OK - 12);    //packet length error
  NET_QOS_ERR_PACKET_TOO_BIG = (NET_QOS_OK - 13);    //packet too big
  NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH = (NET_QOS_OK - 20);    //schedparams invalid bandwidth
  NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION = (NET_QOS_OK - 21);    //schedparams bad fraction
  NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL = (NET_QOS_OK - 22);    //schedparams bad minimum interval

const
  NET_ERROR_TRUNK_LINE = 711;    //子系统已被配成干线
  NET_ERROR_MIXED_JOINT = 712;    //不能进行混合拼接
  NET_ERROR_DISPLAY_SWITCH = 713;    //不能进行显示通道切换
  NET_ERROR_USED_BY_BIG_SCREEN = 714;    //解码资源被大屏占用
  NET_ERROR_USE_OTHER_DEC_RESOURCE = 715;    //不能使用其他解码子系统资源
  NET_ERROR_DISP_MODE_SWITCH = 716;    //显示通道显示状态切换中
  NET_ERROR_SCENE_USING = 717;    //场景正在使用
  NET_ERR_NO_ENOUGH_DEC_RESOURCE = 718;    //解码资源不足
  NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE = 719;    //畅显资源不足
  NET_ERR_NO_ENOUGH_VIDEO_MEMORY = 720;    //显存资源不足
  NET_ERR_MAX_VIDEO_NUM = 721;    //一拖多资源不足
  NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL = 722;    //窗口跨越了畅显输出口和非畅显输出口
  NET_ERR_FREE_SHOW_WIN_SPLIT = 723;    //畅显窗口不支持分屏
  NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW = 724;    //不是输出口整数倍的窗口不支持开启畅显
  NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT = 725;    //开启透明度的窗口不支持分屏
  NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT = 726;    //开启多分屏的窗口不支持透明度设置
  NET_ERR_MAX_LOGO_NUM = 727;    //logo数达到上限
  NET_ERR_MAX_WIN_LOOP_NUM = 728;    //轮巡窗口数达到上限
  NET_ERR_VIRTUAL_LED_VERTICAL_CROSS = 729;    //虚拟LED不能纵向跨屏
  NET_ERR_MAX_VIRTUAL_LED_HEIGHT = 730;    //虚拟LED高度超限
  NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER = 731;    //虚拟LED内容包含非法字符
  NET_ERR_BASEMAP_NOT_EXIST = 732;    //底图图片不存在
  NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED = 733;    //LED屏幕不支持虚拟LED
  NET_ERR_LED_RESOLUTION_NOT_SUPPORT = 734;    //LED分辨率不支持
  NET_ERR_PLAN_OVERDUE = 735;    //预案超期，不能再调用
  NET_ERR_PROCESSER_MAX_SCREEN_BLK = 736;    //单个处理器接入的信号跨越的屏幕个数超限
  NET_ERR_WND_SIZE_TOO_SMALL = 737;    //开窗窗口宽高太小
  NET_ERR_WND_SPLIT_NOT_SUPPORT_ROAM = 738;    //分屏窗口不支持漫游
  NET_ERR_OUTPUT_ONE_BOARD_ONE_WALL = 739;    //同一个子板的输出口只能绑定到同一面墙上
  NET_ERR_WND_CANNOT_LCD_AND_LED_OUTPUT = 740;    //窗口不能同时跨LCD和LED输出口
  NET_ERR_MAX_OSD_NUM = 741;    //OSD数量达到最大

const
  NET_SDK_CANCEL_WND_TOPKEEP_ATTR_FIRST = 751;    //先取消置顶保持窗口的置顶保持属性才能进行置底操作
  NET_SDK_ERR_LED_SCREEN_CHECKING = 752;    //正在校正LED屏幕
  NET_SDK_ERR_NOT_SUPPORT_SINGLE_RESOLUTION = 753;    //LCD/LED输出口绑定之后不支持单个输出口的分辨率配置
  NET_SDK_ERR_LED_RESOLUTION_MISMATCHED = 754;    //该输出口的LED分辨率和其他输出口的LED分辨率不匹配，需要满足同行等高、同列等宽


const
  NET_SDK_ERR_MAX_VIRTUAL_LED_WIDTH = 755;    //虚拟LED宽度超限，包括最大值和最小值
  NET_SDK_ERR_MAX_VIRTUAL_LED_IN_SCREEN = 756;    //单屏虚拟LED数量超限
  NET_SDK_ERR_MAX_VIRTUAL_LED_IN_WALL = 757;    //单墙虚拟LED数量超限
  NET_SDK_ERR_VIRTUAL_LED_OVERLAP = 758;    //虚拟LED重叠错误
  NET_SDK_ERR_VIRTUAL_LED_TYPE = 759;    //类型错误
  NET_SDK_ERR_VIRTUAL_LED_COLOUR = 760;    //颜色错误
  NET_SDK_ERR_VIRTUAL_LED_MOVE_DIRECTION = 761;    //移动方向错误
  NET_SDK_ERR_VIRTUAL_LED_MOVE_MODE = 762;    //移动模式错误
  NET_SDK_ERR_VIRTUAL_LED_MOVE_SPEED = 763;    //移动速度错误
  NET_SDK_ERR_VIRTUAL_LED_DISP_MODE = 764;    //显示模式有误
  NET_SDK_ERR_VIRTUAL_LED_NO = 765;    //虚拟LED序号错误
  NET_SDK_ERR_VIRTUAL_LED_PARA = 766;    //虚拟LED参数配置错误，包括结构体内其他参数
  NET_SDK_ERR_BASEMAP_POSITION = 767;    //底图窗口宽高参数错误
  NET_SDK_ERR_BASEMAP_PICTURE_LEN = 768;    //底图图片长度超限
  NET_SDK_ERR_BASEMAP_PICTURE_RESOLUTION = 769;    //底图图片分辨率错误
  NET_SDK_ERR_BASEMAP_PICTURE_FORMAT = 770;    //底图图片格式错误
  NET_SDK_ERR_MAX_VIRTUAL_LED_NUM = 771;    //设备支持的虚拟LED数量超限
  NET_SDK_ERR_MAX_TIME_VIRTUAL_LED_IN_WALL = 772;    //单面电视墙支持的时间虚拟LED的数量超限

const
  NET_ERR_TERMINAL_BUSY = 780;    //终端忙，终端处于会议中

const
  NET_ERR_DATA_RETURNED_ILLEGAL = 790;    //设备返回的数据不合法
  NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR = 791;    //设备其它功能占用资源，导致该功能无法开启

const
  NET_DVR_ERR_IMPORT_EMPTY_FILE = 792;    //导入文件为空
  NET_DVR_ERR_IMPORT_TOO_LARGE_FILE = 793;    //导入文件过大
  NET_DVR_ERR_BAD_IPV4_ADDRESS = 794;    //IPV4地址无效
  NET_DVR_ERR_BAD_NET_MASK = 795;    //子网掩码地址无效
  NET_DVR_ERR_INVALID_NET_GATE_ADDRESS = 796;    //网关地址无效
  NET_DVR_ERR_BAD_DNS = 797;    //DNS地址无效
  NET_DVR_ERR_ILLEGAL_PASSWORD = 798;    //密码不能包含用户名

const
  NET_DVR_DEV_NET_OVERFLOW = 800;    //网络流量超过设备能力上限
  NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK = 801;    //录像文件在录像，无法被锁定
  NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK = 802;    //由于硬盘太小无法格式化

//N+1错误码
const
  NET_SDK_ERR_REMOTE_DISCONNECT = 803;    //远端无法连接
  NET_SDK_ERR_RD_ADD_RD = 804;    //备机不能添加备机
  NET_SDK_ERR_BACKUP_DISK_EXCEPT = 805;    //备份盘异常
  NET_SDK_ERR_RD_LIMIT = 806;    //备机数已达上限
  NET_SDK_ERR_ADDED_RD_IS_WD = 807;    //添加的备机是工作机
  NET_SDK_ERR_ADD_ORDER_WRONG = 808;    //添加顺序出错，比如没有被工作机添加为备机，就添加工作机
  NET_SDK_ERR_WD_ADD_WD = 809;    //工作机不能添加工作机
  NET_SDK_ERR_WD_SERVICE_EXCETP = 810;    //工作机CVR服务异常
  NET_SDK_ERR_RD_SERVICE_EXCETP = 811;    //备机CVR服务异常
  NET_SDK_ERR_ADDED_WD_IS_RD = 812;    //添加的工作机是备机
  NET_SDK_ERR_PERFORMANCE_LIMIT = 813;    //性能达到上限
  NET_SDK_ERR_ADDED_DEVICE_EXIST = 814;    //添加的设备已经存在

//审讯机错误码
const
  NET_SDK_ERR_INQUEST_RESUMING = 815;    //审讯恢复中
  NET_SDK_ERR_RECORD_BACKUPING = 816;    //审讯备份中
  NET_SDK_ERR_DISK_PLAYING = 817;    //光盘回放中
  NET_SDK_ERR_INQUEST_STARTED = 818;    //审讯已开启
  NET_SDK_ERR_LOCAL_OPERATING = 819;    //本地操作进行中
  NET_SDK_ERR_INQUEST_NOT_START = 820;    //审讯未开启
//Netra3.1.0错误码
const
  NET_SDK_ERR_CHAN_AUDIO_BIND = 821;    //通道未绑定或绑定语音对讲失败
//云存储错误码
const
  NET_DVR_N_PLUS_ONE_MODE = 822;    //设备当前处于N+1模式
  NET_DVR_CLOUD_STORAGE_OPENED = 823;    //云存储模式已开启

const
  NET_DVR_ERR_OPER_NOT_ALLOWED = 824;    //设备处于N+0被接管状态，不允许该操作
  NET_DVR_ERR_NEED_RELOCATE = 825;    //设备处于N+0被接管状态，需要获取重定向信息，再重新操作

//庭审主机错误码
const
  NET_SDK_ERR_IR_PORT_ERROR = 830;    //红外输出口错误
  NET_SDK_ERR_IR_CMD_ERROR = 831;    //红外输出口的命令号错误
  NET_SDK_ERR_NOT_INQUESTING = 832;    //设备处于非审讯状态
  NET_SDK_ERR_INQUEST_NOT_PAUSED = 833;    //设备处于非暂停状态
  NET_DVR_CHECK_PASSWORD_MISTAKE_ERROR = 834;    //校验密码错误
  NET_DVR_CHECK_PASSWORD_NULL_ERROR = 835;    //校验密码不能为空
  NET_DVR_UNABLE_CALIB_ERROR = 836;    // 当前无法标定
  NET_DVR_PLEASE_CALIB_ERROR = 837;    //请先完成标定
  NET_DVR_ERR_PANORAMIC_CAL_EMPTY = 838;    //Flash中全景标定为空
  NET_DVR_ERR_CALIB_FAIL_PLEASEAGAIN = 839;    //标定失败，请重新标定(Calibration failed. Please calibrate again.)
  NET_DVR_ERR_DETECTION_LINE = 840;    //规则线配置错误，请重新配置规则线，确保规则线位于红色区域内(Please set detection line again. The detection line should be within the red count area.)
  NET_DVR_ERR_TURN_OFF_IMAGE_PARA = 841;    //请先关闭图像参数切换功能(Please turn off the image parameters switch first.)
  NET_DVR_EXCEED_FACE_IMAGES_ERROR = 843;    //超过人脸图片最大张数
  NET_DVR_ANALYSIS_FACE_IMAGES_ERROR = 844;    //图片数据识别失败
  NET_ERR_ALARM_INPUT_OCCUPIED = 845;    //A<-1报警号已用于触发车辆抓拍Alarm Input No. A<-1 is used to trigger vehicle capture.
  NET_DVR_FACELIB_DATABASE_ERROR = 846;    //人脸库中数据库版本不匹配
  NET_DVR_FACELIB_DATA_ERROR = 847;    //人脸库数据错误
  NET_DVR_FACE_DATA_ID_ERROR = 848;    //人脸数据PID无效
  NET_DVR_FACELIB_ID_ERROR = 849;    //人脸库ID无效
  NET_DVR_EXCEED_FACE_LIBARY_ERROR = 850;    //超过人脸库最大个数
  NET_DVR_PIC_ANALYSIS_NO_TARGET_ERROR = 851;    //图片未识别到目标
  NET_DVR_SUBPIC_ANALYSIS_MODELING_ERROR = 852;    //子图建模失败
  NET_DVR_PIC_ANALYSIS_NO_RESOURCE_ERROR = 853;    //无对应智能分析引擎支持图片二次识别
  NET_DVR_ANALYSIS_ENGINES_NO_RESOURCE_ERROR = 854;    //无分析引擎资源
  NET_DVR_ANALYSIS_ENGINES_USAGE_EXCEED_ERROR = 855;    //引擎使用率超负荷，已达100%
  NET_DVR_EXCEED_HUMANMISINFO_FILTER_ENABLED_ERROR = 856;    //超过开启人体去误报最大通道个数
  NET_DVR_NAME_ERROR = 857;    //名称错误
  NET_DVR_NAME_EXIST_ERROR = 858;    //名称已存在
  NET_DVR_FACELIB_PIC_IMPORTING_ERROR = 859;    //人脸库导入图片中
  NET_DVR_ERR_CALIB_POSITION = 860;    //标定位置超出摄像机运动范围
  NET_DVR_ERR_DELETE = 861;    //无法删除
  NET_DVR_ERR_SCENE_ID = 862;    //场景ID无效
  NET_DVR_ERR_CALIBING = 863;    //标定中
  NET_DVR_PIC_FORMAT_ERROR = 864;    //图片格式错误
  NET_DVR_PIC_RESOLUTION_INVALID_ERROR = 865;    //图片分辨率无效错误
  NET_DVR_PIC_SIZE_EXCEED_ERROR = 866;    //图片过大
  NET_DVR_PIC_ANALYSIS_TARGRT_NUM_EXCEED_ERROR = 867;    //图片目标个数超过上限
  NET_DVR_ANALYSIS_ENGINES_LOADING_ERROR = 868;    //分析引擎初始化中
  NET_DVR_ANALYSIS_ENGINES_ABNORMA_ERROR = 869;    //分析引擎异常
  NET_DVR_ANALYSIS_ENGINES_FACELIB_IMPORTING = 870;    //分析引擎正在导入人脸库
  NET_DVR_NO_DATA_FOR_MODELING_ERROR = 871;    //无待建模数据
  NET_DVR_FACE_DATA_MODELING_ERROR = 872;    //设备正在进行图片建模操作，不支持并发处理
  NET_ERR_FACELIBDATA_OVERLIMIT = 873;    //超过设备中支持导入人脸数最大个数限制（导入的人脸库中数据）
  NET_DVR_ANALYSIS_ENGINES_ASSOCIATED_CHANNEL = 874;    //分析引擎已关联通道
  NET_DVR_ERR_CUSTOMID_LEN = 875;    //上层自定义ID的长度最小32字符长度
  NET_DVR_ERR_CUSTOMFACELIBID_REPEAT = 876;    //上层下发重复的自定义人脸库ID
  NET_DVR_ERR_CUSTOMHUMANID_REPEAT = 877;    //上层下发重复的自定义人员ID
  NET_DVR_ERR_URL_DOWNLOAD_FAIL = 878;    //url下载失败
  NET_DVR_ERR_URL_DOWNLOAD_NOTSTART = 879;    //url未开始下载

const
  NET_DVR_CFG_FILE_SECRETKEY_ERROR = 880;    //配置文件安全校验密钥错误
  NET_DVR_WDR_NOTDISABLE_ERROR = 881;    //请先关闭所有通道当前日夜参数转换模式下的宽动态
  NET_DVR_HLC_NOTDISABLE_ERROR = 882;    //请先关闭所有通道当前日夜参数转换模式下的强光抑制

const
  NET_DVR_THERMOMETRY_REGION_OVERSTEP_ERROR = 883;    //测温区域越界


const
  NET_DVR_ERR_MODELING_DEVICEINTERNAL = 884;    //建模失败，设备内部错误
  NET_DVR_ERR_MODELING_FACE = 885;    //建模失败，人脸建模错误
  NET_DVR_ERR_MODELING_FACEGRADING = 886;    //建模失败，人脸质量评分错误
  NET_DVR_ERR_MODELING_FACEGFEATURE = 887;    //建模失败，特征点提取错误
  NET_DVR_ERR_MODELING_FACEGANALYZING = 888;    //建模失败，属性提取错误

const
  NET_DVR_ERR_STREAM_LIMIT = 889;    //码流性能超过上限，请减少取流路数
  NET_DVR_ERR_STREAM_DESCRIPTION = 890;    //请输入码流描述
  NET_DVR_ERR_STREAM_DELETE = 891;    //码流正在使用无法删除
  NET_DVR_ERR_CUSTOMSTREAM_NAME = 892;    //自定义码流名称为空或不合法
  NET_DVR_ERR_CUSTOMSTREAM_NOTEXISTED = 893;    //该自定义码流不存在

const
  NET_DVR_ERR_TOO_SHORT_CALIBRATING_TIME = 894;    //标定时间太短
  NET_DVR_ERR_AUTO_CALIBRATE_FAILED = 895;    //自动标定失败
  NET_DVR_ERR_VERIFICATION_FAILED = 896;    //校验失败

const
  NET_DVR_NO_TEMP_SENSOR_ERROR = 897;    //无温度传感器
  NET_DVR_PUPIL_DISTANCE_OVERSIZE_ERROR = 898;    //瞳距过大
  NET_DVR_ERR_UNOPENED_FACE_SNAP = 899;    //操作无效，请先开启人脸抓拍
//2011-10-25多屏控制器错误码（900-950）
const
  NET_ERR_CUT_INPUTSTREAM_OVERLIMIT = 900;    //信号源裁剪数值超限
  NET_ERR_WINCHAN_IDX = 901;    // 开窗通道号错误
  NET_ERR_WIN_LAYER = 902;    // 窗口层数错误，单个屏幕上最多覆盖的窗口层数
  NET_ERR_WIN_BLK_NUM = 903;    // 窗口的块数错误，单个窗口可覆盖的屏幕个数
  NET_ERR_OUTPUT_RESOLUTION = 904;    // 输出分辨率错误
  NET_ERR_LAYOUT = 905;    // 布局号错误
  NET_ERR_INPUT_RESOLUTION = 906;    // 输入分辨率不支持
  NET_ERR_SUBDEVICE_OFFLINE = 907;    // 子设备不在线
  NET_ERR_NO_DECODE_CHAN = 908;    // 没有空闲解码通道
  NET_ERR_MAX_WINDOW_ABILITY = 909;    // 开窗能力上限, 分布式多屏控制器中解码子设备能力上限或者显示处理器能力上限导致
  NET_ERR_ORDER_ERROR = 910;    // 调用顺序有误
  NET_ERR_PLAYING_PLAN = 911;    // 正在执行预案
  NET_ERR_DECODER_USED = 912;    // 解码板正在使用
  NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW = 913;    // 输出板数据量超限
  NET_ERR_SAME_USER_NAME = 914;    // 用户名相同
  NET_ERR_INVALID_USER_NAME = 915;    // 无效用户名
  NET_ERR_MATRIX_USING = 916;    // 输入矩阵正在使用
  NET_ERR_DIFFERENT_CHAN_TYPE = 917;    // 通道类型不同（矩阵输出通道和控制器的输入为不同的类型）
  NET_ERR_INPUT_CHAN_BINDED = 918;    // 输入通道已经被其他矩阵绑定
  NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW = 919;    // 正在使用的矩阵输出通道个数超过矩阵与控制器绑定的通道个数
  NET_ERR_MAX_SIGNAL_NUM = 920;    // 输入信号源个数达到上限
  NET_ERR_INPUT_CHAN_USING = 921;    // 输入通道正在使用
  NET_ERR_MANAGER_LOGON = 922;    // 管理员已经登陆，操作失败
  NET_ERR_USERALREADY_LOGON = 923;    // 该用户已经登陆，操作失败
  NET_ERR_LAYOUT_INIT = 924;    // 布局正在初始化，操作失败
  NET_ERR_BASEMAP_SIZE_NOT_MATCH = 925;    // 底图大小不符
  NET_ERR_WINDOW_OPERATING = 926;    // 窗口正在执行其他操作，本次操作失败
  NET_ERR_SIGNAL_UPLIMIT = 927;    // 信号源开窗个数达到上限
  NET_ERR_SIGNAL_MAX_ENLARGE_TIMES = 928;    // 信号源放大倍数超限
  NET_ERR_ONE_SIGNAL_MULTI_CROSS = 929;    // 单个信号源不能多次跨屏
  NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN = 930;    // 超高清信号源不能重复开窗
  NET_ERR_MAX_VIRTUAL_LED_WIDTH = 931;    //虚拟LED宽度大于限制值
  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN = 932;    //虚拟LED字符数大于限制值
  NET_ERR_SINGLE_OUTPUTPARAM_CONFIG = 933;    //不支持单个显示输出参数设置
  NET_ERR_MULTI_WIN_BE_COVER = 934;    //多分屏窗口被覆盖
  NET_ERR_WIN_NOT_EXIST = 935;    //窗口不存在
  NET_ERR_WIN_MAX_SIGNALSOURCE = 936;    //窗口信号源数超过限制值
  NET_ERR_MULTI_WIN_MOVE = 937;    //对多分屏窗口移动
  NET_ERR_MULTI_WIN_YPBPR_SDI = 938;    // YPBPR 和SDI信号源不支持9/16分屏
  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE = 939;    //不同类型输出板混插
  NET_ERR_SPLIT_WIN_CROSS = 940;    //对跨屏窗口分屏
  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN = 941;    //对未满屏窗口分屏
  NET_ERR_SPLIT_WIN_MANY_WIN = 942;    //对单个输出口上有多个窗口的窗口分屏
  NET_ERR_WINDOW_SIZE_OVERLIMIT = 943;    //窗口大小超限
  NET_ERR_INPUTSTREAM_ALREADY_JOINT = 944;    //信号源已加入拼接
  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT = 945;    //拼接信号源个数超限

const
  NET_ERR_LED_RESOLUTION = 946;    //LED 分辨率大于输出分辨率
  NET_ERR_JOINT_SCALE_OVERLIMIT = 947;    //拼接信号源的规模超限
  NET_ERR_INPUTSTREAM_ALREADY_DECODE = 948;    //信号源已上墙
  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE = 949;    //信号源不支持抓图
  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN = 950;    //该信号源不支持分屏

//解码器错误码（951-999）
const
  NET_ERR_MAX_WIN_OVERLAP = 951;    //达到最大窗口重叠数
  NET_ERR_STREAMID_CHAN_BOTH_VALID = 952;    //stream ID和通道号同时有效
  NET_ERR_NO_ZERO_CHAN = 953;    //设备无零通道
  NEED_RECONNECT = 955;    //需要重定向（转码子系统使用）
  NET_ERR_NO_STREAM_ID = 956;    //流ID不存在
  NET_DVR_TRANS_NOT_START = 957;    //转码未启动
  NET_ERR_MAXNUM_STREAM_ID = 958;    //流ID数达到上限
  NET_ERR_WORKMODE_MISMATCH = 959;    //工作模式不匹配
  NET_ERR_MODE_IS_USING = 960;    //已工作在当前模式
  NET_ERR_DEV_PROGRESSING = 961;    //设备正在处理中
  NET_ERR_PASSIVE_TRANSCODING = 962;    //正在被动转码

const
  NET_ERR_RING_NOT_CONFIGURE = 964;    //环网未配置

const
  NET_ERR_CLOSE_WINDOW_FIRST = 971;    //切换全帧率畅显时必须先关闭对应的已上墙的窗口
  NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT = 972;    //VGA/DVI/DP/HDMI/HDBase_T输入源在全帧率畅显下不支持9/16画面
  NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK = 973;    //单信号源回显连接数量超限
  NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION = 974;    //只有分屏窗口支持子窗口放大
  NET_DVR_ERR_WINDOW_SIZE_PLACE = 975;    //窗口位置错误
  NET_DVR_ERR_RGIONAL_RESTRICTIONS = 976;    //屏幕距离超限
  NET_ERR_WNDZOOM_NOT_SUPPORT = 977;    //单窗口不支持子窗口全屏功能
  NET_ERR_LED_SCREEN_SIZE = 978;    //LED屏宽高不正确
  NET_ERR_OPEN_WIN_IN_ERROR_AREA = 979;    //在非法区域开窗(包括跨LCD/LED屏)
  NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE = 980;    //平铺模式不支持漫游
  NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER = 981;    //平铺模式不支持图层覆盖
  NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT = 982;    //平铺模式不支持分屏
  NET_DVR_LED_WINDOWS_ALREADY_CLOSED = 983;    //LED区域内输出口的分辨率发生变化，设备已关闭该区域内的所有LED窗口
  NET_DVR_ERR_CLOSE_WINDOWS = 984;    //操作失败，请先关闭窗口
  NET_DVR_ERR_MATRIX_LOOP_ABILITY = 985;    //超出轮巡解码能力限制
  NET_DVR_ERR_MATRIX_LOOP_TIME = 986;    //轮巡解码时间不支持
  NET_DVR_ERR_LINKED_OUT_ABILITY = 987;    //联动通道数超过上限
  NET_ERR_REACH_SCENE_MAX_NUM = 988;    //场景数量达到上限
  NET_ERR_SCENE_MEM_NOT_ENOUGH = 989;    //内存不足，无法新建场景
  NET_ERR_RESOLUTION_NOT_SUPPORT_ODD_VOUT = 990;    //奇口不支持该分辨率
  NET_ERR_RESOLUTION_NOT_SUPPORT_EVEN_VOUT = 991;    //偶口不支持该分辨率

const
  NET_DVR_CANCEL_WND_OPENKEEP_ATTR_FIRST = 992;    //常开窗口需要先取消常开属性才能被关闭
  NET_SDK_LED_MODE_NOT_SUPPORT_SPLIT = 993;    //LED模式下不支持窗口分屏
  NET_ERR_VOICETALK_ONLY_SUPPORT_ONE_TALK = 994;    //同时只支持一路语音对讲
  NET_ERR_WND_POSITION_ADJUSTED = 995;    //窗口位置被设备调整，上层需要重新获取下窗口位置
  NET_SDK_ERR_STARTTIME_CANNOT_LESSTHAN_CURTIME = 996;    //开始时间不能小于当前时间
  NET_SDK_ERR_NEED_ADJUST_PLAN = 997;    //场景已被预案关联，请先将该场景从预案中删除
  NET_ERR_UnitConfig_Failed = 998;    //当“启用单位统一”勾选时，测温下配置的单位与系统设置下的单位不同返回单位配置错误

//能力集解析库错误码
const
  XML_ABILITY_NOTSUPPORT = 1000;    //不支持能力节点获取
  XML_ANALYZE_NOENOUGH_BUF = 1001;    //输出内存不足
  XML_ANALYZE_FIND_LOCALXML_ERROR = 1002;    //无法找到对应的本地xml
  XML_ANALYZE_LOAD_LOCALXML_ERROR = 1003;    //加载本地xml出错
  XML_NANLYZE_DVR_DATA_FORMAT_ERROR = 1004;    //设备能力数据格式错误
  XML_ANALYZE_TYPE_ERROR = 1005;    //能力集类型错误
  XML_ANALYZE_XML_NODE_ERROR = 1006;    //XML能力节点格式错误
  XML_INPUT_PARAM_ERROR = 1007;    //输入的能力XML节点值错误

const
  NET_DVR_ERR_RETURNED_XML_DATA = 1008;    //设备返回的XML数据有误

//传显错误码
const
  NET_ERR_LEDAREA_EXIST_WINDOW = 1051;    //LED区域有窗口存在(如果LED区域上已经有窗口存在，不允许修改LED区域）
  NET_ERR_AUDIO_EXIST = 1052;    //输出口上存在音频输出，不允许解除绑定
  NET_ERR_MATERIAL_NAME_EXIST = 1053;    //素材名称已存在
  NET_ERR_MATERIAL_APPROVE_STATE = 1054;    //素材审核状态错误
  NET_ERR_DATAHD_SIGNAL_FORMAT = 1055;    //已使用的硬盘不允许单个格式化

const
  NET_ERR_SCENE_SWITCHING = 1056;    //场景正在切换
  NER_ERR_DATA_TRANSFER = 1057;    //设备正在数据转移中
  NET_ERR_DATA_RESTORE = 1058;    //设备正在数据还原中
  NET_ERR_CHECK_NOT_ENABLE = 1059;    //校正使能未开启
  NET_ERR_AREA_OFFLINE = 1060;    //区域不在线
  NET_ERR_SCREEN_TYPE = 1061;    //屏幕类型不匹配
  NET_ERR_MIN_OPERATE_UNIT = 1062;    //最小操作单元不匹配
  NET_ERR_MAINHD_NOT_BACKUP = 1063;    //第一槽位上的普通盘（主盘）禁止设置成备份盘
  NET_ERR_ONE_BACKUP_HD = 1064;    //设置备份盘时，设备至少有一块普通盘
  NET_ERR_CONNECT_SUB_SYSTEM_ABNORMAL = 1065;    //连接子系统异常
  NET_ERR_SERIAL_PORT_VEST = 1066;    //错误的串口归属
  NET_ERR_BLOCKLIST_FULL = 1067;    //允许名单列表数量已满
  NET_ERR_NOT_MATCH_SOURCE = 1068;    //不匹配的信号源类型
  NET_ERR_CLOCK_VIRTUAL_LED_FULL = 1069;    //开启时钟功能的虚拟LED达上限
  NET_ERR_MAX_WIN_SIGNAL_LOOP_NUM = 1070;    //窗口轮巡信号源个数已达上限
  NET_ERR_RESOLUTION_NO_MATCH_FRAME = 1071;    //分辨率与当前帧数不匹配
  NET_ERR_NOT_UPDATE_LOW_VERSION = 1072;    //不支持向低版本升级
  NET_ERR_NO_CUSTOM_TO_UPDATE = 1073;    //非定制程序无法升级
  NET_ERR_CHAN_RESOLUTION_NOT_SUPPORT_SPLIT = 1074;    //该输出口分辨率不支持分屏
  NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_SPLIT = 1075;    //超高清不支持9/16画面分割
  NET_ERR_MIRROR_IMAGE_BY_VIDEO_WALL = 1076;    //电视墙镜像出错
  NET_ERR_MAX_OSD_FONT_SIZE = 1077;    //超过OSD最大支持字符数
  NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_VIDEO_SET = 1078;    //超清不支持视频参数设置
  NET_ERR_TILE_MODE_NOT_SUPPORT_JOINT = 1079;    //平铺模式不支持拼接窗口
  NET_ERR_ADD_AUDIO_MATRIX_FAILED = 1080;    //创建音频矩阵失败
  NET_ERR_ONE_VIRTUAL_LED_AREA_BIND_ONE_AUDIO_AREA = 1081;    //一个虚拟LED区域只能绑定一个音频区域
  NET_ERR_NAT_NOT_MODIFY_SERVER_NETWORK_PARAM = 1082;    //NAT下无法修改服务器网络参数
  NET_ERR_ORIGINAL_CHECH_DATA_ERROR = 1083;    //原始校正数据错误
  NET_ERR_INPUT_BOARD_SPLICED_IN_DIFFERENT_NETWORKAREAS = 1084;    //不同网络区域的输入板不能拼接
  NET_ERR_SPLICINGSOURCE_ONWALL_IN_DIFFERENT_NETWORKAREAS = 1085;    //不同网络区域的拼接源不能上墙
  NET_ERR_ONWALL_OUTPUTBOARD_MODIFY_NETWORKAREAS = 1086;    //已绑定在电视墙上的输出板不能修改网络区域
  NET_ERR_LAN_AND_WAN_CANNOT_SAME_NET_SEGMENT = 1087;    //LAN口IP和WAN口IP不能处于同一网段
  NET_ERR_USERNAME_REPETITIVE = 1088;    //用户名重复
  NET_ERR_ASSOCIATED_SAMEWALL_IN_DIFFERENT_NETWORKAREAS = 1089;    //不同数据网络区域的输出口不能关联到同一电视墙
  NET_ERR_BASEMAP_ROAM_IN_LED_AREA = 1090;    //LED区域不允许底图漫游
  NET_ERR_VIRTUAL_LED_NOT_SUPPORT_4K_OUTPUT = 1091;    //虚拟LED不支持4K输出口显示
  NET_ERR_BASEMAP_NOT_SUPPORT_4K_OUTPUT = 1092;    //底图不支持4K输出口显示
  NET_ERR_MIN_BLOCK_IN_VIRTUAL_LED_AND_OUTPUT = 1093;    //虚拟LED与输出口相交出现最小块
  NET_ERR_485FIlE_VERSION_INVALID = 1094;    //485文件版本无效
  NET_ERR_485FIlE_CHECK_ERROR = 1095;    //485文件校验错误
  NET_ERR_485FIlE_ABNORMAL_SIZE = 1096;    //485文件大小异常效
  NET_ERR_MODIFY_SUBBOARD_NETCFG_IN_NAT = 1097;    //NAT下无法修改子板网络参
  NET_ERR_OSD_CONTENT_WITH_ILLEGAL_CHARACTERS = 1098;    //OSD内容包含非法字符
  NET_ERR_NON_SLAVE_DEVICE_INSERT_SYNC_LINE = 1099;    //非从设备禁止插入同步线
//民用错误码（1100～1200）
const
  NET_ERR_PLT_USERID = 1100;    //验证平台userid错误
  NET_ERR_TRANS_CHAN_START = 1101;    //透明通道已打开，当前操作无法完成
  NET_ERR_DEV_UPGRADING = 1102;    //设备正在升级
  NET_ERR_MISMATCH_UPGRADE_PACK_TYPE = 1103;    //升级包类型不匹配
  NET_ERR_DEV_FORMATTING = 1104;    //设备正在格式化
  NET_ERR_MISMATCH_UPGRADE_PACK_VERSION = 1105;    //升级包版本不匹配
  NET_ERR_PT_LOCKED = 1106;    //PT锁定功能

const
  NET_DVR_LOGO_OVERLAY_WITHOUT_UPLOAD_PIC = 1110;    //logo叠加失败，没有上传logo图片
  NET_DVR_ERR_ILLEGAL_VERIFICATION_CODE = 1111;    //不合法验证码
  NET_DVR_ERR_LACK_VERIFICATION_CODE = 1112;    //缺少验证码
  NET_DVR_ERR_FORBIDDEN_IP = 1113;    //该IP地址已被禁止，不允许配置(设备支持的IP地址过滤功能)
  NET_DVR_ERR_UNLOCKPTZ = 1114;    //操作无效，请先锁定云台
  NET_DVR_ERR_COUNTAREA_LARGE = 1116;    //计数区域绘制错误，区域面积大于设备允许值
  NET_DVR_ERR_LABEL_ID_EXCEED = 1117;    //标签ID超限
  NET_DVR_ERR_LABEL_TYPE = 1118;    //标签类型错误
  NET_DVR_ERR_LABEL_FULL = 1119;    //标签满
  NET_DVR_ERR_LABEL_DISABLED = 1120;    //标签未使能
  NET_DVR_ERR_DOME_PT_TRANS_TO_DOME_XY = 1121;    //球机PT转球机XY失败
  NET_DVR_ERR_DOME_PT_TRANS_TO_PANORAMA_XY = 1122;    //球机PT转全景XY失败
  NET_DVR_ERR_PANORAMA_XY_TRANS_TO_DOME_PT = 1123;    //全景XY坐标转球机PT错误
  NET_DVR_ERR_SCENE_DUR_TIME_LESS_THAN_INTERV_TIME = 1124;    //场景停留时间要大于检测周期
  NET_DVR_ERR_HTTP_BKN_EXCEED_ONE = 1125;    //断网续传布防只支持一路
  NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_WEBSOCKETS_FIRST = 1126;    //删除失败，请先关闭HTTPS和网络服务中的增强型SDK服务及WebSockets服务。
  NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_FIRST = 1127;    //删除失败，请先关闭HTTPS和网络服务中的增强型SDK服务
  NET_DVR_ERR_PTZ_OCCUPIED_PRIORITY = 1128;    // 有高优先级云台控制权限用户操作
  NET_DVR_ERR_INCORRECT_VIDEOAUDIO_ID = 1129;    // 视频通道编码ID或语音输出通道编码ID错误
  NET_DVR_ERR_REPETITIONTIME_OVER_MAXIMUM = 1130;    // 去重时间最大不超过最大值
  NET_DVR_ERR_FORMATTING_FAILED = 1131;    // 格式化错误，请重新
  NET_DVR_ERR_ENCRYPTED_FORMATTING_FAILED = 1132;    // 加密格式化失败，请重试
  NET_DVR_ERR_WRONG_PASSWORD = 1133;    // 密码错误,请输入正确的密码（SD卡 密码校验失败）
  NET_DVR_ERR_EXPOSURE_SYNC = 1134;    // 镜头间曝光同步已开启，不允许配置手动RGB

//2012-10-16 报警设备错误码（1200~1300）
const
  NET_ERR_SEARCHING_MODULE = 1201;    // 正在搜索外接模块
  NET_ERR_REGISTERING_MODULE = 1202;    // 正在注册外接模块
  NET_ERR_GETTING_ZONES = 1203;    // 正在获取防区参数
  NET_ERR_GETTING_TRIGGERS = 1204;    // 正在获取触发器
  NET_ERR_ARMED_STATUS = 1205;    // 系统处于布防状态
  NET_ERR_PROGRAM_MODE_STATUS = 1206;    // 系统处于编程模式
  NET_ERR_WALK_TEST_MODE_STATUS = 1207;    // 系统处于步测模式
  NET_ERR_BYPASS_STATUS = 1208;    // 旁路状态
  NET_ERR_DISABLED_MODULE_STATUS = 1209;    // 功能未使能
  NET_ERR_NOT_SUPPORT_OPERATE_ZONE = 1210;    // 防区不支持该操作
  NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR = 1211;    // 模块地址不能被修改
  NET_ERR_UNREGISTERED_MODULE = 1212;    // 模块未注册
  NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF = 1213;    // 公共子系统关联自身
  NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM = 1214;    // 超过公共子系统最大关联个数
  NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM = 1215;    // 子系统被其他公共子系统关联
  NET_ERR_ZONE_FAULT_STATUS = 1216;    // 防区处于故障状态
  NET_ERR_SAME_EVENT_TYPE = 1217;    // 事件触发报警输出开启和事件触发报警输出关闭中有相同事件类型
  NET_ERR_ZONE_ALARM_STATUS = 1218;    // 防区处于报警状态
  NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT = 1219;    //扩展总线短路
  NET_ERR_PWD_CONFLICT = 1220;    //密码冲突
  NET_ERR_DETECTOR_GISTERED_BY_OTHER_ZONE = 1221;    //探测器已被其他防区注册
  NET_ERR_DETECTOR_GISTERED_BY_OTHER_PU = 1222;    //探测器已被其他主机注册
  NET_ERR_DETECTOR_DISCONNECT = 1223;    //探测器不在线
  NET_ERR_CALL_BUSY = 1224;    //设备正在通话中
  NET_DVR_ERR_ZONE_TAMPER_STAUS = 1225;    //防区处于防拆状态
  NET_DVR_ERR_WIRELESS_DEV_REGISTER = 1226;    //无线外设已被其他主机注册
  NET_DVR_ERR_WIRELESS_DEV_ADDED = 1227;    //无线外设已被添加
  NET_DVR_ERR_WIRELESS_DEV_OFFLINE = 1228;    //无线外设不在线
  NET_DVR_ERR_WIRELESS_DEV_TAMPER_STATUS = 1229;    //无线外设处于防拆状态
  NET_DVR_ERR_GPRS_PHONE_CONFLICT = 1230;    //电话报警与无线报警中心冲突
  NET_ERR_INIT_PASSWORD_NOT_MODIFY = 1231;    //初始密码未修改，无法进行其他操作（安装商/管理员用户在初始密码未修改时，除修改自身用户密码外，其他操作均返回该错误码
  NET_ERR_USER_DISABLED = 1232;    //用户未开启
  NET_ERR_DEVICE_DEBUGGING = 1233;    //当前设备处于调试模式中
//信息发布主机
const
  NET_ERR_GET_ALL_RETURN_OVER = 1300;    //获取所有返回数目超限
  NET_ERR_RESOURCE_USING = 1301;    //信息发布资源正在使用，不能修改
  NET_ERR_FILE_SIZE_OVERLIMIT = 1302;    //文件大小超限

//信息发布服务器错误码
const
  NET_ERR_MATERIAL_NAME = 1303;    //素材名称非法
  NET_ERR_MATERIAL_NAME_LEN = 1304;    //素材名称长度非法
  NET_ERR_MATERIAL_REMARK = 1305;    //素材描述非法
  NET_ERR_MATERIAL_REMARK_LEN = 1306;    //素材描述长度非法
  NET_ERR_MATERIAL_SHARE_PROPERTY = 1307;    //素材共享属性非法
  NET_ERR_UNSUPPORT_MATERIAL_TYPE = 1308;    //素材类型不支持
  NET_ERR_MATERIAL_NOT_EXIST = 1309;    //素材不存在
  NET_ERR_READ_FROM_DISK = 1310;    //从硬盘读取素材文件失败
  NET_ERR_WRITE_TO_DISK = 1311;    //向硬盘写素材文件失败
  NET_ERR_WRITE_DATA_BASE = 1312;    //素材写数据库失败
  NET_ERR_NO_APPROVED_NOT_EXPORT = 1313;    //未审核内容禁止发布
  NET_ERR_MATERIAL_EXCEPTION = 1314;    //素材异常
  NET_ERR_NO_MISINFO = 1315;    //无误报信息
  NET_ERR_LAN_NOT_SUP_DHCP_CLIENT_CONFIGURATION = 1316;    //网桥在路由模式下，配置DHCP客户端返回错误
  NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT = 1317;    //电视墙上各输出口分辨率不一致(主要用于设置输出分辨率为4K出现异常时报错)
  NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT_UNBIND_OPTPORT_FIRST = 1318;    //电视墙上各输出口分辨率不一致，请先解绑定输出口(主要用于绑定输出口出现异常时报错)
  NET_ERR_FOUR_K_OUTPUT_RESOLUTION_UNSUPPORT_NINE_TO_SIXTEEN_SPLIT_SCREEN = 1319;    //4K输出分辨率不支持9/16分屏
  NET_ERR_SIGNAL_SOURCE_UNSUPPORT_CUSTOM_RESOLUTION = 1320;    //信号源不支持该自定义分辨率
  NET_ERR_DVI_UNSUPPORT_FOURK_OUTPUT_RESOLUTION = 1321;    //DVI不支持4K输出分辨率
  NET_ERR_BNC_UNSUPPORT_SOURCE_CROPPING = 1322;    //BNC不支持信号源裁剪
  NET_ERR_OUTPUT_NOT_SUPPORT_VIDEOWALL_RESOLUTION = 1323;    //输出口不支持电视墙分辨率

//多屏互动错误码
const
  NET_ERR_MAX_SCREEN_CTRL_NUM = 1351;    //屏幕控制连接数达到上限
  NET_ERR_FILE_NOT_EXIST = 1352;    //文件不存在
  NET_ERR_THUMBNAIL_NOT_EXIST = 1353;    //缩略图不存在
  NET_ERR_DEV_OPEN_FILE_FAIL = 1354;    //设备端打开文件失败
  NET_ERR_SERVER_READ_FILE_FAIL = 1355;    //设备端读取文件失败
  NET_ERR_FILE_SIZE = 1356;    //文件大小错误
  NET_ERR_FILE_NAME = 1357;    //文件名称错误，为空或不合法

//分段错误码（1351-1400）
const
  NET_ERR_BROADCAST_BUSY = 1358;    //设备正在广播中

//2012-12-20抓拍机错误码（1400-1499）
const
  NET_DVR_ERR_LANENUM_EXCEED = 1400;    //车道数超出能力
  NET_DVR_ERR_PRAREA_EXCEED = 1401;    //牌识区域过大
  NET_DVR_ERR_LIGHT_PARAM = 1402;    //信号灯接入参数错误
  NET_DVR_ERR_LANE_LINE_INVALID = 1403;    //车道线配置错误
  NET_DVR_ERR_STOP_LINE_INVALID = 1404;    //停止线配置错误
  NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID = 1405;    //左/右转分界线配置错误
  NET_DVR_ERR_LANE_NO_REPEAT = 1406;    //叠加车道号重复
  NET_DVR_ERR_PRAREA_INVALID = 1407;    //牌识多边形不符合要求
  NET_DVR_ERR_LIGHT_NUM_EXCEED = 1408;    //视频检测交通灯信号灯数目超出最大值
  NET_DVR_ERR_SUBLIGHT_NUM_INVALID = 1409;    //视频检测交通灯信号灯子灯数目不合法
  NET_DVR_ERR_LIGHT_AREASIZE_INVALID = 1410;    //视频检测交通灯输入信号灯框大小不合法
  NET_DVR_ERR_LIGHT_COLOR_INVALID = 1411;    //视频检测交通灯输入信号灯颜色不合法
  NET_DVR_ERR_LIGHT_DIRECTION_INVALID = 1412;    //视频检测交通灯输入灯方向属性不合法
  NET_DVR_ERR_LACK_IOABLITY = 1413;    //IO口实际支持的能力不足

const
  NET_DVR_ERR_FTP_PORT = 1414;    //FTP端口号非法（端口号重复或者异常）
  NET_DVR_ERR_FTP_CATALOGUE = 1415;    //FTP目录名非法（启用多级目录，多级目录传值为空）
  NET_DVR_ERR_FTP_UPLOAD_TYPE = 1416;    //FTP上传类型非法（单ftp只支持全部/双ftp只支持卡口和违章）
  NET_DVR_ERR_FLASH_PARAM_WRITE = 1417;    //配置参数时写FLASH失败
  NET_DVR_ERR_FLASH_PARAM_READ = 1418;    //配置参数时读FLASH失败
  NET_DVR_ERR_PICNAME_DELIMITER = 1419;    //FTP图片命名分隔符非法
  NET_DVR_ERR_PICNAME_ITEM = 1420;    //FTP图片命名项非法（例如 分隔符）
  NET_DVR_ERR_PLATE_RECOGNIZE_TYPE = 1421;    //牌识区域类型非法 （矩形和多边形有效性校验）
  NET_DVR_ERR_CAPTURE_TIMES = 1422;    //抓拍次数非法 （有效值是0～5）
  NET_DVR_ERR_LOOP_DISTANCE = 1423;    //线圈距离非法 （有效值是0～2000ms）
  NET_DVR_ERR_LOOP_INPUT_STATUS = 1424;    //线圈输入状态非法 （有效值）
  NET_DVR_ERR_RELATE_IO_CONFLICT = 1425;    //测速组IO关联冲突
  NET_DVR_ERR_INTERVAL_TIME = 1426;    //连拍间隔时间非法 （0～6000ms）
  NET_DVR_ERR_SIGN_SPEED = 1427;    //标志限速值非法（大车标志限速不能大于小车标志限速 ）
  NET_DVR_ERR_PIC_FLIP = 1428;    //图像配置翻转 （配置交互影响）
  NET_DVR_ERR_RELATE_LANE_NUMBER = 1429;    //关联车道数错误 (重复 有效值校验1～99)
  NET_DVR_ERR_TRIGGER_MODE = 1430;    //配置抓拍机触发模式非法
  NET_DVR_ERR_DELAY_TIME = 1431;    //触发延时时间错误(2000ms)
  NET_DVR_ERR_EXCEED_RS485_COUNT = 1432;    //超过最大485个数限制
  NET_DVR_ERR_RADAR_TYPE = 1433;    //雷达类型错误
  NET_DVR_ERR_RADAR_ANGLE = 1434;    //雷达角度错误
  NET_DVR_ERR_RADAR_SPEED_VALID_TIME = 1435;    //雷达有效时间错误
  NET_DVR_ERR_RADAR_LINE_CORRECT = 1436;    //雷达线性矫正参数错误
  NET_DVR_ERR_RADAR_CONST_CORRECT = 1437;    //雷达常量矫正参数错误
  NET_DVR_ERR_RECORD_PARAM = 1438;    //录像参数无效（预录时间不超过10s）
  NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION = 1439;    //视频检测信号灯配置信号灯个数，但是没有勾选信号灯方向和颜色的
  NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION = 1440;    //视频检测信号灯配置信号灯个数，但是没有画检测区域
  NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM = 1441;    //牌识参数省份参数的合法性

const
  NET_DVR_ERR_SPEED_TIMEOUT = 1442;    //IO测速超时时间非法（有效值大于0）
  NET_DVR_ERR_NTP_TIMEZONE = 1443;    //ntp时区参数错误
  NET_DVR_ERR_NTP_INTERVAL_TIME = 1444;    //ntp校时间隔错误
  NET_DVR_ERR_NETWORK_CARD_NUM = 1445;    //可配置网卡数目错误
  NET_DVR_ERR_DEFAULT_ROUTE = 1446;    //默认路由错误
  NET_DVR_ERR_BONDING_WORK_MODE = 1447;    //bonding网卡工作模式错误
  NET_DVR_ERR_SLAVE_CARD = 1448;    //slave网卡错误
  NET_DVR_ERR_PRIMARY_CARD = 1449;    //Primary网卡错误
  NET_DVR_ERR_DHCP_PPOE_WORK = 1450;    //dhcp和pppoE不能同时启动
  NET_DVR_ERR_NET_INTERFACE = 1451;    //网络接口错误
  NET_DVR_ERR_MTU = 1452;    //MTU错误
  NET_DVR_ERR_NETMASK = 1453;    //子网掩码错误
  NET_DVR_ERR_IP_INVALID = 1454;    //IP地址不合法
  NET_DVR_ERR_MULTICAST_IP_INVALID = 1455;    //多播地址不合法
  NET_DVR_ERR_GATEWAY_INVALID = 1456;    //网关不合法
  NET_DVR_ERR_DNS_INVALID = 1457;    //DNS不合法
  NET_DVR_ERR_ALARMHOST_IP_INVALID = 1458;    //告警主机地址不合法
  NET_DVR_ERR_IP_CONFLICT = 1459;    //IP冲突
  NET_DVR_ERR_NETWORK_SEGMENT = 1460;    //IP不支持同网段
  NET_DVR_ERR_NETPORT = 1461;    //端口错误

const
  NET_DVR_ERR_PPPOE_NOSUPPORT = 1462;    //PPPOE不支持
  NET_DVR_ERR_DOMAINNAME_NOSUPPORT = 1463;    //域名不支持
  NET_DVR_ERR_NO_SPEED = 1464;    //未启用测速功能
  NET_DVR_ERR_IOSTATUS_INVALID = 1465;    //IO状态错误
  NET_DVR_ERR_BURST_INTERVAL_INVALID = 1466;    //连拍间隔非法
  NET_DVR_ERR_RESERVE_MODE = 1467;    //备用模式错误

const
  NET_DVR_ERR_LANE_NO = 1468;    //叠加车道号错误
  NET_DVR_ERR_COIL_AREA_TYPE = 1469;    //线圈区域类型错误
  NET_DVR_ERR_TRIGGER_AREA_PARAM = 1470;    //触发区域参数错误
  NET_DVR_ERR_SPEED_LIMIT_PARAM = 1471;    //违章限速参数错误
  NET_DVR_ERR_LANE_PROTOCOL_TYPE = 1472;    //车道关联协议类型错误

const
  NET_DVR_ERR_INTERVAL_TYPE = 1473;    //连拍间隔类型非法
  NET_DVR_ERR_INTERVAL_DISTANCE = 1474;    //连拍间隔距离非法
  NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE = 1475;    //RS485关联类型非法
  NET_DVR_ERR_RS485_ASSOCIATE_LANENO = 1476;    //RS485关联车道号非法
  NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485 = 1477;    //车道号关联多个RS485口
  NET_DVR_ERR_LIGHT_DETECTION_REGION = 1478;    //视频检测信号灯配置信号灯个数，但是检测区域宽或高为0

const
  NET_DVR_ERR_DN2D_NOSUPPORT = 1479;    //不支持抓拍帧2D降噪
  NET_DVR_ERR_IRISMODE_NOSUPPORT = 1480;    //不支持的镜头类型
  NET_DVR_ERR_WB_NOSUPPORT = 1481;    //不支持的白平衡模式
  NET_DVR_ERR_IO_EFFECTIVENESS = 1482;    //IO口的有效性
  NET_DVR_ERR_LIGHTNO_MAX = 1483;    //信号灯检测器接入红/黄灯超限(16)
  NET_DVR_ERR_LIGHTNO_CONFLICT = 1484;    //信号灯检测器接入红/黄灯冲突

const
  NET_DVR_ERR_CANCEL_LINE = 1485;    //直行触发线
  NET_DVR_ERR_STOP_LINE = 1486;    //待行区停止线
  NET_DVR_ERR_RUSH_REDLIGHT_LINE = 1487;    //闯红灯触发线
  NET_DVR_ERR_IOOUTNO_MAX = 1488;    //IO输出口编号越界

const
  NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX = 1489;    //IO输出口提前时间超限
  NET_DVR_ERR_IOOUTNO_IOWORKTIME = 1490;    //IO输出口有效持续时间超限
  NET_DVR_ERR_IOOUTNO_FREQMULTI = 1491;    //IO输出口脉冲模式下倍频出错
  NET_DVR_ERR_IOOUTNO_DUTYRATE = 1492;    //IO输出口脉冲模式下占空比出错
  NET_DVR_ERR_VIDEO_WITH_EXPOSURE = 1493;    //以曝闪起效，工作方式不支持视频
  NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET = 1494;    //车牌亮度自动使能闪光灯仅在车牌亮度补偿模式下起效

const
  NET_DVR_ERR_RECOGNIZE_TYPE_PARAM = 1495;    //识别类型非法 车牌识别参数（如大车、小车、背向、正向、车标识别等）
  NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM = 1496;    //牌识参数非法 牌识区域配置时判断出错
  NET_DVR_ERR_PORT_CONFLICT = 1497;    //端口有冲突
  NET_DVR_ERR_LOOP_IP = 1498;    //IP不能设置为回环地址
  NET_DVR_ERR_DRIVELINE_SENSITIVE = 1499;    //压线灵敏度出错(视频电警模式下)


//2013-3-6VQD错误码（1500～1550）
const
  NET_ERR_VQD_TIME_CONFLICT = 1500;    //VQD诊断时间段冲突
  NET_ERR_VQD_PLAN_NO_EXIST = 1501;    //VQD诊断计划不存在
  NET_ERR_VQD_CHAN_NO_EXIST = 1502;    //VQD布防点不存在
  NET_ERR_VQD_CHAN_MAX = 1503;    //VQD计划数已达上限
  NET_ERR_VQD_TASK_MAX = 1504;    //VQD任务数已达上限

const
  NET_SDK_GET_INPUTSTREAMCFG = 1551;    //获取信号源
  NET_SDK_AUDIO_SWITCH_CONTROL = 1552;    //子窗口音频开关控制
  NET_SDK_GET_VIDEOWALLDISPLAYNO = 1553;    //获取设备显示输出号
  NET_SDK_GET_ALLSUBSYSTEM_BASIC_INFO = 1554;    //获取所有子系统基本信息
  NET_SDK_SET_ALLSUBSYSTEM_BASIC_INFO = 1555;    //设置所有子系统基本信息
  NET_SDK_GET_AUDIO_INFO = 1556;    //获取所有音频信息
  NET_SDK_GET_MATRIX_STATUS_V50 = 1557;    // 获取视频综合平台状态_V50
  NET_SDK_DELETE_MONITOR_INFO = 1558;    //删除Monitor信息
  NET_SDK_DELETE_CAMERA_INFO = 1559;    //删除Camaera信息


//抓拍机错误码新增扩展(1600~1900)
const
  NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES = 1600;    //抓拍模式为频闪时最大抓拍张数为2张(IVT模式下)
  NET_DVR_ERR_REDAR_TYPE_CONFLICT = 1601;    //相同485口关联雷达类型冲突
  NET_DVR_ERR_LICENSE_PLATE_NULL = 1602;    //车牌号为空
  NET_DVR_ERR_WRITE_DATABASE = 1603;    //写入数据库失败
  NET_DVR_ERR_LICENSE_EFFECTIVE_TIME = 1604;    //车牌有效时间错误
//视频电警
const
  NET_DVR_ERR_PRERECORDED_STARTTIME_LONG = 1605;    //预录开始时间大于违法抓拍张数
//混合卡口
const
  NET_DVR_ERR_TRIGGER_RULE_LINE = 1606;    //触发规则线错误
  NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL = 1607;    //左/右触发线不垂直
  NET_DVR_ERR_FLASH_LAMP_MODE = 1608;    //闪光灯闪烁模式错误
  NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM = 1609;    //违章抓拍张数错误
  NET_DVR_ERR_ILLEGAL_DETECTION_TYPE = 1610;    //违章检测类型错误
  NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH = 1611;    //正背向触发线高度错误
  NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS = 1612;    //混合模式下只支持机非人抓拍类型

const
  NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED = 1613;    //小车标志限速大于限速值
  NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED = 1614;    //大车标志限速大于限速值
  NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED = 1615;    //大车标志限速大于小车标志限速值
  NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED = 1616;    //大车限速值大于小车限速值
  NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT = 1617;    //大车低速限速值大于小车低速限速值
  NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED = 1618;    //小车限速大于异常高速值
  NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED = 1619;    //大车限速大于异常高速值
  NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE = 1620;    //停止线超过直行触发线
  NET_DVR_ERR_YELLOWLIGHTTIME_INVALID = 1621;    //视频检测黄灯持续时间不合法报错
  NET_DVR_ERR_TRIGGERLINE1_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE2 = 1622;    //第一条不礼让行人触发线的位置超过了第二条不礼让行人触发线
  NET_DVR_ERR_TRIGGERLINE2_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE1 = 1623;    //第二条不礼让行人触发线的位置超过了第一条不礼让行人触发线

//门禁主机错误码
const
  NET_ERR_TIME_OVERLAP = 1900;    //时间段重叠
  NET_ERR_HOLIDAY_PLAN_OVERLAP = 1901;    //假日计划重叠
  NET_ERR_CARDNO_NOT_SORT = 1902;    //卡号未排序
  NET_ERR_CARDNO_NOT_EXIST = 1903;    //卡号不存在
  NET_ERR_ILLEGAL_CARDNO = 1904;    //卡号错误
  NET_ERR_ZONE_ALARM = 1905;    //防区处于布防状态(参数修改不允许)
  NET_ERR_ZONE_OPERATION_NOT_SUPPORT = 1906;    //防区不支持该操作
  NET_ERR_INTERLOCK_ANTI_CONFLICT = 1907;    //多门互锁和反潜回同时配置错误
  NET_ERR_DEVICE_CARD_FULL = 1908;    //卡已满（卡达到10W后返回）
  NET_ERR_HOLIDAY_GROUP_DOWNLOAD = 1909;    //假日组下载失败
  NET_ERR_LOCAL_CONTROL_OFF = 1910;    //就地控制器离线
  NET_ERR_LOCAL_CONTROL_DISADD = 1911;    //就地控制器未添加
  NET_ERR_LOCAL_CONTROL_HASADD = 1912;    //就地控制器已添加
  NET_ERR_LOCAL_CONTROL_DOORNO_CONFLICT = 1913;    //与已添加的就地控制器门编号冲突
  NET_ERR_LOCAL_CONTROL_COMMUNICATION_FAIL = 1914;    //就地控制器通信失败
  NET_ERR_OPERAND_INEXISTENCE = 1915;    //操作对象不存在（对门、报警输出、报警输入相关操作，当对象未添加时返回）
  NET_ERR_LOCAL_CONTROL_OVER_LIMIT = 1916;    //就地控制器超出设备最大能力（主控对就地数量有限制）
  NET_ERR_DOOR_OVER_LIMIT = 1917;    //门超出设备最大能力
  NET_ERR_ALARM_OVER_LIMIT = 1918;    //报警输入输出超出设备最大能力
  NET_ERR_LOCAL_CONTROL_ADDRESS_INCONFORMITY_TYPE = 1919;    //就地控制器地址与类型不符
  NET_ERR_NOT_SUPPORT_ONE_MORE_CARD = 1920;    //不支持一人多卡
  NET_ERR_DELETE_NO_EXISTENCE_FACE = 1921;    //删除的人脸不存在
  NET_ERR_DOOR_SPECIAL_PASSWORD_REPEAT = 1922;    //与设备门特殊密码重复
  NET_ERR_AUTH_CODE_REPEAT = 1923;    //与设备认证码重复
  NET_ERR_DEPLOY_EXCEED_MAX = 1924;    //布防超过最大连接数
  NET_ERR_NOT_SUPPORT_DEL_FP_BY_ID = 1925;    //读卡器不支持按手指ID删除指纹
  NET_ERR_TIME_RANGE = 1926;    //有效期参数配置范围有误
  NET_ERR_CAPTURE_TIMEOUT = 1927;    //采集超时
  NET_ERR_LOW_SCORE = 1928;    //采集质量低
  NET_ERR_OFFLINE_CAPTURING = 1929;    //离线采集中，无法响应

//可视对讲错误码
const
  NET_DVR_ERR_OUTDOOR_COMMUNICATION = 1950;    //与门口机通信异常
  NET_DVR_ERR_ROOMNO_UNDEFINED = 1951;    //未设置房间号
  NET_DVR_ERR_NO_CALLING = 1952;    //无呼叫
  NET_DVR_ERR_RINGING = 1953;    //响铃
  NET_DVR_ERR_IS_CALLING_NOW = 1954;    //正在通话
  NET_DVR_ERR_LOCK_PASSWORD_WRONG = 1955;    //智能锁密码错误
  NET_DVR_ERR_CONTROL_LOCK_FAILURE = 1956;    //开关锁失败
  NET_DVR_ERR_CONTROL_LOCK_OVERTIME = 1957;    //开关锁超时
  NET_DVR_ERR_LOCK_DEVICE_BUSY = 1958;    //智能锁设备繁忙
  NET_DVR_ERR_UNOPEN_REMOTE_LOCK_FUNCTION = 1959;    //远程开锁功能未打开


//后端错误码 （2100 - 3000）
const
  NET_DVR_ERR_FILE_NOT_COMPLETE = 2100;    //下载的文件不完整
  NET_DVR_ERR_IPC_EXIST = 2101;    //该IPC已经存在
  NET_DVR_ERR_ADD_IPC = 2102;    //该通道已添加IPC
  NET_DVR_ERR_OUT_OF_RES = 2103;    //网络带宽能力不足
  NET_DVR_ERR_CONFLICT_TO_LOCALIP = 2104;    //IPC的ip地址跟DVR的ip地址冲突
  NET_DVR_ERR_IP_SET = 2105;    //非法ip地址
  NET_DVR_ERR_PORT_SET = 2106;    //非法的端口号

const
  NET_ERR_WAN_NOTSUPPORT = 2107;    //不在同一个局域网，无法设置安全问题或导出GUID文件
  NET_ERR_MUTEX_FUNCTION = 2108;    //功能互斥
  NET_ERR_QUESTION_CONFIGNUM = 2109;    //安全问题配置数量错误
  NET_ERR_FACECHAN_NORESOURCE = 2110;    //人脸智能通道资源已用完
  NET_ERR_DATA_CALLBACK = 2111;    //正在数据回迁
  NET_ERR_ATM_VCA_CHAN_IS_RELATED = 2112;    //ATM智能通道已被关联
  NET_ERR_ATM_VCA_CHAN_IS_OVERLAPED = 2113;    //ATM智能通道已被叠加
  NET_ERR_FACE_CHAN_UNOVERLAP_EACH_OTHER = 2114;    //人脸通道不能互相叠加
  NET_ERR_ACHIEVE_MAX_CHANNLE_LIMIT = 2115;    //达到最大路数限制
  NET_DVR_SMD_ENCODING_NORESOURSE = 2116;    //SMD编码资源不足
  NET_DVR_SMD_DECODING_NORESOURSE = 2117;    //SMD解码资源不足
  NET_DVR_FACELIB_DATA_PROCESSING = 2118;    //人脸库数据正在处理
  NET_DVR_ERR_LARGE_TIME_DIFFRENCE = 2119;    //设备和服务器之间的时间差异太大
  NET_DVR_NO_SUPPORT_WITH_PLAYBACK = 2120;    //已开启回放，不支持本功能
  NET_DVR_CHANNEL_NO_SUPPORT_WITH_SMD = 2121;    //通道已开启SMD，不支持本功能
  NET_DVR_CHANNEL_NO_SUPPORT_WITH_FD = 2122;    //通道已开启人脸抓拍，不支持本功能
  NET_DVR_ILLEGAL_PHONE_NUMBER = 2123;    //非法的电话号码
  NET_DVR_ILLEGAL_CERITIFICATE_NUMBER = 2124;    //非法的证件号码
  NET_DVR_ERR_CHANNEL_RESOLUTION_NO_SUPPORT = 2125;    //通道分辨率不支持
  NET_DVR_ERR_CHANNEL_COMPRESSION_NO_SUPPORT = 2126;    //通道编码格式不支持

const
  NET_DVR_ERR_CLUSTER_DEVICE_TOO_LESS = 2127;    //设备数少，不允许删除
  NET_DVR_ERR_CLUSTER_DEL_DEVICE_CM_PLAYLOAD = 2128;    //该设备是集群主机，不允许删除
  NET_DVR_ERR_CLUSTER_DEVNUM_OVER_UPPER_LIMIT = 2129;    //设备数达到上限，不允许增加
  NET_DVR_ERR_CLUSTER_DEVICE_TYPE_INCONFORMITY = 2130;    //设备类型不一致
  NET_DVR_ERR_CLUSTER_DEVICE_VERSION_INCONFORMITY = 2131;    //设备版本不一致
  NET_DVR_ERR_CLUSTER_IP_CONFLICT = 2132;    //集群系统IP地址冲突：ipv4地址冲突、ipv6地址冲突
  NET_DVR_ERR_CLUSTER_IP_INVALID = 2133;    //集群系统IP地址无效：ipv4非法、ipv6非法
  NET_DVR_ERR_CLUSTER_PORT_CONFLICT = 2134;    //集群系统端口冲突
  NET_DVR_ERR_CLUSTER_PORT_INVALID = 2135;    //集群系统端口非法
  NET_DVR_ERR_CLUSTER_USERNAEM_OR_PASSWORD_INVALID = 2136;    //组网用户名或密码非法
  NET_DVR_ERR_CLUSTER_DEVICE_ALREADY_EXIST = 2137;    //存在相同设备
  NET_DVR_ERR_CLUSTER_DEVICE_NOT_EXIST = 2138;    //设备不存在(组网时下发的cs列表中的设备信息在任何一台cs上都找不到，删除的时候下发的id不对)
  NET_DVR_ERR_CLUSTER_NON_CLUSTER_MODE = 2139;    //设备处于非集群模式
  NET_DVR_ERR_CLUSTER_IP_NOT_SAME_LAN = 2140;    //IP地址不在同一局域网，不同区域网不允许组网/扩容

const
  NET_DVR_ERR_CAPTURE_PACKAGE_FAILED = 2141;    //抓包失败
  NET_DVR_ERR_CAPTURE_PACKAGE_PROCESSING = 2142;    //正在抓包
  NET_DVR_ERR_SAFETY_HELMET_NO_RESOURCE = 2143;    //安全帽检测资源不足
  NET_DVR_NO_SUPPORT_WITH_ABSTRACT = 2144;    //已开启视频摘要，不支持本功能
  NET_DVR_ERR_TAPE_LIB_NEED_STOP_ARCHIVE = 2145;    //磁带库归档需要停止
  NET_DVR_INSUFFICIENT_DEEP_LEARNING_RESOURCES = 2146;    //深度学习资源超限
  NET_DVR_ERR_IDENTITY_KEY = 2147;    //交互口令错误
  NET_DVR_MISSING_IDENTITY_KEY = 2148;    //交互口令缺失
  NET_DVR_NO_SUPPORT_WITH_PERSON_DENSITY_DETECT = 2149;    //已开启人员密度检测，不支持本功能
  NET_DVR_IPC_RESOLUTION_OVERFLOW = 2150;    //IPC分辨率超限
  NET_DVR_IPC_BITRATE_OVERFLOW = 2151;    //IPC码率超限
  NET_DVR_ERR_INVALID_TASKID = 2152;    //无效的taskID
  NET_DVR_PANEL_MODE_NOT_CONFIG = 2153;    //没有配置面板路智能
  NET_DVR_NO_HUMAN_ENGINES_RESOURCE = 2154;    //人体引擎资源不足
  NET_DVR_ERR_TASK_NUMBER_OVERFLOW = 2155;    //任务数据超过上限
  NET_DVR_ERR_COLLISION_TIME_OVERFLOW = 2156;    //碰撞时间超过上限
  NET_DVR_ERR_CAPTURE_PACKAGE_NO_USB = 2157;    //未识别到U盘，请插入U盘或重新插入
  NET_DVR_ERR_NO_SET_SECURITY_EMAIL = 2158;    //未设置安全邮箱
  NET_DVR_ERR_EVENT_NOTSUPPORT = 2159;    //订阅事件不支持
  NET_DVR_ERR_PASSWORD_FORMAT = 2160;    //密码格式不对
  NET_DVR_ACCESS_FRONT_DEVICE_PARAM_FAILURE = 2161;    //获取前端设备参数失败
  NET_DVR_ACCESS_FRONT_DEVICE_STREAM_FAILURE = 2162;    //对前端设备取流失败
  NET_DVR_ERR_USERNAME_FORMAT = 2163;    //用户名格式不对
  NET_DVR_ERR_UNOPENED_HIGH_RESOLUTION_MODE = 2164;    //超高分辨率模式未开启
  NET_DVR_ERR_TOO_SMALL_QUATO = 2165;    //配额设置太小
  NET_DVR_ERR_EMAIL_FORMAT = 2166;    //邮箱格式不对
  NET_DVR_ERR_SECURITY_CODE_FORMAT = 2167;    //安全码格式不对
  NET_DVR_PD_SPACE_TOO_SMALL = 2168;    //阵列硬盘容量太小
  NET_DVR_PD_NUM_TOO_BIG = 2169;    //阵列硬盘总数超过总盘数的二分之一
  NET_DVR_ERR_USB_IS_FULL = 2170;    //U盘已满
  NET_DVR_EXCEED_MAX_SMD_TYPE = 2171;    //达到最大SMD事件种类上限
  NET_DVR_CHANNEL_NO_SUPPORT_WITH_BEHAVIOR = 2172;    //通道已开启异常行为检测，不支持本功能
  NET_DVR_NO_BEHAVIOR_ENGINES_RESOURCE = 2173;    //异常行为检测资源不足
  NET_DVR_NO_RETENTION_ENGINES_RESOURCE = 2174;    //人员滞留检测资源不足
  NET_DVR_NO_LEAVE_POSITION_ENGINES_RESOURCE = 2175;    //离岗检测资源不足
  NET_DVR_NO_PEOPLE_NUM_CHANGE_ENGINES_RESOURCE = 2176;    //人数异常资源不足
  NET_DVR_PANEL_MODE_NUM_OVER_LIMIT = 2177;    //超过面板路最大路数
  NET_DVR_SURROUND_MODE_NUM_OVER_LIMIT = 2178;    //超过环境路最大路数
  NET_DVR_FACE_MODE_NUM_OVER_LIMIT = 2179;    //超过人脸路最大路数
  NET_DVR_SAFETYCABIN_MODE_NUM_OVER_LIMIT = 2180;    //超过防护舱路最大路数
  NET_DVR_DETECT_REGION_RANGE_INVALID = 2181;    //检测区域范围非法
  NET_DVR_CHANNEL_CAPTURE_PICTURE_FAILURE = 2182;    //通道抓图失败
  NET_DVR_VCACHAN_IS_NORESOURCE = 2183;    //智能通道资源用完
  NET_DVR_IPC_NUM_REACHES_LIMIT = 2184;    // Ipc通道数目达到上限
  NET_DVR_IOT_NUM_REACHES_LIMIT = 2185;    // IOT通道数目达到上限
  NET_DVR_IOT_CHANNEL_DEVICE_EXIST = 2186;    //当前IOT通道已经添加设备
  NET_DVR_IOT_CHANNEL_DEVICE_NOT_EXIST = 2187;    //当前IOT通道不存在设备
  NET_DVR_INVALID_IOT_PROTOCOL_TYPE = 2188;    //非法的IOT协议类型
  NET_DVR_INVALID_EZVIZ_SECRET_KEY = 2189;    //非法的萤石注册验证码
  NET_DVR_DUPLICATE_IOT_DEVICE = 2190;    //重复的IOT设备
  NET_DVR_SADP_MODIFY_FALIURE = 2191;    // SADP修改失败
  NET_DVR_IPC_NETWORK_ABNORMAL = 2192;    // IPC网络异常
  NET_DVR_IPC_PASSWORD_ERROR = 2193;    // IPC用户名密码错误
  NET_DVR_ERROR_IPC_TYPE = 2194;    //IPC类型不对
  NET_DVR_ERROR_IPC_LIST_NOT_EMPTY = 2195;    //已添加IPC列表不为空，不支持一键配置
  NET_DVR_ERROR_IPC_LIST_NOT_MATCH_PAIRING = 2196;    //IPC列表和配单不匹配
  NET_DVR_ERROR_IPC_BAD_LANGUAGE = 2197;    //IPC语言和设备不匹配
  NET_DVR_ERROR_IPC_IS_LOCKING = 2198;    //IPC已被锁
  NET_DVR_ERROR_IPC_NOT_ACTIVATED = 2199;    //IPC未激活
  NET_DVR_FIELD_CODING_NOT_SUPPORT = 2200;    //场编码不支持
  NET_DVR_ERROR_H323_NOT_SUPPORT_H265 = 2201;    //H323视频会议就不支持H265码流
  NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_P = 2202;    //P制式下，曝光时间过大
  NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_N = 2203;    //N制式下，曝光时间过大
  NET_DVR_ERROR_PING_PROCESSING = 2204;    //正在PING
  NET_DVR_ERROR_PING_NOT_START = 2205;    //Ping功能未开始
  NET_DVR_ERROR_NEED_DOUBLE_VERIFICATION = 2206;    //需要二次认证
  NET_DVR_NO_DOUBLE_VERIFICATION_USER = 2207;    //无二次认证用户
  NET_DVR_CHANNEL_OFFLINE = 2208;    //通道离线
  NET_DVR_TIMESPAN_NUM_OVER_LIMIT = 2209;    //时间段超出支持最大数目
  NET_DVR_CHANNEL_NUM_OVER_LIMIT = 2210;    //通道数目超出支持最大数目
  NET_DVR_NO_SEARCH_ID_RESOURCE = 2211;    //分页查询的searchID资源不足
  NET_DVR_ERROR_ONEKEY_EXPORT = 2212;    //正在进行导出操作，请稍后再试
  NET_DVR_NO_CITY_MANAGEMENT_ENGINES_RESOURCE = 2213;    //城管算法引擎资源不足
  NET_DVR_NO_SITUATION_ANALYSIS_ENGINES_RESOURCE = 2214;    //态势分析引擎资源不足
  NET_DVR_INTELLIGENT_ANALYSIS_IPC_CANNT_DELETE = 2215;    //正在进行智能分析的IPC无法删除
  NET_DVR_NOSUPPORT_RESET_PASSWORD = 2216;    //NVR不支持对IPC重置密码
  NET_DVR_ERROR_IPC_NEED_ON_LAN = 2217;    // IPC需要在局域网内
  NET_DVR_CHANNEL_NO_SUPPORT_WITH_SAFETY_HELMET = 2218;    //通道已开启安全帽检测，不支持本功能
  NET_DVR_ERROR_GET_RESETPASSWORDTYPE_IS_ABNORMAL = 2219;    //IPC重置密码时，获取IPC的重置密码类型异常
  NET_DVR_ERROR_IPC_NOSUPPORT_RESET_PASSWORD = 2220;    // IPC不支持重置密码
  NET_DVR_ERROR_IP_IS_NOT_ONLY_ONE = 2221;    //IPC的IP不唯一，有重复
  NET_DVR_NO_SUPPORT_WITH_SMD_OR_SCD = 2222;    //已开启SMD/SCD，不支持本功能（SCD为场景变更）
  NET_DVR_NO_SUPPORT_WITH_FD = 2223;    //已开启人脸抓拍，不支持本功能
  NET_DVR_NO_FD_ENGINES_RESOURCE = 2224;    //人脸抓拍资源不足
  NET_DVR_ERROR_ONEKEY_REMOVE = 2225;    //正在进行删除操作，请稍后再试
  NET_DVR_FACE_PIP_BACKGROUND_CHANNEL_OVERFLOW = 2226;    //人脸画中画背景通道超限
  NET_DVR_MICIN_CHANNEL_OCCUPIED = 2227;    //micin通道被占用
  NET_DVR_IPC_CHANNEL_IS_IN_PIP = 2228;    //操作失败，该通道已关联到审讯通道，请先取消画中画配置关联

const
  NET_DVR_CHANNEL_NO_SUPPORT_WITH_FACE_CONTRAST = 2229;    //通道已开启人脸比对，不支持本功能

const
  NET_DVR_INVALID_RECHARGE_CARD = 2230;    //无效的充值卡
  NET_DVR_CLOUD_PLATFORM_SERVER_EXCEPTION = 2231;    //云平台服务器异常
  NET_DVR_OPERATION_FAILURE_WITHOUT_LOGIN = 2232;    //未登录操作失败
  NET_DVR_INVALID_ASSOCIATED_SERIAL_NUMBER = 2233;    //关联序列号非法
  NET_DVR_CLOUD_PLATFORM_ACCOUNT_NOT_EXIST = 2234;    //云平台帐号不存在
  NET_DVR_DEVICE_SERIAL_NUMBER_REGISTERED = 2235;    //设备序列号已注册
  NET_DVR_CONFERENCE_ROOM_NOT_EXIST = 2236;    //会议室不存在
  NET_DVR_NEED_DISABLED_ANALOG_CHANNEL = 2237;    //需禁用模拟通道
  NET_DVR_STUDENT_ROLL_CALL_FAILURE = 2238;    //学生点名失败
  NET_DVR_SUB_DEVICE_NOT_ENABLE_INDIVIDUAL_BEHAVIOR = 2239;    //子设备未启用个体行为模式
  NET_DVR_SUB_DEVICE_CHANNEL_CONTROL_FAILED = 2240;    //子设备通道控制失败
  NET_DVR_DEVICE_NOT_IN_CONFERENCE = 2241;    //设备不在会议中
  NET_DVR_ALREADY_EXIST_CONFERENCE = 2242;    //当前已经存在会议
  NET_DVR_NO_SUPPORT_WITH_VIDEO_CONFERENCE = 2243;    //当前正在视频会议中，不支持本功能
  NET_DVR_START_INTERACTION_FAILURE = 2244;    //互动开始失败
  NET_DVR_ASK_QUESTION_STARTED = 2245;    //已开始提问
  NET_DVR_ASK_QUESTION_CLOSED = 2246;    //已结束提问
  NET_DVR_UNABLE_OPERATE_BY_HOST = 2247;    //已被主持人禁用，无法操作
  NET_DVR_REPEATED_ASK_QUESTION = 2248;    //重复提问
  NET_DVR_SWITCH_TIMEDIFF_LESS_LIMIT = 2249;    //开关机时间差小于限制值(10分钟)
  NET_DVR_CHANNEL_DEVICE_EXIST = 2250;    //当前通道已经添加设备
  NET_DVR_CHANNEL_DEVICE_NOT_EXIST = 2251;    //当前通道不存在设备
  NET_DVR_ERROR_ADJUSTING_RESOLUTION = 2252;    //先关闭摄像机的裁剪，再调整分辨率
  NET_DVR_SSD_FILE_SYSTEM_IS_UPGRADING = 2253;    //SSD文件系统正在升级
  NET_DVR_SSD_FILE_SYSTEM_IS_FORMAT = 2254;    //SSD正在格式化
  NET_DVR_CHANNEL_IS_CONNECTING = 2255;    //当前通道正在连接

const
  NET_DVR_CHANNEL_STREAM_TYPE_NOT_SUPPORT = 2257;    //当前通道码流类型不支持
  NET_DVR_CHANNEL_USERNAME_NOT_EXIST = 2258;    //当前通道用户名不存在
  NET_DVR_CHANNEL_ACCESS_PARAM_FAILURE = 2259;    //当前通道获取参数失败
  NET_DVR_CHANNEL_GET_STREAM_FAILURE = 2260;    //当前通道取流失败
  NET_DVR_CHANNEL_RISK_PASSWORD = 2261;    //当前通道密码为风险密码

const
  NET_DVR_NO_SUPPORT_DELETE_STRANGER_LIB = 2262;    //不支持删除陌生人库
  NET_DVR_NO_SUPPORT_CREATE_STRANGER_LIB = 2263;    //不支持创建陌生人库

const
  NET_DVR_NETWORK_PORT_CONFLICT = 2264;    //网络配置端口冲突
  NET_DVR_TRANSCODE_NO_RESOURCES = 2265;    //转码资源不足
  NET_DVR_SSD_FILE_SYSTEM_ERROR = 2266;    //SSD文件系统错误
  NET_DVR_INSUFFICIENT_SSD__FOR_FPD = 2267;    //用于人员频次业务的SSD容量不够
  NET_DVR_ASSOCIATED_FACELIB_OVER_LIMIT = 2268;    //关联人脸库已达上限
  NET_DVR_NEED_DELETE_DIGITAL_CHANNEL = 2269;    //需删除数字通道
  NET_DVR_ERR_FALL_DOWN_RULENUM_LIMIT = 2270;    //人员倒地规则数上限
  NET_DVR_ERR_VIOLENT_MOTION_RULENUM_LIMIT = 2271;    //剧烈运动规则数上限
  NET_DVR_UPGRADE_ENGINE_VERSION_MISMATCH = 2272;    //升级包引擎版本不匹配(升级过程中返回)
  NET_ERR_SLEEP_STREAM_UNSUPPORT = 2273;    //相机处于休眠中，开启预览失败；请先唤醒后再进行尝试

//热成像产线相关错误码（3001 - 3500）
const
  NET_DVR_ERR_NOTSUPPORT_DEICING = 3001;    //设备当前状态不支持除冰功能（只在POE+、AC24V、DC12V供电下支持除冰功能）
  NET_DVR_ERR_THERMENABLE_CLOSE = 3002;    //测温功能总使能未开启。(即NET_DVR_THERMOMETRY_BASICPARAM使能未开启)
  NET_DVR_ERR_NOTMEET_DEICING = 3003;    //当前空腔温度不满足手动除冰开启条件（需空腔温度小于30度才可开启）
  NET_DVR_ERR_PANORAMIC_LIMIT_OPERATED = 3004;    //全景地图和限位不可同时操作
  NET_DVR_ERR_SMARTH264_ROI_OPERATED = 3005;    //SmartH264和ROI不可同时操作
  NET_DVR_ERR_RULENUM_LIMIT = 3006;    //规则数上限
  NET_DVR_ERR_LASER_DEICING_OPERATED = 3007;    //激光以及除冰功能不可同时操作
  NET_DVR_ERR_OFFDIGITALZOOM_OR_MINZOOMLIMIT = 3008;    //请先关闭数据变倍功能或变倍限制设置为最小值。当执行烟火检测、异常行为检测、船只检测、坏点矫正、测温、烟火屏蔽功能时，若没有关闭数据变倍或者变倍限制没有设置为最小值时，将会提示该错误码。
  NET_DVR_ERR_FIREWAITING = 3009;    //设备云台正在火点等待中
  NET_DVR_SYNCHRONIZEFOV_ERROR = 3010;    //同步视场角错误
  NET_DVR_CERTIFICATE_VALIDATION_ERROR = 3011;    //证书验证不通过
  NET_DVR_CERTIFICATES_NUM_EXCEED_ERROR = 3012;    //证书个数超过上限
  NET_DVR_RULE_SHIELDMASK_CONFLICT_ERROR = 3013;    //规则区域与屏蔽区域冲突
  NET_DVR_MOTOR_PREHEATING_ERROR = 3014;    //电机预热中
  NET_DVR_PT_DEICING_ERROR = 3015;    //云台除冰中

//前端产品线错误码（3501-4000）
const
  NET_DVR_ERR_NO_SAFETY_HELMET_REGION = 3501;    //未配置安全帽检测区域
  NET_DVR_ERR_UNCLOSED_SAFETY_HELMET = 3502;    //未关闭安全帽检测使能
  NET_DVR_ERR_MUX_RECV_STATE = 3503;    //多路复用接收状态异常
  NET_DVR_UPLOAD_HBDLIBID_ERROR = 3504;    // 上传人体库ID（HBDID or customHBDID）错误
  NET_DVR_NOTSUPPORT_SMALLER_RATIOS = 3505;    // 倍率小于1倍时不支持功能配置,请调高倍率
  NET_ERR_ACCOUNT_NOT_ACTIVED = 3506;    // 用户账户未激活，排查建议：请先登录账户修改初始密码，再尝试操作。

const
  NET_ERR_NPQ_BASE_INDEX = 8000;    //NPQ库错误码
  NET_ERR_NPQ_PARAM = (NET_ERR_NPQ_BASE_INDEX + 1);    //NPQ库参数有误
  NET_ERR_NPQ_SYSTEM = (NET_ERR_NPQ_BASE_INDEX + 2);    //NPQ库操作系统调用错误(包括资源申请失败或内部错误等）
  NET_ERR_NPQ_GENRAL = (NET_ERR_NPQ_BASE_INDEX + 3);    //NPQ库内部通用错误
  NET_ERR_NPQ_PRECONDITION = (NET_ERR_NPQ_BASE_INDEX + 4);    //NPQ库调用顺序错误
  NET_ERR_NPQ_NOTSUPPORT = (NET_ERR_NPQ_BASE_INDEX + 5);    //NPQ库功能不支持

const
  NET_ERR_NPQ_NOTCALLBACK = (NET_ERR_NPQ_BASE_INDEX + 100);    //数据没有回调上来
  NET_ERR_NPQ_LOADLIB = (NET_ERR_NPQ_BASE_INDEX + 101);    //NPQ库加载失败
  NET_ERR_NPQ_STEAM_CLOSE = (NET_ERR_NPQ_BASE_INDEX + 104);    //本路码流NPQ功能未开启
  NET_ERR_NPQ_MAX_LINK = (NET_ERR_NPQ_BASE_INDEX + 110);    //NPQ取流路数达到上限
  NET_ERR_NPQ_STREAM_CFG = (NET_ERR_NPQ_BASE_INDEX + 111);    //编码参数存在冲突配置
  NET_ERR_NPQ_PLAYBACK_OVERSPEED = (NET_ERR_NPQ_BASE_INDEX + 112);    //NPQ回放倍率达到上限
  NET_ERR_NPQ_PLAYBACK_BELOWSPEED = (NET_ERR_NPQ_BASE_INDEX + 113);    //NPQ回放倍率达到下限

const
  NET_EZVIZ_P2P_BASE_INDEX = 8300;    //萤石P2P组件错误码
  NET_DVR_EZVIZ_P2P_REGISTER_ERROR = (NET_EZVIZ_P2P_BASE_INDEX + 1);    
  NET_DVR_EZVIZ_P2P_LOGIN_2C_ERROR = (NET_EZVIZ_P2P_BASE_INDEX + 2);    
  NET_DVR_EZVIZ_P2P_LOGIN_2B_ERROR = (NET_EZVIZ_P2P_BASE_INDEX + 3);    
  NET_DVR_EZVIZ_P2P_BUILDLINK_ERROR = (NET_EZVIZ_P2P_BASE_INDEX + 4);    
  NET_DVR_EZVIZ_P2P_PORTMAPPING_ERROR = (NET_EZVIZ_P2P_BASE_INDEX + 5);    
  NET_DVR_EZVIZ_P2P_COULDNT_RESOLVE_HOST = (NET_EZVIZ_P2P_BASE_INDEX + 6);    //P2PCLOUD_ER_COULDNT_RESOLVE_HOST    1006
  NET_DVR_EZVIZ_P2P_COULDNT_CONNECT = (NET_EZVIZ_P2P_BASE_INDEX + 7);    //P2PCLOUD_ER_COULDNT_CONNECT 1007
  NET_DVR_EZVIZ_P2P_OPERATION_TIMEOUT = (NET_EZVIZ_P2P_BASE_INDEX + 8);    //P2PCLOUD_ER_OPERATION_TIMEOUT   1028
  NET_DVR_EZVIZ_P2P_NOT_INITIALIZED = (NET_EZVIZ_P2P_BASE_INDEX + 9);    //P2PCLOUD_ER_NOT_INITIALIZED 2001
  NET_DVR_EZVIZ_P2P_INVALID_ARG = (NET_EZVIZ_P2P_BASE_INDEX + 10);    //P2PCLOUD_ER_INVALID_ARG 2002
  NET_DVR_EZVIZ_P2P_EXCEED_MAX_SERVICE = (NET_EZVIZ_P2P_BASE_INDEX + 11);    //P2PCLOUD_ER_EXCEED_MAX_SERVICE  2003
  NET_DVR_EZVIZ_P2P_TOKEN_NOT_EXIST = (NET_EZVIZ_P2P_BASE_INDEX + 12);    //P2PCLOUD_ER_TOKEN_NOT_EXIST 2004
  NET_DVR_EZVIZ_P2P_DISCONNECTED = (NET_EZVIZ_P2P_BASE_INDEX + 13);    //P2PCLOUD_ER_DISCONNECTED    2005
  NET_DVR_EZVIZ_P2P_RELAY_ADDR_NOT_EXIST = (NET_EZVIZ_P2P_BASE_INDEX + 14);    //P2PCLOUD_ER_RELAY_ADDR_NOT_EXIST    2006
  NET_DVR_EZVIZ_P2P_DEV_NOT_ONLINE = (NET_EZVIZ_P2P_BASE_INDEX + 15);    //P2PCLOUD_ER_DEV_NOT_ONLINE  3121
  NET_DVR_EZVIZ_P2P_DEV_CONNECT_EXCEED = (NET_EZVIZ_P2P_BASE_INDEX + 16);    //P2PCLOUD_ER_DEV_CONNECT_EXCEED  3123
  NET_DVR_EZVIZ_P2P_DEV_CONNECT_FAILED = (NET_EZVIZ_P2P_BASE_INDEX + 17);    //P2PCLOUD_ER_DEV_CONNECT_FAILED  3209
  NET_DVR_EZVIZ_P2P_DEV_RECV_TIMEOUT = (NET_EZVIZ_P2P_BASE_INDEX + 18);    //P2PCLOUD_ER_DEV_RECV_TIMEOUT    3213
  NET_DVR_EZVIZ_P2P_USER_FORCE_STOP = (NET_EZVIZ_P2P_BASE_INDEX + 19);    //P2PCLOUD_ER_USER_FORCE_STOP 3216
  NET_DVR_EZVIZ_P2P_NO_PERMISSION = (NET_EZVIZ_P2P_BASE_INDEX + 20);    //P2PCLOUD_ER_NO_PERMISSION   3255
  NET_DVR_EZVIZ_P2P_DEV_PU_NOT_FOUND = (NET_EZVIZ_P2P_BASE_INDEX + 21);    //P2PCLOUD_ER_DEV_PU_NOT_FOUND    3297
  NET_DVR_EZVIZ_P2P_DEV_CONN_NOLONGER_AVAIL = (NET_EZVIZ_P2P_BASE_INDEX + 22);    //P2PCLOUD_ER_DEV_CONN_NOLONGER_AVAIL 3351
  NET_DVR_EZVIZ_P2P_DEV_NOT_LISTENING = (NET_EZVIZ_P2P_BASE_INDEX + 23);    //P2PCLOUD_ER_DEV_NOT_LISTENING   3610
  NET_DVR_EZVIZ_P2P_DEV_TUNNEL_SOCKET_LIMITED = (NET_EZVIZ_P2P_BASE_INDEX + 24);    //P2PCLOUD_ER_DEV_TUNNEL_SOCKET_LIMITED   3612
  NET_DVR_EZVIZ_P2P_FAIL_CREATE_THREAD = (NET_EZVIZ_P2P_BASE_INDEX + 25);    //TUNNEL_ER_FAIL_CREATE_THREAD    4001
  NET_DVR_EZVIZ_P2P_FAIL_ALLOC_BUFFERS = (NET_EZVIZ_P2P_BASE_INDEX + 26);    //P2PCLOUD_ER_FAIL_ALLOC_BUFFERS  4002
  NET_DVR_EZVIZ_P2P_FAIL_CREATE_SOCKET = (NET_EZVIZ_P2P_BASE_INDEX + 27);    //P2PCLOUD_ER_FAIL_CREATE_SOCKET  4003
  NET_DVR_EZVIZ_P2P_BIND_LOCAL_SERVICE = (NET_EZVIZ_P2P_BASE_INDEX + 28);    //P2PCLOUD_ER_BIND_LOCAL_SERVICE  4004
  NET_DVR_EZVIZ_P2P_LISTEN_LOCAL_SERVICE = (NET_EZVIZ_P2P_BASE_INDEX + 29);    //P2PCLOUD_ER_LISTEN_LOCAL_SERVICE    4005
  NET_DVR_EZVIZ_P2P_SVR_RSP_BAD = (NET_EZVIZ_P2P_BASE_INDEX + 30);    //P2PCLOUD_ER_SVR_RSP_BAD 5001
  NET_DVR_EZVIZ_P2P_SVR_RSP_INVALID = (NET_EZVIZ_P2P_BASE_INDEX + 31);    //P2PCLOUD_ER_SVR_RSP_INVALID 5002
  NET_DVR_EZVIZ_P2P_SVR_LOGIN_FAILED = (NET_EZVIZ_P2P_BASE_INDEX + 32);    //P2PCLOUD_ER_SVR_LOGIN_FAILED    5003
  NET_DVR_EZVIZ_P2P_SVR_TOKEN_EXPIRED = (NET_EZVIZ_P2P_BASE_INDEX + 33);    //P2PCLOUD_ER_SVR_TOKEN_EXPIRED   5004
  NET_DVR_EZVIZ_P2P_SVR_DEV_NOT_BELONG_TO_USER = (NET_EZVIZ_P2P_BASE_INDEX + 34);    //P2PCLOUD_ER_SVR_DEV_NOT_BELONG_TO_USER  5005


//传显错误码 8501~9500
const
  NET_ERR_UPGRADE_PROG_ERR = 8501;    //程序执行出错
  NET_ERR_UPGRADE_NO_DEVICE = 8502;    //没有设备(指LED控制器没有接接收卡)
  NET_ERR_UPGRADE_NO_FILE = 8503;    //没有找到升级文件
  NET_ERR_UPGRADE_DATA_ERROR = 8504;    //升级文件数据不兼容
  NET_ERR_UPGRADE_LINK_SERVER_ERR = 8505;    //与服务器连接失败
  NET_ERR_UPGRADE_OEMCODE_NOMATCH = 8506;    //oemCode不匹配
  NET_ERR_UPGRADE_FLASH_NOENOUGH = 8507;    //flash不足
  NET_ERR_UPGRADE_RAM_NOENOUGH = 8508;    //RAM不足
  NET_ERR_UPGRADE_DSPRAM_NOENOUGH = 8509;    //DSP RAM不足
  NET_ERR_NOT_SUPPORT_CHECK = 8510;    //该屏幕型号不支持校正
  NET_ERR_LED_DEVICE_BUSY_CHECK = 8511;    //LED设备忙（正在校正）
  NET_ERR_DEVICE_MEM_NOT_ENOUGH = 8512;    //设备内存不足
  NET_ERR_CHECK_PARAM = 8513;    //校正参数错误
  NET_ERR_RESOLUTION_OVER_LIMIT = 8514;    //输入分辨率超过限制
  NET_ERR_NO_CUSTOM_BASE = 8515;    //无自定义底图
  NET_ERR_PRIORITY_LOWER = 8516;    //优先级低于当前模式
  NET_ERR_SEND_MESSAGE_EXCEPT = 8517;    //消息发送异常
  NET_ERR_SENDCARD_UPGRADING = 8518;    //发送卡升级中
  NET_ERR_NO_WIRELESS_NETCARD = 8519;    //未插入无线网卡
  NET_ERR_LOAD_FS_FAIL = 8520;    //从屏幕加载失败
  NET_ERR_FLASH_UNSTORAGE_RECCARD = 8521;    //Flash中未存储接收卡参数
  NET_ERR_NOT_SUPPORT_SINGLE_NETWORKCARD_AGGREGA = 8522;    //不支持单网卡聚合
  NET_ERR_DISPLAYRESOLUTION_LESSTHAN_SMALLESTRESOLUTION = 8523;    //显示分辨率小于最小分辨率
  NET_ERR_NOT_SUPPORT_LOCAL_SOURCE_DRAG_MORE = 8524;    //不支持本地源一拖多
  NET_ERR_CANCEL_CURRENT_LED_AREA = 8525;    //请先取消LED区域
  NET_ERR_LED_OUT_ASSOCIATED_AREA = 8526;    //LED未在关联区域
  NET_ERR_MAX_VIRTUAL_LED_PICTURE_SIZE = 8527;    //虚拟LED图片大小超限
  NET_ERR_DEVICE_CTRLED_BY_REMOTER = 8528;    //设备当前受遥控器控制
//******************全局错误码 end*********************

{************************************************
NET_DVR_IsSupport()返回值
1－9位分别表示以下信息（位与是TRUE)表示支持；
*************************************************}
const
  NET_DVR_SUPPORT_DDRAW = $01;    //支持DIRECTDRAW，如果不支持，则播放器不能工作；
  NET_DVR_SUPPORT_BLT = $02;    //显卡支持BLT操作，如果不支持，则播放器不能工作；
  NET_DVR_SUPPORT_BLTFOURCC = $04;    //显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换；
  NET_DVR_SUPPORT_BLTSHRINKX = $08;    //显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换；
  NET_DVR_SUPPORT_BLTSHRINKY = $10;    //显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换；
  NET_DVR_SUPPORT_BLTSTRETCHX = $20;    //显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换；
  NET_DVR_SUPPORT_BLTSTRETCHY = $40;    //显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换；
  NET_DVR_SUPPORT_SSE = $80;    //CPU支持SSE指令，Intel Pentium3以上支持SSE指令；
  NET_DVR_SUPPORT_MMX = $100;    //CPU支持MMX指令集，Intel Pentium3以上支持SSE指令；

//*********************云台控制命令 begin************************
const
  LIGHT_PWRON = 2;    // 接通灯光电源 
  WIPER_PWRON = 3;    // 接通雨刷开关 
  FAN_PWRON = 4;    // 接通风扇开关 
  HEATER_PWRON = 5;    // 接通加热器开关 
  AUX_PWRON1 = 6;    // 接通辅助设备开关 
  AUX_PWRON2 = 7;    // 接通辅助设备开关 
  SET_PRESET = 8;    // 设置预置点 
  CLE_PRESET = 9;    // 清除预置点 

const
  ZOOM_IN = 11;    // 焦距以速度SS变大(倍率变大) 
  ZOOM_OUT = 12;    // 焦距以速度SS变小(倍率变小) 
  FOCUS_NEAR = 13;    // 焦点以速度SS前调 
  FOCUS_FAR = 14;    // 焦点以速度SS后调 
  IRIS_OPEN = 15;    // 光圈以速度SS扩大 
  IRIS_CLOSE = 16;    // 光圈以速度SS缩小 

const
  TILT_UP = 21;    // 云台以SS的速度上仰 
  TILT_DOWN = 22;    // 云台以SS的速度下俯 
  PAN_LEFT = 23;    // 云台以SS的速度左转 
  PAN_RIGHT = 24;    // 云台以SS的速度右转 
  UP_LEFT = 25;    // 云台以SS的速度上仰和左转 
  UP_RIGHT = 26;    // 云台以SS的速度上仰和右转 
  DOWN_LEFT = 27;    // 云台以SS的速度下俯和左转 
  DOWN_RIGHT = 28;    // 云台以SS的速度下俯和右转 
  PAN_AUTO = 29;    // 云台以SS的速度左右自动扫描 

const
  FILL_PRE_SEQ = 30;    // 将预置点加入巡航序列 
  SET_SEQ_DWELL = 31;    // 设置巡航点停顿时间 
  SET_SEQ_SPEED = 32;    // 设置巡航速度 
  CLE_PRE_SEQ = 33;    // 将预置点从巡航序列中删除 
  STA_MEM_CRUISE = 34;    // 开始记录 
  STO_MEM_CRUISE = 35;    // 停止记录 
  RUN_CRUISE = 36;    // 开始 
  RUN_SEQ = 37;    // 开始巡航 
  STOP_SEQ = 38;    // 停止巡航 
  GOTO_PRESET = 39;    // 快球转到预置点 
//dac通过私有协议接入NVR，NVR通过Onvif协议接入相机时。由于私有协议巡航点位下发速度、时间等为单个命令，
//Onvif为批量下发所有点位，私有协议中无巡航点位下发的开始和结束，导致NVR无法判断何时组Onvif报文给前端设备
const
  SET_SEQ_START = 41;    //  IP快球，开始设置巡航
  SET_SEQ_END = 42;    //  IP快球，结束设置巡航

const
  DEL_SEQ = 43;    // 删除巡航路径 
  STOP_CRUISE = 44;    // 停止 
  DELETE_CRUISE = 45;    // 删除单条 
  DELETE_ALL_CRUISE = 46;    // 删除所有 

const
  PAN_CIRCLE = 50;    // 云台以SS的速度自动圆周扫描 
  DRAG_PTZ = 51;    // 拖动PTZ 
  LINEAR_SCAN = 52;    { 区域扫描 }//2014-03-15
  CLE_ALL_PRESET = 53;    // 预置点全部清除 
  CLE_ALL_SEQ = 54;    // 巡航全部清除 
  CLE_ALL_CRUISE = 55;    // 全部清除 

const
  POPUP_MENU = 56;    // 显示操作菜单 

const
  TILT_DOWN_ZOOM_IN = 58;    // 云台以SS的速度下俯&&焦距以速度SS变大(倍率变大) 
  TILT_DOWN_ZOOM_OUT = 59;    // 云台以SS的速度下俯&&焦距以速度SS变小(倍率变小) 
  PAN_LEFT_ZOOM_IN = 60;    // 云台以SS的速度左转&&焦距以速度SS变大(倍率变大)
  PAN_LEFT_ZOOM_OUT = 61;    // 云台以SS的速度左转&&焦距以速度SS变小(倍率变小)
  PAN_RIGHT_ZOOM_IN = 62;    // 云台以SS的速度右转&&焦距以速度SS变大(倍率变大) 
  PAN_RIGHT_ZOOM_OUT = 63;    // 云台以SS的速度右转&&焦距以速度SS变小(倍率变小) 
  UP_LEFT_ZOOM_IN = 64;    // 云台以SS的速度上仰和左转&&焦距以速度SS变大(倍率变大)
  UP_LEFT_ZOOM_OUT = 65;    // 云台以SS的速度上仰和左转&&焦距以速度SS变小(倍率变小)
  UP_RIGHT_ZOOM_IN = 66;    // 云台以SS的速度上仰和右转&&焦距以速度SS变大(倍率变大)
  UP_RIGHT_ZOOM_OUT = 67;    // 云台以SS的速度上仰和右转&&焦距以速度SS变小(倍率变小)
  DOWN_LEFT_ZOOM_IN = 68;    // 云台以SS的速度下俯和左转&&焦距以速度SS变大(倍率变大) 
  DOWN_LEFT_ZOOM_OUT = 69;    // 云台以SS的速度下俯和左转&&焦距以速度SS变小(倍率变小) 
  DOWN_RIGHT_ZOOM_IN = 70;    // 云台以SS的速度下俯和右转&&焦距以速度SS变大(倍率变大) 
  DOWN_RIGHT_ZOOM_OUT = 71;    // 云台以SS的速度下俯和右转&&焦距以速度SS变小(倍率变小) 
  TILT_UP_ZOOM_IN = 72;    // 云台以SS的速度上仰&&焦距以速度SS变大(倍率变大) 
  TILT_UP_ZOOM_OUT = 73;    // 云台以SS的速度上仰&&焦距以速度SS变小(倍率变小) 
//*********************云台控制命令 end************************

const
  DVR_VEHICLE_CONTROL_LIST = $1;    //车辆名单数据类型(发送的数据类型)2013-11-04


{************************************************
回放时播放控制命令宏定义
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl的宏定义
具体支持查看函数说明和代码
*************************************************}
const
  NET_DVR_PLAYSTART = 1;    //开始播放
  NET_DVR_PLAYSTOP = 2;    //停止播放
  NET_DVR_PLAYPAUSE = 3;    //暂停播放
  NET_DVR_PLAYRESTART = 4;    //恢复播放
  NET_DVR_PLAYFAST = 5;    //快放
  NET_DVR_PLAYSLOW = 6;    //慢放
  NET_DVR_PLAYNORMAL = 7;    //正常速度
  NET_DVR_PLAYFRAME = 8;    //单帧放
  NET_DVR_PLAYSTARTAUDIO = 9;    //打开声音
  NET_DVR_PLAYSTOPAUDIO = 10;    //关闭声音
  NET_DVR_PLAYAUDIOVOLUME = 11;    //调节音量
  NET_DVR_PLAYSETPOS = 12;    //改变文件回放的进度
  NET_DVR_PLAYGETPOS = 13;    //获取文件回放的进度
  NET_DVR_PLAYGETTIME = 14;    //获取当前已经播放的时间(按文件回放的时候有效)
  NET_DVR_PLAYGETFRAME = 15;    //获取当前已经播放的帧数(按文件回放的时候有效)
  NET_DVR_GETTOTALFRAMES = 16;    //获取当前播放文件总的帧数(按文件回放的时候有效)
  NET_DVR_GETTOTALTIME = 17;    //获取当前播放文件总的时间(按文件回放的时候有效)
  NET_DVR_THROWBFRAME = 20;    //丢B帧
  NET_DVR_SETSPEED = 24;    //设置码流速度
  NET_DVR_KEEPALIVE = 25;    //保持与设备的心跳(如果回调阻塞，建议2秒发送一次)
  NET_DVR_PLAYSETTIME = 26;    //按绝对时间定位
  NET_DVR_PLAYGETTOTALLEN = 27;    //获取按时间回放对应时间段内的所有文件的总长度
  NET_DVR_PLAYSETTIME_V50 = 28;    //按绝对时间定位(支持时区扩展)
  NET_DVR_PLAY_FORWARD = 29;    //倒放切换为正放
  NET_DVR_PLAY_REVERSE = 30;    //正放切换为倒放
  NET_DVR_SET_DECODEFFRAMETYPE = 31;    
  NET_DVR_SET_TRANS_TYPE = 32;    //设置转码格式
  NET_DVR_PLAY_CONVERT = 33;    //回放转码
  NET_DVR_START_DRAWFRAME = 34;    //开始抽帧回放
  NET_DVR_STOP_DRAWFRAME = 35;    //停止抽帧回放
  NET_DVR_CHANGEWNDRESOLUTION = 36;    //窗口大小改变，通知播放库
  NET_DVR_RESETBUFFER = 37;    //清空矩阵解码缓冲区（远程回放文件）
  NET_DVR_VOD_DRAG_ING = 38;    //回放拖动中
  NET_DVR_VOD_DRAG_END = 39;    //回放拖动结束
  NET_DVR_VOD_RESET_PLAYTIME = 40;    //重设播放时间


const
  PLAYM4_DECODE_NORMAIL = 0;    //正常解码
  PLAYM4_DECODE_KEY_FRAME = 1;    //只解I帧
  PLAYM4_DECODE_NONE = 2;    //全不解
  PLAYM4_DECODE_TEMPORAL_LAYER_0 = 3;    //解1/2
  PLAYM4_DECODE_TEMPORAL_LAYER_1 = 4;    //解1/4


//远程按键定义如下：
// key value send to CONFIG program 
const
  KEY_CODE_1 = 1;    
  KEY_CODE_2 = 2;    
  KEY_CODE_3 = 3;    
  KEY_CODE_4 = 4;    
  KEY_CODE_5 = 5;    
  KEY_CODE_6 = 6;    
  KEY_CODE_7 = 7;    
  KEY_CODE_8 = 8;    
  KEY_CODE_9 = 9;    
  KEY_CODE_0 = 10;    
  KEY_CODE_POWER = 11;    
  KEY_CODE_MENU = 12;    
  KEY_CODE_ENTER = 13;    
  KEY_CODE_CANCEL = 14;    
  KEY_CODE_UP = 15;    
  KEY_CODE_DOWN = 16;    
  KEY_CODE_LEFT = 17;    
  KEY_CODE_RIGHT = 18;    
  KEY_CODE_EDIT = 19;    
  KEY_CODE_ADD = 20;    
  KEY_CODE_MINUS = 21;    
  KEY_CODE_PLAY = 22;    
  KEY_CODE_REC = 23;    
  KEY_CODE_PAN = 24;    
  KEY_CODE_M = 25;    
  KEY_CODE_A = 26;    
  KEY_CODE_F1 = 27;    
  KEY_CODE_F2 = 28;    

// for PTZ control 
const
  KEY_PTZ_UP_START = KEY_CODE_UP;    
  KEY_PTZ_UP_STOP = 32;    

const
  KEY_PTZ_DOWN_START = KEY_CODE_DOWN;    
  KEY_PTZ_DOWN_STOP = 33;    

const
  KEY_PTZ_LEFT_START = KEY_CODE_LEFT;    
  KEY_PTZ_LEFT_STOP = 34;    

const
  KEY_PTZ_RIGHT_START = KEY_CODE_RIGHT;    
  KEY_PTZ_RIGHT_STOP = 35;    

const
  KEY_PTZ_AP1_START = KEY_CODE_EDIT;    //光圈+
  KEY_PTZ_AP1_STOP = 36;    

const
  KEY_PTZ_AP2_START = KEY_CODE_PAN;    //光圈-
  KEY_PTZ_AP2_STOP = 37;    

const
  KEY_PTZ_FOCUS1_START = KEY_CODE_A;    //聚焦+
  KEY_PTZ_FOCUS1_STOP = 38;    

const
  KEY_PTZ_FOCUS2_START = KEY_CODE_M;    //聚焦-
  KEY_PTZ_FOCUS2_STOP = 39;    

const
  KEY_PTZ_B1_START = 40;    //变倍+
  KEY_PTZ_B1_STOP = 41;    

const
  KEY_PTZ_B2_START = 42;    //变倍-
  KEY_PTZ_B2_STOP = 43;    

//9000新增
const
  KEY_CODE_11 = 44;    
  KEY_CODE_12 = 45;    
  KEY_CODE_13 = 46;    
  KEY_CODE_14 = 47;    
  KEY_CODE_15 = 48;    
  KEY_CODE_16 = 49;    



//************************参数配置命令 begin******************************
//用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构

const
  NET_DVR_GET_DEVICECFG = 100;    //获取设备参数
  NET_DVR_SET_DEVICECFG = 101;    //设置设备参数
  NET_DVR_GET_NETCFG = 102;    //获取网络参数
  NET_DVR_SET_NETCFG = 103;    //设置网络参数
  NET_DVR_GET_PICCFG = 104;    //获取图象参数
  NET_DVR_SET_PICCFG = 105;    //设置图象参数
  NET_DVR_GET_COMPRESSCFG = 106;    //获取压缩参数
  NET_DVR_SET_COMPRESSCFG = 107;    //设置压缩参数
  NET_DVR_GET_RECORDCFG = 108;    //获取录像时间参数
  NET_DVR_SET_RECORDCFG = 109;    //设置录像时间参数
  NET_DVR_GET_DECODERCFG = 110;    //获取解码器参数
  NET_DVR_SET_DECODERCFG = 111;    //设置解码器参数
  NET_DVR_GET_RS232CFG = 112;    //获取232串口参数
  NET_DVR_SET_RS232CFG = 113;    //设置232串口参数
  NET_DVR_GET_ALARMINCFG = 114;    //获取报警输入参数
  NET_DVR_SET_ALARMINCFG = 115;    //设置报警输入参数
  NET_DVR_GET_ALARMOUTCFG = 116;    //获取报警输出参数
  NET_DVR_SET_ALARMOUTCFG = 117;    //设置报警输出参数
  NET_DVR_GET_TIMECFG = 118;    //获取DVR时间
  NET_DVR_SET_TIMECFG = 119;    //设置DVR时间
  NET_DVR_GET_PREVIEWCFG = 120;    //获取预览参数
  NET_DVR_SET_PREVIEWCFG = 121;    //设置预览参数
  NET_DVR_GET_VIDEOOUTCFG = 122;    //获取视频输出参数
  NET_DVR_SET_VIDEOOUTCFG = 123;    //设置视频输出参数
  NET_DVR_GET_USERCFG = 124;    //获取用户参数
  NET_DVR_SET_USERCFG = 125;    //设置用户参数
  NET_DVR_GET_EXCEPTIONCFG = 126;    //获取异常参数
  NET_DVR_SET_EXCEPTIONCFG = 127;    //设置异常参数
  NET_DVR_GET_ZONEANDDST = 128;    //获取时区和夏时制参数
  NET_DVR_SET_ZONEANDDST = 129;    //设置时区和夏时制参数

//注：该命令只支持4条OSD的类型，通常用于V30以下的设备版本。
const
  NET_DVR_GET_SHOWSTRING = 130;    //获取叠加字符参数
  NET_DVR_SET_SHOWSTRING = 131;    //设置叠加字符参数

const
  NET_DVR_GET_EVENTCOMPCFG = 132;    //获取事件触发录像参数
  NET_DVR_SET_EVENTCOMPCFG = 133;    //设置事件触发录像参数
  NET_DVR_GET_FTPCFG = 134;    //获取抓图的FTP参数(基线)
  NET_DVR_SET_FTPCFG = 135;    //设置抓图的FTP参数(基线)
  NET_DVR_GET_AUXOUTCFG = 140;    //获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)
  NET_DVR_SET_AUXOUTCFG = 141;    //设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)
  NET_DVR_GET_PREVIEWCFG_AUX = 142;    //获取-s系列双输出预览参数(-s系列双输出2006-04-13)
  NET_DVR_SET_PREVIEWCFG_AUX = 143;    //设置-s系列双输出预览参数(-s系列双输出2006-04-13)

const
  NET_DVR_GET_PASSWORD_MANAGE_CFG = 144;    //获取密码管理配置
  NET_DVR_SET_PASSWORD_MANAGE_CFG = 145;    //设置密码管理配置
  NET_DVR_UNLOCK_USER = 146;    //用户解锁
  NET_DVR_GET_SECURITY_CFG = 147;    //获取安全认证配置
  NET_DVR_SET_SECURITY_CFG = 148;    //设置安全认证配置
  NET_DVR_GET_LOCKED_INFO_LIST = 149;    //获取所有被锁定信息


//********************************智能部分接口 begin**************************************
//行为对应（NET_VCA_RULECFG）
const
  NET_DVR_SET_RULECFG = 152;    //设置异常行为检测规则
  NET_DVR_GET_RULECFG = 153;    //获取异常行为检测规则
//球机标定参数（NET_DVR_TRACK_CFG ）
const
  NET_DVR_SET_TRACK_CFG = 160;    //设置球机的配置参数
  NET_DVR_GET_TRACK_CFG = 161;    //获取球机的配置参数

//智能分析仪取流配置结构
const
  NET_DVR_SET_IVMS_STREAMCFG = 162;    //设置智能分析仪取流参数
  NET_DVR_GET_IVMS_STREAMCFG = 163;    //获取智能分析仪取流参数
//智能控制参数结构
const
  NET_DVR_SET_VCA_CTRLCFG = 164;    //设置智能控制参数
  NET_DVR_GET_VCA_CTRLCFG = 165;    //获取智能控制参数
//屏蔽区域NET_VCA_MASK_REGION_LIST
const
  NET_DVR_SET_VCA_MASK_REGION = 166;    //设置屏蔽区域参数
  NET_DVR_GET_VCA_MASK_REGION = 167;    //获取屏蔽区域参数

//ATM进入区域 NET_VCA_ENTER_REGION
const
  NET_DVR_SET_VCA_ENTER_REGION = 168;    //设置进入区域参数
  NET_DVR_GET_VCA_ENTER_REGION = 169;    //获取进入区域参数

//标定线配置NET_VCA_LINE_SEGMENT_LIST
const
  NET_DVR_SET_VCA_LINE_SEGMENT = 170;    //设置标定线
  NET_DVR_GET_VCA_LINE_SEGMENT = 171;    //获取标定线

// ivms屏蔽区域NET_IVMS_MASK_REGION_LIST
const
  NET_DVR_SET_IVMS_MASK_REGION = 172;    //设置IVMS屏蔽区域参数
  NET_DVR_GET_IVMS_MASK_REGION = 173;    //获取IVMS屏蔽区域参数
// ivms进入检测区域NET_IVMS_ENTER_REGION
const
  NET_DVR_SET_IVMS_ENTER_REGION = 174;    //设置IVMS进入区域参数
  NET_DVR_GET_IVMS_ENTER_REGION = 175;    //获取IVMS进入区域参数

const
  NET_DVR_SET_IVMS_BEHAVIORCFG = 176;    //设置智能分析仪行为规则参数
  NET_DVR_GET_IVMS_BEHAVIORCFG = 177;    //获取智能分析仪行为规则参数

// IVMS 回放检索
const
  NET_DVR_IVMS_SET_SEARCHCFG = 178;    //设置IVMS回放检索参数
  NET_DVR_IVMS_GET_SEARCHCFG = 179;    //获取IVMS回放检索参数

const
  NET_DVR_SET_POSITION_TRACK = 180;    // 设置场景配置信息
  NET_DVR_GET_POSITION_TRACK = 181;    // 获取场景配置信息

const
  NET_DVR_SET_CALIBRATION = 182;    // 设置标定信息
  NET_DVR_GET_CALIBRATION = 183;    // 获取标定信息

const
  NET_DVR_SET_PDC_RULECFG = 184;    // 设置人流量统计规则
  NET_DVR_GET_PDC_RULECFG = 185;    // 获取人流量统计规则

const
  NET_DVR_SET_PU_STREAMCFG = 186;    // 设置前段取流设备信息
  NET_DVR_GET_PU_STREAMCFG = 187;    // 获取前段取流设备信息

const
  NET_VCA_SET_IVMS_BEHAVIOR_CFG = 192;    // 设置IVMS行为规则配置 不带时间段
  NET_VCA_GET_IVMS_BEHAVIOR_CFG = 193;    // 获取IVMS行为规则配置 不带时间段

const
  NET_VCA_SET_SIZE_FILTER = 194;    // 设置全局尺寸过滤器
  NET_VCA_GET_SIZE_FILTER = 195;    // 获取全局尺寸过滤器

const
  NET_DVR_SET_TRACK_PARAMCFG = 196;    // 设置球机本地菜单规则
  NET_DVR_GET_TRACK_PARAMCFG = 197;    // 获取球机本地菜单规则

const
  NET_DVR_SET_DOME_MOVEMENT_PARAM = 198;    // 设置球机机芯参数
  NET_DVR_GET_DOME_MOVEMENT_PARAM = 199;    // 获取球机机芯参数

const
  NET_DVR_GET_PICCFG_EX = 200;    //获取图象参数(SDK_V14扩展命令)
  NET_DVR_SET_PICCFG_EX = 201;    //设置图象参数(SDK_V14扩展命令)
  NET_DVR_GET_USERCFG_EX = 202;    //获取用户参数(SDK_V15扩展命令)
  NET_DVR_SET_USERCFG_EX = 203;    //设置用户参数(SDK_V15扩展命令)
  NET_DVR_GET_COMPRESSCFG_EX = 204;    //获取压缩参数(SDK_V15扩展命令2006-05-15)
  NET_DVR_SET_COMPRESSCFG_EX = 205;    //设置压缩参数(SDK_V15扩展命令2006-05-15)


const
  NET_DVR_GET_NETAPPCFG = 222;    //获取网络应用参数 NTP/DDNS/EMAIL
  NET_DVR_SET_NETAPPCFG = 223;    //设置网络应用参数 NTP/DDNS/EMAIL
  NET_DVR_GET_NTPCFG = 224;    //获取网络应用参数 NTP
  NET_DVR_SET_NTPCFG = 225;    //设置网络应用参数 NTP
  NET_DVR_GET_DDNSCFG = 226;    //获取网络应用参数 DDNS
  NET_DVR_SET_DDNSCFG = 227;    //设置网络应用参数 DDNS
//对应NET_DVR_EMAILPARA
const
  NET_DVR_GET_EMAILCFG = 228;    //获取网络应用参数 EMAIL
  NET_DVR_SET_EMAILCFG = 229;    //设置网络应用参数 EMAIL

const
  NET_DVR_GET_NFSCFG = 230;    // NFS disk config 
  NET_DVR_SET_NFSCFG = 231;    // NFS disk config 

{注：该命令为定制，只支持8条OSD的类型，不会兼容V30设备版本之前的
NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（不建议使用）}
const
  NET_DVR_GET_SHOWSTRING_EX = 238;    //获取叠加字符参数扩展(支持8条字符)
  NET_DVR_SET_SHOWSTRING_EX = 239;    //设置叠加字符参数扩展(支持8条字符)
  NET_DVR_GET_NETCFG_OTHER = 244;    //获取网络参数
  NET_DVR_SET_NETCFG_OTHER = 245;    //设置网络参数

//对应NET_DVR_EMAILCFG结构
const
  NET_DVR_GET_EMAILPARACFG = 250;    //Get EMAIL parameters
  NET_DVR_SET_EMAILPARACFG = 251;    //Setup EMAIL parameters


const
  NET_DVR_GET_DDNSCFG_EX = 274;    //获取扩展DDNS参数
  NET_DVR_SET_DDNSCFG_EX = 275;    //设置扩展DDNS参数

const
  NET_DVR_SET_PTZPOS = 292;    //云台设置PTZ位置
  NET_DVR_GET_PTZPOS = 293;    //云台获取PTZ位置
  NET_DVR_GET_PTZSCOPE = 294;    //云台获取PTZ范围

const
  NET_DVR_GET_AP_INFO_LIST = 305;    //获取无线网络资源参数
  NET_DVR_SET_WIFI_CFG = 306;    //设置IP布防设备无线参数
  NET_DVR_GET_WIFI_CFG = 307;    //获取IP布防设备无线参数
  NET_DVR_SET_WIFI_WORKMODE = 308;    //设置IP布防设备网口工作模式参数
  NET_DVR_GET_WIFI_WORKMODE = 309;    //获取IP布防设备网口工作模式参数
  NET_DVR_GET_WIFI_STATUS = 310;    //获取设备当前wifi连接状态
//********************************智能交通事件begin**************************************
const
  NET_DVR_GET_REFERENCE_REGION = 400;    //获取参考区域
  NET_DVR_SET_REFERENCE_REGION = 401;    //设置参考区域

const
  NET_DVR_GET_TRAFFIC_MASK_REGION = 402;    //获取交通事件屏蔽区域
  NET_DVR_SET_TRAFFIC_MASK_REGION = 403;    //设置交通事件屏蔽区域
  NET_DVR_SET_AID_RULECFG = 404;    //设置交通事件规则参数
  NET_DVR_GET_AID_RULECFG = 405;    //获取交通事件规则参数

const
  NET_DVR_SET_TPS_RULECFG = 406;    //设置交通统计规则参数
  NET_DVR_GET_TPS_RULECFG = 407;    //获取交通统计规则参数

const
  NET_DVR_SET_LANECFG = 408;    //设置车道规则
  NET_DVR_GET_LANECFG = 409;    //获取车道规则
  NET_DVR_GET_VCA_RULE_COLOR_CFG = 410;    //获取智能规则关联的颜色参数
  NET_DVR_SET_VCA_RULE_COLOR_CFG = 411;    //设置智能规则关联的颜色参数
  NET_DVR_GET_SWITCH_LAMP_CFG = 412;    //获取开关灯检测规则配置参数
  NET_DVR_SET_SWITCH_LAMP_CFG = 413;    //设置开关灯检测规则配置参数


//********************************智能交通事件end**************************************
const
  NET_DVR_SET_FACEDETECT_RULECFG = 420;    // 设置人脸检测规则
  NET_DVR_GET_FACEDETECT_RULECFG = 421;    // 获取人脸检测规则

const
  NET_DVR_SET_VEHICLE_RECOG_TASK = 422;    //车辆二次识别任务提交
  NET_DVR_GET_VEHICLE_RECOG_TASK = 423;    //车辆二次识别任务获取

const
  NET_DVR_SET_TIMECORRECT = 432;    //校时配置（只做校时操作，不记录校时配置 eg.NET_DVR_SET_TIMECFG 会修改设备的校时配置（NTP校时，会被修改为手动校时））
  NET_DVR_GET_CONNECT_LIST = 433;    //获取连接设备列表信息

//**************************DS9000新增命令(_V30) begin ****************************
//网络(NET_DVR_NETCFG_V30结构)
const
  NET_DVR_GET_NETCFG_V30 = 1000;    //获取网络参数
  NET_DVR_SET_NETCFG_V30 = 1001;    //设置网络参数

//图象(NET_DVR_PICCFG_V30结构)
const
  NET_DVR_GET_PICCFG_V30 = 1002;    //获取图象参数
  NET_DVR_SET_PICCFG_V30 = 1003;    //设置图象参数

//录像时间(NET_DVR_RECORD_V30结构)
const
  NET_DVR_GET_RECORDCFG_V30 = 1004;    //获取录像参数
  NET_DVR_SET_RECORDCFG_V30 = 1005;    //设置录像参数

//用户(NET_DVR_USER_V30结构)
const
  NET_DVR_GET_USERCFG_V30 = 1006;    //获取用户参数
  NET_DVR_SET_USERCFG_V30 = 1007;    //设置用户参数

//录像时间(NET_DVR_RECORD_V40结构)
const
  NET_DVR_GET_RECORDCFG_V40 = 1008;    //获取录像参数(扩展)
  NET_DVR_SET_RECORDCFG_V40 = 1009;    //设置录像参数(扩展)

//9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构)
const
  NET_DVR_GET_DDNSCFG_V30 = 1010;    //获取DDNS(9000扩展)
  NET_DVR_SET_DDNSCFG_V30 = 1011;    //设置DDNS(9000扩展)

//EMAIL功能(NET_DVR_EMAILCFG_V30结构)
const
  NET_DVR_GET_EMAILCFG_V30 = 1012;    //获取EMAIL参数
  NET_DVR_SET_EMAILCFG_V30 = 1013;    //设置EMAIL参数

const
  NET_DVR_GET_NETCFG_V50 = 1015;    //获取网络参数配置(V50)
  NET_DVR_SET_NETCFG_V50 = 1016;    //设置网络参数配置(V50)

const
  NET_GET_CRUISEPOINT_V40 = 1018;    //获取巡航路径配置

//巡航参数 (NET_DVR_CRUISE_PARA结构)
const
  NET_DVR_GET_CRUISE = 1020;    
  NET_DVR_SET_CRUISE = 1021;    


//报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构)
const
  NET_DVR_GET_ALARMINCFG_V30 = 1024;    
  NET_DVR_SET_ALARMINCFG_V30 = 1025;    

//报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构)
const
  NET_DVR_GET_ALARMOUTCFG_V30 = 1026;    
  NET_DVR_SET_ALARMOUTCFG_V30 = 1027;    

//视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构)
const
  NET_DVR_GET_VIDEOOUTCFG_V30 = 1028;    
  NET_DVR_SET_VIDEOOUTCFG_V30 = 1029;    


{该命令支持8条OSD的类型（即设备版本为V30以上时），并会通过设备版本的匹配，
同时兼容之前的NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（建议使用）}
//叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构)
const
  NET_DVR_GET_SHOWSTRING_V30 = 1030;    
  NET_DVR_SET_SHOWSTRING_V30 = 1031;    

//异常结构参数 (NET_DVR_EXCEPTION_V30结构)
const
  NET_DVR_GET_EXCEPTIONCFG_V30 = 1034;    
  NET_DVR_SET_EXCEPTIONCFG_V30 = 1035;    

//串口232结构参数 (NET_DVR_RS232CFG_V30结构)
const
  NET_DVR_GET_RS232CFG_V30 = 1036;    
  NET_DVR_SET_RS232CFG_V30 = 1037;    

//网络硬盘接入结构参数 (NET_DVR_NET_DISKCFG结构)
const
  NET_DVR_GET_NET_DISKCFG = 1038;    //网络硬盘接入获取
  NET_DVR_SET_NET_DISKCFG = 1039;    //网络硬盘接入设置
//压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构)
const
  NET_DVR_GET_COMPRESSCFG_V30 = 1040;    
  NET_DVR_SET_COMPRESSCFG_V30 = 1041;    

//获取485解码器参数 (NET_DVR_DECODERCFG_V30结构)
const
  NET_DVR_GET_DECODERCFG_V30 = 1042;    //获取解码器参数
  NET_DVR_SET_DECODERCFG_V30 = 1043;    //设置解码器参数

//获取预览参数 (NET_DVR_PREVIEWCFG_V30结构)
const
  NET_DVR_GET_PREVIEWCFG_V30 = 1044;    //获取预览参数
  NET_DVR_SET_PREVIEWCFG_V30 = 1045;    //设置预览参数

//辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构)
const
  NET_DVR_GET_PREVIEWCFG_AUX_V30 = 1046;    //获取辅助预览参数
  NET_DVR_SET_PREVIEWCFG_AUX_V30 = 1047;    //设置辅助预览参数

//IP接入配置参数 （NET_DVR_IPPARACFG结构）
const
  NET_DVR_GET_IPPARACFG = 1048;    //获取IP接入配置信息
  NET_DVR_SET_IPPARACFG = 1049;    //设置IP接入配置信息

//IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构）
const
  NET_DVR_GET_IPALARMINCFG = 1050;    //获取IP报警输入接入配置信息
  NET_DVR_SET_IPALARMINCFG = 1051;    //设置IP报警输入接入配置信息

//IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构）
const
  NET_DVR_GET_IPALARMOUTCFG = 1052;    //获取IP报警输出接入配置信息
  NET_DVR_SET_IPALARMOUTCFG = 1053;    //设置IP报警输出接入配置信息

//硬盘管理的参数获取 (NET_DVR_HDCFG结构)
const
  NET_DVR_GET_HDCFG = 1054;    //获取硬盘管理配置参数
  NET_DVR_SET_HDCFG = 1055;    //设置硬盘管理配置参数
//盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构)
const
  NET_DVR_GET_HDGROUP_CFG = 1056;    //获取盘组管理配置参数
  NET_DVR_SET_HDGROUP_CFG = 1057;    //设置盘组管理配置参数

//设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构)
const
  NET_DVR_GET_COMPRESSCFG_AUD = 1058;    //获取设备语音对讲编码参数
  NET_DVR_SET_COMPRESSCFG_AUD = 1059;    //设置设备语音对讲编码参数

//IP接入配置参数 （NET_DVR_IPPARACFG_V31结构）
const
  NET_DVR_GET_IPPARACFG_V31 = 1060;    //获取IP接入配置信息
  NET_DVR_SET_IPPARACFG_V31 = 1061;    //设置IP接入配置信息

// 通道资源配置 (NET_DVR_IPPARACFG_V40结构)
const
  NET_DVR_GET_IPPARACFG_V40 = 1062;    // 获取IP接入配置
  NET_DVR_SET_IPPARACFG_V40 = 1063;    // 设置IP接入配置

const
  NET_DVR_GET_CCDPARAMCFG = 1067;    //IPC获取CCD参数配置
  NET_DVR_SET_CCDPARAMCFG = 1068;    //IPC设置CCD参数配置

const
  NET_DVR_GET_IOINCFG = 1070;    //获取抓拍机IO输入参数
  NET_DVR_SET_IOINCFG = 1071;    //设置抓拍机IO输入参数

const
  NET_DVR_GET_IOOUTCFG = 1072;    //获取抓拍机IO输出参数
  NET_DVR_SET_IOOUTCFG = 1073;    //设置抓拍机IO输出参数

const
  NET_DVR_GET_FLASHCFG = 1074;    //获取IO闪光灯输出参数
  NET_DVR_SET_FLASHCFG = 1075;    //设置IO闪光灯输出参数

const
  NET_DVR_GET_LIGHTSNAPCFG = 1076;    //获取抓拍机红绿灯参数
  NET_DVR_SET_LIGHTSNAPCFG = 1077;    //设置抓拍机红绿灯参数

const
  NET_DVR_GET_MEASURESPEEDCFG = 1078;    //获取抓拍机测速参数
  NET_DVR_SET_MEASURESPEEDCFG = 1079;    //设置抓拍机测速参数

const
  NET_DVR_GET_IMAGEOVERLAYCFG = 1080;    //获取抓拍机图像叠加信息参数
  NET_DVR_SET_IMAGEOVERLAYCFG = 1081;    //设置抓拍机图像叠加信息参数

const
  NET_DVR_GET_SNAPCFG = 1082;    //获取单IO触发抓拍功能配置
  NET_DVR_SET_SNAPCFG = 1083;    //设置单IO触发抓拍功能配置

const
  NET_DVR_GET_VTPPARAM = 1084;    //获取虚拟线圈参数
  NET_DVR_SET_VTPPARAM = 1085;    //设置虚拟线圈参数

const
  NET_DVR_GET_SNAPENABLECFG = 1086;    //获取抓拍机使能参数
  NET_DVR_SET_SNAPENABLECFG = 1087;    //设置抓拍机使能参数

const
  NET_DVR_GET_POSTEPOLICECFG = 1088;    //获取卡口电警参数
  NET_DVR_SET_POSTEPOLICECFG = 1089;    //设置卡口电警参数

const
  NET_DVR_GET_JPEGCFG_V30 = 1090;    //获取抓图的JPEG参数(基线)
  NET_DVR_SET_JPEGCFG_V30 = 1091;    //设置抓图的JPEG参数(基线)

const
  NET_DVR_GET_SPRCFG = 1092;    //获取车牌识别参数
  NET_DVR_SET_SPRCFG = 1093;    //设置车牌识别参数
  NET_DVR_GET_PLCCFG = 1094;    //获取车牌亮度补偿参数
  NET_DVR_SET_PLCCFG = 1095;    //设置车牌亮度补偿参数

const
  NET_DVR_GET_DEVICESTATECFG = 1096;    //获取设备当前状态参数
  NET_DVR_SET_CALIBRATE_TIME = 1097;    //设置扩展时间校时
  NET_DVR_GET_CALIBRATE_TIME = 1098;    //获取扩展时间校时

const
  NET_DVR_GET_DEVICECFG_V40 = 1100;    //获取扩展设备参数
  NET_DVR_SET_DEVICECFG_V40 = 1101;    //设置扩展设备参数

const
  NET_DVR_GET_ZEROCHANCFG = 1102;    //获取零通道压缩参数
  NET_DVR_SET_ZEROCHANCFG = 1103;    //设置零通道压缩参数

const
  NET_DVR_GET_ZERO_PREVIEWCFG_V30 = 1104;    // 获取零通道预览参数配置
  NET_DVR_SET_ZERO_PREVIEWCFG_V30 = 1105;    // 设置零通道预览参数配置

const
  NET_DVR_SET_ZERO_ZOOM = 1106;    //设置零通道的缩放配置
  NET_DVR_GET_ZERO_ZOOM = 1107;    //获取零通道的缩放配置

const
  NET_DVR_NATASSOCIATECFG_GET = 1110;    //获取NAT功能相关信息
  NET_DVR_NATASSOCIATECFG_SET = 1111;    //设置NAT功能相关信息

const
  NET_DVR_GET_SNMPCFG = 1112;    //获取SNMP参数
  NET_DVR_SET_SNMPCFG = 1113;    //设置SNMP参数

const
  NET_DVR_GET_SNMPCFG_V30 = 1114;    //获取SNMPv30参数
  NET_DVR_SET_SNMPCFG_V30 = 1115;    //设置SNMPv30参数

const
  NET_DVR_VIDEOPLATFORMALARMCFG_GET = 1130;    //获取视频综合平台报警配置
  NET_DVR_VIDEOPLATFORMALARMCFG_SET = 1131;    //设置视频综合平台报警配置

const
  NET_DVR_GET_RAID_ADAPTER_INFO = 1134;    // 获取适配器信息
  NET_DVR_SET_RAID_ADAPTER_INFO = 1135;    // 设置适配器信息

const
  NET_DVR_MATRIX_BIGSCREENCFG_GET = 1140;    //获取大屏拼接参数
  NET_DVR_MATRIX_BIGSCREENCFG_SET = 1141;    //设置大屏拼接参数

const
  NET_DVR_GET_MB_PLATFORMPARA = 1145;    //获取平台登录参数
  NET_DVR_SET_MB_PLATFORMPARA = 1146;    //设置平台登录参数
  NET_DVR_GET_MB_DEVSTATUS = 1147;    //获取移动设备状态

const
  NET_DVR_GET_DECODER_JOINT_CHAN = 1151;    //获取解码关联通道
  NET_DVR_SET_DECODER_JOINT_CHAN = 1152;    //设置解码关联通道

//多网卡配置
const
  NET_DVR_GET_NETCFG_MULTI = 1161;    //获取多网卡配置
  NET_DVR_SET_NETCFG_MULTI = 1162;    //设置多网卡配置
  NET_DVR_GET_NETCFG_MULTI_V50 = 1163;    //获取多网卡配置(分组)
  NET_DVR_SET_NETCFG_MULTI_V50 = 1164;    //设置多网卡配置(分组)

const
  NET_DVR_GET_CMSPARA = 1170;    //获取平台参数
  NET_DVR_SET_CMSPARA = 1171;    //设置平台参数
  NET_DVR_GET_DIALSTATUS = 1172;    //获取拨号状态参数
  NET_DVR_GET_SMSRELATIVEPARA = 1173;    //获取短信相关参数
  NET_DVR_SET_SMSRELATIVEPARA = 1174;    //设置短信相关参数
  NET_DVR_GET_PINSTATUS = 1175;    //获取Pin状态
  NET_DVR_SET_PINCMD = 1176;    //设置PIN命令
  NET_DVR_SET_SENSOR_CFG = 1180;    //设置模拟量参数
  NET_DVR_GET_SENSOR_CFG = 1181;    //获取模拟量参数
  NET_DVR_SET_ALARMIN_PARAM = 1182;    //设置报警输入参数
  NET_DVR_GET_ALARMIN_PARAM = 1183;    //获取报警输入参数
  NET_DVR_SET_ALARMOUT_PARAM = 1184;    //设置报警输出参数
  NET_DVR_GET_ALARMOUT_PARAM = 1185;    //获取报警输出参数
  NET_DVR_SET_SIREN_PARAM = 1186;    //设置警号参数
  NET_DVR_GET_SIREN_PARAM = 1187;    //获取警号参数
  NET_DVR_SET_ALARM_RS485CFG = 1188;    //设置报警主机485参数
  NET_DVR_GET_ALARM_RS485CFG = 1189;    //获取报警主机485参数
  NET_DVR_GET_ALARMHOST_MAIN_STATUS = 1190;    //获取报警主机主要状态
  NET_DVR_GET_ALARMHOST_OTHER_STATUS = 1191;    //获取报警主机其他状态
  NET_DVR_SET_ALARMHOST_ENABLECFG = 1192;    //获取报警主机使能状态
  NET_DVR_GET_ALARMHOST_ENABLECFG = 1193;    //设置报警主机使能状态
  NET_DVR_SET_ALARM_CAMCFG = 1194;    //设置视频综合平台报警触发CAM操作配置
  NET_DVR_GET_ALARM_CAMCFG = 1195;    //设置视频综合平台报警触发CAM操作配置
  NET_DVR_GET_GATEWAY_CFG = 1196;    //获取门禁参数配置
  NET_DVR_SET_GATEWAY_CFG = 1197;    //设置门禁参数配置

const
  NET_DVR_GET_ALARMDIALMODECFG = 1198;    //获取报警主机拨号参数
  NET_DVR_SET_ALARMDIALMODECFG = 1199;    //设置报警主机拨号参数
  NET_DVR_SET_ALARMIN_PARAM_V50 = 1200;    // 设置防区参数V50
  NET_DVR_GET_ALARMIN_PARAM_V50 = 1201;    // 获取防区参数V50
  NET_DVR_SET_WINCFG = 1202;    //窗口参数设置
  NET_DVR_GET_ALARMHOSTDIALSETUPMODE = 1204;    //获取报警主机拨号启用方式
  NET_DVR_SET_ALARMHOSTDIALSETUPMODE = 1205;    //设置报警主机拨号启用方式

//视频报警主机海外版命令(视频报警主机 V1.3)
const
  NET_DVR_SET_SUBSYSTEM_ALARM = 1210;    //设置子系统布/撤防
  NET_DVR_GET_SUBSYSTEM_ALARM = 1211;    //获取子系统布/撤防
  NET_DVR_GET_ALLOWLIST_ALARM = 1215;    //获取允许名单参数
  NET_DVR_SET_ALLOWLIST_ALARM = 1216;    //设置允许名单参数
  NET_DVR_GET_ALARMHOST_MODULE_LIST = 1222;    //获取所有模块
  NET_DVR_SET_PRIOR_ALARM = 1223;    //设置子系统布/撤防
  NET_DVR_GET_PRIOR_ALARM = 1224;    //获取子系统布/撤防
  NET_DVR_SET_TAMPER_ALARMIN_PARAM = 1225;    // 设置防区防拆参数
  NET_DVR_GET_TAMPER_ALARMIN_PARAM = 1226;    // 获取防区防拆参数

const
  NET_DVR_GET_HOLIDAY_PARAM_CFG = 1240;    // 获取节假日参数
  NET_DVR_SET_HOLIDAY_PARAM_CFG = 1241;    // 设置节假日参数

const
  NET_DVR_GET_MOTION_HOLIDAY_HANDLE = 1242;    // 获取移动侦测假日报警处理方式
  NET_DVR_SET_MOTION_HOLIDAY_HANDLE = 1243;    // 获取移动侦测假日报警处理方式

const
  NET_DVR_GET_VILOST_HOLIDAY_HANDLE = 1244;    // 获取视频信号丢失假日报警处理方式
  NET_DVR_SET_VILOST_HOLIDAY_HANDLE = 1245;    // 获取视频信号丢失假日报警处理方式

const
  NET_DVR_GET_HIDE_HOLIDAY_HANDLE = 1246;    // 获取遮盖假日报警处理方式
  NET_DVR_SET_HIDE_HOLIDAY_HANDLE = 1247;    // 设置遮盖假日报警处理方式

const
  NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE = 1248;    // 获取报警输入假日报警处理方式
  NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE = 1249;    // 设置报警输入假日报警处理方式
  NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE = 1250;    // 获取报警输出假日报警处理方式
  NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE = 1251;    // 设置报警输出假日报警处理方式
  NET_DVR_GET_HOLIDAY_RECORD = 1252;    // 获取假日录像参数
  NET_DVR_SET_HOLIDAY_RECORD = 1253;    // 设置假日录像参数
  NET_DVR_GET_NETWORK_BONDING = 1254;    // 获取BONDING网络参数
  NET_DVR_SET_NETWORK_BONDING = 1255;    // 设置BONDING网络参数
  NET_DVR_GET_LINK_STATUS = 1256;    // 获取通道IP工作状态
  NET_DVR_GET_DISK_QUOTA_CFG = 1278;    // 获取磁盘配额信息
  NET_DVR_SET_DISK_QUOTA_CFG = 1279;    // 设置磁盘配额信息
  NET_DVR_GET_JPEG_CAPTURE_CFG = 1280;    // 获取DVR抓图配置
  NET_DVR_SET_JPEG_CAPTURE_CFG = 1281;    // 设置DVR抓图配置
  NET_DVR_GET_SCHED_CAPTURECFG = 1282;    // 获取抓图计划
  NET_DVR_SET_SCHED_CAPTURECFG = 1283;    // 设置抓图计划
  NET_DVR_GET_VGA_PREVIEWCFG = 1284;    // 获取VGA预览配置
  NET_DVR_SET_VGA_PREVIEWCFG = 1285;    // 设置VGA预览配置
  NET_DVR_GET_VIDEO_INPUT_EFFECT = 1286;    // 获取通道视频输入图像参数
  NET_DVR_SET_VIDEO_INPUT_EFFECT = 1287;    // 设置通道视频输入图像参数

const
  NET_DVR_GET_STORAGE_SERVER_SWITCH = 1290;    //获取存储服务器开关状态
  NET_DVR_SET_STORAGE_SERVER_SWITCH = 1291;    //设置存储服务器开关状态

const
  NET_DVR_GET_DISK_QUOTA_CFG_V60 = 1292;    //获取磁盘配额信息V60
  NET_DVR_SET_DISK_QUOTA_CFG_V60 = 1293;    //设置磁盘配额信息V60

const
  NET_DVR_GET_OPTICAL_CHANNEL = 1300;    //获取光端子系统通道关联信息
  NET_DVR_SET_OPTICAL_CHANNEL = 1301;    //设置光端子系统通道关联信息
  NET_DVR_GET_FIBER_CASCADE = 1302;    //获取光纤级联模式
  NET_DVR_SET_FIBER_CASCADE = 1303;    //设置光纤级联模式
  NET_DVR_GET_SPARTAN_STATUS = 1304;    //获取畅显状态
  NET_DVR_SET_SPARTAN_STATUS = 1305;    //设置畅显状态
  NET_DVR_GET_ETHERNET_CHANNEL = 1306;    //获取端口聚合参数
  NET_DVR_SET_ETHERMET_CHANNEL = 1307;    //设置端口聚合参数
  NET_DVR_OPTICAL_REBOOT = 1320;    //光端机重启
  NET_DVR_SET_AUDIOCHAN_CFG = 1321;    //设置音频切换参数
  NET_DVR_GET_AUDIOCHAN_CFG = 1322;    //获取音频切换参数
//SDI矩阵1.0
const
  NET_DVR_SET_MATRIX_BASE_CFG = 1332;    //设置矩阵基本参数
  NET_DVR_GET_MATRIX_BASE_CFG = 1333;    //获取矩阵基本参数
  NET_DVR_SWITCH_MATRIX_IO = 1334;    //矩阵输入输出切换
  NET_DVR_GET_MATRIX_IO_RELATION = 1335;    //获取矩阵输入输入关联关系

const
  NET_DVR_V6PSUBSYSTEMARAM_GET = 1501;    //获取V6子系统配置
  NET_DVR_V6PSUBSYSTEMARAM_SET = 1502;    //设置V6子系统配置
  NET_DVR_GET_ALLWINCFG = 1503;    //窗口参数获取

const
  NET_DVR_BIGSCREENASSOCIATECFG_GET = 1511;    //获取大屏关联配置
  NET_DVR_BIGSCREENASSOCIATECFG_SET = 1512;    //设置大屏关联配置

//1200起
const
  NET_DVR_GETSCREENINFO = 1601;    //获取大屏信息配置
  NET_DVR_SETSCREENINFO = 1602;    //设置大屏信息配置
  NET_DVR_GET_SCREEN_WINCFG = 1603;    //单个窗口参数获取
  NET_DVR_LAYOUTLIST_GET = 1605;    //获取布局列表
  NET_DVR_SET_LAYOUTCFG = 1606;    //布局设置
  NET_DVR_LAYOUTCTRL = 1607;    //布局控制，1-open，2-close
  NET_DVR_INPUTLIST_GET = 1608;    //获取输入信号源列表
  NET_DVR_SET_INPUTSTREAMCFG = 1609;    //输入信号源设置
  NET_DVR_OUTPUT_SET = 1610;    //输出参数设置
  NET_DVR_OUTPUT_GET = 1611;    //输出参数获取
  NET_DVR_SET_OSDCFG = 1612;    //OSD参数设置
  NET_DVR_GET_OSDCFG = 1613;    //OSD参数获取
  NET_DVR_BIGSCREEN_GETSERIAL = 1614;    //获取大屏串口信息
  NET_DVR_GET_PLANLIST = 1615;    //获取预案列表
  NET_DVR_SET_PLAN = 1616;    //设置预案
  NET_DVR_CTRL_PLAN = 1617;    //控制预案
  NET_DVR_GET_DEVICE_RUN_STATUS = 1618;    //获取设备运行状态
  NET_DVR_GET_EXTERNAL_MATRIX_CFG = 1619;    //获取矩阵信息
  NET_DVR_SET_EXTERNAL_MATRIX_CFG = 1620;    //设置矩阵信息
  NET_DVR_GET_OUTPUT_SCREEN_RELATION = 1621;    //获取输出和屏幕的绑定关系
  NET_DVR_SET_OUTPUT_SCREEN_RELATION = 1622;    //设置输出和屏幕的绑定关系
  NET_DVR_GET_VCS_USER_CFG = 1623;    //获取用户信息配置
  NET_DVR_SET_VCS_USER_CFG = 1624;    //设置用户信息配置
  NET_DVR_CONTROL_SCREEN = 1625;    //屏幕控制
  NET_DVR_GET_EXTERNAL_MATRIX_CFG_V50 = 1626;    //获取矩阵信息
  NET_DVR_SET_EXTERNAL_MATRIX_CFG_V50 = 1627;    //设置矩阵信息

const
  NET_DVR_GET_DEV_BASEINFO = 1650;    //获取单个设备信息
  NET_DVR_SET_DEV_BASEINFO = 1651;    //设置单个设备信息
  NET_DVR_GET_DEV_NETINFO = 1652;    //获取设备的网络信息
  NET_DVR_SET_DEV_NETINFO = 1653;    //设置设备的网络信息
  NET_DVR_GET_SIGNAL_SOURCE_INFO = 1654;    //获取信号源信息
  NET_DVR_SET_SIGNAL_SOURCE_INFO = 1655;    //设置信号源信息
  NET_DVR_ADJUST_PIC_V40 = 1656;    //图像微调
  NET_DVR_RESTORE_V40 = 1657;    //恢复默认参数
  NET_DVR_SET_NET_SIGNAL = 1658;    //设置网络信号源
  NET_DVR_REBOOT_V40 = 1659;    //重启
  NET_DVR_CONTROL_PICTURE_V41 = 1660;    //图片控制V41

const
  NET_DVR_GET_AUTO_REBOOT_CFG = 1710;    //获取自动重启参数
  NET_DVR_SET_AUTO_REBOOT_CFG = 1711;    //设置自动重启参数
  NET_DVR_GET_TRUNK_USE_STATE = 1713;    //获取指定干线使用状态
  NET_DVR_SET_PTZ_CTRL_INFO = 1714;    //设置PTZ控制参数
  NET_DVR_GET_PTZ_CTRL_INFO = 1715;    //获取PTZ控制参数
  NET_DVR_GET_PTZ_STATUS = 1716;    //获取PTZ状态
  NET_DVR_GET_DISP_ROUTE_LIST = 1717;    //获取显示路径列表

const
  NET_DVR_GET_DEC_RESOURCE_LIST = 1720;    //获取可用解码资源列表
  NET_DVR_SET_DEC_RESOURCE_LIST = 1721;    //预分配解码资源
  NET_DVR_GET_DEC_YUV = 1722;    //获取解码通道关联YUV输出参数
  NET_DVR_SET_DEC_YUV = 1723;    //设置解码通道关联YUV输出参数
  NET_DVR_GET_DEC_RESOUCE = 1724;    //向视频综合平台申请解码资源
  NET_DVR_FREE_DEC_RESOURCE = 1725;    //释放解码资源

const
  NET_DVR_SET_VIDEOWALLDISPLAYMODE = 1730;    //设置电视墙拼接模式
  NET_DVR_GET_VIDEOWALLDISPLAYMODE = 1731;    //获取电视墙拼接模式
  NET_DVR_GET_VIDEOWALLDISPLAYNO = 1732;    //获取设备显示输出号
  NET_DVR_SET_VIDEOWALLDISPLAYPOSITION = 1733;    //设置显示输出位置参数
  NET_DVR_GET_VIDEOWALLDISPLAYPOSITION = 1734;    //获取显示输出位置参数
  NET_DVR_GET_VIDEOWALLWINDOWPOSITION = 1735;    //获取电视墙窗口参数
  NET_DVR_SET_VIDEOWALLWINDOWPOSITION = 1736;    //设置电视墙窗口参数
  NET_DVR_VIDEOWALLWINDOW_CLOSEALL = 1737;    //电视墙关闭所有窗口
  NET_DVR_SET_VIRTUALLED = 1738;    //虚拟LED设置
  NET_DVR_GET_VIRTUALLED = 1739;    //虚拟LED获取
  NET_DVR_GET_IMAGE_CUT_MODE = 1740;    //获取图像切割模式
  NET_DVR_SET_IMAGE_CUT_MODE = 1741;    //设置图像切割模式
  NET_DVR_GET_USING_SERIALPORT = 1742;    //获取当前使用串口
  NET_DVR_SET_USING_SERIALPORT = 1743;    //设置当前使用串口
  NET_DVR_SCENE_CONTROL = 1744;    //场景控制
  NET_DVR_GET_CURRENT_SCENE = 1745;    //获取当前场景号
  NET_DVR_GET_VW_SCENE_PARAM = 1746;    //获取电视墙场景模式参数
  NET_DVR_SET_VW_SCENE_PARAM = 1747;    //设置电视墙场景模式参数
  NET_DVR_DISPLAY_CHANNO_CONTROL = 1748;    //电视墙显示编号控制
  NET_DVR_GET_WIN_DEC_INFO = 1749;    //获取窗口解码信息（批量）
  NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION = 1750;    //解除电视墙输出接口绑定
  NET_DVR_SET_VW_AUDIO_CFG = 1752;    //设置音频切换参数
  NET_DVR_GET_VW_AUDIO_CFG = 1753;    //获取音频切换参数
  NET_DVR_GET_GBT28181_DECCHANINFO_CFG = 1754;    //获取GBT28181协议接入设备的解码通道信息
  NET_DVR_SET_GBT28181_DECCHANINFO_CFG = 1755;    //设置GBT28181协议接入设备的解码通道信息
  NET_DVR_SET_MAINBOARD_SERIAL = 1756;    //设置主控板串口参数
  NET_DVR_GET_MAINBOARD_SERIAL = 1757;    //获取主控板串口参数
  NET_DVR_GET_SUBBOARD_INFO = 1758;    //获取子板信息
  NET_DVR_GET_SUBBOARD_EXCEPTION = 1759;    //获取异常子板异常信息

const
  NET_DVR_GET_CAMERACHAN_SERIALCFG = 1760;    //获取Camera通道绑定串口配置
  NET_DVR_SET_CAMERACHAN_SERIALCFG = 1761;    //设置Camera通道绑定串口配置
  NET_DVR_GET_MATRIX_STATUS = 1762;    //获取视频综合平台状态
  NET_SET_MULTIFUNCTION_SERIALCFG = 1763;    //设置多功能串口配置
  NET_GET_MULTIFUNCTION_SERIALCFG = 1764;    //获取多功能串口配置
  NET_DVR_PTZ_3D_SPEED = 1765;    // 3维带速度的云台控制

const
  NET_DVR_GET_SIGNAL_JOINT = 1766;    //获取信号源绑定配置
  NET_DVR_SET_SIGNAL_JOINT = 1767;    //设置信号源绑定配置
  NET_DVR_SIGNAL_CUT = 1768;    //信号源裁剪
  NET_DVR_DYNAMIC_DECODE_BATCH = 1769;    //批量动态解码
  NET_DVR_DECSWITCH_SET_BATCH = 1770;    //批量设置解码通道开关
  NET_DVR_DECSWITCH_GET_BATCH = 1771;    //批量获取解码通道开关
  NET_DVR_GET_ALL_SIGNAL_JOINT = 1772;    //获取所有信号源绑定配置
  NET_DVR_GET_PLAYING_PLAN = 1773;    //获取正在执行预案
  NET_DVR_WALL_RELATION_GET = 1774;    //获取设备墙与物理墙的关联
  NET_DVR_WALL_RELATION_SET = 1775;    //设置设备墙与物理墙的关联
  NET_DVR_SET_INPUTSTREAMCFG_V40 = 1776;    //输入信号源设置
  NET_DVR_PTZCFG_INPUTSTREAM_GET = 1777;    //获取输入源反向云台控制配置
  NET_DVR_PTZCFG_INPUTSTREAM_SET = 1778;    //设置输入源反向云台控制配置
  NET_DVR_SIGNAL_CUTPARAM_GET = 1779;    //获取信号源裁剪参数

const
  NET_DVR_GET_SUBSYSTEM_NETCFG = 1780;    //获取子系统网卡参数
  NET_DVR_SET_SUBSYSTEM_NETCFG = 1781;    //设置子系统网卡参数
  NET_DVR_DEL_SIGNAL_JOINT = 1782;    //删除拼接信号源

const
  NET_DVR_GET_PICTURE_INFO = 1783;    //获取图片信息
  NET_DVR_SET_PICTURE_INFO = 1784;    //设置图片信息
  NET_DVR_GET_VIDEO_INFO = 1785;    //获取视频信息
  NET_DVR_SET_VIDEO_INFO = 1786;    //设置视频信息
  NET_DVR_SET_PLAYLIST = 1787;    //设置播放列表
  NET_DVR_GET_PLAYLIST = 1788;    //获取播放列表
  NET_DVR_GET_ALL_PLAYLIST = 1789;    //获取所有播放列表
  NET_DVR_PLAYITEM_CONTROL = 1790;    //播放项操作
  NET_DVR_SET_PLAYPLAN_TEMPLATE = 1791;    //设置播放计划模板
  NET_DVR_GET_PLAYPLAN_TEMPLATE = 1792;    //获取播放计划
  NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE = 1793;    //获取所有播放计划
  NET_DVR_SET_WINDOW_PLAYPLAN = 1794;    //设置窗口播放计划
  NET_DVR_GET_WINDOW_PLAYPLAN = 1795;    //获取窗口播放计划
  NET_DVR_TOPLAY_ITEM = 1796;    //指定播放
  NET_DVR_DEVICE_PLAY_CONTROL = 1797;    //设备播放控制
  NET_DVR_GET_PLAY_INFO = 1798;    //获取当前播放信息
  NET_DVR_GET_ALL_PICTURE_INFO = 1799;    //获取图片信息
  NET_DVR_GET_ALL_VIDEO_INFO = 1800;    //获取视频信息
  NET_DVR_DELETE_VIDEO_FILE = 1801;    //删除视频


const
  NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG = 2001;    //报警主机获取子系统参数
  NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG = 2002;    //报警主机设置子系统参数
  NET_DVR_GETEXTENDALARMININFO = 2003;    //获取防区编号信息
  NET_DVR_MODIFYALARMINNO = 2004;    //修改防区编号信息
  NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG = 2005;    //获取无线网络参数配置
  NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG = 2006;    //设置无线网络参数配置
  NET_DVR_GET_ALARMHOST_NETCFG = 2007;    //获取网络参数配置
  NET_DVR_SET_ALARMHOST_NETCFG = 2008;    //设置网络参数配置
  NET_DVR_GET_LED_SCREEN_CFG = 2009;    // 获取LED屏幕参数
  NET_DVR_SET_LED_SCREEN_CFG = 2010;    // 设置LED屏幕参数
  NET_DVR_GET_LED_CONTENT_CFG = 2011;    // 获取LED屏显内容
  NET_DVR_SET_LED_CONTENT_CFG = 2012;    // 设置LED屏显内容
  NET_DVR_TURNON_LED = 2013;    // 打开LED屏
  NET_DVR_TURNOFF_LED = 2014;    // 关闭LED屏
  NET_DVR_GET_LED_TIMER_SWITCH = 2015;    // 获取LED屏定时开关参数
  NET_DVR_SET_LED_TIMER_SWITCH = 2016;    // 设置LED屏定时开关参数
  NET_DVR_SET_LED_BRIGHTNESS = 2017;    // 手动设置LED屏亮度
  NET_DVR_GET_LED_TIMER_BRIGHTNESS = 2018;    //设置分时LED屏亮度
  NET_DVR_SET_LED_TIMER_BRIGHTNESS = 2019;    //获取分时LED屏亮度
  NET_DVR_LED_CHECKTIME = 2020;    //LED校时
  NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM = 2021;    //获取音频报警事件
  NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM = 2022;    //设置音频报警事件
  NET_DVR_GET_LED_STATUS = 2023;    //获取LED屏状态
  NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM = 2027;    //关闭子系统故障提示音
  NET_DVR_SET_SUBSYSTEM_BYPASS = 2028;    //子系统旁路
  NET_DVR_CANCEL_SUBSYSTEM_BYPASS = 2029;    //子系统旁路恢复

const
  NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX = 2030;    //获取子系统扩展参数
  NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX = 2031;    //设置子系统扩展参数
  NET_DVR_GET_ALARMHOST_PRINTER_CFG = 2032;    //获取打印机打印使能
  NET_DVR_SET_ALARMHOST_PRINTER_CFG = 2033;    //设置打印机打印使能
  NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM = 2034;    //获取指定子系统内的所有防区
  NET_DVR_GET_ALARMHOST_TRIGGER_LIST = 2035;    //获取所有触发器
  NET_DVR_ARM_ALARMHOST_SUBSYSTEM = 2036;    //按布防类型对子系统布防
  NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG = 2037;    // 获取事件触发报警输出配置
  NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG = 2038;    // 设置事件触发报警输出配置
  NET_DVR_GET_ALARMHOST_FAULT_CFG = 2039;    // 获取故障处理配置
  NET_DVR_SET_ALARMHOST_FAULT_CFG = 2040;    // 设置故障处理配置
  NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE = 2041;    //自动搜索
  NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE = 2042;    //自动注册
  NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM = 2043;    //关闭全局故障提示音

const
  NET_DVR_GET_SAFETYCABIN_WORK_MODE = 2044;    //获取防护舱工作模式参数
  NET_DVR_SET_SAFETYCABIN_WORK_MODE = 2045;    //设置防护舱工作模式参数
  NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG = 2046;    //获取防护舱人信号探测参数
  NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG = 2047;    //设置防护舱人信号探测参数

const
  NET_DVR_GET_ALARMHOST_MODULE_CFG = 2048;    //获取模块信息
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG            2049//设置模块信息(预留)

const
  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE = 2050;    //获取485外接设备状态
  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = 2051;    //设置外接设备报警限值
  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = 2052;    //获取外接设备报警限值
  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG = 2053;    // 获取模拟量关联配置
  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG = 2054;    // 设置模拟量关联配置
  NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG = 2055;    // 设置报警主机485槽位参数
  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG = 2056;    // 获取报警主机485槽位参数

const
  NET_DVR_GET_ALL_VARIABLE_INFO = 2057;    // 获取所有变量元素信息
  NET_DVR_GET_ALARM_POINT_CFG = 2058;    // 获取点号信息
  NET_DVR_SET_ALARM_POINT_CFG = 2059;    // 设置点号信息
  NET_DVR_GET_HISTORY_VALUE = 2060;    // 获取历史数据
  NET_DVR_GET_ALARMHOST_ALARM_MODE = 2061;    // 获取数据上传方式
  NET_DVR_SET_ALARMHOST_ALARM_MODE = 2062;    // 设置数据上传方式
  NET_DVR_GET_ALARMHOST_SENSOR_VALUE = 2063;    // 获取模拟量实时数据

const
  NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40 = 2064;    // 获取数据上传方式
  NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40 = 2065;    // 设置数据上传方式
  NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG = 2068;    // 获取时控输出参数
  NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG = 2069;    // 设置时控输出参数
  NET_DVR_GET_CMS_CFG = 2070;    
  NET_DVR_SET_CMS_CFG = 2071;    

const
  NET_DVR_GET_PASSTHROUGH_CAP = 2073;    //获取设备透传能力集

const
  NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40 = 2072;    // 获取主要状态V40
  NET_DVR_GET_ALARMHOST_MAIN_STATUS_V51 = 2083;    // 获取主要状态V51

//************************************视频报警主机1.3 begin************************************
const
  NET_DVR_GET_ALARM_CAPTRUE_CFG = 2074;    //获取报警抓图参数配置
  NET_DVR_SET_ALARM_CAPTRUE_CFG = 2075;    //设置报警抓图参数配置
  NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40 = 2078;    // 获取单个时控输出参数V40
  NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40 = 2079;    // 设置单个时控输出参数V40
  NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40 = 2080;    // 获取时控输出参数V40
  NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40 = 2081;    // 设置时控输出参数V40
  NET_DVR_ALARMHOST_CLOSE_SUBSYSTEM = 2082;    //对子系统撤防操作
//************************************视频报警主机1.3 end*************************************


const
  NET_DVR_GET_WEEK_PLAN_CFG = 2100;    //获取门状态周计划参数
  NET_DVR_SET_WEEK_PLAN_CFG = 2101;    //设置门状态周计划参数
  NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN = 2102;    //获取门状态假日计划参数
  NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN = 2103;    //设置门状态假日计划参数
  NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP = 2104;    //获取门状态假日组参数
  NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP = 2105;    //设置门状态假日组参数
  NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE = 2106;    //获取门状态计划模板参数
  NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE = 2107;    //设置门状态计划模板参数
  NET_DVR_GET_DOOR_CFG = 2108;    //获取门参数
  NET_DVR_SET_DOOR_CFG = 2109;    //设置门参数
  NET_DVR_GET_DOOR_STATUS_PLAN = 2110;    //获取门状态计划参数
  NET_DVR_SET_DOOR_STATUS_PLAN = 2111;    //设置门状态计划参数
  NET_DVR_GET_GROUP_CFG = 2112;    //获取群组参数
  NET_DVR_SET_GROUP_CFG = 2113;    //设置群组参数
  NET_DVR_GET_MULTI_CARD_CFG = 2114;    //获取多重卡参数
  NET_DVR_SET_MULTI_CARD_CFG = 2115;    //设置多重卡参数
  NET_DVR_GET_CARD_CFG = 2116;    //获取卡参数
  NET_DVR_SET_CARD_CFG = 2117;    //设置卡参数
  NET_DVR_CLEAR_ACS_PARAM = 2118;    //清空门禁主机参数
  NET_DVR_GET_SNEAK_CFG = 2119;    //获取反潜回参数
  NET_DVR_SET_SNEAK_CFG = 2120;    //设置反潜回参数
  NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG = 2121;    //获取多门互锁参数
  NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG = 2122;    //设置多门互锁参数
  NET_DVR_GET_ACS_WORK_STATUS = 2123;    //获取门禁主机工作状态
  NET_DVR_GET_VERIFY_WEEK_PLAN = 2124;    //获取读卡器验证方式周计划参数
  NET_DVR_SET_VERIFY_WEEK_PLAN = 2125;    //设置读卡器验证方式周计划参数
  NET_DVR_GET_CARD_RIGHT_WEEK_PLAN = 2126;    //获取卡权限周计划参数
  NET_DVR_SET_CARD_RIGHT_WEEK_PLAN = 2127;    //设置卡权限周计划参数
  NET_DVR_GET_VERIFY_HOLIDAY_PLAN = 2128;    //获取读卡器验证方式假日计划参数
  NET_DVR_SET_VERIFY_HOLIDAY_PLAN = 2129;    //设置读卡器验证方式假日计划参数
  NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN = 2130;    //获取卡权限假日计划参数
  NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN = 2131;    //设置卡权限假日计划参数
  NET_DVR_GET_VERIFY_HOLIDAY_GROUP = 2132;    //获取读卡器验证方式假日组参数
  NET_DVR_SET_VERIFY_HOLIDAY_GROUP = 2133;    //设置读卡器验证方式假日组参数
  NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP = 2134;    //获取卡权限假日组参数
  NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP = 2135;    //设置卡权限假日组参数
  NET_DVR_GET_VERIFY_PLAN_TEMPLATE = 2136;    //获取读卡器验证方式计划模板参数
  NET_DVR_SET_VERIFY_PLAN_TEMPLATE = 2137;    //设置读卡器验证方式计划模板参数
  NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE = 2138;    //获取卡权限计划模板参数
  NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE = 2139;    //设置卡权限计划模板参数
  NET_DVR_GET_CARD_READER_CFG = 2140;    //获取读卡器参数
  NET_DVR_SET_CARD_READER_CFG = 2141;    //设置读卡器参数
  NET_DVR_GET_CARD_READER_PLAN = 2142;    //获取读卡器验证计划参数
  NET_DVR_SET_CARD_READER_PLAN = 2143;    //设置读卡器验证计划参数
  NET_DVR_GET_CASE_SENSOR_CFG = 2144;    //获取事件触发器参数
  NET_DVR_SET_CASE_SENSOR_CFG = 2145;    //设置事件触发器参数
  NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG = 2146;    //获取读卡器反潜回参数
  NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG = 2147;    //设置读卡器反潜回参数
  NET_DVR_GET_PHONE_DOOR_RIGHT_CFG = 2148;    //获取手机关联门权限参数
  NET_DVR_SET_PHONE_DOOR_RIGHT_CFG = 2149;    //获取手机关联门权限参数
  NET_DVR_GET_FINGERPRINT_CFG = 2150;    //获取指纹参数
  NET_DVR_SET_FINGERPRINT_CFG = 2151;    //设置指纹参数
  NET_DVR_DEL_FINGERPRINT_CFG = 2152;    //删除指纹参数
  NET_DVR_GET_EVENT_CARD_LINKAGE_CFG = 2153;    //获取事件卡号联动配置参数
  NET_DVR_SET_EVENT_CARD_LINKAGE_CFG = 2154;    //设置事件卡号联动配置参数
  NET_DVR_GET_ANTI_SNEAK_HOST_CFG = 2155;    //获取主机组反潜回参数
  NET_DVR_SET_ANTI_SNEAK_HOST_CFG = 2156;    //设置主机组反潜回参数
  NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG = 2157;    //获取主机组读卡器反潜回参数
  NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG = 2158;    //设置主机组读卡器反潜回参数
  NET_DVR_GET_ACS_CFG = 2159;    //获取门禁主机参数
  NET_DVR_SET_ACS_CFG = 2160;    //设置门禁主机参数
  NET_DVR_GET_CARD_PASSWD_CFG = 2161;    //获取卡密码开门使能配置
  NET_DVR_SET_CARD_PASSWD_CFG = 2162;    //设置卡密码开门使能配置
  NET_DVR_GET_CARD_USERINFO_CFG = 2163;    //获取卡号关联用户信息参数
  NET_DVR_SET_CARD_USERINFO_CFG = 2164;    //设置卡号关联用户信息参数

const
  NET_DVR_GET_ACS_EXTERNAL_DEV_CFG = 2165;    //获取门禁主机串口外设参数
  NET_DVR_SET_ACS_EXTERNAL_DEV_CFG = 2166;    //设置门禁主机串口外设参数
  NET_DVR_GET_PERSONNEL_CHANNEL_CFG = 2167;    //获取人员通道参数
  NET_DVR_SET_PERSONNEL_CHANNEL_CFG = 2168;    //设置人员通道参数
  NET_DVR_SET_PLATFORM_VERIFY_CFG = 2169;    //下发平台认证结果
  NET_DVR_GET_PERSON_STATISTICS_CFG = 2170;    //获取人数统计参数
  NET_DVR_SET_PERSON_STATISTICS_CFG = 2171;    //设置人数统计参数
  NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG = 2172;    //获取屏幕字符串显示参数
  NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG = 2173;    //设置屏幕字符串显示参数
  NET_DVR_GET_GATE_TIME_CFG = 2174;    //获取人员通道闸门时间参数
  NET_DVR_SET_GATE_TIME_CFG = 2175;    //设置人员通道闸门时间参数
  NET_DVR_GET_LOCAL_CONTROLLER_STATUS = 2176;    //获取就地控制器状态
  NET_DVR_GET_ONLINE_LOCAL_CONTROLLER = 2177;    //搜索在线就地控制器
  NET_DVR_GET_CARD_CFG_V50 = 2178;    //获取新卡参数(V50)
  NET_DVR_SET_CARD_CFG_V50 = 2179;    //设置新卡参数(V50)
  NET_DVR_GET_ACS_WORK_STATUS_V50 = 2180;    //获取门禁主机工作状态(V50)
  NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V50 = 2181;    //获取事件卡号联动配置参数(V50)
  NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V50 = 2182;    //设置事件卡号联动配置参数(V50)
  NET_DVR_GET_FINGERPRINT_CFG_V50 = 2183;    //获取指纹参数V50
  NET_DVR_SET_FINGERPRINT_CFG_V50 = 2184;    //设置指纹参数V50

const
  NET_DVR_GET_SAFETYCABIN_STATE = 2197;    //获取防护舱状态
  NET_DVR_GET_RS485_CASCADE_CFG = 2198;    //获取Rs485级联设备配置
  NET_DVR_SET_RS485_CASCADE_CFG = 2199;    //设置Rs485级联设备配置

//************************************视频报警主机2.0 begin************************************
const
  NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG = 2200;    //获取遥控器权限参数
  NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG = 2201;    //设置遥控器权限参数
  NET_DVR_GET_KEYBOARD_CFG = 2202;    //获取键盘参数配置
  NET_DVR_SET_KEYBOARD_CFG = 2203;    //设置键盘参数配置
  NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO = 2204;    //无线业务查询
  NET_DVR_GET_ALL_REMOTECONTROLLER_LIST = 2205;    //获取所有遥控器
  NET_DVR_GET_PREVIEW_DELAY_CFG = 2206;    //获取延迟预览参数配置
  NET_DVR_SET_PREVIEW_DELAY_CFG = 2207;    //设置延迟预览参数配置
  NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG = 2208;    //获取防区联动视频通道配置
  NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG = 2209;    //设置防区联动视频通道配置
  NET_DVR_GET_CENTER_SERVER_CFG = 2210;    //获取报警中心服务器
  NET_DVR_SET_CENTER_SERVER_CFG = 2211;    //设置报警中心服务器
//************************************视频报警主机2.0 end*************************************

//*******************************一键式紧急报警产品V1.0.0 begin*******************************
const
  NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP = 2212;    //获取一键式紧急报警产品能力
  NET_DVR_GET_CALL_WAITTING_CFG_CAP = 2213;    //获取呼叫等待参数配置能力
  NET_DVR_GET_CALL_WAITTING_CFG = 2214;    //获取呼叫等待参数配置
  NET_DVR_SET_CALL_WAITTING_CFG = 2215;    //设置呼叫等待参数配置
  NET_DVR_GET_ALARM_LAMP_CFG_CAP = 2216;    //获取警灯参数配置能力
  NET_DVR_GET_ALARM_LAMP_CFG = 2217;    //获取警灯参数配置
  NET_DVR_SET_ALARM_LAMP_CFG = 2218;    //设置警灯参数配置
  NET_DVR_GET_VOICE_PROMPTION_CFG_CAP = 2219;    //获取语音提示配置能力
  NET_DVR_GET_VOICE_PROMPTION_CFG = 2220;    //获取语音提示配置
  NET_DVR_SET_VOICE_PROMPTION_CFG = 2221;    //设置语音提示配置
  NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP = 2222;    //获取紧急报警处理能力
  NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL = 2223;    //紧急报警处理控制
//*******************************一键式紧急报警产品V1.0.0 end*********************************

//网络报警主机 V2.2
const
  NET_DVR_GET_ALARMHOST_NETCFG_V50 = 2224;    //获取报警主机网络参数配置V50
  NET_DVR_SET_ALARMHOST_NETCFG_V50 = 2225;    //设置报警主机网络参数配置V50
  NET_DVR_REGISTER_ALARM_RS485 = 2226;    //RS485重新注册
//*********************************动环报警主机V3.0***************************************

const
  NET_DVR_GET_ALARMIN_PARAM_LIST = 2227;    //获取防区参数列表
//无线报警主机1.0.0
const
  NET_DVR_GET_ALARMHOST_OTHER_STATUS_V50 = 2228;    //获取报警主机其他状态v50
  NET_DVR_GET_ALARMHOST_OTHER_STATUS_V51 = 2236;    //获取报警主机其他状态V51
  NET_DVR_GET_ALARMIN_ASSOCIATED_CHAN_LIST = 2229;    //获取防区防区联动视频通道参数列表
  NET_DVR_GET_ALARMIN_TRIGGER = 2230;    //获取报警主机防区联动配置
  NET_DVR_SET_ALARMIN_TRIGGER = 2231;    //设置报警主机防区联动配置
  NET_DVR_GET_EMERGENCY_CALL_HELP_TRIGGER = 2232;    //获取报警主机紧急求助联动配置
  NET_DVR_SET_EMERGENCY_CALL_HELP_TRIGGER = 2233;    //设置报警主机紧急求助联动配置
  NET_DVR_GET_CONSULT_TRIGGER = 2234;    //获取报警主机业务咨询联动配置
  NET_DVR_SET_CONSULT_TRIGGER = 2235;    //设置报警主机业务咨询联动配置
  NET_DVR_GET_ALARMIN_PARAM_LIST_V50 = 2237;    //获取防区参数列表V50

const
  NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50 = 2304;    //获取卡权限周计划参数V50
  NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50 = 2305;    //设置卡权限周计划参数V50

const
  NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2310;    //获取卡权限假日计划参数V50
  NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2311;    //设置卡权限假日计划参数V50

const
  NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2316;    //获卡权限假日组参数V50
  NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2317;    //设置卡权限假日组参数V50

const
  NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2322;    //获取卡权限计划模板参数V50
  NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2323;    //设置卡权限计划模板参数V50

//*********************************经济型指纹门禁产品V1.0 设备不做***************************************
const
  NET_DVR_GET_SCHEDULE_INFO = 2500;    //获取排班信息
  NET_DVR_GET_ATTENDANCE_SUMMARY_INFO = 2501;    //获取考勤汇总信息
  NET_DVR_GET_ATTENDANCE_RECORD_INFO = 2502;    //获取考勤记录信息
  NET_DVR_GET_ABNORMAL_INFO = 2503;    //获取异常统计信息
//*********************************经济型指纹门禁产品V1.0***************************************

//************************************视频门禁一体机1.0 begin*************************************
const
  NET_DVR_CAPTURE_FINGERPRINT_INFO = 2504;    //采集指纹信息
//************************************视频门禁一体机1.0 end*************************************

//************************************嵌入式智能终端1.0 begin*************************************
const
  NET_DVR_BULK_UPLOAD_BLOCKLIST_PICTURE = 2520;    //批量上传禁止名单图片
  NET_DVR_BULK_UPLOAD_ID_BLOCKLIST = 2521;    //批量上传身份证禁止名单
  NET_DVR_GET_FAILED_FACE_INFO = 2522;    //获取设备升级建模失败的人脸记录
  NET_DVR_GET_FACE_AND_TEMPLATE = 2523;    //获取人脸及模板数据
  NET_DVR_SET_FACE_AND_TEMPLATE = 2524;    //设置人脸及模板数据
//************************************嵌入式智能终端1.0 end*************************************

//************************************人脸识别门禁一体机1.0 begin*************************************
const
  NET_DVR_GET_CARD_READER_CFG_V50 = 2505;    //获取读卡器参数(V50)
  NET_DVR_SET_CARD_READER_CFG_V50 = 2506;    //设置读卡器参数(V50)
  NET_DVR_GET_FACE_PARAM_CFG = 2507;    //获取人脸参数
  NET_DVR_SET_FACE_PARAM_CFG = 2508;    //设置人脸参数
  NET_DVR_DEL_FACE_PARAM_CFG = 2509;    //删除人脸参数
  NET_DVR_CAPTURE_FACE_INFO = 2510;    //采集人脸信息
//************************************人脸识别门禁一体机1.0 end*************************************
const
  NET_DVR_GET_REGISTER_INFO = 2511;    //登记信息获取

const
  NET_DVR_GET_SMSRELATIVEPARA_V50 = 2512;    //获取短信相关参数
  NET_DVR_SET_SMSRELATIVEPARA_V50 = 2513;    //设置短信相关参数
  NET_DVR_GET_ACS_EVENT = 2514;    //设备事件获取
  NET_DVR_GET_MULTI_CARD_CFG_V50 = 2515;    //获取多重卡参数V50
  NET_DVR_SET_MULTI_CARD_CFG_V50 = 2516;    //设置多重卡参数V50
  NET_DVR_DEL_FINGERPRINT_CFG_V50 = 2517;    //删除指纹参数V50
  NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V51 = 2518;    //获取事件卡号联动配置参数(V51)
  NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V51 = 2519;    //设置事件卡号联动配置参数(V51)

const
  NET_DVR_SET_EXAM_INFO = 2530;    //考试信息下发
  NET_DVR_SET_EXAMINEE_INFO = 2531;    //考生信息下发
  NET_DVR_SEARCH_EXAM_COMPARE_RESULT = 2532;    //考试比对结果查询
  NET_DVR_BULK_CHECK_FACE_PICTURE = 2533;    //批量校验人脸图片
  NET_DVR_JSON_CONFIG = 2550;    //JSON透传数据
  NET_DVR_FACE_DATA_RECORD = 2551;    //添加人脸数据到人脸库
  NET_DVR_FACE_DATA_SEARCH = 2552;    //查询人脸库中的人脸数据
  NET_DVR_FACE_DATA_MODIFY = 2553;    //修改人脸库中的人脸数据
  NET_DVR_CAPTURE_DATA_SEARCH = 2554;    //查询离线采集数据集中数据
  NET_DVR_SET_FORM_DATA = 2555;    //长连接设置表单数据
  NET_DVR_GET_FORM_DATA = 2556;    //长连接获取表单数据

const
  NET_DVR_GET_CARD = 2560;    
  NET_DVR_SET_CARD = 2561;    
  NET_DVR_DEL_CARD = 2562;    
  NET_DVR_GET_FINGERPRINT = 2563;    
  NET_DVR_SET_FINGERPRINT = 2564;    
  NET_DVR_DEL_FINGERPRINT = 2565;    
  NET_DVR_GET_FACE = 2566;    
  NET_DVR_SET_FACE = 2567;    

const
  NET_DVR_GET_ALL_ALARM_RS485CFG = 2705;    // 获取485参数
  NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG = 2706;    // 获取所有报警主机485槽位参数
  NET_DVR_GET_DEVICE_SELF_CHECK_STATE = 2707;    //获取设备自检功能
  NET_DVR_GET_ALL_ALARM_POINT_CFG = 2708;    // 获取所有点号参数
  NET_DVR_GET_ALL_ALARM_SENSOR_CFG = 2709;    // 获取所有模拟量参数
  NET_DVR_GET_ALL_ALARM_SENSOR_JOINT = 2710;    //获取所有模拟量联动参数
  NET_DVR_GET_AIR_CONDITION_PARAM = 2711;    //获取空调参数
  NET_DVR_GET_OUT_SCALE_CFG = 2712;    //获取主辅口输出配置
  NET_DVR_SET_OUT_SCALE_CFG = 2713;    //设置主辅口输出配置
  NET_DVR_GET_ALARM_CHAN_ABLITITY = 2714;    //获取报警相关通道参
//*********************************动环报警主机V3.0***************************************

//动环报警主机D2000 V1.0
const
  NET_DVR_GET_ALARMCENTER_NETCFG = 2715;    //获取报警中心网络参数配置
  NET_DVR_SET_ALARMCENTER_NETCFG = 2716;    //获取报警中心网络参数配置


const
  NET_ITC_GET_TRIGGERCFG = 3003;    //获取触发参数
  NET_ITC_SET_TRIGGERCFG = 3004;    //设置触发参数
  NET_ITC_GET_IOOUT_PARAM_CFG = 3005;    //获取IO输出参数（3.1含之后版本）
  NET_ITC_SET_IOOUT_PARAM_CFG = 3006;    //设置IO输出参数（3.1含之后版本）

const
  NET_DVR_GET_CAMERA_SETUPCFG = 3007;    //获取相机架设参数
  NET_DVR_SET_CAMERA_SETUPCFG = 3008;    //设置相机架设参数

const
  NET_ITC_GET_TRIGGER_DEFAULTCFG = 3013;    //获取触发模式推荐参数
  NET_DVR_GET_STATUS_DETECTCFG = 3015;    //获取状态检测使能参数
  NET_DVR_SET_STATUS_DETECTCFG = 3016;    //设置状态检测使能参数
  NET_ITC_GET_VIDEO_TRIGGERCFG = 3017;    //获取视频电警触发参数
  NET_ITC_SET_VIDEO_TRIGGERCFG = 3018;    //设置视频电警触发参数
  NET_DVR_GET_TPS_ALARMCFG = 3019;    //获取交通统计报警参数
  NET_DVR_SET_TPS_ALARMCFG = 3020;    //设置交通统计报警参数


const
  NET_DVR_GET_REDAREACFG = 3100;    //获取红绿灯区域参数
  NET_DVR_SET_REDAREACFG = 3101;    //设置红绿灯区域参数
  NET_DVR_GET_TEST_SPOT = 3102;    //获取SPOT口测试总步数和当前第几步
  NET_DVR_SET_TEST_SPOT = 3103;    //设置SPOT口测试总步数和当前第几步
  NET_DVR_GET_CABINETCFG = 3104;    //机柜参数配置获取
  NET_DVR_SET_CABINETCFG = 3105;    //机柜参数配置设置
  NET_DVR_VEHICLE_CHECK_START = 3106;    //禁止名单稽查数据回传
  NET_DVR_SET_CAPTUREPIC_CFG = 3107;    //车载抓图配置设置命令
  NET_DVR_GET_CAPTUREPIC_CFG = 3108;    //车载抓图配置获取命令
  NET_DVR_SET_MOBILEPLATE_RECOG_CFG = 3109;    //车载车牌识别配置设置命令
  NET_DVR_GET_MOBILEPLATE_RECOG_CFG = 3110;    //车载车牌识别配置获取命令
  NET_DVR_SET_MOBILE_RADAR_CFG = 3111;    //车载雷达配置设置命令
  NET_DVR_GET_MOBILE_RADAR_CFG = 3112;    //车载雷达配置获取命令
  NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG = 3113;    //车载禁止名单本地对比配置设置命令
  NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG = 3114;    //车载禁止名单本地对比配置获取命令

const
  NET_ITC_GET_ICRCFG = 3115;    //获取ICR配置切换
  NET_ITC_SET_ICRCFG = 3116;    //设置ICR配置切换
  NET_ITC_GET_RS485_ACCESSINFO = 3117;    //获取Rs485关联接入设备的信息
  NET_ITC_SET_RS485_ACCESSINFO = 3118;    //设置Rs485关联接入设备的信息
  NET_ITC_GET_EXCEPTIONCFG = 3119;    //获取异常参数
  NET_ITC_SET_EXCEPTIONCFG = 3120;    //设置异常参数
  NET_ITC_GET_FTPCFG = 3121;    //获取ITC  FTP设置参数
  NET_ITC_SET_FTPCFG = 3122;    //设置ITC FTP设置参数

const
  NET_DVR_VEHICLE_CONTROL_LIST_START = 3123;    //设置车辆禁止和允许名单信息
  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST = 3124;    //获取所有车辆禁止和允许名单信息
  NET_DVR_VEHICLE_DELINFO_CTRL = 3125;    //删除设备内禁止名单数据库信息
  NET_DVR_GET_ENTRANCE_PARAMCFG = 3126;    //获取出入口控制参数
  NET_DVR_SET_ENTRANCE_PARAMCFG = 3127;    //设置出入口控制参数
  NET_DVR_BARRIERGATE_CTRL = 3128;    //远程控制道闸
  NET_DVR_GATELAMP_CTRL = 3129;    //常亮灯功能
  NET_DVR_GET_CURTRIGGERMODE = 3130;    //获取设备当前触发模式
  NET_DVR_GET_GPSDATACFG = 3131;    //获取GPS参数
  NET_DVR_SET_GPSDATACFG = 3132;    //设置GPS参数
  NET_DVR_VEHICLELIST_CTRL_START = 3133;    //设置车辆禁止和允许名单信息

const
  NET_DVR_GET_GUARDCFG = 3134;    //获取车牌识别检测计划
  NET_DVR_SET_GUARDCFG = 3135;    //设置车牌识别检测计划
  NET_DVR_GET_SNAPINFO_CFG = 3136;    //获取抓拍图片参数
  NET_DVR_SET_SNAPINFO_CFG = 3137;    //设置抓拍图片参数
  NET_DVR_GET_SNAPINFO_CFG_V40 = 3138;    //获取抓拍图片参数扩展
  NET_DVR_SET_SNAPINFO_CFG_V40 = 3139;    //设置抓拍图片参数扩展
  NET_DVR_SET_CURTRIGGERMODE = 3140;    //设置设备当前触发模式(仅IPC/D支持)
  NET_DVR_GET_TRAFFIC_DATA = 3141;    //长连接获取交通数据
  NET_DVR_GET_TRAFFIC_FLOW = 3142;    //长连接获取交通流量
  NET_DVR_PARKING_VEHICLE_SEND = 3143;    //停车车辆信息下发
  NET_DVR_PARKING_CARD_SEND = 3144;    //停车卡下发
  NET_DVR_PARKING_CARD_CTRL = 3145;    //停车场停车卡控制接口

const
  NET_DVR_GET_ALARMCTRL_CAPABILITIES = 3146;    //获取报警控制能力
  NET_DVR_SET_ALARMCTRL_CFG = 3147;    //设置报警控制
  NET_DVR_GET_ALARMCTRL_CFG = 3148;    //获取报警控制

const
  NET_DVR_GET_AUDIO_INPUT = 3201;    //获取音频输入参数
  NET_DVR_SET_AUDIO_INPUT = 3202;    //设置音频输入参数
  NET_DVR_GET_CAMERA_DEHAZE_CFG = 3203;    //获取透雾参数配置
  NET_DVR_SET_CAMERA_DEHAZE_CFG = 3204;    //设置透雾参数配置
  NET_DVR_REMOTECONTROL_ALARM = 3205;    //远程控制遥控器布防
  NET_DVR_REMOTECONTROL_DISALARM = 3206;    //远程控制遥控器撤防
  NET_DVR_REMOTECONTROL_STUDY = 3207;    //远程控制遥控器学习
  NET_DVR_WIRELESS_ALARM_STUDY = 3208;    //远程控制无线报警学习
  NET_IPC_GET_AUX_ALARMCFG = 3209;    //获取辅助报警参数配置
  NET_IPC_SET_AUX_ALARMCFG = 3210;    //设置辅助报警参数配置
  NET_DVR_GET_PREVIEW_DISPLAYCFG = 3211;    //获取预览显示参数
  NET_DVR_SET_PREVIEW_DISPLAYCFG = 3212;    //设置预览显示参数
  NET_DVR_REMOTECONTROL_PTZ = 3213;    //远程控制PTZ
  NET_DVR_REMOTECONTROL_PRESETPOINT = 3214;    //远程控制预置点
  NET_DVR_REMOTECONTROL_CRUISE = 3215;    //远程控制巡航

const
  NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG = 3216;    //远程获取多码流压缩参数
  NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG = 3217;    //远程设置多码流压缩参数

const
  NET_DVR_GET_WPSCFG = 3218;    //获取WPS参数
  NET_DVR_SET_WPSCFG = 3219;    //设置WPS参数
  NET_DVR_WPS_CONNECT = 3220;    //远程启用WPS连接
  NET_DVR_GET_DEVICE_PIN = 3221;    //获取设备PIN码
  NET_DVR_UPDATE_PIN = 3223;    //更新设备PIN码
  NET_DVR_GET_PRESETCFG = 3224;    //获取预置点参数
  NET_DVR_GET_PTZCRUISECFG = 3225;    //获取巡航路径参数
  NET_DVR_GET_PRESET_NUM = 3226;    //获取预置点个数
  NET_DVR_GET_PTZCRUISE_NUM = 3227;    //获取巡航路径个数

const
  NET_DVR_GET_MOTION_TRACK_CFG = 3228;    //获取运动参数
  NET_DVR_SET_MOTION_TRACK_CFG = 3229;    //设置运动参数
  NET_DVR_CLEAR_IPC_PARAM = 3230;    //清空前端参数
  NET_DVR_GET_IPADDR_FILTERCFG = 3232;    //获取IP地址过滤参数
  NET_DVR_SET_IPADDR_FILTERCFG = 3233;    //设置IP地址过滤参数

const
  NET_DVR_GET_LOGO_OVERLAYCFG = 3234;    //获取LOGO图片叠加参数
  NET_DVR_SET_LOGO_OVERLAYCFG = 3235;    //设置LOGO图片叠加参数

const
  NET_DVR_GET_IPV6_LIST = 3236;    //获取网卡的全部IPV6地址信息
  NET_DVR_GET_AUDIOOUT_VOLUME = 3237;    //获取输出音频大小
  NET_DVR_SET_AUDIOOUT_VOLUME = 3238;    //设置输出音频大小
  NET_DVR_GET_FUZZY_UPGRADE = 3239;    //获取模糊升级匹配信息

const
  NET_DVR_GET_BV_CORRECT_PARAM = 3240;    //获取相机校正参数
  NET_DVR_SET_BV_CORRECT_PARAM = 3241;    //设置相机校正参数
  NET_DVR_GET_OUTPUT_VIDEO_TYPE = 3242;    //获取输出视频类型
  NET_DVR_SET_OUTPUT_VIDEO_TYPE = 3243;    //设置输出视频类型

const
  NET_DVR_FISHEYE_CFG = 3244;    //鱼眼长连接配置
  NET_DVR_GET_PTZ_POINT = 3245;    //获取PTZ点坐标
  NET_DVR_SET_PTZ_POINT = 3246;    //设置PTZ点坐标
  NET_DVR_REMOTECONTROL_DEV_PARAM = 3247;    //设置设备登录客户端参数
  NET_DVR_GET_FISHEYE_STREAM_STATUS = 3248;    //获取鱼眼码流状态

const
  NET_DVR_GET_GBT28181_ACCESS_CFG = 3249;    //获取GBT28181协议接入配置
  NET_DVR_SET_GBT28181_ACCESS_CFG = 3250;    //设置GBT28181协议接入配置
  NET_DVR_GET_GBT28181_CHANINFO_CFG = 3251;    //获取GBT28181协议接入设备的通道信息
  NET_DVR_SET_GBT28181_CHANINFO_CFG = 3252;    //设置GBT28181协议接入设备的通道信息
  NET_DVR_GET_GBT28181_ALARMINCFG = 3253;    //获取GBT28181协议接入设备的报警信息
  NET_DVR_SET_GBT28181_ALARMINCFG = 3254;    //设置GBT28181协议接入设备的报警信息
  NET_DVR_GET_ISP_CAMERAPARAMCFG = 3255;    //获取ISP前端参数配置
  NET_DVR_SET_ISP_CAMERAPARAMCFG = 3256;    //设置ISP前端参数配置
  NET_DVR_GET_DEVSERVER_CFG = 3257;    //获取模块服务配置
  NET_DVR_SET_DEVSERVER_CFG = 3258;    //设置模块服务配置

//2013-11-25
const
  NET_DVR_GET_WIPERINFO_CFG = 3259;    //雨刷配置获取
  NET_DVR_SET_WIPERINFO_CFG = 3260;    //雨刷配置设置
  NET_DVR_GET_TRACK_DEV_PARAM = 3261;    //获取设备参数
  NET_DVR_SET_TRACK_DEV_PARAM = 3262;    //设置设备参数
  NET_DVR_GET_PTZ_TRACK_PARAM = 3263;    //获取PTZ参数
  NET_DVR_SET_PTZ_TRACK_PARAM = 3264;    //设置PTZ参数
  NET_DVR_GET_CENTER_POINT_CFG = 3265;    //获取中心点参数
  NET_DVR_SET_CENTER_POINT_CFG = 3266;    //设置中心点参数
  NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES = 3267;    //获取中心点参数能力
  NET_DVR_GET_FISHEYE_CAPABILITIES = 3268;    //获取鱼眼能力

const
  NET_DVR_GET_BASICPARAMCFG = 3270;    //获取PTZ配置基本参数信息
  NET_DVR_SET_BASICPARAMCFG = 3271;    //设置PTZ配置基本参数信息
  NET_DVR_GET_PTZOSDCFG = 3272;    //获取PTZ OSD配置参数信息
  NET_DVR_SET_PTZOSDCFG = 3273;    //设置PTZ OSD配置参数信息
  NET_DVR_GET_POWEROFFMEMCFG = 3274;    //获取掉电记忆模式参数信息
  NET_DVR_SET_POWEROFFMEMCFG = 3275;    //设置掉电记忆模式参数信息
  NET_DVR_GET_LIMITCFG = 3276;    //获取限位参数配置信息
  NET_DVR_SET_LIMITCFG = 3277;    //设置限位参数配置信息
  NET_DVR_PTZLIMIT_CTRL = 3278;    //清除限位参数控制

const
  NET_DVR_PTZ_CLEARCTRL = 3279;    //清除配置信息控制接口
  NET_DVR_GET_PRIORITIZECFG = 3281;    //获取云台优先配置信息
  NET_DVR_SET_PRIORITIZECFG = 3282;    //设置云台优先配置信息
  NET_DVR_PTZ_INITIALPOSITIONCTRL = 3283;    //零方位角控制
  NET_DVR_GET_PRIVACY_MASKSCFG = 3285;    //获取隐私遮蔽参数
  NET_DVR_SET_PRIVACY_MASKSCFG = 3286;    //设置隐私遮蔽参数
  NET_DVR_GET_PTZLOCKCFG = 3287;    //获取云台锁定信息
  NET_DVR_SET_PTZLOCKCFG = 3288;    //设置云台锁定信息
  NET_DVR_PTZ_ZOOMRATIOCTRL = 3289;    //设置倍率
  NET_DVR_GET_PTZLOCKINFO = 3290;    //获取云台锁定剩余秒数
  NET_DVR_GET_PRIVACY_MASKS_ENABLECFG = 3291;    //获取全局使能
  NET_DVR_SET_PRIVACY_MASKS_ENABLECFG = 3292;    //设置全局使能
  NET_DVR_GET_SMARTTRACKCFG = 3293;    //获取智能运动配置信息
  NET_DVR_SET_SMARTTRACKCFG = 3294;    //设置智能运动配置信息
  NET_DVR_GET_EPTZ_CFG = 3295;    //获取EPTZ参数
  NET_DVR_SET_EPTZ_CFG = 3296;    //设置EPTZ参数
  NET_DVR_GET_EPTZ_CFG_CAPABILITIES = 3297;    //获取EPTZ参数能力

const
  NET_DVR_GET_LOW_LIGHTCFG = 3303;    //获取快球低照度设置信息
  NET_DVR_SET_LOW_LIGHTCFG = 3304;    //设置快球低照度设置信息
  NET_DVR_GET_FOCUSMODECFG = 3305;    //获取快球聚焦模式信息
  NET_DVR_SET_FOCUSMODECFG = 3306;    //设置快球聚焦模式信息
  NET_DVR_GET_INFRARECFG = 3307;    //获取快球红外设置信息
  NET_DVR_SET_INFRARECFG = 3308;    //设置快球红外设置信息
  NET_DVR_GET_AEMODECFG = 3309;    //获取快球其他设置信息
  NET_DVR_SET_AEMODECFG = 3310;    //设置快球其他设置信息
  NET_DVR_CONTROL_RESTORE_SUPPORT = 3311;    //恢复前端默认参数(参数能力中有的前端参数配置相关的都恢复)
  NET_DVR_CONTROL_RESTART_SUPPORT = 3312;    //快球机芯重启
  NET_DVR_CONTROL_PTZ_PATTERN = 3313;    //云台花样扫描
  NET_DVR_GET_PTZ_PARKACTION_CFG = 3314;    //获取云台守望参数
  NET_DVR_SET_PTZ_PARKACTION_CFG = 3315;    //设置云台守望参数
  NET_DVR_CONTROL_PTZ_MANUALTRACE = 3316;    //手动定位
  NET_DVR_GET_ROI_DETECT_NUM = 3349;    //获取ROI检测区域编号数目
  NET_DVR_GET_ROI_DETECT = 3350;    //获取ROI检测区域配置
  NET_DVR_SET_ROI_DETECT = 3351;    //设置ROI检测区域配置
  NET_DVR_GET_FACE_DETECT = 3352;    //获取人脸侦测配置
  NET_DVR_SET_FACE_DETECT = 3353;    //设置人脸侦测配置
  NET_DVR_GET_CORRIDOR_MODE = 3354;    //获取走廊模式功能配置
  NET_DVR_SET_CORRIDOR_MODE = 3355;    //设置走廊模式功能配置
  NET_DVR_GET_SCENECHANGE_DETECTIONCFG = 3356;    //获取场景变更报警配置
  NET_DVR_SET_SCENECHANGE_DETECTIONCFG = 3357;    //设置场景变更报警配置
  NET_DVR_GET_TRAVERSE_PLANE_DETECTION = 3360;    
  NET_DVR_SET_TRAVERSE_PLANE_DETECTION = 3361;    
  NET_DVR_GET_FIELD_DETECTION = 3362;    //获取区域侦测配置
  NET_DVR_SET_FIELD_DETECTION = 3363;    //设置区域侦测配置
  NET_DVR_GET_DEFOCUSPARAM = 3364;    //获取虚焦侦测参数配置
  NET_DVR_SET_DEFOCUSPARAM = 3365;    //设置虚焦侦测参数配置
  NET_DVR_GET_AUDIOEXCEPTIONPARAM = 3366;    //获取音频异常配置
  NET_DVR_SET_AUDIOEXCEPTIONPARAM = 3367;    //设置音频异常配置
  NET_DVR_GET_CCDPARAMCFG_EX = 3368;    //获取CCD参数配置
  NET_DVR_SET_CCDPARAMCFG_EX = 3369;    //设置CCD参数配置
  NET_DVR_START_GET_INPUTVOLUME = 3370;    //开始获取音量
  NET_DVR_SET_SCH_TASK = 3380;    //设置球机定时任务
  NET_DVR_GET_SCH_TASK = 3381;    //获取球机定时任务
  NET_DVR_SET_PRESET_NAME = 3382;    //设置预置点名称
  NET_DVR_GET_PRESET_NAME = 3383;    //获取预置点名称
  NET_DVR_SET_AUDIO_NAME = 3384;    //设置语音名称
  NET_DVR_GET_AUDIO_NAME = 3385;    //获取语音名称
  NET_DVR_RESUME_INITRACKPOS = 3386;    //恢复初始位
  NET_DVR_NTP_SERVER_TEST = 3387;    //NTP服务器测试
  NET_DVR_NAS_SERVER_TEST = 3388;    //NAS服务器测试
  NET_DVR_EMAIL_SERVER_TEST = 3389;    //Email服务器测试
  NET_DVR_FTP_SERVER_TEST = 3390;    //FTP服务器测试
  NET_DVR_IP_TEST = 3391;    //IP测试
  NET_DVR_GET_NET_DISKCFG_V40 = 3392;    //网络硬盘接入获取v40
  NET_DVR_SET_NET_DISKCFG_V40 = 3393;    //网络硬盘接入设置v40
  NET_DVR_GET_IOOUT_CFG = 3394;    //获取补光灯参数
  NET_DVR_SET_IOOUT_CFG = 3395;    //设置补光灯参数
  NET_DVR_GET_SIGNAL_SYNC = 3396;    //获取信号灯同步配置参数
  NET_DVR_SET_SIGNAL_SYNC = 3397;    //设置信号灯同步配置参数

const
  NET_DVR_GET_EZVIZ_ACCESS_CFG = 3398;    //获取EZVIZ接入参数
  NET_DVR_SET_EZVIZ_ACCESS_CFG = 3399;    //设置EZVIZ接入参数
  NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG = 3400;    //获取定时智能参数
  NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG = 3401;    //设置定时智能参数
  NET_DVR_MAKE_I_FRAME = 3402;    //强制I帧
  NET_DVR_GET_ALARM_RELATE = 3403;    //获取报警联动通道功能参数
  NET_DVR_SET_ALARM_RELATE = 3404;    //设置报警联动通道功能参数
  NET_DVR_GET_PDC_RULECFG_V42 = 3405;    //设置人流量统计规则(扩展)
  NET_DVR_SET_PDC_RULECFG_V42 = 3406;    //获取人流量统计规则(扩展)
  NET_DVR_GET_HEATMAP_CFG = 3407;    //设置热度图参数配置
  NET_DVR_SET_HEATMAP_CFG = 3408;    //获取热度图参数配置
  NET_DVR_REMOTECONTROL_LINEARSCAN = 3409;    //设置左右边界参数 2014-03-15
  NET_DVR_DPC_CTRL = 3410;    //坏点校正控制
  NET_DVR_FFC_MANUAL_CTRL = 3411;    //非均匀性校正(FFC)手动模式
  NET_DVR_FFC_BACKCOMP_CTRL = 3412;    //非均匀性校正(FFC)背景补偿
  NET_DVR_GET_FOCUSING_POSITION_STATE = 3413;    //获取聚焦到位状态参数
  NET_DVR_GET_PRIVATE_PROTOCOL_CFG = 3414;    //获取 私有关键信息上传配置接口配置
  NET_DVR_SET_PRIVATE_PROTOCOL_CFG = 3415;    //设置 私有关键信息上传配置接口配置
  NET_DVR_COMPLETE_RESTORE_CTRL = 3420;    //设置完全恢复出厂值

const
  NET_DVR_CLOUDSTORAGE_SERVER_TEST = 3421;    //云存储服务器测试
  NET_DVR_PHONE_NUM_TEST = 3422;    //电话号码测试
  NET_DVR_GET_REMOTECONTROL_STATUS = 3423;    //获取无线布防状态
  NET_DVR_GET_MONITOR_LOCATION_INFO = 3424;    //获取显示点信息
  NET_DVR_SET_MONITOR_LOCATION_INFO = 3425;    //设置显示点信息


const
  NET_DVR_GET_SMART_CAPABILITIES = 3500;    //获取Smart能力
  NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES = 3501;    //获取事件触发能力
  NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES = 3502;    //获取进入区域侦测能力
  NET_DVR_GET_REGION_ENTR_DETECTION = 3503;    //获取进入区域配置
  NET_DVR_SET_REGION_ENTR_DETECTION = 3504;    //设置进入区域配置
  NET_DVR_GET_REGION_ENTR_REGION = 3505;    //获取进入区域的单个区域配置
  NET_DVR_SET_REGION_ENTR_REGION = 3506;    //设置进入区域的单个区域配置
  NET_DVR_GET_REGION_ENTR_TRIGGER = 3507;    //获取进入区域联动配置
  NET_DVR_SET_REGION_ENTR_TRIGGER = 3508;    //设置进入区域联动配置
  NET_DVR_GET_REGION_ENTR_SCHEDULE = 3509;    //获取进入区域布防时间配置
  NET_DVR_SET_REGION_ENTR_SCHEDULE = 3510;    //设置进入区域布防时间配置
  NET_DVR_GET_REGION_EXITINT_CAPABILITIES = 3511;    //获取离开区域侦测能力
  NET_DVR_GET_REGION_EXITING_DETECTION = 3512;    //获取离开区域配置
  NET_DVR_SET_REGION_EXITING_DETECTION = 3513;    //设置离开区域配置
  NET_DVR_GET_REGION_EXITING_REGION = 3514;    //获取离开区域的单个区域配置
  NET_DVR_SET_REGION_EXITING_REGION = 3515;    //设置离开区域的单个区域配置
  NET_DVR_GET_REGION_EXIT_TRIGGER = 3516;    //获取离开区域联动配置
  NET_DVR_SET_REGION_EXIT_TRIGGER = 3517;    //设置离开区域联动配置
  NET_DVR_GET_REGION_EXIT_SCHEDULE = 3518;    //获取离开区域布防时间配置
  NET_DVR_SET_REGION_EXIT_SCHEDULE = 3519;    //设置离开区域布防时间配置
  NET_DVR_GET_LOITERING_CAPABILITIES = 3520;    //获取徘徊侦测能力
  NET_DVR_GET_LOITERING_DETECTION = 3521;    //获取徘徊侦测配置
  NET_DVR_SET_LOITERING_DETECTION = 3522;    //设置徘徊侦测配置
  NET_DVR_GET_LOITERING_REGION = 3523;    //获取徘徊的单个区域配置
  NET_DVR_SET_LOITERING_REGION = 3524;    //设置徘徊的单个区域配置
  NET_DVR_GET_LOITERING_TRIGGER = 3525;    //获取徘徊联动配置
  NET_DVR_SET_LOITERING_TRIGGER = 3526;    //设置徘徊联动配置
  NET_DVR_GET_LOITERING_SCHEDULE = 3527;    //获取徘徊布防时间配置
  NET_DVR_SET_LOITERING_SCHEDULE = 3528;    //设置徘徊布防时间配置
  NET_DVR_GET_GROUPDETECTION_CAPABILITIES = 3529;    //获取人员聚集侦测能力
  NET_DVR_GET_GROUP_DETECTION = 3530;    //获取人员聚集侦测配置
  NET_DVR_SET_GROUP_DETECTION = 3531;    //设置人员聚集侦测配置
  NET_DVR_GET_GROUPDETECTION_REGION = 3532;    //获取人员聚集的单个区域配置
  NET_DVR_SET_GROUPDETECTION_REGION = 3533;    //设置人员聚集的单个区域配置
  NET_DVR_GET_GROUPDETECTION_TRIGGER = 3534;    //获取人员聚集联动配置
  NET_DVR_SET_GROUPDETECTION_TRIGGER = 3535;    //设置人员聚集联动配置
  NET_DVR_GET_GROUPDETECTION_SCHEDULE = 3536;    //获取人员聚集布防时间配置
  NET_DVR_SET_GROUPDETECTION_SCHEDULE = 3537;    //设置人员聚集布防时间配置
  NET_DVR_GET_RAPIDMOVE_CAPABILITIES = 3538;    //获取快速运动侦测能力
  NET_DVR_GET_RAPIDMOVE_DETECTION = 3539;    //获取快速运动侦测配置
  NET_DVR_SET_RAPIDMOVE_DETECTION = 3540;    //设置快速运动侦测配置
  NET_DVR_GET_RAPIDMOVE_REGION = 3541;    //获取快速运动的单个区域配置
  NET_DVR_SET_RAPIDMOVE_REGION = 3542;    //设置快速运动的单个区域配置
  NET_DVR_GET_RAPIDMOVE_TRIGGER = 3543;    //获取快速运动联动配置
  NET_DVR_SET_RAPIDMOVE_TRIGGER = 3544;    //设置快速运动联动配置
  NET_DVR_GET_RAPIDMOVE_SCHEDULE = 3545;    //获取快速运动的布防时间配置
  NET_DVR_SET_RAPIDMOVE_SCHEDULE = 3546;    //设置快速运动的布防时间配置
  NET_DVR_GET_PATKING_CAPABILITIES = 3547;    //获取停车侦测能力
  NET_DVR_GET_PARKING_DETECTION = 3548;    //获取停车侦测配置
  NET_DVR_SET_PARKING_DETECTION = 3549;    //设置停车侦测配置
  NET_DVR_GET_PARKING_REGION = 3550;    //获取停车侦测的单个区域配置
  NET_DVR_SET_PARKING_REGION = 3551;    //设置停车侦测的单个区域配置
  NET_DVR_GET_PARKING_TRIGGER = 3552;    //获取停车侦测联动配置
  NET_DVR_SET_PARKING_TRIGGER = 3553;    //设置停车侦测联动配置
  NET_DVR_GET_PARKING_SCHEDULE = 3554;    //获取停车侦测的布防时间配置
  NET_DVR_SET_PARKING_SCHEDULE = 3555;    //设置停车侦测的布防时间配置
  NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES = 3556;    //获取物品遗留侦测能力
  NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION = 3557;    //获取物品遗留侦测配置
  NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION = 3558;    //设置物品遗留侦测配置
  NET_DVR_GET_UNATTENDED_BAGGAGE_REGION = 3559;    //获取物品遗留侦测的单个区域配置
  NET_DVR_SET_UNATTENDED_BAGGAGE_REGION = 3560;    //设置物品遗留侦测的单个区域配置
  NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER = 3561;    //获取物品遗留侦测联动配置
  NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER = 3562;    //设置物品遗留侦测联动配置
  NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE = 3563;    //获取物品遗留侦测的布防时间配置
  NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE = 3564;    //设置物品遗留侦测的布防时间配置
  NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES = 3565;    //获取物品拿取侦测能力
  NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION = 3566;    //获取物品拿取侦测配置
  NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION = 3567;    //设置物品拿取侦测配置
  NET_DVR_GET_ATTENDEDBAGGAGE_REGION = 3568;    //获取物品拿取侦测的单个区域配置
  NET_DVR_SET_ATTENDEDBAGGAGE_REGION = 3569;    //设置物品拿取侦测的单个区域配置
  NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER = 3570;    //获取物品拿取侦测联动配置
  NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER = 3571;    //设置物品拿取侦测联动配置
  NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE = 3572;    //获取物品遗留侦测的布防时间配置
  NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE = 3573;    //设置物品拿取侦测的布防时间配置
  NET_DVR_GET_REGIONCLIP_CAPABILITIES = 3574;    //获取区域裁剪能力
  NET_DVR_GET_REGION_CLIP = 3575;    //获取区域裁剪配置
  NET_DVR_SET_REGION_CLIP = 3576;    //设置区域裁剪配置
  NET_DVR_GET_NETWORK_CAPABILITIES = 3577;    //获取网络能力
  NET_DVR_GET_WIRELESS_DIAL = 3578;    //获取无线参数配置
  NET_DVR_SET_WIRELESS_DIAL = 3579;    //设置无线参数配置
  NET_DVR_GET_WIRELESSDIAL_CAPABILITIES = 3580;    //获取无线拨号参数能力
  NET_DVR_GET_WIRELESSDIAL_SCHEDULE = 3581;    //获取拨号计划配置
  NET_DVR_SET_WIRELESSDIAL_SCHEDULE = 3582;    //设置拨号计划配置
  NET_DVR_GET_WIRELESSDIAL_STATUS = 3583;    //获取拨号状态
  NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES = 3584;    //获取进入区域侦测布防时间能力
  NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES = 3585;    //获取离开区域侦测布防时间能力
  NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES = 3586;    //获取徘徊侦测布防时间能力
  NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES = 3587;    //获取人员聚集侦测布防时间能力
  NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES = 3588;    //获取快速运动侦测布防时间能力
  NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES = 3589;    //获取停车侦测布防时间能力
  NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES = 3590;    //获取物品遗留侦测布防时间能力
  NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES = 3591;    //获取物品拿取侦测布防时间能力
  NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES = 3592;    //获取拨号计划能力
  NET_DVR_WIRELESSDIAL_CONNECT = 3593;    //控制无线网络连网断网

const
  NET_DVR_GET_LITESTORAGE = 3594;    //获取轻存储配置
  NET_DVR_SET_LITESTORAGE = 3595;    //设置轻存储配置
  NET_DVR_GET_LITESTORAGE_CAPABILITIES = 3596;    //获取轻存储能力

const
  NET_DVR_GET_VEHICLE_CAPABILITIES = 3597;    //获取车俩检测标定能力
  NET_DVR_GET_VEHICLE_CALIBRATION = 3598;    //获取车辆检测标定

const
  NET_DVR_GET_SLAVECAMERA_CAPABILITIES = 3599;    //获取从摄像机IP信息配置能力
  NET_DVR_GET_SLAVECAMERA = 3600;    //获取从摄像机IP信息配置
  NET_DVR_SET_SLAVECAMERA = 3601;    //设置从摄像机IP信息配置
  NET_DVR_GET_SLAVECAMERA_STATUS = 3602;    //获取从摄像机连接状态
  NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES = 3603;    //获取从摄像机配置&&标定能力
  NET_DVR_GET_SLAVECAMERA_CALIB = 3604;    //获取从摄像机标定配置
  NET_DVR_SET_SLAVECAMERA_CALIB = 3605;    //设置从摄像机标定配置
  NET_DVR_GET_PHY_RATIO = 3606;    //获取物理倍率坐标信息
  NET_DVR_SET_PHY_RATIO = 3607;    //设置物理倍率坐标信息
  NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES = 3608;    //获取主从能力
  NET_DVR_SET_TRACKINGRATIO = 3610;    //设置从摄像机倍率
  NET_DVR_GET_TRACKING = 3611;    //获取主从功能相机配置
  NET_DVR_SET_TRACKING = 3612;    //设置主从功能相机配置
  NET_DVR_GET_TRACKING_CAPABILITIES = 3613;    //获取主从功能相机配置能力

const
  NET_DVR_GET_SLAVECAMERA_CALIB_V50 = 3614;    //获取从摄像机标定配置V50
  NET_DVR_SET_SLAVECAMERA_CALIB_V50 = 3615;    //设置从摄像机标定配置V50
  NET_DVR_SET_TRACKINGRATIO_MANUAL = 3616;    //设置从摄像机手动倍率
  NET_DVR_GET_TRACKINGRATIO_MANUAL = 3617;    //获取从摄像机手动倍率
  NET_DVR_SET_TRACK_INITPOSTION = 3618;    //设置从摄像机初始位置
  NET_DVR_GET_PTZ_CAPABILITIES = 3619;    //获取ptz球机控制能力

const
  NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES = 3620;    //获取测温配置能力
  NET_DVR_GET_THERMOMETRY_BASICPARAM = 3621;    //获取测温配置参数
  NET_DVR_SET_THERMOMETRY_BASICPARAM = 3622;    //设置测温配置参数
  NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES = 3623;    //获取测温预置点关联配置能力
  NET_DVR_GET_THERMOMETRY_PRESETINFO = 3624;    //获取测温预置点关联配置参数
  NET_DVR_SET_THERMOMETRY_PRESETINFO = 3625;    //设置测温预置点关联配置参数
  NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES = 3626;    //获取测温报警方式配置能力
  NET_DVR_GET_THERMOMETRY_ALARMRULE = 3627;    //获取测温预置点报警规则配置参数
  NET_DVR_SET_THERMOMETRY_ALARMRULE = 3628;    //设置测温预置点报警规则配置参数
  NET_DVR_GET_REALTIME_THERMOMETRY = 3629;    //实时温度检测
  NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON = 3630;    //获取测温预置点温差规则配置参数
  NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON = 3631;    //设置测温预置点温差规则配置参数
  NET_DVR_GET_THERMOMETRY_TRIGGER = 3632;    //获取测温联动配置
  NET_DVR_SET_THERMOMETRY_TRIGGER = 3633;    //设置测温联动配置

const
  NET_DVR_GET_THERMAL_CAPABILITIES = 3634;    //获取热成像（Thermal）能力
  NET_DVR_GET_FIREDETECTION_CAPABILITIES = 3635;    //获取火点检测配置能力
  NET_DVR_GET_FIREDETECTION = 3636;    //获取火点检测参数
  NET_DVR_SET_FIREDETECTION = 3637;    //设置火点检测参数
  NET_DVR_GET_FIREDETECTION_TRIGGER = 3638;    //获取火点检测联动配置
  NET_DVR_SET_FIREDETECTION_TRIGGER = 3639;    //设置火点检测联动配置

const
  NET_DVR_GET_OIS_CAPABILITIES = 3640;    //获取光学防抖参数配置能力
  NET_DVR_GET_OIS_CFG = 3641;    //获取光学防抖配置
  NET_DVR_SET_OIS_CFG = 3642;    //设置光学防抖配置
  NET_DVR_GET_MACFILTER_CAPABILITIES = 3643;    //获取MAC地址过滤配置能力
  NET_DVR_GET_MACFILTER_CFG = 3644;    //获取MAC地址过滤配置
  NET_DVR_SET_MACFILTER_CFG = 3645;    //设置MAC地址过滤配置
  NET_DVR_GET_EAGLEFOCUS_CALCFG_CAPABILITIES = 3646;    //鹰视聚焦标定配置能力
  NET_DVR_GET_EAGLEFOCUSING_CALCFG = 3647;    //获取鹰视聚焦标定配置
  NET_DVR_SET_EAGLEFOCUSING_CALCFG = 3648;    //设置鹰视聚焦标定配置
  NET_DVR_GET_EAGLEFOCUSING_CFG_CAPABILITIES = 3649;    //获取鹰视聚焦配置能力
  NET_DVR_GET_EAGLEFOCUSING_CTRL = 3650;    //获取鹰视聚焦配置
  NET_DVR_SET_EAGLEFOCUSING_CTRL = 3651;    //设置鹰视聚焦配置

const
  NET_DVR_GET_PXOFFLINE_CAPABILITIES = 3652;    //获取停车场票箱脱机下参数配置 能力
  NET_DVR_SET_PXOFFLINE_CFG = 3653;    //设置停车场票箱脱机下参数配置信息
  NET_DVR_GET_PXOFFLINE_CFG = 3654;    //获取停车场票箱脱机下参数配置信息
  NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES = 3655;    //获取停车场出入口纸票信息下发 能力
  NET_DVR_SET_PAPERCHARGEINFO = 3656;    //设置停车场出入口纸票信息下发
  NET_DVR_GET_PARKINGSAPCE_CAPABILITIES = 3657;    //获取停车场出入口停车位信息下发 能力
  NET_DVR_SET_PARKINGSAPCE_INFO = 3658;    //设置停车场出入口停车位信息下发
  NET_DVR_GET_PXMULTICTRL_CAPABILITIES = 3659;    //获取停车场票箱从属设备多角度参数配置 能力
  NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES = 3661;    //获取停车场票箱参数配置能力
  NET_DVR_SET_CHARGE_ACCOUNTINFO = 3662;    //设置缴费金额信息
  NET_DVR_SET_PXMULTICTRL_CFG = 3663;    //设置停车场票箱从属设备多角度参数配置信息
  NET_DVR_GET_PXMULTICTRL_CFG = 3664;    //获取停车场票箱从属设备多角度参数配置信息
  NET_DVR_GET_TME_CHARGERULE = 3665;    //获取停车场出入口车卡收费规则规则
  NET_DVR_SET_TME_CHARGERULE = 3666;    //设置停车场出入口车卡收费规则规则
  NET_DVR_GET_TME_CHARGERULE_CAPABILITIES = 3667;    //获取停车场出入口 车卡收费信息配置能力
  NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES = 3668;    //获取停车场票箱参数配置能力
  NET_DVR_GET_ILLEGALCARDFILTERING_CFG = 3669;    //获取停车场票箱参数配置
  NET_DVR_SET_ILLEGALCARDFILTERING_CFG = 3670;    //设置停车场票箱参数配置
  NET_DVR_GET_LEDDISPLAY_CAPABILITIES = 3671;    //获取LED屏幕显示参数配置参数能力
  NET_DVR_SET_LEDDISPLAY_CFG = 3672;    //设置LED屏幕显示参数
  NET_DVR_GET_LEDDISPLAY_CFG = 3673;    //获取LED屏幕显示参数
  NET_DVR_GET_VOICEBROADCAST_CAPABILITIES = 3674;    //获取语音播报控制参数配置参数能力
  NET_DVR_SET_VOICEBROADCAST_CFG = 3675;    //设置语音播报控制参数
  NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES = 3676;    //获取纸票打印格式配置能力
  NET_DVR_GET_PAPERPRINTFORMAT_CFG = 3677;    //获取纸票打印格式参数配置
  NET_DVR_SET_PAPERPRINTFORMAT_CFG = 3678;    //设置纸票打印格式参数配置
  NET_DVR_GET_LOCkGATE_CAPABILITIES = 3679;    //获取智能锁闸配置能力
  NET_DVR_GET_LOCKGATE_CFG = 3680;    //获取智能锁闸参数配置
  NET_DVR_SET_LOCKGATE_CFG = 3681;    //设置智能锁闸参数配置
  NET_DVR_GET_PARKING_DATASTATE = 3682;    //获取数据同步状态
  NET_DVR_SET_PARKING_DATASTATE = 3683;    //设置数据同步状态
  NET_DVR_GET_TME_CAPABILITIES = 3684;    //获取停车场出入口设备 能力

const
  NET_DVR_GET_TMEVOICE_CAPABILITIES = 3686;    //获取语音配置信息能力
  NET_DVR_SET_TMEVOICE_CFG = 3687;    //设置语音参数配置
  NET_DVR_GET_TMEVOICE_CFG = 3688;    //获取语音参数配置
  NET_DVR_DEL_TMEVOICE_CFG = 3689;    //删除语音参数配置
  NET_DVR_GET_POSITION = 3698;    // 获取方位矫正配置参数
  NET_DVR_SET_POSITION = 3699;    // 设置方位矫正配置参数
  NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES = 3700;    //获取集中布防能力
  NET_DVR_GET_CENTRALIZEDCTRL = 3701;    //获取集中布防参数配置
  NET_DVR_SET_CENTRALIZEDCTRL = 3702;    //设置集中布防参数配置
  NET_DVR_GET_COMPASS_CAPABILITIES = 3703;    //获取电子罗盘能力
  NET_DVR_GET_VANDALPROOFALARM = 3704;    //获取防破坏报警参数配置
  NET_DVR_SET_VANDALPROOFALARM = 3705;    //设置防破坏报警参数配置
  NET_DVR_COMPASS_CALIBRATE_CTRL = 3706;    //电子罗盘矫正控制接口
  NET_DVR_COMPASS_NORTH_CTRL = 3707;    //电子罗盘指向正北控制接口
  NET_DVR_GET_AZIMUTHINFO = 3708;    //获取方位角度参数配置


const
  NET_DVR_GET_SATELLITETIME = 3709;    //获取卫星定位参数配置
  NET_DVR_SET_SATELLITETIME = 3710;    //设置卫星定位参数配置
  NET_DVR_GET_GISINFO = 3711;    //获取当前球机的GIS信息数据
  NET_DVR_GET_STREAMING_CAPABILITIES = 3712;    //获取视频流的能力
  NET_DVR_GET_REFRESHFRAME_CAPABILITIES = 3713;    //获取刷新帧的能力
  NET_DVR_STREAMING_REFRESH_FRAME = 3714;    //取流预览的强制刷新帧
  NET_DVR_FACECAPTURE_STATISTICS = 3715;    //长连接人员统计
  NET_DVR_GET_WIRELESSSERVER_CAPABILITIES = 3716;    //获取热点功能配置协议的能力
  NET_DVR_GET_WIRELESSSERVER = 3717;    //获取热点功能配置协议
  NET_DVR_SET_WIRELESSSERVER = 3718;    //设置热点功能配置协议
  NET_DVR_GET_CONNECT_LIST_CAPABILITIES = 3719;    //获取连接设备列表信息的能力
  NET_DVR_GET_THSCREEN_CAPABILITIES = 3720;    //获取温湿度配置协议的能力
  NET_DVR_GET_THSCREEN = 3721;    //获取温湿度配置协议
  NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES = 3722;    //获取外设配置协议的能力
  NET_DVR_GET_EXTERNALDEVICE = 3723;    //获取外设配置协议
  NET_DVR_SET_EXTERNALDEVICE = 3724;    //设置外设配置协议
  NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES = 3725;    //获取LED显示信息的能力
  NET_DVR_SET_LEDDISPLAYINFO = 3726;    //设置LED显示信息
  NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES = 3727;    //获取内置补光灯配置协议的能力 (球机支持，软件实现，补光灯是设计在设备内部的)
  NET_DVR_GET_SUPPLEMENTLIGHT = 3728;    //获取内置补光灯配置协议
  NET_DVR_SET_SUPPLEMENTLIGHT = 3729;    //设置内置补光灯配置协议
  NET_DVR_SET_THSCREEN = 3730;    //设置温湿度配置协议
  NET_DVR_GET_LOWPOWER_CAPABILITIES = 3731;    //获取低功耗配置协议的能力
  NET_DVR_GET_LOWPOWER = 3732;    //获取低功耗配置协议
  NET_DVR_SET_LOWPOWER = 3733;    //设置低功耗配置协议
  NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES = 3734;    //获取变倍联动配置协议的能力
  NET_DVR_GET_ZOOMLINKAGE = 3735;    //获取变倍联动配置协议
  NET_DVR_SET_ZOOMLINKAGE = 3736;    //设置变倍联动配置协议
  NET_DVR_THSCREEN_TIMING = 3737;    //温湿度
  NET_DVR_GET_OSD_BATTERY_POWER_CFG = 3741;    //获取OSD电池电量显示参数
  NET_DVR_SET_OSD_BATTERY_POWER_CFG = 3742;    //设置OSD电池电量显示参数
  NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES = 3743;    //OSD电池电量显示参数的能力
  NET_DVR_GET_VANDALPROOFALARM_TRIGGER = 3744;    //获取防破坏报警联动配置
  NET_DVR_SET_VANDALPROOFALARM_TRIGGER = 3745;    //设置防破坏报警联动配置
  NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES = 3746;    //获取全景图像的能力
  NET_DVR_GET_PANORAMAIMAGE = 3747;    //获取全景图像参数的协议
  NET_DVR_SET_PANORAMAIMAGE = 3748;    //设置全景图像参数的协议
  NET_DVR_GET_STREAMENCRYPTION = 3749;    //获取码流加密配置
  NET_DVR_SET_STREAMENCRYPTION = 3750;    //设置码流加密配置
  NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES = 3751;    //获取码流加密能力
  NET_DVR_GET_REVISE_GPS_CAPABILITIES = 3752;    //获取校准GPS经纬度能力
  NET_DVR_GET_REVISE_GPS = 3753;    //获取校准GPS经纬度能力
  NET_DVR_SET_REVISE_GPS = 3754;    //设置校准GPS经纬度能力
  NET_DVR_GET_PDC_RECOMMEND = 3755;    //获取客流统计表示推荐值
  NET_DVR_REMOVE_FLASHSTORAGE = 3756;    //客流数据清除操作
  NET_DVR_GET_COUNTING_CAPABILITIES = 3757;    //获取客流量统计能力
  NET_DVR_SET_SENSOR_ADJUSTMENT = 3758;    //设置Sensor 调节参数的协议
  NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES = 3759;    //获取Sensor 调节参数的协议的能力
  NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG = 3760;    //获取wifi热点参数配置(完整版)
  NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG = 3761;    //设置wifi热点参数配置(完整版)
  NET_DVR_GET_ONLINEUSER_INFO = 3762;    //长连接获取用户在线信息
  NET_DVR_GET_SENSOR_ADJUSTMENT_INFO = 3763;    //获取指定sensor调节参数
  NET_DVR_SENSOR_RESET_CTRL = 3764;    //Sensor 调节复位

const
  NET_DVR_GET_POSTRADAR_CAPABILITIES = 3765;    //获取雷达测速配置能力
  NET_DVR_GET_POSTRADARSPEED_CFG = 3766;    //获取雷达测速配置
  NET_DVR_SET_POSTRADARSPEED_CFG = 3767;    //设置雷达测速配置
  NET_DVR_GET_POSTRADARSPEED_RECOM_CFG = 3768;    //获取雷达测速推荐值
  NET_DVR_GET_POSTRADARPARAM_CFG = 3769;    //获取雷达参数配置
  NET_DVR_SET_POSTRADARPARAM_CFG = 3770;    //设置雷达参数配置
  NET_DVR_GET_POSTRADARPARAM_RECOM_CFG = 3771;    //获取雷达参数推荐值

const
  NET_DVR_GET_ENCRYPT_DEVICE_INFO = 3772;    //获取加密设备信息
  NET_DVR_GET_ANR_ARMING_HOST = 3773;    //获取断网续传的主机信息
  NET_DVR_GET_FIRMWARE_VERSION = 3776;    //GET firmware version
//*******************************IPC基线FF车牌***************************
const
  NET_DVR_GET_FTP_CAPABILITIES = 3782;    //获取ftp能力
  NET_DVR_GET_FTPUPLOAD_CFG = 3783;    //获取ftp上传信息规整参数
  NET_DVR_SET_FTPUPLOAD_CFG = 3784;    //设置ftp上传信息规整参数
  NET_DVR_GET_VEHICLE_INFORMATION = 3785;    //获取车辆信息
  NET_DVR_GET_DDNS_COUNTRY_ABILITY = 3800;    //获取设备支持的DDNS国家能力列表
  NET_DVR_GET_DEVICECFG_V50 = 3801;    //获取设备参数
  NET_DVR_SET_DEVICECFG_V50 = 3802;    //设置设备参数
  NET_DVR_SET_VEHICLE_RECOG_TASK_V50 = 3851;    //车辆二次识别任务提交V50扩展
  NET_DVR_GET_SMARTCALIBRATION_CAPABILITIES = 3900;    // Smart行为标定过滤尺寸功能能力
  NET_DVR_GET_TEMPERATURE_TRIGGER = 3903;    //获取测温差联动配置
  NET_DVR_SET_TEMPERATURE_TRIGGER = 3904;    //设置测温差联动配置

const
  NET_DVR_GET_SMARTCALIBRATION_CFG = 3910;    //获取Smart行为标定过滤尺寸功能
  NET_DVR_SET_SMARTCALIBRATION_CFG = 3911;    //设置Smart行为标定过滤尺寸功能
  NET_DVR_POST_SETUP_CALIB = 3912;    //架设标定
  NET_DVR_SET_POS_INFO_OVERLAY = 3913;    //设置Pos信息码流叠加控制
  NET_DVR_GET_POS_INFO_OVERLAY = 3914;    //获取Pos信息码流叠加控制
  NET_DVR_GET_CAMERA_WORK_MODE = 3915;    //设置相机工作模式参数
  NET_DVR_SET_CAMERA_WORK_MODE = 3916;    //获取相机工作模式参数
  NET_DVR_GET_RESOLUTION_SWITCH_CAPABILITIES = 3917;    //获取分辨率模式切换能力
  NET_DVR_GET_RESOLUTION_SWITCH = 3918;    //获取分辨率模式切换配置
  NET_DVR_SET_RESOLUTION_SWITCH = 3919;    //设置分辨率模式切换配置
  NET_DVR_GET_CONFIRM_MECHANISM_CAPABILITIES = 3920;    //报警上传确认机制控制能力
  NET_DVR_CONFIRM_MECHANISM_CTRL = 3921;    //报警上传确认机制控制
  NET_DVR_GET_VEHICLLE_RESULT_CAPABILITIES = 3951;    //获取获取车辆信息结果能力
  NET_DVR_GET_CALIB_CAPABILITIES = 3952;    //获取架设标定能力
  NET_DVR_GET_POSINFO_OVERLAY_CAPABILITIES = 3953;    //获取获取Pos叠加能力
  NET_SDK_FINDMEDICALFILE = 3954;    //慧影科技智慧医疗查找录像文件
  NET_SDK_FINDMEDICALPICTURE = 3955;    //慧影科技智慧医疗查找图片文件
  NET_DVR_SET_POSINFO_OVERLAY = 3960;    //设置Pos叠加
  NET_DVR_GET_POSINFO_OVERLAY = 3961;    //获取Pos叠加
  NET_DVR_GET_FACELIB_TRIGGER = 3962;    //获取人脸比对库的联动配置
  NET_DVR_SET_FACELIB_TRIGGER = 3963;    //设置人脸比对库的联动配置
  NET_DVR_GET_FACECONTRAST_TRIGGER = 3965;    //获取人脸比对联动配置
  NET_DVR_SET_FACECONTRAST_TRIGGER = 3966;    //设置人脸比对联动配置
  NET_DVR_GET_FACECONTRAST_SCHEDULE_CAPABILITIES = 3967;    //获取人脸比对布防时间能力
  NET_DVR_GET_FACECONTRAST_SCHEDULE = 3968;    //获取人脸比对布防时间配置
  NET_DVR_SET_FACECONTRAST_SCHEDULE = 3969;    //设置人脸比对布防时间配置
  NET_DVR_GET_FACELIB_SCHEDULE_CAPABILITIES = 3970;    //获取人脸比对库的布防时间能力
  NET_DVR_GET_VCA_VERSION_LIST = 3973;    //获取算法库版本
  NET_DVR_GET_SETUP_CALIB = 3974;    //获取架设标定
  NET_DVR_GET_PANORAMA_LINKAGE = 3975;    //获取联动抓图上传使能配置
  NET_DVR_SET_PANORAMA_LINKAGE = 3976;    //设置联动抓图上传使能配置
  NET_DVR_GET_FACELIB_SCHEDULE = 3977;    //获取人脸比对库的布防时间配置
  NET_DVR_SET_FACELIB_SCHEDULE = 3978;    //设置人脸比对库的布防时间配置
  NET_DVR_GET_SOFTWARE_SERVICE_CAPABILITIES = 3980;    //获取软件服务能力
  NET_DVR_GET_SOFTWARE_SERVICE = 3981;    //获取软件服务配置
  NET_DVR_SET_SOFTWARE_SERVICE = 3982;    //设置软件服务配置
  NET_DVR_GET_PREVIEW_MODE_CAPABILITIES = 3983;    //获取预览模式配置能力
  NET_DVR_SET_EAGLE_FOCUS_GOTOSCENE = 3984;    //鹰式聚焦设置摄像机转向指定的场景ID
  NET_DVR_EAGLE_FOCUS_SCENE_DEL = 3985;    //删除鹰式聚焦标定的场景
  NET_DVR_GET_SAFETY_HELMET_TRIGGER = 3986;    //获取安全帽检测联动配置
  NET_DVR_SET_SAFETY_HELMET_TRIGGER = 3987;    //设置安全帽检测联动配置
  NET_DVR_GET_SAFETY_HELMET_SCHEDULE_CAPABILITIES = 3988;    //获取安全帽检测布防时间能力
  NET_DVR_GET_SAFETY_HELMET_SCHEDULE = 3989;    //获取安全帽检测布防时间配置
  NET_DVR_SET_SAFETY_HELMET_SCHEDULE = 3990;    //设置安全帽检测布防时间配置

const
  NET_DVR_GET_SIGN_ABNORMAL_TRIGGER = 4150;    //获取体征异常联动配置
  NET_DVR_SET_SIGN_ABNORMAL_TRIGGER = 4151;    //设置体征异常联动配置

const
  NET_DVR_ONE_KEY_CONFIG_SAN_V50 = 4152;    //一键配置SAN(V50)
  NET_DVR_GET_HDCFG_V50 = 4153;    //获取硬盘信息参数V50
  NET_DVR_SET_HDCFG_V50 = 4154;    //设置硬盘信息参数V50
  NET_DVR_GET_HDVOLUME_CFG = 4155;    //获取硬盘卷信息
  NET_DVR_SET_HDVOLUME_CFG = 4156;    //设置硬盘卷信息
  NET_DVR_GET_POWER_SUPPLY_CABINET_TRIGGER = 4157;    //获取机柜供电检测的联动配置
  NET_DVR_SET_POWER_SUPPLY_CABINET_TRIGGER = 4158;    //设置机柜供电检测的联动配置
  NET_DVR_GET_SENSOR_TRIGGER = 4159;    //获取传感器检测的联动配置
  NET_DVR_SET_SENSOR_TRIGGER = 4160;    //设置传感器检测的联动配置
  NET_DVR_GET_FACESNAP_TRIGGER = 4161;    //获取人脸抓拍联动配置
  NET_DVR_SET_FACESNAP_TRIGGER = 4162;    //设置人脸抓拍联动配置
  NET_DVR_GET_FACESNAP_SCHEDULE_CAPABILITIES = 4163;    //获取人脸抓拍布防时间能力
  NET_DVR_GET_FACESNAP_SCHEDULE = 4164;    //获取人脸抓拍布防时间配置
  NET_DVR_SET_FACESNAP_SCHEDULE = 4165;    //设置人脸抓拍布防时间配置

const
  NET_DVR_SET_SCREEN_SWITCH = 4171;    //画面切换控制
  NET_DVR_GET_BV_CALIB_PIC = 4172;    //获取设备抓取图片和附加信息
  NET_DVR_GET_BV_CALIB_RESULT = 4173;    //获取双目外参标定结果
  NET_DVR_GET_BV_HCORRECTION = 4174;    //获取双目高度矫正数据
  NET_DVR_DEL_BV_CALIB_PIC = 4175;    //删除样本图片
  NET_DVR_GET_TV_SCREEN_CFG = 4176;    //获取导播画面停留时间配置
  NET_DVR_SET_TV_SCREEN_CFG = 4177;    //设置导播画面停留时间配置
  NET_DVR_ADJUST_BV_CALIB = 4178;    //双目标定微调
  NET_DVR_GET_HUMAN_CALIB = 4179;    //获取人体坐标标定配置
  NET_DVR_SET_HUMAN_CALIB = 4180;    //设置人体坐标标定配置
  NET_DVR_GET_USERCFG_V51 = 4181;    //获取用户参数
  NET_DVR_SET_USERCFG_V51 = 4182;    //设置用户参数
  NET_DVR_GET_SOFTIO_TRIGGER = 4183;    //获取SoftIO联动配置
  NET_DVR_SET_SOFTIO_TRIGGER = 4184;    //设置SoftIO联动配置
  NET_DVR_GET_SOFTIO_SCHEDULE_CAPABILITIES = 4185;    //获取SoftIO布防时间能力
  NET_DVR_GET_SOFTIO_SCHEDULE = 4186;    //获取SoftIO布防时间配置
  NET_DVR_SET_SOFTIO_SCHEDULE = 4187;    //设置SoftIO布防时间配置
  NET_DVR_GET_HFPD_TRIGGER = 4188;    //获取高频人员侦测联动配置
  NET_DVR_SET_HFPD_TRIGGER = 4189;    //设置高频人员侦测联动配置
  NET_DVR_GET_HFPD_SCHEDULE_CAPABILITIES = 4190;    //获取高频人员侦测布防时间能力
  NET_DVR_GET_HFPD_SCHEDULE = 4191;    //获取高频人员侦测布防时间配置
  NET_DVR_SET_HFPD_SCHEDULE = 4192;    //设置高频人员侦测布防时间配置
  NET_DVR_GET_ALARM_INFO = 4193;    //获取报警事件信息
  NET_DVR_GET_USERCFG_V52 = 4194;    //获取用户参数
  NET_DVR_SET_USERCFG_V52 = 4195;    //设置用户参数

//*******************************NVR_后端产品线***************************
const
  NET_DVR_GET_MUTEX_FUNCTION = 4353;    //获取功能互斥信息

const
  NET_DVR_GET_SINGLE_CHANNELINFO = 4360;    //获取单个通道属性数据
  NET_DVR_GET_CHANNELINFO = 4361;    //获取通道属性数据
  NET_DVR_CHECK_LOGIN_PASSWORDCFG = 4362;    //用户登录密码校验
  NET_DVR_GET_SINGLE_SECURITY_QUESTION_CFG = 4363;    //获取单个设备安全问题
  NET_DVR_SET_SINGLE_SECURITY_QUESTION_CFG = 4364;    //设置单个设备安全问题
  NET_DVR_GET_SECURITY_QUESTION_CFG = 4365;    //获取设备安全问题
  NET_DVR_SET_SECURITY_QUESTION_CFG = 4366;    //设置设备安全问题
  NET_DVR_GET_ONLINEUSERLIST_SC = 4367;    //远程获取登陆用户信息（短连接）

const
  NET_DVR_GET_BLOCKLIST_FACECONTRAST_TRIGGER = 4368;    //获取禁止单人脸比对联动配置
  NET_DVR_SET_BLOCKLIST_FACECONTRAST_TRIGGER = 4369;    //设置禁止单人脸比对联动配置
  NET_DVR_GET_ALLOWLIST_FACECONTRAST_TRIGGER = 4370;    //获取允许名单人脸比对联动配置
  NET_DVR_SET_ALLOWLIST_FACECONTRAST_TRIGGER = 4371;    //设置允许名单人脸比对联动配置
  NET_DVR_GET_BLOCKLIST_FACECONTRAST_SCHEDULE_CAPABILITIES = 4372;    //获取禁止单人脸比对布防时间能力
  NET_DVR_GET_BLOCKLIST_FACECONTRAST_SCHEDULE = 4373;    //获取禁止单人脸比对布防时间配置
  NET_DVR_SET_BLOCKLIST_FACECONTRAST_SCHEDULE = 4374;    //设置禁止单人脸比对布防时间配置
  NET_DVR_GET_ALLOWLIST_FACECONTRAST_SCHEDULE_CAPABILITIES = 4375;    //获取允许名单人脸比对布防时间能力
  NET_DVR_GET_ALLOWLIST_FACECONTRAST_SCHEDULE = 4376;    //获取允许名单人脸比对布防时间配置
  NET_DVR_SET_ALLOWLIST_FACECONTRAST_SCHEDULE = 4377;    //设置允许名单人脸比对布防时间配置

const
  NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE_CAPABILITIES = 4378;    //获取人体识别布防时间能力
  NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE = 4379;    //获取人体识别布防时间配置
  NET_DVR_SET_HUMAN_RECOGNITION_SCHEDULE = 4380;    //设置人体识别布防时间配置
  NET_DVR_GET_HUMAN_RECOGNITION_TRIGGER = 4381;    //获取人体识别联动配置
  NET_DVR_SET_HUMAN_RECOGNITION_TRIGGER = 4382;    //设置人体识别联动配置
  NET_DVR_GET_GBT28181_AUDIO_OUTPUT_CFG = 4383;    //获取GBT28181协议接入设备的语音对讲信息
  NET_DVR_SET_GBT28181_AUDIO_OUTPUT_CFG = 4384;    //设置GBT28181协议接入设备的语音对讲信息

const
  NET_DVR_GET_STUDENTS_STOODUP_TRIGGER = 4386;    //获取学生起立检测联动配置
  NET_DVR_SET_STUDENTS_STOODUP_TRIGGER = 4387;    //设置学生起立检测联动配置
  NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE_CAPABILITIES = 4388;    //获取区域人数统计布防时间能力
  NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE = 4389;    //获取区域人数统计布防时间配置
  NET_DVR_SET_FRAMES_PEOPLE_COUNTING_SCHEDULE = 4390;    //设置区域人数统计布防时间配置
  NET_DVR_GET_FRAMES_PEOPLE_COUNTING_TRIGGER = 4391;    //获取区域人数统计联动配置
  NET_DVR_SET_FRAMES_PEOPLE_COUNTING_TRIGGER = 4392;    //设置区域人数统计联动配置

const
  NET_DVR_GET_PERSONDENSITY_TRIGGER = 4393;    //获取人员密度检测的联动配置
  NET_DVR_SET_PERSONDENSITY_TRIGGER = 4394;    //设置人员密度检测的联动配置
  NET_DVR_GET_PERSONDENSITY_SCHEDULE_CAPABILITIES = 4395;    //获取人员密度检测的布防时间能力
  NET_DVR_GET_PERSONDENSITY_SCHEDULE = 4396;    //获取人员密度检测的布防时间配置
  NET_DVR_SET_PERSONDENSITY_SCHEDULE = 4397;    //设置人员密度检测的布防时间配置

const
  NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE_CAPABILITIES = 4398;    //获取学生起立检测布防时间能力
  NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE = 4399;    //获取学生起立检测布防时间配置
  NET_DVR_SET_STUDENTS_STOODUP_SCHEDULE = 4400;    //设置学生起立检测布防时间配置

const
  NET_DVR_SET_FACE_THERMOMETRY_TRIGGER = 4401;    //设置人脸测温联动配置
  NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE_CAPABILITIES = 4402;    //获取人脸测温布防时间能力
  NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE = 4403;    //获取人脸测温布防时间配置
  NET_DVR_SET_FACE_THERMOMETRY_SCHEDULE = 4404;    //设置人脸测温布防时间配置
  NET_DVR_GET_FACE_THERMOMETRY_TRIGGER = 4405;    //获取人脸测温联动配置
  NET_DVR_GET_PERSONQUEUE_TRIGGER = 4406;    //获取人员排队检测的联动配置
  NET_DVR_SET_PERSONQUEUE_TRIGGER = 4407;    //设置人员排队检测的联动配置
  NET_DVR_GET_PERSONQUEUE_SCHEDULE_CAPABILITIES = 4408;    //获取人员排队检测的布防时间能力
  NET_DVR_GET_PERSONQUEUE_SCHEDULE = 4409;    //获取人员排队检测的布防时间配置
  NET_DVR_SET_PERSONQUEUE_SCHEDULE = 4410;    //设置人员排队检测的布防时间配置
  NET_DVR_SET_START_VIDEOAUDIO = 4411;    //设置NVR开启音视频功能(仅供设备自测功能)


//*******************************智能人脸识别***************************
const
  NET_DVR_GET_FACESNAPCFG = 5001;    //获取人脸抓拍参数
  NET_DVR_SET_FACESNAPCFG = 5002;    //设置人脸抓拍参数
  NET_DVR_GET_DEVACCESS_CFG = 5005;    //获取接入设备参数
  NET_DVR_SET_DEVACCESS_CFG = 5006;    //设置接入设备参数
  NET_DVR_GET_SAVE_PATH_CFG = 5007;    //获取存储信息参数
  NET_DVR_SET_SAVE_PATH_CFG = 5008;    //设置存储信息参数
  NET_VCA_GET_RULECFG_V41 = 5011;    //获取异常行为检测参数(扩展)
  NET_VCA_SET_RULECFG_V41 = 5012;    //设置异常行为检测参数(扩展)
  NET_DVR_GET_AID_RULECFG_V41 = 5013;    //获取交通事件规则参数
  NET_DVR_SET_AID_RULECFG_V41 = 5014;    //设置交通事件规则参数
  NET_DVR_GET_TPS_RULECFG_V41 = 5015;    //获取交通统计规则参数(扩展)
  NET_DVR_SET_TPS_RULECFG_V41 = 5016;    //设置交通统计规则参数(扩展)
  NET_VCA_GET_FACEDETECT_RULECFG_V41 = 5017;    //获取ATM人脸检测规则(扩展)
  NET_VCA_SET_FACEDETECT_RULECFG_V41 = 5018;    //设置ATM人脸检测规则(扩展)
  NET_DVR_GET_PDC_RULECFG_V41 = 5019;    //设置人流量统计规则(扩展)
  NET_DVR_SET_PDC_RULECFG_V41 = 5020;    //获取人流量统计规则(扩展)
  NET_DVR_GET_TRIAL_VERSION_CFG = 5021;    //获取试用版信息
  NET_DVR_GET_VCA_CTRLINFO_CFG = 5022;    //批量获取智能控制参数
  NET_DVR_SET_VCA_CTRLINFO_CFG = 5023;    //批量设置智能控制参数
  NET_DVR_SYN_CHANNEL_NAME = 5024;    //同步通道名
  NET_DVR_GET_RESET_COUNTER = 5025;    //获取统计数据清零参数（人流量、交通统计）
  NET_DVR_SET_RESET_COUNTER = 5026;    //设置统计数据清零参数（人流量、交通统计）
  NET_DVR_GET_OBJECT_COLOR = 5027;    //获取物体颜色属性
  NET_DVR_SET_OBJECT_COLOR = 5028;    //设置物体颜色属性
  NET_DVR_GET_AUX_AREA = 5029;    //获取辅助区域
  NET_DVR_SET_AUX_AREA = 5030;    //设置辅助区域
  NET_DVR_GET_CHAN_WORKMODE = 5031;    //获取通道工作模式
  NET_DVR_SET_CHAN_WORKMODE = 5032;    //设置通道工作模式
  NET_DVR_GET_SLAVE_CHANNEL = 5033;    //获取从通道参数
  NET_DVR_SET_SLAVE_CHANNEL = 5034;    //设置从通道参数
  NET_DVR_GET_VQD_EVENT_RULE = 5035;    //获取视频质量诊断事件规则
  NET_DVR_SET_VQD_EVENT_RULE = 5036;    //设置视频质量诊断事件规则
  NET_DVR_GET_BASELINE_SCENE = 5037;    //获取基准场景参数
  NET_DVR_SET_BASELINE_SCENE = 5038;    //设置基准场景参数
  NET_DVR_CONTROL_BASELINE_SCENE = 5039;    //基准场景操作
  NET_DVR_SET_VCA_DETION_CFG = 5040;    //设置智能移动参数配置
  NET_DVR_GET_VCA_DETION_CFG = 5041;    //获取智能移动参数配置
  NET_DVR_GET_STREAM_ATTACHINFO_CFG = 5042;    //获取码流附加信息配置
  NET_DVR_SET_STREAM_ATTACHINFO_CFG = 5043;    //设置码流附加信息配置

const
  NET_DVR_GET_BV_CALIB_TYPE = 5044;    //获取双目标定类型
  NET_DVR_CONTROL_BV_SAMPLE_CALIB = 5045;    //双目样本标定
  NET_DVR_GET_BV_SAMPLE_CALIB_CFG = 5046;    //获取双目标定参数
  NET_DVR_GET_RULECFG_V42 = 5049;    //获取异常行为检测参数(支持16条规则扩展)
  NET_DVR_SET_RULECFG_V42 = 5050;    //设置异常行为检测参数(支持16条规则扩展)
  NET_DVR_SET_VCA_DETION_CFG_V40 = 5051;    //设置智能移动参数配置
  NET_DVR_GET_VCA_DETION_CFG_V40 = 5052;    //获取智能移动参数配置
  NET_DVR_SET_FLASH_CFG = 5110;    //写入数据到Flash 测试使用
//*******************************智能人脸识别 end***************************

//2014-12-03
const
  NET_DVR_GET_T1TEST_CFG = 5053;    //产线测试配置接口（获取）
  NET_DVR_SET_T1TEST_CFG = 5054;    ////产线测试配置接口（设置）

//*******************************ITS***************************
const
  NET_ITS_GET_OVERLAP_CFG_V50 = 5055;    //获取字符叠加参数配置扩展
  NET_ITS_SET_OVERLAP_CFG_V50 = 5056;    //设置字符叠加参数配置扩展

const
  NET_DVR_GET_PARKLAMP_STATE = 5057;    //获取停车场信号灯状态信息
  NET_DVR_GET_CLOUDSTORAGE_CFG = 5058;    //获取云存储配置参数
  NET_DVR_SET_CLOUDSTORAGE_CFG = 5059;    //设置云存储配置参数

const
  NET_ITS_GET_BASE_INFO = 5060;    //获取终端基本信息
  NET_DVR_GET_SENSOR_INFO = 5061;    //传感器信息查询
  NET_DVR_SET_SENSOR_SWITCH = 5062;    //传感器远程控制
  NET_ITS_GET_IMGMERGE_CFG = 5063;    //获取图片合成配置参数
  NET_ITS_SET_IMGMERGE_CFG = 5064;    //设置图片合成配置参数
  NET_ITS_GET_UPLOAD_CFG = 5065;    //获取数据上传配置
  NET_ITS_SET_UPLOAD_CFG = 5066;    //设置数据上传配置
  NET_DVR_GET_SENSOR_PORT_CAPABILITIES = 5067;    //获取传感器能力
  NET_ITS_GET_WORKSTATE = 5069;    //获取终端工作状态
  NET_ITS_GET_IPC_CHAN_CFG = 5070;    //获取通道IPC信息
  NET_ITS_SET_IPC_CHAN_CFG = 5071;    //设置通道IPC信息
  NET_ITS_GET_OVERLAP_CFG = 5072;    //获取字符叠加参数配置
  NET_ITS_SET_OVERLAP_CFG = 5073;    //设置字符叠加参数配置
  NET_DVR_GET_TRIGGEREX_CFG = 5074;    //获取ITC扩展配置
  NET_DVR_SET_TRIGGEREX_CFG = 5075;    //设置ITC扩展配置
  NET_ITS_GET_ROAD_INFO = 5076;    //获取路口信息

const
  NET_ITS_REMOTE_DEVICE_CONTROL = 5077;    //设置远程设备控制
  NET_ITS_GET_GATEIPC_CHAN_CFG = 5078;    //获取出入口参数
  NET_ITS_SET_GATEIPC_CHAN_CFG = 5079;    //设置出入口参数
  NET_ITS_TRANSCHAN_START = 5080;    //同步数据服务器建立连接
  NET_ITS_GET_ECTWORKSTATE = 5081;    //获取出入口终端工作状态
  NET_ITS_GET_ECT_CHAN_INFO = 5082;    //获取出入口终端通道状态
  NET_DVR_GET_HEATMAP_RESULT = 5083;    //热度图数据查找
  NET_DVR_SET_ITS_EXDEVCFG = 5084;    //设置ITS外接设备信息
  NET_DVR_GET_ITS_EXDEVCFG = 5085;    //获取ITS外接设备信息
  NET_DVR_GET_ITS_EXDEVSTATUS = 5086;    //获取ITS所有外接设备信息
  NET_DVR_SET_ITS_ENDEVCMD = 5087;    //设置ITS终端出入口控制命令
  NET_DVR_SET_ENISSUED_DATADEL = 5088;    //设置ITS终端出入口控制清除
  NET_DVR_GET_PDC_RESULT = 5089;    //客流量数据查询 2014-03-21
  NET_ITS_GET_LAMP_CTRLCFG = 5090;    //获取内外置灯参数
  NET_ITS_SET_LAMP_CTRLCFG = 5091;    //设置内外置灯参数
  NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG = 5092;    //获取特殊车位参数
  NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG = 5093;    //设置特殊车位参数
  NET_ITS_SET_LAMP_EXTERNAL_CFG = 5095;    //设置外控配置参数
  NET_ITS_SET_COMPEL_CAPTURE = 5096;    //设置车位强制抓图
  NET_DVR_SET_TIMESIGN_CFG = 5097;    //设置扩展校时自定义标记
  NET_DVR_GET_TIMESIGN_CFG = 5098;    //获取扩展校时自定义标记
  NET_DVR_GET_SIGNALLAMP_STATUS = 5099;    //信号灯检测
//*******************************ITS end***************************

const
  NET_DVR_GET_MONITOR_PLAN_VQD = 5100;    //长连接获取诊断服务器计划
  NET_DVR_GET_MONITORID_VQD = 5101;    //长连接获取对应计划内的布防点信息
  NET_DVR_SET_MONITOR_INFO = 5102;    //批量设置计划内的布防点信息
  NET_DVR_DEL_MONITOR_PLAN_VQD = 5103;    //删除计划
  NET_DVR_GET_MONITOR_VQD_STATUS = 5104;    //平台查询诊断服务器的状态
  NET_DVR_GET_RECORD_INFO = 5105;    //获取资源图片查询
  NET_DVR_GET_MONITOR_VQDCFG = 5106;    //获取服务器的布防点信息
  NET_DVR_SET_MONITOR_VQDCFG = 5107;    //设置服务器的布防点信息
  NET_DVR_SET_MONITOR_PLAN_VQDCFG = 5108;    //设置管理计划(单独的计划)

const
  NET_DVR_SCENE_CHANGE_UPDATE = 5109;    //场景变更数据更新

const
  NET_DVR_GET_CALIBRATE_POINT = 5153;    //归一化坐标转换（枪球联动设备 外部交互命令码 基线代码不实现，防止冲突，提交基线）/*************************智能多场景*******************************}
  NET_DVR_GET_SCENE_CFG = 5201;    //获取场景信息
  NET_DVR_SET_SCENE_CFG = 5202;    //设置场景信息
  NET_DVR_GET_SCENE_REFERENCE_REGION = 5203;    //获取参考区域
  NET_DVR_SET_SCENE_REFERENCE_REGION = 5204;    //设置参考区域
  NET_DVR_GET_SCENE_CALIBRATION = 5205;    //获取标定信息
  NET_DVR_SET_SCENE_CALIBRATION = 5206;    //设置标定信息
  NET_DVR_GET_SCENE_MASK_REGION = 5207;    //获取屏蔽区域
  NET_DVR_SET_SCENE_MASK_REGION = 5208;    //设置屏蔽区域
  NET_DVR_GET_SCENE_LANECFG = 5209;    //获取车道规则
  NET_DVR_SET_SCENE_LANECFG = 5210;    //设置车道规则
  NET_DVR_GET_SCENE_AID_RULECFG = 5211;    //获取交通事件规则参数
  NET_DVR_SET_SCENE_AID_RULECFG = 5212;    //设置交通事件规则参数
  NET_DVR_GET_SCENE_TPS_RULECFG = 5213;    //获取交通统计规则参数
  NET_DVR_SET_SCENE_TPS_RULECFG = 5214;    //设置交通统计规则参数
  NET_DVR_GET_SCENE_TIME_CFG = 5215;    //获取通道的场景时间段配置
  NET_DVR_SET_SCENE_TIME_CFG = 5216;    //设置通道的场景时间段配置
  NET_DVR_GET_FORENSICS_MODE = 5217;    //获取取证方式参数
  NET_DVR_SET_FORENSICS_MODE = 5218;    //设置取证方式参数
  NET_DVR_FORCESTOP_FORENSICS_CTRL = 5219;    //强制停止取证
  NET_DVR_GET_ALARM_PROCESS_CFG = 5220;    //获取报警处理参数
  NET_DVR_SET_ALARM_PROCESS_CFG = 5221;    //设置报警处理参数
  NET_DVR_GET_BLOCKLIST_ALARM_INFO = 5222;    //获取名单报警
  NET_DVR_GET_STORAGE_RESOURCE_CFG = 5225;    //获取存储资源参数
  NET_DVR_SET_STORAGE_RESOURCE_CFG = 5226;    //设置存储资源参数
  NET_DVR_DEL_BLOCKLIST_ALARM_RECORD = 5227;    //远程删除名单报警记录
  NET_DVR_SET_BLOCKLIST_GROUP_INFO = 5229;    //远程分组列表参数配置
  NET_DVR_DEL_BLOCKLIST_GROUP_INFO = 5230;    //远程删除分组列表
  NET_DVR_GET_BLOCKLIST_GROUP_INFO = 5231;    //远程获取全部分组列表
  NET_DVR_SET_BLOCKLIST_GROUP_RECORD_CFG = 5232;    //分组记录参数配置
  NET_DVR_GET_BLOCKLIST_GROUP_RECORD_CFG = 5234;    //远程获取分组记录参数
  NET_DVR_DEL_BLOCKLIST_GROUP_RECORD_CFG = 5235;    //远程删除分组记录参数
  NET_DVR_GET_AREA_MONITOR_CFG = 5236;    //获取区域布防点参数
  NET_DVR_SET_AREA_MONITOR_CFG = 5237;    //设置区域布防点参数
  NET_DVR_DEL_AREA_MONITOR_CFG = 5238;    //删除区域布防点
  NET_DVR_RETRIEVAL_SNAP_RECORD = 5240;    //抓拍库检索
  NET_DVR_GET_ALARMLIST = 5241;    //获取名单报警列表
  NET_DVR_DETECT_IMAGE = 5242;    //单张图片检测
  NET_DVR_GET_SNAP_RECORD = 5243;    //获取抓拍记录
  NET_DVR_DEL_SNAP_RECORD = 5244;    //删除抓拍记录
  NET_DVR_GET_FACE_RECORD = 5245;    //远程获取人脸记录列表
  NET_DVR_SET_FACE_RECORD = 5246;    //添加人脸记录
  NET_DVR_DEL_FACE_RECORD = 5247;    //删除人脸记录
  NET_DVR_GET_FACE_DATABASE = 5248;    //获取人脸库配置参数
  NET_DVR_SET_FACE_DATABASE = 5249;    //设置人脸库配置参数
  NET_DVR_DEL_FACE_DATABASE = 5250;    //删除人脸库
  NET_DVR_RETRIEVAL_FACE_DATABASE = 5251;    //人脸库检索
  NET_DVR_SET_BLOCKLIST_REL_DEV_CFG = 5252;    //设备关联名单分组关联
  NET_DVR_DEL_BLOCKLIST_REL_DEV = 5253;    //删除 设备关联名单分组信息
//************************智能多场景end****************************

const
  NET_DVR_GET_DISK_RAID_INFO = 6001;    //获取磁盘Raid信息
  NET_DVR_SET_DISK_RAID_INFO = 6002;    //设置磁盘Raid信息

const
  NET_DVR_GET_DVR_SYNCHRONOUS_IPC = 6005;    //获取：是否为前端IPC同步设备参数
  NET_DVR_SET_DVR_SYNCHRONOUS_IPC = 6006;    //设置：是否为前端IPC同步设备参数

const
  NET_DVR_SET_DVR_IPC_PASSWD = 6008;    //设置：IPC用户名密码
  NET_DVR_GET_DEVICE_NET_USING_INFO = 6009;    //获取：当前设备网络资源使用情况

const
  NET_DVR_SET_DVR_IPC_NET = 6012;    //设置：设置前端IPC的网络地址

const
  NET_DVR_GET_RECORD_CHANNEL_INFO = 6013;    //获取：录像通道信息
  NET_DVR_SET_RECORD_CHANNEL_INFO = 6014;    //设置：录像通道信息


const
  NET_DVR_MOUNT_DISK = 6015;    // 加载磁盘
  NET_DVR_UNMOUNT_DISK = 6016;    // 卸载磁盘

// CVR
const
  NET_DVR_GET_STREAM_SRC_INFO = 6017;    //获取：流来源信息
  NET_DVR_SET_STREAM_SRC_INFO = 6018;    //设置：流来源信息
  NET_DVR_GET_STREAM_RECORD_INFO = 6019;    //获取：流录像信息
  NET_DVR_SET_STREAM_RECORD_INFO = 6020;    //设置：流录像信息
  NET_DVR_GET_STREAM_RECORD_STATUS = 6021;    //获取：流录像状态
  NET_DVR_SET_STREAM_RECORD_STATUS = 6022;    //设置：流录像状态
  NET_DVR_GET_STREAM_INFO = 6023;    //获取已添加的流ID信息
  NET_DVR_GET_STREAM_SRC_INFO_V40 = 6024;    //获取：流来源信息
  NET_DVR_SET_STREAM_SRC_INFO_V40 = 6025;    //设置：流来源信息
  NET_DVR_GET_RELOCATE_INFO = 6026;    //获取N+0模式下重定向信息
  NET_DVR_START_GOP_INFO_PASSBACK = 6032;    //智能信息回填
  NET_DVR_GET_CHANS_RECORD_STATUS_CFG = 6035;    //获取通道录像状态信息
  NET_DVR_SET_CHANS_RECORD_STATUS_CFG = 6036;    //设置通道录像状态信息
//NVR：96xx
const
  NET_DVR_GET_IP_ALARM_GROUP_NUM = 6100;    //获取：IP通道报警输入输出组数
  NET_DVR_GET_IP_ALARM_IN = 6101;    //获取：IP通道报警输入信息
  NET_DVR_GET_IP_ALARM_OUT = 6102;    //获取：IP通道报警输出信息

//9000 v2.2
const
  NET_DVR_GET_FTPCFG_SECOND = 6103;    //获取图片上传FTP参数
  NET_DVR_SET_FTPCFG_SECOND = 6104;    //设置图片上传FTP参数

const
  NET_DVR_GET_DEFAULT_VIDEO_EFFECT = 6105;    // 获取视频输入效果参数默认值
  NET_DVR_SET_VIDEO_EFFECT = 6106;    // 设置通道视频输入图像参数
  NET_DVR_DEL_INVALID_DISK = 6107;    // 删除无效磁盘

const
  NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG = 6109;    //获取抽帧通道磁盘配额
  NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG = 6110;    //设置抽帧通道磁盘配额

const
  NET_DVR_GET_NAT_CFG = 6111;    //获取NAT映射参数
  NET_DVR_SET_NAT_CFG = 6112;    //设置NAT映射参数
  NET_DVR_GET_AES_KEY = 6113;    //获取设备AES加密密钥
  NET_DVR_GET_POE_CFG = 6114;    //获取POE参数
  NET_DVR_SET_POE_CFG = 6115;    //设置POE参数
  NET_DVR_GET_CUSTOM_PRO_CFG = 6116;    //获取自定义协议参数
  NET_DVR_SET_CUSTOM_PRO_CFG = 6117;    //设置自定义协议参数
  NET_DVR_GET_STREAM_CABAC = 6118;    //获取码流压缩性能选项
  NET_DVR_SET_STREAM_CABAC = 6119;    //设置码流压缩性能选项
  NET_DVR_GET_ESATA_MINISAS_USAGE_CFG = 6120;    //获取eSATA和miniSAS用途
  NET_DVR_SET_ESATA_MINISAS_USAGE_CFG = 6121;    //设置eSATA和miniSAS用途

const
  NET_DVR_GET_HDCFG_V40 = 6122;    //获取硬盘信息参数
  NET_DVR_SET_HDCFG_V40 = 6123;    //设置硬盘信息参数
  NET_DVR_GET_POE_CHANNEL_ADD_MODE = 6124;    //获取POE通道添加方式
  NET_DVR_SET_POE_CHANNEL_ADD_MODE = 6125;    //设置POE通道添加方式
  NET_DVR_GET_DIGITAL_CHANNEL_STATE = 6126;    //获取设备数字通道状态
  NET_DVR_GET_BONJOUR_CFG = 6127;    // 获取Bonjour信息
  NET_DVR_SET_BONJOUR_CFG = 6128;    // 设置Bonjour信息


const
  NET_DVR_GET_SOCKS_CFG = 6130;    //获取SOCKS信息
  NET_DVR_SET_SOCKS_CFG = 6131;    //设置SOCKS信息

const
  NET_DVR_GET_QOS_CFG = 6132;    //获取QoS信息
  NET_DVR_SET_QOS_CFG = 6133;    //设置QoS信息

const
  NET_DVR_GET_HTTPS_CFG = 6134;    //获取HTTPS信息
  NET_DVR_SET_HTTPS_CFG = 6135;    //设置HTTPS信息

const
  NET_DVR_GET_WD1_CFG = 6136;    //远程获取WD1使能开关
  NET_DVR_SET_WD1_CFG = 6137;    //远程设置WD1使能开关

const
  NET_DVR_CREATE_CERT = 6138;    //创建证书
  NET_DVR_DELETE_CERT = 6139;    //删除证书


const
  NET_DVR_GET_RECORD_LOCK_PERCENTAGE = 6140;    //获取录像段锁定比例
  NET_DVR_SET_RECORD_LOCK_PERCENTAGE = 6141;    //设置录像段锁定比例

const
  NET_DVR_CMD_TRIGGER_PERIOD_RECORD = 6144;    //外部命令触发指定时间录像
  NET_DVR_UPLOAD_CERT = 6145;    //上传证书
  NET_DVR_DOWNLOAD_CERT = 6146;    //下载证书
  NET_DVR_GET_CERT = 6147;    //获取证书

const
  NET_DVR_GET_POS_FILTER_CFG = 6148;    //获取POS过滤规则
  NET_DVR_SET_POS_FILTER_CFG = 6149;    //设置POS过滤规则
  NET_DVR_GET_CONNECT_POS_CFG = 6150;    //获取DVR与POS连接方式
  NET_DVR_SET_CONNECT_POS_CFG = 6151;    //设置DVR与POS连接方式
  NET_DVR_GET_CHAN_FILTER_CFG = 6152;    //获取规则与通道关联信息
  NET_DVR_SET_CHAN_FILTER_CFG = 6153;    //设置规则与通道关联信息


const
  NET_DVR_GET_FTPCFG_V40 = 6162;    //获取FTP信息
  NET_DVR_SET_FTPCFG_V40 = 6163;    //设置FTP信息

const
  NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION = 6164;    //获取月历录像分布
  NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO = 6165;    //获取待接入设备通道信息
  NET_DVR_GET_PREVIEW_SWITCH_CFG = 6166;    //获取设备本地预览切换参数
  NET_DVR_SET_PREVIEW_SWITCH_CFG = 6167;    //设置设备本地预览切换参数

//Netra3.0.0
const
  NET_DVR_GET_N_PLUS_ONE_WORK_MODE = 6168;    //获取N+1工作模式
  NET_DVR_SET_N_PLUS_ONE_WORK_MODE = 6169;    //设置N+1工作模式

const
  NET_DVR_GET_HD_STATUS = 6170;    //获取硬盘状态
  NET_DVR_SET_HD_STATUS = 6171;    //设置硬盘状态

const
  NET_DVR_IMPORT_IPC_CFG_FILE = 6172;    //导入IPC配置文件
  NET_DVR_EXPORT_IPC_CFG_FILE = 6173;    //导出IPC配置文件
  NET_DVR_UPGRADE_IPC = 6174;    //升级IP通道

const
  NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED = 6175;    //获取RAID后台任务速度
  NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED = 6176;    //设置RAID后台任务速度

//marvell 256路NVR
const
  NET_DVR_GET_EXCEPTIONCFG_V40 = 6177;    //获取异常参数配置
  NET_DVR_SET_EXCEPTIONCFG_V40 = 6178;    //设置异常参数配置
  NET_DVR_GET_PICCFG_V40 = 6179;    //获取图象参数 支持变长    NetSDK_
  NET_DVR_SET_PICCFG_V40 = 6180;    //设置图象参数， 支持变长
  NET_DVR_GET_ALARMINCFG_V40 = 6181;    //获取报警输入参数，支持变长
  NET_DVR_SET_ALARMINCFG_V40 = 6182;    //获取报警输入参数，支持变长
  NET_DVR_GET_IPALARMINCFG_V40 = 6183;    //获取IP报警输入接入配置信息
  NET_DVR_GET_IPALARMOUTCFG_V40 = 6185;    //获取IP报警输出接入配置信息
  NET_DVR_GET_USERCFG_V40 = 6187;    //获取用户参数
  NET_DVR_SET_USERCFG_V40 = 6188;    //设置用户参数
  NET_DVR_GET_WORK_STATUS = 6189;    //获取设备工作状态
  NET_DVR_GET_JPEG_CAPTURE_CFG_V40 = 6190;    //获取DVR抓图配置
  NET_DVR_SET_JPEG_CAPTURE_CFG_V40 = 6191;    //设置DVR抓图配置
  NET_DVR_GET_HDGROUP_CFG_V40 = 6192;    //获取盘组管理配置参数
  NET_DVR_SET_HDGROUP_CFG_V40 = 6193;    //设置盘组管理配置参数
  NET_DVR_GET_SMD_HOLIDAY_HANDLE = 6194;    //获取简易智能假日计划
  NET_DVR_SET_SMD_HOLIDAY_HANDLE = 6195;    //设置简易智能假日计划
  NET_DVR_GET_PIC_MODEL_CFG = 6196;    //获取图片建模配置参数
  NET_DVR_SET_PIC_MODEL_CFG = 6197;    //设置图片建模配置参数
  NET_DVR_START_LOCAL_MOUSE_EVENT = 6198;    //开启设备本地鼠标事件记录
  NET_DVR_START_SIMULARE_MOUSE_EVENT = 6199;    //远程模拟鼠标事件
  NET_DVR_GET_WORK_STATUS_V50 = 6200;    //获取设备工作状态V50

//91系列HD-SDI高清DVR
const
  NET_DVR_GET_ACCESS_CAMERA_INFO = 6201;    // 获取前端相机信息
  NET_DVR_SET_ACCESS_CAMERA_INFO = 6202;    // 设置前端相机信息
  NET_DVR_PULL_DISK = 6203;    // 安全拔盘
  NET_DVR_SCAN_RAID = 6204;    // 扫描阵列
// CVR 2.0.X
const
  NET_DVR_GET_USER_RIGHT_CFG = 6210;    // 获取用户权限
  NET_DVR_SET_USER_RIGHT_CFG = 6211;    // 设置用户权限

const
  NET_DVR_ONE_KEY_CONFIG = 6212;    // 一键配置CVR
  NET_DVR_RESTART_SERVICE = 6213;    // 重启CVR服务

const
  NET_DVR_GET_MAX_MACHINE_NUM_CFG = 6214;    // 获取备机最大个数
  NET_DVR_SET_MAX_MACHINE_NUM_CFG = 6215;    // 设置备机最大个数

const
  NET_DVR_ADD_DEVICE = 6216;    //N+1模式添加设备
  NET_DVR_DEL_DEVICE = 6217;    //N+1模式删除设备

const
  NET_DVR_GET_DATA_CALLBACK_CFG = 6218;    // 获取数据回迁状态
  NET_DVR_SET_DATA_CALLBACK_CFG = 6219;    // 设置数据回迁状态

const
  NET_DVR_CLONE_LUN = 6220;    //克隆LUN卷
  NET_DVR_EXPAND_LUN = 6221;    //扩展和重命名LUN卷

const
  NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO = 6222;    //获取N+1设备信息
  NET_DVR_MODIFY_DVR_NET_DISK = 6223;    //修改DVR网盘
//#define NET_DVR_DEL_DVR_NET_DISK                6224    //删除DVR网盘

const
  NET_DVR_CREATE_NAS = 6225;    //创建NAS
  NET_DVR_DELETE_NAS = 6226;    //删除NAS

const
  NET_DVR_OPEN_ISCSI = 6227;    //开启iSCSI
  NET_DVR_CLOSE_ISCSI = 6228;    //关闭iSCSI

const
  NET_DVR_GET_FC = 6229;    //获取光纤信息
  NET_DVR_OPEN_FC = 6230;    //开启FC
  NET_DVR_CLOSE_FC = 6231;    //关闭FC
  NET_DVR_ONE_KEY_CONFIG_SAN = 6232;    // 一键配置SAN, 与一键配置CVR逻辑一样

//CVR2.3.2
const
  NET_DVR_RECORD_CHECK = 6233;    //录像完整性检测
  NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL = 6234;    //手动添加录像回传任务
  NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL = 6235;    //获取所有手动添加录像回传任务
  NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL = 6236;    //控制手动录像回传任务
  NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL = 6237;    //删除手动录像回传任务
  NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG = 6238;    //获取录像回传计划配置
  NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG = 6239;    //设置录像回传计划配置
  NET_DVR_GET_DEV_STORAGE_CFG = 6240;    //获取设备存储信息
  NET_DVR_GET_ONLINE_USER_CFG = 6241;    //获取在线用户参数
  NET_DVR_GET_RECORD_SEGMENT_CFG = 6242;    //获取录像段总量

const
  NET_DVR_GET_REC_PASSBACK_TASK_EXECUTABLE = 6243;    //查询手动录像回传任务可执行性
  NET_DVR_GET_STREAM_MEDIA_CFG = 6244;    //获取流媒体回传录像参数配置（流ID方式）
  NET_DVR_SET_STREAM_MEDIA_CFG = 6245;    //设置流媒体回传录像参数配置（流ID方式）
  NET_DVR_GET_USERCFG_V50 = 6246;    //获取用户参数V50
  NET_DVR_SET_USERCFG_V50 = 6247;    //设置用户参数V50

const
  NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG_CAP = 6248;    //获取CVR回传功能基础配置能力
  NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG = 6249;    //获取CVR回传功能基础配置
  NET_DVR_SET_RECORD_PASSBACK_BASIC_CFG = 6250;    //设置CVR回传功能基础配置
  NET_DVR_ONE_KEY_CONFIG_V50 = 6251;    // 一键配置CVR(V50)
  NET_DVR_GET_RACM_CAP = 6252;    //获取存储总能力（RACM能力）
  NET_DVR_GET_THUMBNAILS = 6253;    //获取缩略图（默认是录像的缩略图）(支持流ID)
  NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL_V50 = 6254;    //手动添加录像回传任务V50（返回任务ID）
  NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG_CAP = 6255;    //获取CVR回传历史录像计划能力
  NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG = 6256;    //获取CVR回传历史录像计划配置
  NET_DVR_SET_RECORD_PASSBACK_HISTORY_PLAN_CFG = 6257;    //设置CVR回传历史录像计划配置
  NET_DVR_ONE_KEY_CONFIG_V51 = 6258;    // 一键配置CVR(V51)


const
  NET_DVR_GET_RECORD_PACK = 6301;    //获取录像打包参数
  NET_DVR_SET_RECORD_PACK = 6302;    //设置录像打包参数

const
  NET_DVR_GET_CLOUD_STORAGE_CFG = 6303;    //获取云存储配置信息
  NET_DVR_SET_CLOUD_STORAGE_CFG = 6304;    //设置云存储配置信息
  NET_DVR_GET_GOP_INFO = 6305;    //获取GOP信息
  NET_DVR_GET_PHY_DISK_INFO = 6306;    //获取物理磁盘信息
//录播主机外部命令
const
  NET_DVR_GET_RECORDING_AUTO_TRACK_CFG = 6307;    //获取SDI自动配置信息
  NET_DVR_SET_RECORDING_AUTO_TRACK_CFG = 6308;    //设置SDI自动配置信息

const
  NET_DVR_GET_RECORDING_PUBLISH_CFG = 6309;    //获取一键发布信息
  NET_DVR_SET_RECORDING_PUBLISH_CFG = 6310;    //设置一键发布信息


const
  NET_DVR_RECORDING_ONEKEY_CONTROL = 6311;    //录播主机控制

const
  NET_DVR_GET_RECORDING_END_TIME = 6312;    //获取录播剩余时间

const
  NET_DVR_RECORDING_PUBLISH = 6313;    //一键发布录像

const
  NET_DVR_GET_CURRICULUM_CFG = 6314;    //获取课表配置信息
  NET_DVR_SET_CURRICULUM_CFG = 6315;    //设置课表配置信息

const
  NET_DVR_GET_COURSE_INDEX_CFG = 6316;    //获取课程信息索引
  NET_DVR_SET_COURSE_INDEX_CFG = 6317;    //设置课程信息索引

const
  NET_DVR_GET_PPT_CHANNEL = 6318;    //获取PPT支持通道号
  NET_DVR_GET_PPT_DETECT_CFG = 6319;    //获取PPT检测参数
  NET_DVR_SET_PPT_DETECT_CFG = 6320;    //设置PPT检测参数

const
  NET_DVR_GET_RECORDINGHOST_CFG = 6321;    //获取录播主机配置信息
  NET_DVR_SET_RECORDINGHOST_CFG = 6322;    //设置录播主机配置信息
  NET_DVR_GET_BACKUP_RECORD_CFG = 6323;    //获取一键备份配置信息
  NET_DVR_SET_BACKUP_RECORD_CFG = 6324;    //设置一键备份配置信息

//庭审主机
const
  NET_DVR_GET_AUDIO_ACTIVATION_CFG = 6326;    //获取语音激励配置参数
  NET_DVR_SET_AUDIO_ACTIVATION_CFG = 6327;    //设置语音激励配置参数
  NET_DVR_GET_DECODERCFG_V40 = 6328;    //获取解码器参数信息
  NET_DVR_SET_DECODERCFG_V40 = 6329;    //设置解码器参数信息

const
  NET_DVR_INFRARED_OUTPUT_CONTROL = 6330;    //红外输出控制
  NET_DVR_GET_INFRARED_CMD_NAME_CFG = 6331;    //获取红外命令名称参数配置
  NET_DVR_SET_INFRARED_CMD_NAME_CFG = 6332;    //设置红外命令名称参数配置
  NET_DVR_START_INFRARED_LEARN = 6333;    //远程红外学码

const
  NET_DVR_GET_TRIAL_SYSTEM_CFG = 6334;    //获取庭审主机系统信息
  NET_DVR_SET_CASE_INFO = 6335;    //案件信息录入
  NET_DVR_GET_TRIAL_MICROPHONE_STATUS = 6336;    //获取麦克风状态信息
  NET_DVR_SET_TRIAL_MICROPHONE_STATUS = 6337;    //获取麦克风状态信息
  NET_DVR_GET_TRIAL_HOST_STATUS = 6338;    //获取庭审主机状态信息
  NET_DVR_GET_LAMP_OUT = 6339;    //获取LAMP输出口信息
  NET_DVR_SET_LAMP_OUT = 6340;    //设置LAMP输出口信息
  NET_DVR_LAMP_REMOTE_CONTROL = 6341;    // LAMP控制
  NET_DVR_REMOTE_CONTROL_PLAY = 6342;    //远程控制本地回放
  NET_DVR_GET_LOCAL_INPUT_CFG = 6343;    //获取庭审主机状态信息庭审主机本地输入信息
  NET_DVR_SET_LOCAL_INPUT_CFG = 6344;    //设置庭审主机本地输入信息
  NET_DVR_GET_CASE_INFO = 6345;    //获取当前案件信息

//审讯机外部命令
const
  NET_DVR_INQUEST_GET_CDW_STATUS = 6350;    //获取审讯机刻录状态-长连接
  NET_DVR_GET_MIX_AUDIOIN_CFG = 6351;    //获取混音输入口参数配置
  NET_DVR_SET_MIX_AUDIOIN_CFG = 6352;    //设置混音输入口参数配置
  NET_DVR_GET_MIX_AUDIOOUT_CFG = 6353;    //获取混音输出口参数配置
  NET_DVR_SET_MIX_AUDIOOUT_CFG = 6354;    //设置混音输出口参数配置
  NET_DVR_GET_AUDIOIN_VOLUME_CFG = 6355;    //获取音频输入口音量调节参数配置
  NET_DVR_SET_AUDIOIN_VOLUME_CFG = 6356;    //设置音频输入口音量调节参数配置
  NET_DVR_GET_AREA_MASK_CFG = 6357;    //获取马赛克区域配置
  NET_DVR_SET_AREA_MASK_CFG = 6358;    //设置马赛克区域配置
  NET_DVR_GET_AUDIO_DIACRITICAL_CFG = 6359;    //获取音频变音配置
  NET_DVR_SET_AUDIO_DIACRITICAL_CFG = 6360;    //设置音频变音配置
  NET_DVR_GET_WIFI_DHCP_ADDR_CFG = 6361;    //获WIFI DHCP 地址范围参数配置
  NET_DVR_SET_WIFI_DHCP_ADDR_CFG = 6362;    //设WIFI DHCP 地址范围参数配置
  NET_DVR_GET_WIFI_CLIENT_LIST_INFO = 6363;    //获取wifi热点下连接的设备信息
  NET_DVR_REMOTECONTROL_POWER_ON = 6364;    //远程开机
  NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG = 6365;    //获取多码流关联通道参数配置
  NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG = 6366;    //设置多码流关联通道参数配置
  NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG = 6367;    //获取设备本地视频输出口分辨率
  NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG = 6368;    //设置设备本地视频输出口分辨率
  NET_DVR_GET_AUDIOOUT_VOLUME_CFG = 6369;    //获取音频输出口音量调节参数配置
  NET_DVR_SET_AUDIOOUT_VOLUME_CFG = 6370;    //设置音频输出口音量调节参数配置
  NET_DVR_INQUEST_PAUSE_CDW = 6371;    //暂停刻录
  NET_DVR_INQUEST_RESUME_CDW = 6372;    //恢复刻录
  NET_DVR_GET_INPUT_CHAN_CFG = 6373;    //获取输入通道配置
  NET_DVR_SET_INPUT_CHAN_CFG = 6374;    //设置输入通道配置
  NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG = 6375;    //获取审讯机音频输入混音配置
  NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG = 6376;    //设置审讯机音频输入混音配置
  NET_DVR_CASE_INFO_CTRL = 6377;    //案件信息显示控制
  NET_DVR_GET_INQUEST_USER_RIGHT = 6378;    //获取审讯机用户权限
  NET_DVR_SET_INQUEST_USER_RIGHT = 6379;    //设置审讯机用户权限
  NET_DVR_GET_INQUEST_CASE_INFO = 6380;    //获取审讯案件信息配置
  NET_DVR_SET_INQUEST_CASE_INFO = 6381;    //设置审讯案件信息配置

const
  NET_DVR_GET_FILM_MODE_CFG = 6387;    //获取电影模式
  NET_DVR_SET_FILM_MODE_CFG = 6388;    //设置电影模式
  NET_DVR_GET_FILM_MODE_CFG_CAP = 6389;    //获取电影模式配置能力

const
  NET_DVR_GET_DIRECTED_STRATEGY_CFG = 6390;    //获取导播策略类型
  NET_DVR_SET_DIRECTED_STRATEGY_CFG = 6391;    //设置导播策略类型
  NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP = 6392;    //获取电影模式配置能力
  NET_DVR_GET_FRAME_CFG = 6393;    //获取画面边框
  NET_DVR_SET_FRAME_CFG = 6394;    //设置画面边框
  NET_DVR_GET_FRAME_CFG_CAP = 6395;    //获取画面边框配置能力
  NET_DVR_GET_AUDIO_EFFECTIVE_CFG = 6396;    //获取音频优化参数
  NET_DVR_SET_AUDIO_EFFECTIVE_CFG = 6397;    //设置音频效果参数
  NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP = 6398;    //获取音频效果优化配置能力
  NET_DVR_GET_RECORD_VIDEO_CFG = 6399;    //获取录制视频参数
  NET_DVR_SET_RECORD_VIDEO_CFG = 6400;    //设置录制视频参数


const
  NET_DVR_GET_OUTPUT_CFG = 6401;    //获取显示输出参数
  NET_DVR_SET_OUTPUT_CFG = 6402;    //设置显示输出参数
  NET_DVR_CODER_DISPLAY_START = 6403;    //开始输出
  NET_DVR_CODER_DISPLAY_STOP = 6404;    //停止输出
  NET_DVR_GET_WINDOW_STATUS = 6405;    //获取显示窗口状态

//VQD功能接口
const
  NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG = 6406;    //获取VQD循环诊断配置参数
  NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG = 6407;    //设置VQD循环诊断配置参数
  NET_DVR_GET_VQD_DIAGNOSE_INFO = 6408;    //手动获取VQD诊断信息

const
  NET_DVR_RECORDING_PUBLISH_FILE = 6421;    //文件发布
  NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP = 6422;    //获取文件发布能力
  NET_DVR_GET_PUBLISH_PROGRESS = 6423;    //获取发布进度
  NET_DVR_GET_RECORD_VIDEO_CFG_CAP = 6424;    //获取录制视频配置能力
  NET_DVR_GET_RTMP_CFG = 6425;    //获取RTMP参数
  NET_DVR_SET_RTMP_CFG = 6426;    //设置RTMP参数
  NET_DVR_GET_RTMP_CFG_CAP = 6427;    //获取RTMP配置能力
  NET_DVR_DEL_BACKGROUND_PIC = 6428;    //删除背景图片文件
  NET_DVR_GET_BACKGROUND_PIC_CFG = 6429;    //查询背景图片文件
  NET_DVR_GET_BACKGROUND_PIC_INFO = 6430;    //获取哪张图片作为背景图片
  NET_DVR_SET_BACKGROUND_PIC_INFO = 6431;    //设置哪张图片作为背景图片
  NET_DVR_GET_BACKGROUND_PIC_INFO_CAP = 6432;    //获取哪张图片作为背景图片配置能力
  NET_DVR_GET_RECORD_HOST_CAP = 6433;    //获取录播主机总能力
  NET_DVR_GET_COURSE_LIST = 6434;    //获取课程列表
  NET_DVR_GET_RECORD_STATUS = 6435;    //查询录播主机当前状态
  NET_DVR_MANUAL_CURRICULUM_CONTROL = 6436;    //手动课表控制
  NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG = 6437;    //获取图像差分检测参数
  NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG = 6438;    //设置图像差分检测参数
  NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP = 6439;    //获取图像差分检测配置能力
  NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO = 6440;    //获取发布文件信息参数
  NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO = 6441;    //设置发布文件信息参数
  NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP = 6442;    //获取发布文件信息配置能力
  NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP = 6443;    //获取手动课程录像的能力
  NET_DVR_GET_STATISTIC_DATA_LIST = 6444;    //获取统计数据列表

const
  NET_DVR_GET_DEVICE_LAN_ENCODE = 6501;    //获取设备的语言编码
  NET_DVR_GET_GBT28181_SERVICE_CFG = 6503;    //获取GB28181服务器参数
  NET_DVR_SET_GBT28181_SERVICE_CFG = 6504;    //设置GB28181服务器参数
  NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES = 6505;    //获取GB28181服务器能力

const
  NET_DVR_GET_CLOUD_URL = 6506;    //获取云存储URL
  NET_DVR_GET_CLOUD_URL_CAP = 6507;    //获取云存储URL-能力集
  NET_DVR_GET_CLOUD_CFG = 6508;    //获取云存储配置参数
  NET_DVR_SET_CLOUD_CFG = 6509;    //设置云存储配置参数
  NET_DVR_GET_CLOUD_CFG_CAP = 6510;    //获取云存储配置-能力集
  NET_DVR_GET_CLOUD_UPLOADSTRATEGY = 6511;    //获取云存储上传策略
  NET_DVR_SET_CLOUD_UPLOADSTRATEGY = 6512;    //设置云存储上传策略
  NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP = 6513;    //云存储上传策略配置-能力集

const
  NET_DVR_GET_VIDEO_IMAGE_DB_CFG = 6601;    //获取视图库信息
  NET_DVR_SET_VIDEO_IMAGE_DB_CFG = 6602;    //设置视图库信息
  NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP = 6603;    //获取视图库相关能力
  NET_DVR_GET_FILE_INFO_BY_ID = 6604;    //根据文件ID获取视图库中文件信息
  NET_DVR_QUERY_FILE_INFO_CAP = 6605;    //根据文件名查询文件信息能力
  NET_DVR_DEL_FILE_FROM_DB = 6606;    //从视图库中删除文件
  NET_DVR_GET_VIDEO_IMAGE_DB_CAP = 6607;    //获取视图库总能力

const
  NET_DVR_GET_FIGURE = 6610;    //获取缩略图

const
  NET_DVR_SYNC_IPC_PASSWD = 6621;    //同步IPC密码与NVR一致
  NET_DVR_GET_VEHICLE_BLOCKLIST_SCHEDULE = 6622;    //获取禁止名单布防时间配置
  NET_DVR_SET_VEHICLE_BLOCKLIST_SCHEDULE = 6623;    //设置禁止名单布防时间配置

const
  NET_DVR_GET_VEHICLE_ALLOWLIST_SCHEDULE = 6624;    //获取允许名单布防时间配置
  NET_DVR_SET_VEHICLE_ALLOWLIST_SCHEDULE = 6625;    //设置允许名单布防时间配置

const
  NET_DVR_GET_VEHICLE_BLOCKLIST_EVENT_TRIGGER = 6626;    //获取禁止名单布防联动配置
  NET_DVR_SET_VEHICLE_BLOCKLIST_EVENT_TRIGGER = 6627;    //设置禁止名单布防联动配置

const
  NET_DVR_GET_VEHICLE_ALLOWLIST_EVENT_TRIGGER = 6628;    //获取允许名单布防联动配置
  NET_DVR_SET_VEHICLE_ALLOWLIST_EVENT_TRIGGER = 6629;    //设置允许名单布防联动配置

const
  NET_DVR_GET_TRAFFIC_CAP = 6630;    //获取抓拍相关能力集
  NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER = 6631;    //获取全部车辆检测布防联动配置
  NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER = 6632;    //设置全部车辆检测布防联动配置
  NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER = 6633;    //获取其他单布防联动配置
  NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER = 6634;    //设置其他单布防联动配置

const
  NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER = 6635;    //获取存储健康检测联动配置
  NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER = 6636;    //设置存储健康检测联动配置
  NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES = 6637;    //获取存储健康检测布防时间能力
  NET_DVR_GET_STORAGEDETECTION_SCHEDULE = 6638;    //获取存储健康布防时间配置
  NET_DVR_SET_STORAGEDETECTION_SCHEDULE = 6639;    //设置存储健康布防时间配置
  NET_DVR_GET_STORAGEDETECTION_STATE = 6640;    //获取存储健康状态

const
  NET_DVR_GET_STORAGEDETECTION_RWLOCK = 6646;    //获取存储侦测的读写锁配置
  NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES = 6647;    //获取存储侦测的读写锁配置能力
  NET_DVR_SET_STORAGEDETECTION_RWLOCK = 6648;    //设置存储侦测的读写锁配置
  NET_DVR_GET_PTZTRACKSTATUS = 6649;    //获取球机联动状态

const
  NET_DVR_SET_STORAGEDETECTION_UNLOCK = 6653;    //设置存储侦测的解锁配置
  NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES = 6654;    //获取存储侦测的解锁配置能力

const
  NET_DVR_SET_SHIPSDETECTION_CFG = 6655;    //设置船只检测参数配置
  NET_DVR_GET_SHIPSDETECTION_CFG = 6656;    //获取船只检测参数配置
  NET_DVR_GET_SHIPSDETECTION_CAPABILITIES = 6657;    //获取船只检测参数配置能力
  NET_DVR_GET_SHIPSDETECTION_COUNT = 6658;    //获取船只计数信息
  NET_DVR_SHIPSCOUNT_DELETE_CTRL = 6659;    //清空船只计数信息

const
  NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES = 6660;    //获取裸数据叠加能力
  NET_DVR_SET_BAREDATAOVERLAY_CFG = 6661;    //设置裸数据叠加
  NET_DVR_GET_BAREDATAOVERLAY_CFG = 6662;    //获取裸数据叠加
  NET_DVR_GET_SHIPSDETECTION_SCHEDULE = 6663;    //获取船只检测布防时间配置
  NET_DVR_SET_SHIPSDETECTION_SCHEDULE = 6664;    //设置船只检测布防时间配置
  NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER = 6665;    //获取船只检测联动配置
  NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER = 6666;    //设置船只检测联动配置
  NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES = 6667;    //获取船只检测布防时间能力

const
  NET_DVR_FIRE_FOCUSZOOM_CTRL = 6670;    //火点可见光镜头聚焦变倍

const
  NET_DVR_GET_FIREDETECTION_SCHEDULE_CAPABILITIES = 6671;    //获取火点检测布防时间能力
  NET_DVR_GET_FIREDETECTION_SCHEDULE = 6672;    //获取火点检测布防时间配置
  NET_DVR_SET_FIREDETECTION_SCHEDULE = 6673;    //设置火点检测布防时间配置
  NET_DVR_GET_MANUALRANGING_CAPABILITIES = 6675;    //获取手动测距配置能力
  NET_DVR_SET_MANUALRANGING = 6677;    //设置手动测距参数
  NET_DVR_GET_MANUALDEICING_CAPABILITIES = 6678;    //获取手动除冰配置能力
  NET_DVR_SET_MANUALDEICING = 6679;    //设置手动除冰
  NET_DVR_GET_MANUALDEICING = 6680;    //获取手动除冰

const
  NET_DVR_GET_THERMALPOWER_CAPABILITIES = 6689;    //获取相机电源配置能力
  NET_DVR_GET_THERMALPOWER = 6690;    //获取相机电源配置参数
  NET_DVR_SET_THERMALPOWER = 6691;    //设置相机电源配置参数
  NET_DVR_GET_PTZABSOLUTEEX_CAPABILITIES = 6695;    //获取高精度PTZ绝对位置配置扩展能力
  NET_DVR_GET_PTZABSOLUTEEX = 6696;    //获取高精度PTZ绝对位置配置扩展
  NET_DVR_SET_PTZABSOLUTEEX = 6697;    //设置高精度PTZ绝对位置配置扩展

const
  NET_DVR_GET_CRUISE_CAPABILITIES = 6698;    //获取设备巡航模式配置能力
  NET_DVR_GET_CRUISE_INFO = 6699;    //获取设备巡航模式
  NET_DVR_GET_TEMP_HUMI_CAPABILITIES = 6700;    //温湿度实时能力获取
  NET_DVR_GET_TEMP_HUMI_INFO = 6701;    //温湿度实时获取

const
  NET_DVR_GET_MANUALTHERM_INFO = 6706;    //手动测温实时获取
  NET_DVR_GET_MANUALTHERM_CAPABILITIES = 6707;    //获取手动测温实时数据能力
  NET_DVR_SET_MANUALTHERM = 6708;    //设置手动测温数据设置

//DVR96000
const
  NET_DVR_GET_ACCESSORY_CARD_INFO_CAPABILITIES = 6709;    //获取配件板信息能力
  NET_DVR_GET_ACCESSORY_CARD_INFO = 6710;    //获取配件板信息

const
  NET_DVR_GET_THERMINTELL_CAPABILITIES = 6711;    //获取热成像智能互斥能力
  NET_DVR_GET_THERMINTELL = 6712;    //获取热成像智能互斥配置参数
  NET_DVR_SET_THERMINTELL = 6713;    //设置热成像智能互斥配置参数
  NET_GET_CRUISEPOINT_V50 = 6714;    //获取巡航路径配置扩展
  NET_DVR_GET_MANUALTHERM_BASIC_CAPABILITIES = 6715;    //获取手动测温基本参数配置能力
  NET_DVR_SET_MANUALTHERM_BASICPARAM = 6716;    //设置手动测温基本参数
  NET_DVR_GET_MANUALTHERM_BASICPARAM = 6717;    //获取手动测温基本参数

const
  NET_DVR_GET_FIRESHIELDMASK_CAPABILITIES = 6718;    //获取火点区域屏蔽能力

const
  NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES = 6720;    //隐藏信息配置能力
  NET_DVR_GET_HIDDEN_INFORMATION = 6721;    //获取隐藏信息参数
  NET_DVR_SET_HIDDEN_INFORMATION = 6722;    //设置隐藏信息参数

const
  NET_DVR_SET_FIRESHIELDMASK_CFG = 6723;    //设置火点区域屏蔽参数
  NET_DVR_GET_FIRESHIELDMASK_CFG = 6724;    //获取火点区域屏蔽参数

const
  NET_DVR_GET_SMOKESHIELDMASK_CAPABILITIES = 6725;    //获取烟雾区域屏蔽能力
  NET_DVR_SET_SMOKESHIELDMASK_CFG = 6726;    //设置烟雾区域屏蔽参数
  NET_DVR_GET_SMOKESHIELDMASK_CFG = 6727;    //获取烟雾区域屏蔽参数

const
  NET_DVR_GET_AREASCAN_CAPABILITIES = 6728;    //获取区域扫描能力
  NET_DVR_GET_AREASCAN_CFG = 6730;    //获取区域扫描参数

const
  NET_DVR_DEL_AREASCAN_CFG = 6731;    //扫描区域删除
  NET_DVR_AREASCAN_INIT_CTRL = 6732;    //进入区域扫描设置
  NET_DVR_AREASCAN_CONFIRM_CTRL = 6733;    //保存区域扫描设置
  NET_DVR_AREASCAN_STOP_CTRL = 6734;    //停止区域扫描设置
  NET_DVR_SAVE_SCANZOOM_CTRL = 6735;    //设置扫描倍率；保存当前光学倍率为扫描倍率
  NET_DVR_GET_SCANZOOM_CTRL = 6736;    //获取扫描倍率；将预览界面中的光学倍率返回到当前扫描倍率。
  NET_DVR_DEL_FIRESHIELDMASK_CTRL = 6737;    //删除火点屏蔽区域
  NET_DVR_DEL_SMOKESHIELDMASK_CTRL = 6738;    //删除烟雾屏蔽区域

const
  NET_DVR_GET_DENSEFOG_EVENT_TRIGGER = 6740;    //获取大雾检测联动配置
  NET_DVR_SET_DENSEFOG_EVENT_TRIGGER = 6741;    //设置大雾检测联动配置
  NET_DVR_SET_DENSEFOGDETECTION_CFG = 6742;    //设置大雾检测参数配置
  NET_DVR_GET_DENSEFOGDETECTION_CFG = 6743;    //获取大雾检测参数配置
  NET_DVR_GET_DENSEFOGDETECTION_CAPABILITIES = 6744;    //获取大雾检测参数配置能力

const
  NET_DVR_GET_THERMOMETRY_SCHEDULE_CAPABILITIES = 6750;    //获取测温检测布防时间能力
  NET_DVR_GET_THERMOMETRY_SCHEDULE = 6751;    //获取测温检测布防时间配置
  NET_DVR_SET_THERMOMETRY_SCHEDULE = 6752;    //设置测温检测布防时间配置
  NET_DVR_GET_TEMPERTURE_SCHEDULE_CAPABILITIES = 6753;    //获取温差布防时间能力
  NET_DVR_GET_TEMPERTURE_SCHEDULE = 6754;    //获取温差布防时间配置
  NET_DVR_SET_TEMPERTURE_SCHEDULE = 6755;    //设置温差布防时间配置
  NET_DVR_GET_SEARCH_LOG_CAPABILITIES = 6756;    //日志类型支持能力
  NET_DVR_GET_VEHICLEFLOW = 6758;    //获取车流量数据
  NET_DVR_GET_IPADDR_FILTERCFG_V50 = 6759;    //获取IP地址过滤参数扩展
  NET_DVR_SET_IPADDR_FILTERCFG_V50 = 6760;    //设置IP地址过滤参数扩展
  NET_DVR_GET_TEMPHUMSENSOR_CAPABILITIES = 6761;    //获取温湿度传感器的能力
  NET_DVR_GET_TEMPHUMSENSOR = 6762;    //获取温湿度传感器配置协议
  NET_DVR_SET_TEMPHUMSENSOR = 6763;    //设置温湿度传感器配置协议

const
  NET_DVR_GET_THERMOMETRY_MODE_CAPABILITIES = 6764;    //获取测温模式能力
  NET_DVR_GET_THERMOMETRY_MODE = 6765;    //获取测温模式参数
  NET_DVR_SET_THERMOMETRY_MODE = 6766;    //设置测温模式参数

const
  NET_DVR_GET_THERMAL_PIP_CAPABILITIES = 6767;    //获取热成像画中画配置能力
  NET_DVR_GET_THERMAL_PIP = 6768;    //获取热成像画中画配置参数
  NET_DVR_SET_THERMAL_PIP = 6769;    //设置热成像画中画配置参数
  NET_DVR_GET_THERMAL_INTELRULEDISPLAY_CAPABILITIES = 6770;    //获取热成像智能规则显示能力
  NET_DVR_GET_THERMAL_INTELRULE_DISPLAY = 6771;    //获取热成像智能规则显示参数
  NET_DVR_SET_THERMAL_INTELRULE_DISPLAY = 6772;    //设置热成像智能规则显示参数
  NET_DVR_GET_THERMAL_ALGVERSION = 6773;    //获取热成像相关算法库版本
  NET_DVR_GET_CURRENT_LOCK_CAPABILITIES = 6774;    //获取电流锁定配置能力
  NET_DVR_GET_CURRENT_LOCK = 6775;    //获取电流锁定配置参数
  NET_DVR_SET_CURRENT_LOCK = 6776;    //设置电流锁定配置参数

const
  NET_DVR_DEL_MANUALTHERM_RULE = 6778;    //删除手动测温规则

const
  NET_DVR_GET_UPGRADE_INFO = 6779;    //获取升级信息

const
  NET_DVR_SWITCH_TRANSFER = 7000;    

const
  NET_DVR_GET_MB_POWERCTRLPARA = 8000;    //获取启动控制参数
  NET_DVR_SET_MB_POWERCTRLPARA = 8001;    //设置启动控制参数
  NET_DVR_GET_AUTOBACKUPPARA = 8002;    //获取自动备份参数
  NET_DVR_SET_AUTOBACKUPPARA = 8003;    //设置自动备份参数
  NET_DVR_GET_MB_GPSPARA = 8004;    //获取GPS参数
  NET_DVR_SET_MB_GPSPARA = 8005;    //设置GPS参数
  NET_DVR_GET_MB_SENSORINPARA = 8006;    //获取SENSOR参数
  NET_DVR_SET_MB_SENSORINPARA = 8007;    //设置SENSOR参数
  NET_DVR_GET_GSENSORPARA = 8008;    //获取GSENSOR参数
  NET_DVR_SET_GSENSORPARA = 8009;    //设置GSENSOR参数
  NET_DVR_GET_MB_DOWNLOADSVRPARA = 8010;    //获取下载服务器参数
  NET_DVR_SET_MB_DOWNLOADSVRPARA = 8011;    //设置下载服务器参数
  NET_DVR_GET_PLATERECOG_PARA = 8012;    //获取车牌识别参数
  NET_DVR_SET_PLATERECOG_PARA = 8013;    //设置车牌识别参数
  NET_DVR_GET_ENFORCESYS_PARA = 8014;    //获取车辆稽查参数
  NET_DVR_SET_ENFORCESYS_PARA = 8015;    //设置车辆稽查参数
  NET_DVR_GET_GPS_DATA = 8016;    //获取GPS数据
  NET_DVR_GET_ANALOG_ALARMINCFG = 8017;    //获取模拟报警输入参数
  NET_DVR_SET_ANALOG_ALARMINCFG = 8018;    //设置模拟报警输入参数

const
  NET_DVR_GET_SYSTEM_CAPABILITIES = 8100;    //获取设备的系统能力
  NET_DVR_GET_EAGLEEYE_CAPABILITIES = 8101;    //获取设备鹰眼能力
  NET_DVR_GET_SLAVECAMERA_CALIB_V51 = 8102;    //获取从摄像机标定配置V51
  NET_DVR_SET_SLAVECAMERA_CALIB_V51 = 8103;    //设置从摄像机标定配置V51
  NET_DVR_SET_GOTOSCENE = 8105;    //设置主摄像机转向指定的场景ID

//I、K、E系列NVR产品升级
const
  NET_DVR_GET_PTZ_NOTIFICATION = 8201;    //获取多通道事件联动PTZ
  NET_DVR_SET_PTZ_NOTIFICATION = 8202;    //设置多通道事件联动PTZ
//****************************电视墙 start***************************
const
  NET_DVR_MATRIX_WALL_SET = 9001;    //设置电视墙中屏幕参数
  NET_DVR_MATRIX_WALL_GET = 9002;    //获取电视墙中屏幕参数
  NET_DVR_WALLWIN_GET = 9003;    //电视墙中获取窗口参数
  NET_DVR_WALLWIN_SET = 9004;    //电视墙中设置窗口参数
  NET_DVR_WALLWINPARAM_SET = 9005;    //设置电视墙窗口相关参数
  NET_DVR_WALLWINPARAM_GET = 9006;    //获取电视墙窗口相关参数
  NET_DVR_WALLSCENEPARAM_GET = 9007;    //设置场景模式参数
  NET_DVR_WALLSCENEPARAM_SET = 9008;    //获取场景模式参数
  NET_DVR_MATRIX_GETWINSTATUS = 9009;    //获取窗口解码状态
  NET_DVR_GET_WINASSOCIATEDDEVINFO = 9010;    //电视墙中获取对应资源信息
  NET_DVR_WALLOUTPUT_GET = 9011;    //电视墙中获取显示输出参数
  NET_DVR_WALLOUTPUT_SET = 9012;    //电视墙中设置显示输出参数
  NET_DVR_GET_UNITEDMATRIXSYSTEM = 9013;    //电视墙中获取对应资源
  NET_DVR_GET_WALL_CFG = 9014;    //获取电视墙全局参数
  NET_DVR_SET_WALL_CFG = 9015;    //设置电视墙全局参数
  NET_DVR_CLOSE_ALL_WND = 9016;    //关闭所有窗口
  NET_DVR_SWITCH_WIN_TOP = 9017;    //窗口置顶
  NET_DVR_SWITCH_WIN_BOTTOM = 9018;    //窗口置底

const
  NET_DVR_CLOSE_ALL_WND_V41 = 9019;    //电视墙关闭所有窗口v41（有多个电视墙）
  NET_DVR_GET_WALL_WINDOW_V41 = 9020;    //获取电视墙中的窗口v41
  NET_DVR_SET_WALL_WINDOW_V41 = 9021;    //设置电视墙中的窗口v41
  NET_DVR_GET_CURRENT_SCENE_V41 = 9022;    //获取当前电视墙中正在使用的场景v41
  NET_DVR_GET_WALL_SCENE_PARAM_V41 = 9023;    //获取当前电视墙中正在使用的场景v41
  NET_DVR_SET_WALL_SCENE_PARAM_V41 = 9024;    //设置当前电视墙中正在使用的场景v41
  NET_DVR_GET_MATRIX_LOGO_CFG = 9025;    //获取logo参数
  NET_DVR_SET_MATRIX_LOGO_CFG = 9026;    //设置logo参数
  NET_DVR_GET_WIN_LOGO_CFG = 9027;    //获取窗口logo参数
  NET_DVR_SET_WIN_LOGO_CFG = 9028;    //设置窗口logo参数
  NET_DVR_DELETE_LOGO = 9029;    //删除logo
  NET_DVR_SET_DISPLAY_EFFECT_CFG = 9030;    //设置显示输出效果参数v41
  NET_DVR_GET_DISPLAY_EFFECT_CFG = 9031;    //获取显示输出效果参数v41
  NET_DVR_DEC_PLAY_REMOTE_FILE = 9032;    //解码播放远程文件
  NET_DVR_DEC_PLAY_REMOTE_FILE_V50 = 9314;    //解码播放远程文件V50
  NET_DVR_GET_WIN_ZOOM_STATUS = 9033;    //获取窗口电子放大状态
  NET_DVR_GET_ALL_MATRIX_LOGOCFG = 9034;    //获取所有logo参数

//****************************电视墙 end*****************************

//******************************LCD拼接屏 begin*****************************************
const
  NET_DVR_SIMULATE_REMOTE_CONTROL = 9035;    //模拟遥控按键 2013-09-05
  NET_DVR_SET_SCREEN_SIGNAL_CFG = 9036;    //设置屏幕信号源参数
  NET_DVR_GET_SCREEN_SIGNAL_CFG = 9037;    //获取屏幕信号源参数
  NET_DVR_SET_SCREEN_SPLICE_CFG = 9038;    //设置屏幕拼接
  NET_DVR_GET_SCREEN_SPLICE_CFG = 9039;    //获取屏幕拼接
  NET_DVR_GET_SCREEN_FAN_WORK_MODE = 9040;    //获取风扇工作方式
  NET_DVR_SET_SCREEN_FAN_WORK_MODE = 9041;    //设置风扇工作方式
  NET_DVR_SHOW_SCREEN_WORK_STATUS = 9044;    //显示屏幕状态
  NET_DVR_GET_VGA_CFG = 9045;    //获取VGA信号配置
  NET_DVR_SET_VGA_CFG = 9046;    //设置VGA信号配置
  NET_DVR_GET_SCREEN_MENU_CFG = 9048;    //获取屏幕菜单配置
  NET_DVR_SET_SCREEN_MENU_CFG = 9049;    //设置屏幕菜单配置
  NET_DVR_SET_SCREEN_DISPLAY_CFG = 9050;    //设置显示参数 2013-08-28
  NET_DVR_GET_SCREEN_DISPLAY_CFG = 9051;    //获取显示参数 2013-08-28

const
  NET_DVR_SET_FUSION_CFG = 9052;    //设置图像融合参数
  NET_DVR_GET_FUSION_CFG = 9053;    //获取图像融合参数

const
  NET_DVR_SET_PIP_CFG = 9060;    //设置画中画参数
  NET_DVR_GET_PIP_CFG = 9061;    //获取画中画参数
  NET_DVR_SET_DEFOG_LCD = 9073;    //设置透雾参数
  NET_DVR_GET_DEFOG_LCD = 9074;    //获取透雾参数
  NET_DVR_SHOW_IP = 9075;    //显示IP
  NET_DVR_SCREEN_MAINTENANCE_WALL = 9076;    //屏幕维墙
  NET_DVR_SET_SCREEN_POS = 9077;    //设置屏幕位置参数
  NET_DVR_GET_SCREEN_POS = 9078;    //获取屏幕位置参数
//******************************LCD拼接屏 end*****************************************

//******************************LCD拼接屏V1.2 begin*****************************************
const
  NET_DVR_SCREEN_INDEX_SET = 9079;    //屏幕索引相关参数设置
  NET_DVR_SCREEN_INDEX_GET = 9080;    //屏幕索引相关参数获取
  NET_DVR_SCREEN_SPLICE_SET = 9081;    //设置屏幕拼接参数
  NET_DVR_SCREEN_SPLICE_GET = 9082;    //获取屏幕拼接参数
  NET_DVR_SET_SCREEN_PARAM = 9083;    //设置屏幕相关参数
  NET_DVR_GET_SCREEN_PARAM = 9084;    //获取屏幕相关参数
  NET_DVR_SET_SWITCH_CFG = 9085;    //设置定时开关机参数
  NET_DVR_GET_SWITCH_CFG = 9086;    //获取定时开关机参数
  NET_DVR_SET_POWERON_DELAY_CFG = 9087;    //设置延时开机参数
  NET_DVR_GET_POWERON_DELAY_CFG = 9088;    //获取延时开机参数
  NET_DVR_SET_SCREEN_POSITION = 9089;    //设置屏幕位置参数
  NET_DVR_GET_SCREEN_POSITION = 9090;    //获取屏幕位置参数
  NET_DVR_SCREEN_SCENE_CONTROL = 9091;    //屏幕场景控制
  NET_DVR_GET_CURRENT_SCREEN_SCENE = 9092;    //获取当前屏幕场景号
  NET_DVR_GET_SCREEN_SCENE_PARAM = 9093;    //获取屏幕场景模式参数
  NET_DVR_SET_SCREEN_SCENE_PARAM = 9094;    //设置屏幕场景模式参数
  NET_DVR_GET_EXTERNAL_MATRIX_RELATION = 9095;    //获取外接矩阵输入输出关联关系
  NET_DVR_GET_LCD_AUDIO_CFG = 9096;    //获取LCD屏幕音频参数
  NET_DVR_SET_LCD_AUDIO_CFG = 9097;    //设置LCD屏幕音频参数
  NET_DVR_GET_LCD_WORK_STATE = 9098;    //获取LCD屏幕工作状态
  NET_DVR_GET_BOOT_LOGO_CFG = 9099;    //获取LCD屏幕开机logo显示参数
  NET_DVR_SET_BOOT_LOGO_CFG = 9100;    //设置LCD屏幕开机logo显示参数

//******************************LCD拼接屏V1.2 end *****************************************
const
  NET_DVR_GET_STREAM_DST_COMPRESSIONINFO = 9101;    //获取目标压缩参数
  NET_DVR_SET_STREAM_DST_COMPRESSIONINFO = 9102;    //设置目标压缩参数
  NET_DVR_GET_STREAM_TRANS_STATUS = 9103;    //获取流状态
  NET_DVR_GET_DEVICE_TRANS_STATUS = 9104;    //获取设备转码状态
  NET_DVR_GET_ALLSTREAM_SRC_INFO = 9105;    //获取所有流信息
  NET_DVR_GET_BIG_SCREEN_AUDIO = 9106;    //获取大屏音频信息
  NET_DVR_SET_BIG_SCREEN_AUDIO = 9107;    //设置大屏音频信息
  NET_DVR_GET_DEV_WORK_MODE = 9108;    //获取转码设备工作模式
  NET_DVR_SET_DEV_WORK_MODE = 9109;    //设置转码设备工作模式
  NET_DVR_APPLY_TRANS_CHAN = 9110;    //按流ID申请转码通道
  NET_DVR_GET_DISPCHAN_CFG = 9111;    //批量获取显示通道参数
  NET_DVR_SET_DISPCHAN_CFG = 9112;    //批量设置显示通道参数

const
  NET_DVR_GET_DEC_CHAN_STATUS = 9113;    //获取解码通道解码状态
  NET_DVR_GET_DISP_CHAN_STATUS = 9114;    //获取显示通道状态
  NET_DVR_GET_ALARMIN_STATUS = 9115;    //获取报警输入状态
  NET_DVR_GET_ALARMOUT_STATUS = 9116;    //获取报警输出状态
  NET_DVR_GET_AUDIO_CHAN_STATUS = 9117;    //获取语音对讲状态

const
  NET_DVR_GET_VIDEO_AUDIOIN_CFG = 9118;    //获取视频的音频输入参数
  NET_DVR_SET_VIDEO_AUDIOIN_CFG = 9119;    //设置视频的音频输入参数

const
  NET_DVR_SET_BASEMAP_CFG = 9120;    //设置底图参数
  NET_DVR_GET_BASEMAP_CFG = 9121;    //获取底图参数
  NET_DVR_GET_VIRTUAL_SCREEN_CFG = 9122;    //获取超高清输入子系统参数
  NET_DVR_SET_VIRTUAL_SCREEN_CFG = 9123;    //设置超高清输入子系统参数
  NET_DVR_GET_BASEMAP_WIN_CFG = 9124;    //获取底图窗口参数
  NET_DVR_SET_BASEMAP_WIN_CFG = 9125;    //设置底图窗口参数
  NET_DVR_DELETE_PICTURE = 9126;    //删除底图
  NET_DVR_GET_BASEMAP_PIC_INFO = 9127;    //获取底图图片信息
  NET_DVR_SET_BASEMAP_WIN_CFG_V40 = 9128;    //设置底图窗口参数V40
  NET_DVR_GET_BASEMAP_WIN_CFG_V40 = 9129;    //获取底图窗口参数V40

const
  NET_DVR_GET_DEC_VCA_CFG = 9130;    //获取解码器智能报警参数
  NET_DVR_SET_DEC_VCA_CFG = 9131;    //设置解码器智能报警参数

const
  NET_DVR_SET_VS_INPUT_CHAN_INIT_ALL = 9132;    //初始化虚拟屏子板的所有输入通道
  NET_DVR_GET_VS_INPUT_CHAN_INIT_ALL = 9133;    //获取虚拟屏子板的所有输入通道的初始化参数
  NET_DVR_GET_VS_INPUT_CHAN_INIT = 9134;    //获取虚拟屏输入通道的初始化参数
  NET_DVR_GET_VS_INPUT_CHAN_CFG = 9135;    //获取虚拟屏输入通道配置参数

const
  NET_DVR_GET_TERMINAL_CONFERENCE_STATUS = 9136;    //获取终端会议状态
  NET_DVR_GET_TERMINAL_INPUT_CFG_CAP = 9137;    //获取终端输入参数能力
  NET_DVR_GET_TERMINAL_INPUT_CFG = 9138;    //获取终端视频会议输入参数
  NET_DVR_SET_TERMINAL_INPUT_CFG = 9139;    //设置终端视频会议输入参数

const
  NET_DVR_GET_CONFERENCE_REGION_CAP = 9140;    //获取终端会议区域能力
  NET_DVR_GET_CONFERENCE_REGION = 9141;    //获取终端会议区域参数
  NET_DVR_SET_CONFERENCE_REGION = 9142;    //设置终端会议区域参数
  NET_DVR_GET_TERMINAL_CALL_CFG_CAP = 9143;    //获取终端呼叫配置能力
  NET_DVR_GET_TERMINAL_CALL_CFG = 9144;    //获取终端呼叫参数
  NET_DVR_SET_TERMINAL_CALL_CFG = 9145;    //设置终端呼叫参数
  NET_DVR_GET_TERMINAL_CTRL_CAP = 9146;    //获取终端呼叫控制能力
  NET_DVR_TERMINAL_CTRL = 9147;    //终端呼叫控制
  NET_DVR_GET_CALL_QUERY_CAP = 9148;    //获取会议查找能力
  NET_DVR_GET_CALLINFO_BY_COND = 9149;    //按条件查询呼叫记录

const
  NET_DVR_SET_FUSION_SCALE = 9150;    //设置图像融合规模
  NET_DVR_GET_FUSION_SCALE = 9151;    //获取图像融合规模

const
  NET_DVR_GET_VCS_CAP = 9152;    //获取MCU能力集


const
  NET_DVR_GET_TERMINAL_GK_CFG_CAP = 9153;    //获取终端注册GK能力
  NET_DVR_GET_TERMINAL_GK_CFG = 9154;    //获取终端注册GK参数
  NET_DVR_SET_TERMINAL_GK_CFG = 9155;    //设置终端注册GK参数
  NET_DVR_GET_MCU_CONFERENCESEARCH_CAP = 9156;    //获取MCU设备的能力
  NET_DVR_SET_VS_INPUT_CHAN_CFG = 9157;    //设置虚拟屏输入通道配置参数
  NET_DVR_GET_VS_NETSRC_CFG = 9158;    //设置虚拟屏网络源参数
  NET_DVR_SET_VS_NETSRC_CFG = 9159;    //设置虚拟屏网络源参数

const
  NET_DVR_GET_LLDP_CFG = 9160;    //获取LLDP参数
  NET_DVR_SET_LLDP_CFG = 9161;    //设置LLDP参数
  NET_DVR_GET_LLDP_CAP = 9162;    //获取LLDP能力集
  NET_DVR_GET_FIBER_CONVERT_BASIC_INFO = 9163;    //获取光纤收发器基本信息
  NET_DVR_GET_FIBER_CONVERT_WORK_STATE = 9164;    //获取光纤收发器工作状
  NET_DVR_GET_FIBER_CONVERT_TOPOLOGY = 9165;    //获取光纤收发器拓扑信息
  NET_DVR_GET_FC_PORT_REMARKS = 9166;    //获取光纤收发器端口注释参数
  NET_DVR_SET_FC_PORT_REMARKS = 9167;    //设置光纤收发器端口注释参数
  NET_DVR_GET_PORT_REMARKS_CAP = 9168;    //获取光纤收发器端口注释能力集

const
  NET_DVR_GET_MCU_CONFERENCECONTROL_CAP = 9169;    //获取会议控制能力
  NET_DVR_GET_MCU_TERMINALCONTROL_CAP = 9170;    //获取终端控制能力
  NET_DVR_GET_MCU_TERIMINALGROUP_CAP = 9171;    //获取终端分组能力
  NET_DVR_GET_MCU_TERMINAL_CAP = 9174;    //获取终端管理能力
  NET_DVR_GET_MCU_CONFERENCE_CAP = 9175;    //获取会议能力
  NET_DVR_GET_MCU_GK_CFG_CAP = 9176;    //获取MCUGK配置能力
  NET_DVR_GET_MCU_GK_SERVER_CAP = 9177;    //获取MCUGK服务能力

const
  NET_DVR_GET_EDID_CFG_FILE_INFO = 9178;    //获取EDID配置文件信息
  NET_DVR_GET_EDID_CFG_FILE_INFO_LIST = 9179;    //获取所有EDID配置文件信息
  NET_DVR_SET_EDID_CFG_FILE_INFO = 9180;    //设置EDID配置文件信息
  NET_DVR_DEL_EDID_CFG_FILE_INFO = 9181;    //删除EDID配置文件信息（包括文件）
  NET_DVR_GET_EDID_CFG_FILE_INFO_CAP = 9182;    //EDID配置文件信息能力集

const
  NET_DVR_GET_SUBWND_DECODE_OSD = 9183;    //获取子窗口解码OSD信息
  NET_DVR_GET_SUBWND_DECODE_OSD_ALL = 9184;    //获取所有子窗口解码OSD信息
  NET_DVR_SET_SUBWND_DECODE_OSD = 9185;    //设置子窗口解码OSD信息
  NET_DVR_GET_SUBWND_DECODE_OSD_CAP = 9186;    //获取子窗口解码OSD信息能力集
  NET_DVR_GET_DECODE_CHANNEL_OSD = 9187;    //获取解码通道OSD信息
  NET_DVR_SET_DECODE_CHANNEL_OSD = 9188;    //设置解码通道OSD信息


const
  NET_DVR_GET_OUTPUT_PIC_INFO = 9200;    //获取输出口图片参数
  NET_DVR_SET_OUTPUT_PIC_INFO = 9201;    //设置输出口图片参数
  NET_DVR_GET_OUTPUT_PIC_WIN_CFG = 9202;    //获取输出口图片窗口参数
  NET_DVR_SET_OUTPUT_PIC_WIN_CFG = 9203;    //设置输出口图片窗口参数
  NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG = 9204;    //获取输出口所有图片窗口参数
  NET_DVR_DELETE_OUPUT_PIC = 9205;    //删除输出口图片
  NET_DVR_GET_OUTPUT_OSD_CFG = 9206;    //获取输出口OSD参数
  NET_DVR_SET_OUTPUT_OSD_CFG = 9207;    //设置输出口OSD参数
  NET_DVR_GET_OUTPUT_ALL_OSD_CFG = 9208;    //获取输出口所有OSD参数
  NET_DVR_GET_CHAN_RELATION = 9209;    //获取编码通道关联资源参数
  NET_DVR_SET_CHAN_RELATION = 9210;    //设置编码通道关联资源参数
  NET_DVR_GET_ALL_CHAN_RELATION = 9211;    //获取所有编码通道关联资源参数
  NET_DVR_GET_NS_RING_CFG = 9212;    //获取光纤板环网配置
  NET_DVR_SET_NS_RING_CFG = 9213;    //设置光纤板环网配置
  NET_DVR_GET_NS_RING_STATUS = 9214;    //获取光纤板环网状态
  NET_DVR_GET_OPTICAL_PORT_INFO = 9220;    //获取光口信息
  NET_DVR_SET_OPTICAL_PORT_INFO = 9221;    //设置光口信息
  NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG = 9222;    //获取编码通道关联光口输入源参数
  NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG = 9223;    //设置编码通道关联光口输入源参数
  NET_DVR_GET_WIN_ROAM_SWITCH_CFG = 9224;    //获取解码器窗口漫游开关参数
  NET_DVR_SET_WIN_ROAM_SWITCH_CFG = 9225;    //设置解码器窗口漫游开关参数
  NET_DVR_START_SCREEN_CRTL = 9226;    //开始屏幕控制
  NET_DVR_GET_SCREEN_FLIE_LIST = 9227;    //获取屏幕文件列表
  NET_DVR_GET_SCREEN_FILEINFO = 9228;    //获取屏幕文件信息参数
  NET_DVR_SET_SCREEN_FILEINFO = 9229;    //设置屏幕文件信息参数

//******************************小间距LED显示屏 begin**************************************
const
  NET_DVR_GET_LED_OUTPUT_CFG = 9230;    //获取发送卡输出参数
  NET_DVR_SET_LED_OUTPUT_CFG = 9231;    //设置发送卡输出参数
  NET_DVR_GET_LED_OUTPUT_PORT_CFG = 9232;    //获取LED发送卡输出端口参数
  NET_DVR_SET_LED_OUTPUT_PORT_CFG = 9233;    //设置LED发送卡输出端口参数
  NET_DVR_GET_LED_DISPLAY_AREA_CFG = 9234;    //获取LED发送卡显示区域
  NET_DVR_SET_LED_DISPLAY_AREA_CFG = 9235;    //设置LED发送卡显示区域
  NET_DVR_GET_LED_PORT_CFG = 9236;    //获取LED发送卡端口参数
  NET_DVR_SET_LED_PORT_CFG = 9237;    //设置LED发送卡端口参数
  NET_DVR_GET_LED_DISPLAY_CFG = 9238;    //获取LED发送卡显示参数
  NET_DVR_SET_LED_DISPLAY_CFG = 9239;    //设置LED发送卡显示参数
  NET_DVR_GET_ALL_LED_PORT_CFG = 9240;    //获取LED发送卡某个输出对应
  NET_DVR_SAVE_LED_CONFIGURATION = 9241;    //参数固化
  NET_DVR_GET_LED_TEST_SIGNAL_CFG = 9242;    //获取LED屏测试信号参数
  NET_DVR_SET_LED_TEST_SIGNAL_CFG = 9243;    //设置LED屏测试信号参数
  NET_DVR_GET_LED_NOSIGNAL_CFG = 9244;    //获取LED屏无信号显示模式参数
  NET_DVR_SET_LED_NOSIGNAL_CFG = 9245;    //设置LED屏无信号显示模式参数
  NET_DVR_GET_LED_INPUT_CFG = 9246;    //获取LED发送卡输入参数
  NET_DVR_SET_LED_INPUT_CFG = 9247;    //设置LED发送卡输入参数
  NET_DVR_GET_LED_RECV_GAMMA_CFG = 9248;    //获取接收卡GAMMA表参数
  NET_DVR_SET_LED_RECV_GAMMA_CFG = 9249;    //设置接收卡GAMMA表参数
  NET_DVR_GET_LED_RECV_CFG = 9250;    //获取接收卡基本参数
  NET_DVR_SET_LED_RECV_CFG = 9251;    //设置接收卡基本参数
  NET_DVR_GET_LED_RECV_ADVANCED_CFG = 9252;    //获取接收卡高级参数
  NET_DVR_SET_LED_RECV_ADVANCED_CFG = 9253;    //设置接收卡高级参数
  NET_DVR_GET_LED_SCREEN_DISPLAY_CFG = 9254;    //获取LED屏显示参数
  NET_DVR_SET_LED_SCREEN_DISPLAY_CFG = 9255;    //设置LED屏显示参数
//******************************小间距LED显示屏 end****************************************

const
  NET_DVR_GET_INSERTPLAY_PROGRESS = 9273;    //获取插播进度

const
  NET_DVR_GET_SCREEN_CONFIG = 9260;    //获取屏幕服务器参数
  NET_DVR_SET_SCREEN_CONFIG = 9261;    //设置屏幕服务器参数
  NET_DVR_GET_SCREEN_CONFIG_CAP = 9262;    //获取屏幕服务器参数能力集

const
  NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS = 9271;    //获取日程发布进度
  NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS = 9272;    //获取信息发布终端升级进度

const
  NET_DVR_GET_INPUT_BOARD_CFG = 9281;    //获取输入板配置信息
  NET_DVR_GET_INPUT_BOARD_CFG_LIST = 9282;    //获取输入板配置信息列表
  NET_DVR_SET_INPUT_BOARD_CFG = 9283;    //设置输入板配置信息

const
  NET_DVR_GET_INPUT_SOURCE_TEXT_CAP = 9284;    //获取输入源字符叠加能力
  NET_DVR_GET_INPUT_SOURCE_TEXT_CFG = 9285;    //获取输入源字符叠加参数
  NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT = 9286;    //获取输入源字符叠加参数列表
  NET_DVR_SET_INPUT_SOURCE_TEXT_CFG = 9287;    //设置输入源字符叠加参数
  NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST = 9288;    //设置输入源字符叠加参数列表
  NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP = 9289;    //获取输入源自定义分辨率能力
  NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG = 9290;    //获取输入源自定义分辨率参数
  NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST = 9291;    //获取输入源自定义分辨率列表
  NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG = 9292;    //设置输入源自定义分辨率参数
  NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST = 9293;    //设置输入源自定义分辨率参数
  NET_DVR_GET_LED_AREA_INFO_LIST = 9295;    //获取LED区域列表

const
  NET_DVR_GET_DISPINPUT_CFG = 9296;    //获取显示输入参数
  NET_DVR_GET_DISPINPUT_CFG_LIST = 9297;    //获取所有显示输入参数
  NET_DVR_SET_DISPINPUT_CFG = 9298;    //设置显示输入参数
  NET_DVR_GET_DISPINPUT_CFG_CAP = 9299;    //获取显示输入参数能力集
  NET_DVR_GET_CURRENT_VALID_PORT = 9300;    //获取当前有效的,可以连接的端口

const
  NET_DVR_SET_ONLINE_UPGRADE = 9301;    //允许在线升级
  NET_DVR_GET_ONLINEUPGRADE_PROGRESS = 9302;    //获取在线升级进度
  NET_DVR_GET_FIRMWARECODE = 9303;    //获取识别码
  NET_DVR_GET_ONLINEUPGRADE_SERVER = 9304;    //获取升级服务器状态
  NET_DVR_GET_ONLINEUPGRADE_VERSION = 9305;    //获取新版本信息
  NET_DVR_GET_RECOMMEN_VERSION = 9306;    //检测是否推荐升级到此版本
  NET_DVR_GET_ONLINEUPGRADE_ABILITY = 9309;    //获取在线升级能力集

const
  NET_DVR_GET_FIBER_CONVERT_BASIC_INFO_V50 = 9310;    //获取远端网管收发器基本信息V50
  NET_DVR_GET_FIBER_CONVERT_WORK_STATE_V50 = 9311;    //获取远端网管收发器工作状态

const
  NET_SDK_LED_SCREEN_CHECK = 9312;    //LED屏幕校正
  NET_SDK_GENERATE_OUTPUT_CONTROL = 9315;    //通用扩展输出口模块控制
  NET_SDK_GET_MATRIX_STATUS_V51 = 9313;    //获取视频综合平台状态

//DS-19D2000-S V2.0升级 报警联动配置参数命令码
const
  NET_DVR_GET_ALARM_LINKAGE_CFG = 9316;    //获取动环报警联动配置参数
  NET_DVR_SET_ALARM_LINKAGE_CFG = 9317;    //设置动环报警联动配置参数


const
  NET_DVR_GET_RS485_WORK_MODE = 10001;    //获取RS485串口工作模式
  NET_DVR_SET_RS485_WORK_MODE = 10002;    //设置RS485串口工作模式
  NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG = 10003;    //获取码分器透明通道参数
  NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG = 10004;    //设置码分器透明通道参数

const
  NET_DVR_GET_RS485_PROTOCOL_VERSION = 10301;    //获取RS485协议库版本信息
  NET_DVR_ALARMHOST_REGISTER_DETECTOR = 10302;    //自动注册探测器

const
  NET_DVR_GET_SIP_CFG = 11001;    //IP可视化机获取SIP参数
  NET_DVR_SET_SIP_CFG = 11002;    //IP可视化机设置SIP参数
  NET_DVR_GET_IP_VIEW_DEVCFG = 11003;    //获取IP对讲分机配置
  NET_DVR_SET_IP_VIEW_DEVCFG = 11004;    //设置IP对讲分机配置
  NET_DVR_GET_IP_VIEW_AUDIO_CFG = 11005;    //获取IP对讲分机音频参数
  NET_DVR_SET_IP_VIEW_AUDIO_CFG = 11006;    //设置IP对讲分机音频参数
  NET_DVR_GET_IP_VIEW_CALL_CFG = 11007;    //获取IP对讲分机呼叫参数
  NET_DVR_SET_IP_VIEW_CALL_CFG = 11008;    //设置IP对讲分机呼叫参数
  NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG = 11009;    //获取声音超限配置参数
  NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG = 11010;    //设置声音超限配置参数
  NET_DVR_GET_BUTTON_DOWN_ALARM_CFG = 11011;    //获取按钮按下告警配置参数
  NET_DVR_SET_BUTTON_DOWN_ALARM_CFG = 11012;    //设置按钮按下告警配置参数

const
  NET_DVR_GET_ISCSI_CFG = 11070;    // 获取ISCSI存储配置协议
  NET_DVR_SET_ISCSI_CFG = 11071;    // 获取ISCSI存储配置协议

const
  NET_DVR_GET_SECURITYMODE = 12004;    //获取当前安全模式
//2013-11-21 获取设备当前的温度和湿度
const
  NET_DVR_GET_TEMP_HUMI = 12005;    

//2014-02-15 民用IPC自动化测试项目
const
  NET_DVR_SET_ALARMSOUNDMODE = 12006;    //设置报警声音模式
  NET_DVR_GET_ALARMSOUNDMODE = 12007;    //获取报警声音模式

const
  NET_DVR_SET_IPDEVICE_ACTIVATED = 13000;    //通过NVR激活前端设备
  NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS = 13001;    //获取数字通道对应设备安全状态
  NET_DVR_GET_ACTIVATE_IPC_ABILITY = 13003;    //获取NVR激活IPC能力集


//******************************楼宇可视对讲机 start**********************************
const
  NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG = 16001;    //获取可视对讲设备编号
  NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG = 16002;    //设置可视对讲设备编号
  NET_DVR_SET_PRIVILEGE_PASSWORD = 16003;    //设置权限密码配置信息
  NET_DVR_GET_OPERATION_TIME_CFG = 16004;    //获取操作时间配置
  NET_DVR_SET_OPERATION_TIME_CFG = 16005;    //设置操作时间配置
  NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG = 16006;    //获取关联网络设备参数
  NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG = 16007;    //设置关联网络设备参数
  NET_DVR_REMOTECONTROL_NOTICE_DATA = 16008;    //公告信息下发
  NET_DVR_REMOTECONTROL_GATEWAY = 16009;    //远程开锁
  NET_DVR_REMOTECONTROL_OPERATION_AUTH = 16010;    //操作权限验证

const
  NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG = 16016;    //获取IO输入参数
  NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG = 16017;    //设置IO输入参数
  NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG = 16018;    //获取IO输出参数
  NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG = 16019;    //设置IO输出参数
  NET_DVR_GET_ELEVATORCONTROL_CFG = 16020;    //获取梯控器参数
  NET_DVR_SET_ELEVATORCONTROL_CFG = 16021;    //设置梯控器参数
  NET_DVR_GET_VIDEOINTERCOM_STREAM = 16022;    //获取可视对讲流通道参数
  NET_DVR_SET_VIDEOINTERCOM_STREAM = 16023;    //设置可视对讲流通道参数
  NET_DVR_GET_WDR_CFG = 16024;    //获取宽动态参数配置
  NET_DVR_SET_WDR_CFG = 16025;    //设置宽动态参数配置
  NET_DVR_GET_VIS_DEVINFO = 16026;    //获取可设备编号信息
  NET_DVR_GET_VIS_REGISTER_INFO = 16027;    //获取可设备注册的设备信息
  NET_DVR_GET_ELEVATORCONTROL_CFG_V40 = 16028;    //获取梯控器参数-扩展
  NET_DVR_SET_ELEVATORCONTROL_CFG_V40 = 16029;    //设置梯控器参数-扩展
  NET_DVR_GET_CALL_ROOM_CFG = 16030;    //获取按键呼叫住户配置
  NET_DVR_SET_CALL_ROOM_CFG = 16031;    //设置按键呼叫住户配置
  NET_DVR_VIDEO_CALL_SIGNAL_PROCESS = 16032;    //可视话对讲信令处理
  NET_DVR_GET_CALLER_INFO = 16033;    //获取主叫长号信息
  NET_DVR_GET_CALL_STATUS = 16034;    //获取通话状态
  NET_DVR_GET_SERVER_DEVICE_INFO = 16035;    //获取设备列表
  NET_DVR_SET_CALL_SIGNAL = 16036;    //可视对讲手机端发送信令
  NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG = 16037;    //获取可视对讲报警事件参数
  NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG = 16038;    //设置可视对讲报警事件参数
  NET_DVR_GET_RING_LIST = 16039;    //查询铃音参数列表

const
  NET_DVR_GET_ROOM_CUSTOM_CFG = 16040;    //房间自定义获取
  NET_DVR_SET_ROOM_CUSTOM_CFG = 16041;    //房间自定义设置
  NET_DVR_GET_ELEVATORCONTROL_CFG_V50 = 16042;    //获取梯控器参数V50
  NET_DVR_SET_ELEVATORCONTROL_CFG_V50 = 16043;    //设置梯控器参数V50
  NET_DVR_GET_SIP_CFG_V50 = 16044;    //获取SIP参数V50
  NET_DVR_SET_SIP_CFG_V50 = 16045;    //设置SIP参数V50
  NET_DVR_GET_NOTICE_VIDEO_DATA = 16050;    //公告视频获取

//******************************楼宇可视对讲机 end**********************************

const
  NET_DVR_DEBUGINFO_START = 18000;    //网传设备调试信息启动命令
  NET_DVR_AUTO_TEST_START = 18001;    //自动测试长连接获取

const
  NET_DVR_GET_SELFCHECK_RESULT = 20000;    //获取设备自检结果
  NET_DVR_SET_TEST_COMMAND = 20001;    //设置测试控制命令
  NET_DVR_SET_TEST_DEVMODULE = 20002;    //设置测试硬件模块控制命令
  NET_DVR_GET_TEST_DEVMODULE = 20003;    //获取测试硬件模块控制命令

const
  NET_DVR_SET_AUTOFOCUS_TEST = 20004;    //保存自动对焦参数 2013-10-26
  NET_DVR_CHECK_USER_STATUS = 20005;    //检测用户是否在线
  NET_DVR_GET_TEST_COMMAND = 20010;    //获取测试控制命令
  NET_DVR_GET_DIAL_SWITCH_CFG = 20200;    //获取拨码开关信息
  NET_DVR_SET_AGING_TRICK_SCAN = 20201;    //设置老化前后工具参数
  NET_DVR_GET_ECCENTRIC_CORRECT_STATE = 20202;    //获取获取偏心校正状态

const
  NET_DVR_GET_THERMOMETRYRULE_TEMPERATURE_INFO = 23001;    //手动获取测温规则温度信息

const
  NET_DVR_T1_TEST_CMD = 131073;    //当测试命令来用，通过数据区域的文本内容区分具体做什么.数据长度不得大于1024
//数据区格式为：<T1TestCmd type="0"/>//恢复设备默认参数并关机。

// 美分定制菜单输出模式外部命令
const
  NET_DVR_GET_MEMU_OUTPUT_MODE = 155649;    // 获取菜单输出模式
  NET_DVR_SET_MEMU_OUTPUT_MODE = 155650;    // 设置菜单输出模式

//**************************DS9000新增命令(_V30) end ****************************

const
  NET_DVR_GET_DEV_LOGIN_RET_INFO = 16777200;    //设备登陆返回参数


const
  NET_DVR_GET_TEST_VERSION_HEAD = 268435441;    //获取测试版本头
  NET_DVR_SET_TEST_VERSION_HEAD = 268435442;    //设置测试版本头
  NET_DVR_GET_TEST_VERSION_HEAD_V1 = 268435443;    //获取测试版本头-第二版
  NET_DVR_SET_TEST_VERSION_HEAD_V1 = 268435444;    //设置测试版本头-第二版
  NET_DVR_GET_TEST_VERSION_HEAD_V2 = 268435445;    //获取测试版本头-第三版
  NET_DVR_SET_TEST_VERSION_HEAD_V2 = 268435446;    //设置测试版本头-第三版

const
  NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0 = 268435447;    //获取测试版本头,当前仅有一个版本
  NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0 = 268435448;    //设置测试版本头,当前仅有一个版本


const
  MAX_LOCAL_ADDR_LEN = 96;    //SOCKS最大本地网段个数
  MAX_COUNTRY_NAME_LEN = 4;    //国家简写名称长度

//***********************DVR日志 begin**************************

// 报警 
//主类型
const
  MAJOR_ALARM = $1;    
//次类型
const
  MINOR_ALARM_IN = $1;    // 报警输入 
  MINOR_ALARM_OUT = $2;    // 报警输出 
  MINOR_MOTDET_START = $3;    // 移动侦测报警开始 
  MINOR_MOTDET_STOP = $4;    // 移动侦测报警结束 
  MINOR_HIDE_ALARM_START = $5;    // 遮挡报警开始 
  MINOR_HIDE_ALARM_STOP = $6;    // 遮挡报警结束 
  MINOR_VCA_ALARM_START = $7;    //智能报警开始
  MINOR_VCA_ALARM_STOP = $8;    //智能报警停止
  MINOR_ITS_ALARM_START = $09;    // 交通事件报警开始
  MINOR_ITS_ALARM_STOP = $0A;    // 交通事件报警结束
//2010-11-10 网络报警日志
const
  MINOR_NETALARM_START = $0b;    //网络报警开始
  MINOR_NETALARM_STOP = $0c;    //网络报警结束
//2010-12-16 报警板日志，与"MINOR_ALARM_IN"配对使用
const
  MINOR_NETALARM_RESUME = $0d;    //网络报警恢复
//2012-4-5 IPC PIR、无线、呼救报警
const
  MINOR_WIRELESS_ALARM_START = $0e;    // 无线报警开始 
  MINOR_WIRELESS_ALARM_STOP = $0f;    // 无线报警结束 
  MINOR_PIR_ALARM_START = $10;    // 人体感应报警开始 
  MINOR_PIR_ALARM_STOP = $11;    // 人体感应报警结束 
  MINOR_CALLHELP_ALARM_START = $12;    // 呼救报警开始 
  MINOR_CALLHELP_ALARM_STOP = $13;    // 呼救报警结束 
  MINOR_IPCHANNEL_ALARMIN_START = $14;    //数字通道报警输入开始：PCNVR在接收到数字通道的MINOR_ALARM_IN产生“数字通道报警输入开始”，10s，再收不到MINOR_ALARM_IN，产生“数字通道报警输入结束”
  MINOR_IPCHANNEL_ALARMIN_STOP = $15;    //数字通道报警输入开始：同上
  MINOR_DETECTFACE_ALARM_START = $16;    // 人脸侦测报警开始 
  MINOR_DETECTFACE_ALARM_STOP = $17;    // 人脸侦测报警结束 
  MINOR_VQD_ALARM_START = $18;    //VQD报警
  MINOR_VQD_ALARM_STOP = $19;    //VQD报警结束
  MINOR_VCA_SECNECHANGE_DETECTION = $1a;    //场景侦测报警 2013-07-16

const
  MINOR_SMART_REGION_EXITING_BEGIN = $1b;    //离开区域侦测开始
  MINOR_SMART_REGION_EXITING_END = $1c;    //离开区域侦测结束
  MINOR_SMART_LOITERING_BEGIN = $1d;    //徘徊侦测开始
  MINOR_SMART_LOITERING_END = $1e;    //徘徊侦测结束

const
  MINOR_VCA_ALARM_LINE_DETECTION_BEGIN = $20;    
  MINOR_VCA_ALARM_LINE_DETECTION_END = $21;    
  MINOR_VCA_ALARM_INTRUDE_BEGIN = $22;    //区域侦测开始
  MINOR_VCA_ALARM_INTRUDE_END = $23;    //区域侦测结束
  MINOR_VCA_ALARM_AUDIOINPUT = $24;    //音频异常输入
  MINOR_VCA_ALARM_AUDIOABNORMAL = $25;    //声强突变
  MINOR_VCA_DEFOCUS_DETECTION_BEGIN = $26;    //虚焦侦测开始
  MINOR_VCA_DEFOCUS_DETECTION_END = $27;    //虚焦侦测结束

//民用NVR
const
  MINOR_EXT_ALARM = $28;    //IPC外部报警
  MINOR_VCA_FACE_ALARM_BEGIN = $29;    //人脸侦测开始
  MINOR_SMART_REGION_ENTRANCE_BEGIN = $2a;    //进入区域侦测开始
  MINOR_SMART_REGION_ENTRANCE_END = $2b;    //进入区域侦测结束
  MINOR_SMART_PEOPLE_GATHERING_BEGIN = $2c;    //人员聚集侦测开始
  MINOR_SMART_PEOPLE_GATHERING_END = $2d;    //人员聚集侦测结束
  MINOR_SMART_FAST_MOVING_BEGIN = $2e;    //快速运动侦测开始
  MINOR_SMART_FAST_MOVING_END = $2f;    //快速运动侦测结束

const
  MINOR_VCA_FACE_ALARM_END = $30;    //人脸侦测结束
  MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN = $31;    //场景变更侦测开始
  MINOR_VCA_SCENE_CHANGE_ALARM_END = $32;    //场景变更侦测结束
  MINOR_VCA_ALARM_AUDIOINPUT_BEGIN = $33;    //音频异常输入开始
  MINOR_VCA_ALARM_AUDIOINPUT_END = $34;    //音频异常输入结束
  MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN = $35;    //声强突变侦测开始
  MINOR_VCA_ALARM_AUDIOABNORMAL_END = $36;    //声强突变侦测结束

const
  MINOR_VCA_LECTURE_DETECTION_BEGIN = $37;    //授课侦测开始报警
  MINOR_VCA_LECTURE_DETECTION_END = $38;    //授课侦测结束报警
  MINOR_VCA_ALARM_AUDIOSTEEPDROP = $39;    //声强陡降 2014-03-21
  MINOR_VCA_ANSWER_DETECTION_BEGIN = $3a;    //回答问题侦测开始报警
  MINOR_VCA_ANSWER_DETECTION_END = $3b;    //回答问题侦测结束报警

const
  MINOR_SMART_PARKING_BEGIN = $3c;    //停车侦测开始
  MINOR_SMART_PARKING_END = $3d;    //停车侦测结束
  MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN = $3e;    //物品遗留侦测开始
  MINOR_SMART_UNATTENDED_BAGGAGE_END = $3f;    //物品遗留侦测结束
  MINOR_SMART_OBJECT_REMOVAL_BEGIN = $40;    //物品拿取侦测开始
  MINOR_SMART_OBJECT_REMOVAL_END = $41;    //物品拿取侦测结束
  MINOR_SMART_VEHICLE_ALARM_START = $46;    //车牌检测开始
  MINOR_SMART_VEHICLE_ALARM_STOP = $47;    //车牌检测结束
  MINOR_THERMAL_FIREDETECTION = $48;    //热成像火点检测侦测开始
  MINOR_THERMAL_FIREDETECTION_END = $49;    //热成像火点检测侦测结束
  MINOR_SMART_VANDALPROOF_BEGIN = $50;    //防破坏检测开始
  MINOR_SMART_VANDALPROOF_END = $51;    //防破坏检测结束

const
  MINOR_FACESNAP_MATCH_ALARM_START = $55;    //人脸比对报警开始
  MINOR_FACESNAP_MATCH_ALARM_STOP = $56;    //人脸比对报警结束
  MINOR_ALLOWLIST_FACESNAP_MATCH_ALARM_START = $57;    //允许名单人脸比对（陌生人）报警开始
  MINOR_ALLOWLIST_FACESNAP_MATCH_ALARM_STOP = $58;    //允许名单人脸比对（陌生人）报警结束

const
  MINOR_THERMAL_SHIPSDETECTION = $5a;    //热成像船只检测侦测
  MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN = $5b;    //热成像测温预警开始
  MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END = $5c;    //热成像测温预警结束
  MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN = $5d;    //热成像测温报警开始
  MINOR_THERMAL_THERMOMETRY_ALARM_END = $5e;    //热成像测温报警结束
  MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN = $5f;    //热成像温差报警开始
  MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END = $60;    //热成像温差报警结束
  MINOR_FACE_THERMOMETRY_ALARM = $63;    //人脸测温报警
  MINOR_SMART_DENSEFOGDETECTION_BEGIN = $6e;    //大雾侦测开始
  MINOR_SMART_DENSEFOGDETECTION_END = $6f;    //大雾侦测结束
  MINOR_RUNNING_ALARM = $70;    //奔跑检测
  MINOR_RETENTION_ALARM = $71;    //滞留检测
  MINOR_SAFETY_HELMET_ALARM_START = $72;    //未佩戴安全帽检测报警开始
  MINOR_SAFETY_HELMET_ALARM_STOP = $73;    //未佩戴安全帽检测报警结束
  MINOR_HFPD_ALARM_START = $74;    //高频人员检测报警开始
  MINOR_HFPD_ALARM_STOP = $75;    //高频人员检测报警结束
  MINOR_MIXED_TARGET_ALARM_START = $76;    //混合目标检测报警开始
  MINOR_MIXED_TARGET_ALARM_STOP = $77;    //混合目标检测报警结束
  MINOR_VCA_PLAY_CELLPHONE_ALARM_BEGIN = $78;    //玩手机检测报警开始
  MINOR_VCA_PLAY_CELLPHONE_ALARM_END = $79;    //玩手机检测报警结束
  MINOR_VCA_GET_UP_ALARM_BEGIN = $80;    //起床检测报警开始
  MINOR_VCA_GET_UP_ALARM_END = $81;    //起床检测报警结束
  MINOR_VCA_ADV_REACH_HEIGHT_ALARM_BEGIN = $82;    //折线攀高报警开始
  MINOR_VCA_ADV_REACH_HEIGHT_ALARM_END = $83;    //折线攀高报警结束
  MINOR_VCA_TOILET_TARRY_ALARM_BEGIN = $84;    //如厕超时报警开始
  MINOR_VCA_TOILET_TARRY_ALARM_END = $85;    //如厕超时报警结束
  MINOR_HUMAN_RECOGNITION_ALARM_BEGIN = $86;    //人体识别报警开始
  MINOR_HUMAN_RECOGNITION_ALARM_END = $87;    //人体识别报警结束
  MINOR_STUDENTS_STOODUP_ALARM_BEGIN = $88;    //学生起立报警开始
  MINOR_STUDENTS_STOODUP_ALARM_END = $89;    //学生起立报警结束
  MINOR_FRAMES_PEOPLE_COUNTING_ALARM = $8a;    //区域人数统计报警
  MINOR_FACE_SNAP_ALARM_BEGIN = $8b;    //人脸抓拍报警开始
  MINOR_FACE_SNAP_ALARM_END = $8c;    //人脸抓拍报警结束
  MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_BEGIN = $8d;    //教师行为检测报警开始
  MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_END = $8e;    //教师行为检测报警结束
  MINOR_PERIMETER_CAPTURE_ALARM_BEGIN = $8f;    //周界抓拍报警开始
  MINOR_PERIMETER_CAPTURE_ALARM_END = $90;    //周界抓拍报警结束
  MINOR_UNREGISTERED_STREET_VENDOR_ALARM = $91;    //非法摆摊报警

const
  MINOR_PERSON_QUEUE_TIME_ALARM_BEGIN = $92;    //排队时长检测报警开始
  MINOR_PERSON_QUEUE_TIME_ALARM_END = $93;    //排队时长检测报警结束
  MINOR_PERSON_QUEUE_COUNTING_ALARM_BEGIN = $94;    //排队人数检测报警开始
  MINOR_PERSON_QUEUE_COUNTING_ALARM_END = $95;    //排队人数检测报警结束
  MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_START = $96;    //人脸比对失败报警开始
  MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_END = $97;    //人脸比对失败报警结束


const
  MINOR_ACCESS_CONTROLLER_EVENT = $100;    //门禁主机事件
  MINOR_VIDEO_INTERCOM_EVENT = $101;    //可视对讲设备事件
  MINOR_GJD_EVENT = $102;    //GJD报警主机事件
  MINOR_LUMINITE_EVENT = $103;    // LUMINITE报警主机事件
  MINOR_OPTEX_EVENT = $104;    // OPTEX报警主机事件
  MINOR_CAMERA_DETECTOR_EVENT = $105;    // 传感器事件
  MINOR_SECURITY_CONTROL_PANEL_EVENT = $106;    //私有报警主机事件

const
  MINOR_VCA_SPACE_CHANGE_START = $10c;    //间距异常检测开始
  MINOR_VCA_SPACE_CHANGE_STOP = $10d;    //间距异常检测结束
  MINOR_MANUAL_ALARM = $10e;    //手动报警
  MINOR_DETECTOR_ALARM = $10f;    //探测器报警
  MINOR_LINKAGE_ALARM = $110;    //联动报警
  MINOR_VCA_SITUATION_ANALYSIS_START = $111;    //态势分析检测开始
  MINOR_VCA_SITUATION_ANALYSIS_STOP = $112;    //态势分析检测结束
  MINOR_FIRE_ALARM = $113;    //火警报警
  MINOR_SUPERVISE_ALARM = $114;    //监管报警
  MINOR_SHIELD_ALARM = $115;    //屏蔽报警
  MINOR_ABNORMAL_ALARM = $116;    //故障报警
  MINOR_RESIDUAL_CURRENT_ALARM = $117;    //剩余电流报警
  MINOR_TEMPERATURE_ALARM = $118;    //温度报警
  MINOR_ARC_ALARM = $119;    //电弧报警

const
  MINOR_VCA_YARD_TARRY_ALARM_BEGIN = $11a;    //放风场滞留报警开始
  MINOR_VCA_YARD_TARRY_ALARM_END = $11b;    //放风场滞留报警结束
  MINOR_VCA_KEY_PERSON_GET_UP_ALARM_BEGIN = $11c;    //重点人员起身报警开始
  MINOR_VCA_KEY_PERSON_GET_UP_ALARM_END = $11d;    //重点人员起身报警结束
  MINOR_VCA_SIT_QUIETLY_ALARM_BEGIN = $11e;    //一动不动报警开始
  MINOR_VCA_SIT_QUIETLY_ALARM_END = $11f;    //一动不动报警结束
  MINOR_VCA_STAND_UP_ALARM_BEGIN = $120;    //站立报警开始
  MINOR_VCA_STAND_UP_ALARM_END = $121;    //站立报警结束
  MINOR_VCA_REACH_HIGHT_ALARM_BEGIN = $122;    //攀高报警开始
  MINOR_VCA_REACH_HIGHT_ALARM_END = $123;    //攀高报警结束

const
  MINOR_LFPD_ALARM_START = $124;    //低频人员检测报警开始
  MINOR_LFPD_ALARM_STOP = $125;    //低频人员检测报警结束

const
  MINOR_DREDGERDETECTION_ALARM = $126;    // 挖沙船检测报警
  MINOR_STUDENT_BEHAVIOR_ALARM_BEGIN = $127;    //课堂学生行为报警开始
  MINOR_STUDENT_BEHAVIOR_ALARM_END = $128;    //课堂学生行为报警结束
  MINOR_VCA_ALARM_VEHICLEMONITOR = $129;    //车辆布防报警(用于车辆布防第一次上来车辆检测（带车辆布防信息）的日志)
  MINOR_WASTEGASDETECTION_ALARM = $130;    // 废气排放显示事件上报
  MINOR_GREYSCALE_ALARM = $131;    // 灰度报警
  MINOR_VIBRATION_DETECTION_ALARM_BEGIN = $132;    //振动侦测报警开始
  MINOR_VIBRATION_DETECTION_ALARM_END = $133;    //振动侦测报警结束
  MINOR_SMOKE_DETECT_ALARM_BEGIN = $134;    //抽烟检测报警开始
  MINOR_SMOKE_DETECT_ALARM_END = $135;    //抽烟检测报警结束
  MINOR_METHANE_CONCENTRATION_ALARM = $136;    //甲烷浓度异常事件
  MINOR_METHANE_LIGHTINTENSITY_ALARM = $137;    //甲烷光强异常事件
  MINOR_SMOG_BEGIN = $138;    //烟雾报警开始
  MINOR_SMOG_END = $139;    //烟雾报警结束
  MINOR_VOCS_ALARM = $140;    //VOCs气体报警

//0x400-0x1000 门禁报警
const
  MINOR_ALARMIN_SHORT_CIRCUIT = $400;    //防区短路报警
  MINOR_ALARMIN_BROKEN_CIRCUIT = $401;    //防区断路报警
  MINOR_ALARMIN_EXCEPTION = $402;    //防区异常报警
  MINOR_ALARMIN_RESUME = $403;    //防区报警恢复
  MINOR_HOST_DESMANTLE_ALARM = $404;    //设备防拆报警
  MINOR_HOST_DESMANTLE_RESUME = $405;    //设备防拆恢复
  MINOR_CARD_READER_DESMANTLE_ALARM = $406;    //读卡器防拆报警
  MINOR_CARD_READER_DESMANTLE_RESUME = $407;    //读卡器防拆恢复
  MINOR_CASE_SENSOR_ALARM = $408;    //事件输入报警
  MINOR_CASE_SENSOR_RESUME = $409;    //事件输入恢复
  MINOR_STRESS_ALARM = $40a;    //胁迫报警
  MINOR_OFFLINE_ECENT_NEARLY_FULL = $40b;    //离线事件满90%报警
  MINOR_CARD_MAX_AUTHENTICATE_FAIL = $40c;    //卡号认证失败超次报警
  MINOR_SD_CARD_FULL = $40d;    //SD卡存储满报警
  MINOR_LINKAGE_CAPTURE_PIC = $40e;    //联动抓拍事件报警
  MINOR_SECURITY_MODULE_DESMANTLE_ALARM = $40f;    //门控安全模块防拆报警
  MINOR_SECURITY_MODULE_DESMANTLE_RESUME = $410;    //门控安全模块防拆恢复

const
  MINOR_POS_START_ALARM = $411;    //POS开启
  MINOR_POS_END_ALARM = $412;    //POS结束
  MINOR_FACE_IMAGE_QUALITY_LOW = $413;    //人脸图像画质低
  MINOR_FINGE_RPRINT_QUALITY_LOW = $414;    //指纹图像画质低
  MINOR_FIRE_IMPORT_SHORT_CIRCUIT = $415;    //消防输入短路报警
  MINOR_FIRE_IMPORT_BROKEN_CIRCUIT = $416;    //消防输入断路报警
  MINOR_FIRE_IMPORT_RESUME = $417;    //消防输入恢复
  MINOR_FIRE_BUTTON_TRIGGER = $418;    //消防按钮触发
  MINOR_FIRE_BUTTON_RESUME = $419;    //消防按钮恢复
  MINOR_MAINTENANCE_BUTTON_TRIGGER = $41a;    //维护按钮触发
  MINOR_MAINTENANCE_BUTTON_RESUME = $41b;    //维护按钮恢复
  MINOR_EMERGENCY_BUTTON_TRIGGER = $41c;    //紧急按钮触发
  MINOR_EMERGENCY_BUTTON_RESUME = $41d;    //紧急按钮恢复
  MINOR_DISTRACT_CONTROLLER_ALARM = $41e;    //分控器防拆报警
  MINOR_DISTRACT_CONTROLLER_RESUME = $41f;    //分控器防拆报警恢复

const
  MINOR_PERSON_DENSITY_DETECTION_START = $420;    //人员密度超阈值报警开始
  MINOR_PERSON_DENSITY_DETECTION_END = $421;    //人员密度超阈值报警结束

const
  MINOR_CHANNEL_CONTROLLER_DESMANTLE_ALARM = $422;    //通道控制器防拆报警
  MINOR_CHANNEL_CONTROLLER_DESMANTLE_RESUME = $423;    //通道控制器防拆报警恢复
  MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM = $424;    //通道控制器消防输入报警
  MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME = $425;    //通道控制器消防输入报警恢复

const
  MINOR_HEART_RATE_ABNORMAL_BEGIN = $426;    //心率异常报警开始
  MINOR_HEART_RATE_ABNORMAL_END = $427;    //心率异常报警结束
  MINOR_BLOOD_OXYGEN_ABNORMAL_BEGIN = $428;    //血氧异常报警开始
  MINOR_BLOOD_OXYGEN_ABNORMAL_END = $429;    //血氧异常报警结束
  MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN = $42a;    //血压收缩压异常报警开始
  MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_END = $42b;    //血压收缩压异常报警结束
  MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN = $42c;    //血压舒张压异常报警开始
  MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_END = $42d;    //血压舒张压异常报警结束
  MINOR_VCA_LEAVE_POSITION_START = $42e;    //离岗检测开始
  MINOR_VCA_LEAVE_POSITION_STOP = $42f;    //离岗检测结束
  MINOR_VCA_STOOODUP_START = $430;    //起立检测开始
  MINOR_VCA_STOOODUP_STOP = $431;    //起立检测结束
  MINOR_VCA_PEOPLENUM_CHANGE_START = $434;    //人数变化开始
  MINOR_VCA_PEOPLENUM_CHANGE_STOP = $435;    //人数变化结束
  MINOR_VCA_RUNNING_START = $438;    //人员奔跑开始
  MINOR_VCA_RUNNING_STOP = $439;    //人员奔跑结束
  MINOR_VCA_VIOLENT_MOTION_START = $43a;    //剧烈运动开始
  MINOR_VCA_VIOLENT_MOTION_STOP = $43b;    //剧烈运动结束
  MINOR_VCA_FAIL_DOWN_START = $43c;    //人员倒地开始
  MINOR_VCA_FAIL_DOWN_STOP = $43d;    //人员倒地结束
  MINOR_VCA_RETENTION_START = $43e;    //人员滞留开始
  MINOR_VCA_RETENTION_STOP = $43f;    //人员滞留结束

const
  MINOR_PRINTER_OUT_OF_PAPER = $440;    //打印机缺纸报警
  MINOR_LEGAL_EVENT_NEARLY_FULL = $442;    //离线合法事件满90%报警
  MINOR_FIRE_IMPORT_ALARM = $443;    //消防输入报警
  MINOR_TRANSACTION_RECORD_NEARLY_FULL = $444;    //交易记录满90%报警

const
  MINOR_ALARM_CUSTOM1 = $900;    //门禁自定义报警1
  MINOR_ALARM_CUSTOM2 = $901;    //门禁自定义报警2
  MINOR_ALARM_CUSTOM3 = $902;    //门禁自定义报警3
  MINOR_ALARM_CUSTOM4 = $903;    //门禁自定义报警4
  MINOR_ALARM_CUSTOM5 = $904;    //门禁自定义报警5
  MINOR_ALARM_CUSTOM6 = $905;    //门禁自定义报警6
  MINOR_ALARM_CUSTOM7 = $906;    //门禁自定义报警7
  MINOR_ALARM_CUSTOM8 = $907;    //门禁自定义报警8
  MINOR_ALARM_CUSTOM9 = $908;    //门禁自定义报警9
  MINOR_ALARM_CUSTOM10 = $909;    //门禁自定义报警10
  MINOR_ALARM_CUSTOM11 = $90a;    //门禁自定义报警11
  MINOR_ALARM_CUSTOM12 = $90b;    //门禁自定义报警12
  MINOR_ALARM_CUSTOM13 = $90c;    //门禁自定义报警13
  MINOR_ALARM_CUSTOM14 = $90d;    //门禁自定义报警14
  MINOR_ALARM_CUSTOM15 = $90e;    //门禁自定义报警15
  MINOR_ALARM_CUSTOM16 = $90f;    //门禁自定义报警16
  MINOR_ALARM_CUSTOM17 = $910;    //门禁自定义报警17
  MINOR_ALARM_CUSTOM18 = $911;    //门禁自定义报警18
  MINOR_ALARM_CUSTOM19 = $912;    //门禁自定义报警19
  MINOR_ALARM_CUSTOM20 = $913;    //门禁自定义报警20
  MINOR_ALARM_CUSTOM21 = $914;    //门禁自定义报警21
  MINOR_ALARM_CUSTOM22 = $915;    //门禁自定义报警22
  MINOR_ALARM_CUSTOM23 = $916;    //门禁自定义报警23
  MINOR_ALARM_CUSTOM24 = $917;    //门禁自定义报警24
  MINOR_ALARM_CUSTOM25 = $918;    //门禁自定义报警25
  MINOR_ALARM_CUSTOM26 = $919;    //门禁自定义报警26
  MINOR_ALARM_CUSTOM27 = $91a;    //门禁自定义报警27
  MINOR_ALARM_CUSTOM28 = $91b;    //门禁自定义报警28
  MINOR_ALARM_CUSTOM29 = $91c;    //门禁自定义报警29
  MINOR_ALARM_CUSTOM30 = $91d;    //门禁自定义报警30
  MINOR_ALARM_CUSTOM31 = $91e;    //门禁自定义报警31
  MINOR_ALARM_CUSTOM32 = $91f;    //门禁自定义报警32
  MINOR_ALARM_CUSTOM33 = $920;    //门禁自定义报警33
  MINOR_ALARM_CUSTOM34 = $921;    //门禁自定义报警34
  MINOR_ALARM_CUSTOM35 = $922;    //门禁自定义报警35
  MINOR_ALARM_CUSTOM36 = $923;    //门禁自定义报警36
  MINOR_ALARM_CUSTOM37 = $924;    //门禁自定义报警37
  MINOR_ALARM_CUSTOM38 = $925;    //门禁自定义报警38
  MINOR_ALARM_CUSTOM39 = $926;    //门禁自定义报警39
  MINOR_ALARM_CUSTOM40 = $927;    //门禁自定义报警40
  MINOR_ALARM_CUSTOM41 = $928;    //门禁自定义报警41
  MINOR_ALARM_CUSTOM42 = $929;    //门禁自定义报警42
  MINOR_ALARM_CUSTOM43 = $92a;    //门禁自定义报警43
  MINOR_ALARM_CUSTOM44 = $92b;    //门禁自定义报警44
  MINOR_ALARM_CUSTOM45 = $92c;    //门禁自定义报警45
  MINOR_ALARM_CUSTOM46 = $92d;    //门禁自定义报警46
  MINOR_ALARM_CUSTOM47 = $92e;    //门禁自定义报警47
  MINOR_ALARM_CUSTOM48 = $92f;    //门禁自定义报警48
  MINOR_ALARM_CUSTOM49 = $930;    //门禁自定义报警49
  MINOR_ALARM_CUSTOM50 = $931;    //门禁自定义报警50
  MINOR_ALARM_CUSTOM51 = $932;    //门禁自定义报警51
  MINOR_ALARM_CUSTOM52 = $933;    //门禁自定义报警52
  MINOR_ALARM_CUSTOM53 = $934;    //门禁自定义报警53
  MINOR_ALARM_CUSTOM54 = $935;    //门禁自定义报警54
  MINOR_ALARM_CUSTOM55 = $936;    //门禁自定义报警55
  MINOR_ALARM_CUSTOM56 = $937;    //门禁自定义报警56
  MINOR_ALARM_CUSTOM57 = $938;    //门禁自定义报警57
  MINOR_ALARM_CUSTOM58 = $939;    //门禁自定义报警58
  MINOR_ALARM_CUSTOM59 = $93a;    //门禁自定义报警59
  MINOR_ALARM_CUSTOM60 = $93b;    //门禁自定义报警60
  MINOR_ALARM_CUSTOM61 = $93c;    //门禁自定义报警61
  MINOR_ALARM_CUSTOM62 = $93d;    //门禁自定义报警62
  MINOR_ALARM_CUSTOM63 = $93e;    //门禁自定义报警63
  MINOR_ALARM_CUSTOM64 = $93f;    //门禁自定义报警64
  MINOR_LOCK_HIJIACK_FINGER_ALARM = $950;    //智能锁防劫持指纹报警
  MINOR_LOCK_HIJIACK_PASSWORD_ALARM = $951;    //智能锁防劫持密码报警
  MINOR_LOCK_PRY_DOOR_ALARM = $952;    //智能锁撬门报警
  MINOR_LOCK_LOCKED_ALARM = $953;    //智能锁锁定报警
  MINOR_LOCK_BATTERLOW_ALARM = $954;    //智能锁低电压报警
  MINOR_LOCK_BLOCKLIST_DOOR_ALARM = $955;    //智能锁禁止名单报警
  MINOR_LOCK_OFFLINE_ALARM = $956;    //智能锁离线报警
  MINOR_LOCK_UNCLOSED_ALARM = $957;    //智能锁虚掩报警
  MINOR_LOCK_NO_HOME_ALARM = $958;    //智能锁用户未回家报警
  MINOR_LOCK_MAGNETOMETER_ALARM = $959;    //门磁探测器报警
  MINOR_LOCK_IR_DETECTOR_ALARM = $95a;    //红外探测器报警
  MINOR_LOCK_FP_LOCKED_ALARM = $95b;    //指纹锁定报警
  MINOR_LOCK_PASSWORD_LOCKED_ALARM = $95c;    //密码锁定报警
  MINOR_LOCK_HIJIACK_ALARM = $95d;    //智能锁防劫持报警

//2018-04-23 通用物联网关报警日志类型
const
  MINOR_ALARMHOST_SHORT_CIRCUIT = $1001;    //短路报警
  MINOR_ALARMHOST_BROKEN_CIRCUIT = $1002;    //断路报警
  MINOR_ALARMHOST_ALARM_RESET = $1003;    //报警复位
  MINOR_ALARMHOST_ALARM_NORMAL = $1004;    //报警恢复正常
  MINOR_ALARMHOST_PASSWORD_ERROR = $1005;    //密码错误（连续3次输入密码错误）
  MINOR_ALARMHOST_ID_CARD_ILLEGALLY = $1006;    //非法感应卡ID
  MINOR_ALARMHOST_KEYPAD_REMOVE = $1007;    //键盘防拆
  MINOR_ALARMHOST_KEYPAD_REMOVE_RESTORE = $1008;    //键盘防拆复位

const
  MINOR_ALARMHOST_BELOW_ALARM_LIMIT1 = $1011;    //模拟量低于报警限1
  MINOR_ALARMHOST_BELOW_ALARM_LIMIT2 = $1012;    //模拟量低于报警限2
  MINOR_ALARMHOST_BELOW_ALARM_LIMIT3 = $1013;    //模拟量低于报警限3
  MINOR_ALARMHOST_BELOW_ALARM_LIMIT4 = $1014;    //模拟量低于报警限4
  MINOR_ALARMHOST_ABOVE_ALARM_LIMIT1 = $1015;    //模拟量高于报警限1
  MINOR_ALARMHOST_ABOVE_ALARM_LIMIT2 = $1016;    //模拟量高于报警限2
  MINOR_ALARMHOST_ABOVE_ALARM_LIMIT3 = $1017;    //模拟量高于报警限3
  MINOR_ALARMHOST_ABOVE_ALARM_LIMIT4 = $1018;    //模拟量高于报警限4

const
  MINOR_ALARMHOST_VIRTUAL_DEFENCE_SUSPECT = $1021;    //软防区匪警
  MINOR_ALARMHOST_VIRTUAL_DEFENCE_FIRE = $1022;    //软防区火警
  MINOR_ALARMHOST_VIRTUAL_DEFENCE_URGENT = $1023;    //软防区紧急

const
  MINOR_UPS_ALARM = $1028;    //UPS报警
  MINOR_ELECTRICITY_METER_ALARM = $1029;    //智能电表报警
  MINOR_SWITCH_POWER_ALARM = $1030;    //开关电源报警
  MINOR_GAS_DETECT_SYS_ALARM = $1031;    //气体检测系统报警
  MINOR_TRANSFORMER_TEMPRATURE_ALARM = $1032;    //变电器温显表报警
  MINOR_TEMP_HUMI_ALARM = $1033;    //温湿度传感器报警
  MINOR_UPS_ALARM_RESTORE = $1034;    //UPS报警恢复
  MINOR_ELECTRICITY_METER_ALARM_RESTORE = $1035;    //智能电表报警恢复
  MINOR_SWITCH_POWER_ALARM_RESTORE = $1036;    //开关电源报警恢复
  MINOR_GAS_DETECT_SYS_ALARM_RESTORE = $1037;    //气体检测系统报警恢复
  MINOR_TRANSFORMER_TEMPRATURE_ALARM_RESTORE = $1038;    //变电器温显表报警恢复
  MINOR_TEMP_HUMI_ALARM_RESTORE = $1039;    //温湿度传感器报警恢复
  MINOR_WATER_LEVEL_SENSOR_ALARM = $1040;    //水位传感器报警
  MINOR_WATER_LEVEL_SENSOR_ALARM_RESTORE = $1041;    //水位传感器报警恢复
  MINOR_DUST_NOISE_ALARM = $1042;    //扬尘噪声传感器报警
  MINOR_DUST_NOISE_ALARM_RESTORE = $1043;    //扬尘噪声传感器报警恢复
  MINOR_ENVIRONMENTAL_LOGGER_ALARM = $1044;    //环境采集仪报警
  MINOR_ENVIRONMENTAL_LOGGER_ALARM_RESTORE = $1045;    //环境采集仪报警恢复

const
  MINOR_TRIGGER_TAMPER = $1046;    //探测器防拆
  MINOR_TRIGGER_TAMPER_RESTORE = $1047;    //探测器防拆恢复
  MINOR_EMERGENCY_CALL_HELP_ALARM = $1048;    //紧急呼叫求助报警
  MINOR_EMERGENCY_CALL_HELP_ALARM_RESTORE = $1049;    //紧急呼叫求助报警恢复
  MINOR_CONSULTING_ALARM = $1050;    //业务咨询报警
  MINOR_CONSULTING_ALARM_RESTORE = $1051;    //业务咨询报警恢复
  MINOR_ALARMHOST_ZONE_MODULE_REMOVE = $1052;    //防区模块防拆
  MINOR_ALARMHOST_ZONE_MODULE_RESET = $1053;    //防区模块防拆复位

const
  MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM = $1054;    //风速传感器告警
  MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM_RESTORE = $1055;    //风速传感器告警恢复
  MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_ALARM = $1056;    //通用扩展输出模块告警
  MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_RESTORE = $1057;    //通用扩展输出模块告警恢复
  MINOR_ALARMHOST_ALARM_SOAK_ALARM = $1058;    //水浸传感器告警
  MINOR_ALARMHOST_ALARM_SOAK_ALARM_RESTORE = $1059;    //水浸传感器告警恢复
  MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM = $1060;    //太阳能传感器告警
  MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM_RESTORE = $1061;    //太阳能传感器告警恢复
  MINOR_ALARMHOST_ALARM_SF6_ALARM = $1062;    //SF6报警主机告警
  MINOR_ALARMHOST_ALARM_SF6_ALARM_RESTORE = $1063;    //SF6报警主机告警恢复
  MINOR_ALARMHOST_ALARM_WEIGHT_ALARM = $1064;    //称重仪告警
  MINOR_ALARMHOST_ALARM_WEIGHT_ALARM_RESTORE = $1065;    //称重仪告警恢复
  MINOR_ALARMHOST_ALARM_WEATHER_ALARM = $1066;    //气象采集系统告警
  MINOR_ALARMHOST_ALARM_WEATHER_ALARM_RESTORE = $1067;    //气象采集系统告警恢复
  MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM = $1068;    //燃气显示系统告警
  MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM_RESTORE = $1069;    //燃气显示系统告警恢
  MINOR_ALARMHOST_ALARM_FIRE_ALARM = $1070;    //火灾报警系统告警
  MINOR_ALARMHOST_ALARM_FIRE_ALARM_RESTORE = $1071;    //火灾报警系统告警恢复
  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_REMOVE = $1072;    //无线输出模块防拆
  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_RESET = $1073;    //无线输出模块防拆复位
  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_REMOVE = $1074;    //无线中继器防拆

const
  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_REMOVE = $1075;    //无线警号防拆
  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_RESET = $1076;    //无线警号防拆复位

const
  MINOR_RS485_DEV_ALARM = $1077;    //RS485外接设备报警（针对设备类型未知的设备）
  MINOR_RS485_DEV_RESTORE = $1078;    //RS485外接设备报警恢复（针对设备类型未知的设备）
  MINOR_ALARMHOST_ALARM_HOST_ALARM = $1079;    //消防主机报警
  MINOR_ALARMHOST_ALARM_HOST_RESTORE = $107a;    //消防主机报警恢复

const
  MINOR_AIR_CONDITION_DEV_ALARM = $107b;    //空调控制器报警
  MINOR_AIR_CONDITION_DEV_RESTORE = $107c;    //空调控制器报警恢复

const
  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_RESET = $107d;    //无线中继器防拆复位

const
  MINOR_ALARM_ELEVATOR_BREAKDOWN = $107e;    //电梯故障
  MINOR_WATER_PRESSURE_SENSOR_ALARM = $107f;    //水压传感器报警
  MINOR_FLOW_SENSOR_ALARM = $1080;    //流量传感器报警
  MINOR_SENSOR_LINKAGE_ALARM = $1081;    //传感器联动报警
  MINOR_SENSOR_LINKAGE_ALARM_RESTORE = $1082;    //传感器联动报警恢复
  MINOR_SHELF_ABNORMAL_ALARM = $1083;    //货架异常报警

//LED报警次类型 0x1201 ~ 0x1300
const
  MINOR_SYSTEM_CHECK_ALARM = $1201;    //系统检测报警

// 异常 
//主类型
const
  MAJOR_EXCEPTION = $2;    
//次类型
const
  MINOR_SUBSYSTEM_ERROR = $0a;    // 子系统异常 
  MINOR_RAID_ERROR = $20;    // 阵列异常 
  MINOR_VI_LOST = $21;    // 视频信号丢失 
  MINOR_ILLEGAL_ACCESS = $22;    // 非法访问 
  MINOR_HD_FULL = $23;    // 硬盘满 
  MINOR_HD_ERROR = $24;    // 硬盘错误 
  MINOR_DCD_LOST = $25;    // MODEM 掉线(保留不使用) 
  MINOR_IP_CONFLICT = $26;    // IP地址冲突 
  MINOR_NET_BROKEN = $27;    // 网络断开
  MINOR_REC_ERROR = $28;    // 录像出错 
  MINOR_IPC_NO_LINK = $29;    // IPC连接异常 
  MINOR_VI_EXCEPTION = $2a;    // 视频输入异常(只针对模拟通道) 
  MINOR_IPC_IP_CONFLICT = $2b;    //ipc ip 地址 冲突
  MINOR_SENCE_EXCEPTION = $2c;    // 场景异常

const
  MINOR_PIC_REC_ERROR = $2d;    // 抓图出错--获取图片文件失败
  MINOR_VI_MISMATCH = $2e;    // 视频制式不匹配
  MINOR_RESOLUTION_MISMATCH = $2f;    //前端/录像分辨率不匹配  

//2009-12-16 增加视频综合平台日志类型
const
  MINOR_FANABNORMAL = $31;    // 视频综合平台：风扇状态异常 
  MINOR_FANRESUME = $32;    // 视频综合平台：风扇状态恢复正常 
  MINOR_SUBSYSTEM_ABNORMALREBOOT = $33;    // 视频综合平台：6467异常重启 
  MINOR_MATRIX_STARTBUZZER = $34;    // 视频综合平台：dm6467异常，启动蜂鸣器 

//2010-01-22 增加视频综合平台异常日志次类型
const
  MINOR_NET_ABNORMAL = $35;    //网络状态异常
  MINOR_MEM_ABNORMAL = $36;    //内存状态异常
  MINOR_FILE_ABNORMAL = $37;    //文件状态异常
  MINOR_PANEL_ABNORMAL = $38;    //前面板连接异常
  MINOR_PANEL_RESUME = $39;    //前面板恢复正常
  MINOR_RS485_DEVICE_ABNORMAL = $3a;    //RS485连接状态异常
  MINOR_RS485_DEVICE_REVERT = $3b;    //RS485连接状态异常恢复

//2012-2-18 增加大屏控制器异常日志次类型
const
  MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT = $3c;    //子板异常启动
  MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT = $3d;    //子板插入
  MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT = $3e;    //子板拔出
  MINOR_SCREEN_ABNARMALTEMPERATURE = $3f;    //温度异常
//2012-07-26 视频综合平台v2.1
const
  MINOR_HIGH_TEMPERATURE_PROTECT = $40;    //子板过热保护

//Netra 2.2.2
const
  MINOR_RECORD_OVERFLOW = $41;    //缓冲区溢出
  MINOR_DSP_ABNORMAL = $42;    //DSP异常

//Netra 3.0.0
const
  MINOR_ANR_RECORD_FAIED = $43;    //ANR录像失败
  MINOR_SPARE_WORK_DEVICE_EXCEPT = $44;    //热备设备工作机异常
  MINOR_START_IPC_MAS_FAILED = $45;    //开启IPC MAS失败
//256路NVR
const
  MINOR_IPCM_CRASH = $46;    //IPCM异常重启
  MINOR_POE_POWER_EXCEPTION = $47;    //POE 供电异常
  MINOR_UPLOAD_DATA_CS_EXCEPTION = $48;    //云存储数据上传失败/
  MINOR_DIAL_EXCEPTION = $49;    //拨号异常
  MINOR_DEV_EXCEPTION_OFFLINE = $50;    //设备异常下线
  MINOR_UPGRADEFAIL = $51;    //远程升级设备失败
  MINOR_AI_LOST = $52;    // 音频信号丢失 
  MINOR_SYNC_IPC_PASSWD = $53;    // 同步IPC密码异常 
  MINOR_EZVIZ_OFFLINE = $54;    // 萤石下线异常
  MINOR_VQD_ABNORMAL = $55;    //VQD异常
  MINOR_ACCESSORIES_PLATE = $57;    //配件板异常
  MINOR_KMS_EXPAMSION_DISK_LOST = $58;    // KMS扩容盘丢失
  MINOR_ABNORMAL_PORT = $59;    // 端口异常
  MINOR_CAMERA_ANGLE_ANOMALY = $60;    //  相机视角异常
  MINOR_DATA_DISK_ERROE = $61;    //  数据盘错误
  MINOR_INTELLIGENT_SYSTEM_RUNNING_ERROR = $62;    //  智能系统运行异常
  MINOR_FACESNAP_RESOLUTION_OVERFLOW = $63;    //  人脸抓拍码流分辨率超限
  MINOR_SMD_RESOLUTION_OVERFLOW = $64;    //  SMD码流分辨率超限
  MINOR_AUDIO_LOSS_EXCEPTION = $65;    //  音频丢失异常
  MINOR_SAFETY_HELMET_EXCEPTION = $66;    //未佩戴安全帽检测异常
  MINOR_VCA_PIC_LENGTH_OVERFLOW = $67;    // VCA图片长度过长（例如超过2M大小的图片）
  MINOR_FACE_MODEL_EXCEPTION = $68;    //  人脸库模型同步异常
  MINOR_SSD_EXCEPTION = $69;    // SSD异常
//NVR集群
const
  MINOR_CLUSTER_DEVICE_OFFLINE = $70;    // 集群内设备下线
  MINOR_CLUSTER_CONFIG_FAILED = $71;    // 集群内设备配置失败
  MINOR_CLUSTER_DISASTER_TOLERANCE_EXCEPT = $72;    // 集群容灾异常:集群CM选举失败,集群存储周期不足,集群带宽不足,集群通道资源不足,集群设备不足等
  MINOR_CLUSTER_STORFULL_EXCEPTION = $73;    //集群硬盘满
  MINOR_CLUSTER_VERSION_EXCEPTION = $74;    //集群版本异常
  MINOR_CLUSTER_OFFLINENODE_EXCEPTION = $75;    //集群掉线数超限
  MINOR_CLUSTER_RECORDCYCLE_EXCEPTION = $76;    //集群录像周期不足
  MINOR_CLUSTER_IPCTRANSFER_EXCEPTION = $77;    //集群IPC迁移失败
  MINOR_CLUSTER_IPCONFLICT_EXCEPTION = $78;    // 集群IP冲突，记录CM的IP地址

const
  MINOR_GET_SUB_STREAM_FAILURE = $79;    //子码流取流失败
  MINOR_HDD_SHM_DETECT_EXCEPTION = $7a;    //硬盘SHM检测异常
  MINOR_DEVICE_FORTIFY_FAILURE = $7b;    //前端设备报警布防失败
  MINOR_EVENT_UPLOAD_EXCEPTION = $7c;    //事件发送异常（设备上传事件失败或者丢弃了）

const
  MINOR_LORA_EXCEPTION = $7d;    //LoRa异常
  MINOR_AK_OR_SK_IS_EMPTY = $7e;    //云存储密码或加密密码为空

const
  MINOR_HIGH_HD_TEMPERATURE = $80;    //硬盘温度过高
  MINOR_LOW_HD_TEMPERATURE = $81;    //硬盘温度过低
  MINOR_HD_IMPACT = $82;    //硬盘受到冲击
  MINOR_HD_BAD_BLOCK = $83;    //硬盘出现坏块
  MINOR_SEVERE_HD_FAILURE = $84;    //硬盘严重故障
  MINOR_RELEASE_FAILED = $85;    //信息发布失败
  MINOR_PORT_CONFLICT = $86;    //端口冲突
  MINOR_MODULE_STARTUP_FAILED = $87;    //模块启动失败
  MINIOR_VCA_RUNNING_EXCEPTION = $88;    //智能板运行异常

//0x400-0x1000 门禁异常类型
const
  MINOR_DEV_POWER_ON = $400;    //设备上电启动
  MINOR_DEV_POWER_OFF = $401;    //设备掉电关闭
  MINOR_WATCH_DOG_RESET = $402;    //看门狗复位
  MINOR_LOW_BATTERY = $403;    //蓄电池电压低
  MINOR_BATTERY_RESUME = $404;    //蓄电池电压恢复正常
  MINOR_AC_OFF = $405;    //交流电断电
  MINOR_AC_RESUME = $406;    //交流电恢复
  MINOR_NET_RESUME = $407;    //网络恢复
  MINOR_FLASH_ABNORMAL = $408;    //FLASH读写异常
  MINOR_CARD_READER_OFFLINE = $409;    //读卡器掉线
  MINOR_CARD_READER_RESUME = $40a;    //读卡器掉线恢复
  MINOR_INDICATOR_LIGHT_OFF = $40b;    //指示灯关闭
  MINOR_INDICATOR_LIGHT_RESUME = $40c;    //指示灯恢复
  MINOR_CHANNEL_CONTROLLER_OFF = $40d;    //通道控制器掉线
  MINOR_CHANNEL_CONTROLLER_RESUME = $40e;    //通道控制器恢复
  MINOR_SECURITY_MODULE_OFF = $40f;    //门控安全模块掉线
  MINOR_SECURITY_MODULE_RESUME = $410;    //门控安全模块在线
  MINOR_BATTERY_ELECTRIC_LOW = $411;    //电池电压低(仅人脸设备使用)
  MINOR_BATTERY_ELECTRIC_RESUME = $412;    //电池电压恢复正常(仅人脸设备使用)
  MINOR_LOCAL_CONTROL_NET_BROKEN = $413;    //就地控制器网络断开
  MINOR_LOCAL_CONTROL_NET_RSUME = $414;    //就地控制器网络恢复
  MINOR_MASTER_RS485_LOOPNODE_BROKEN = $415;    //主控RS485环路节点断开
  MINOR_MASTER_RS485_LOOPNODE_RESUME = $416;    //主控RS485环路节点恢复
  MINOR_LOCAL_CONTROL_OFFLINE = $417;    //就地控制器掉线
  MINOR_LOCAL_CONTROL_RESUME = $418;    //就地控制器掉线恢复
  MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN = $419;    //就地下行RS485环路断开
  MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME = $41a;    //就地下行RS485环路恢复
  MINOR_DISTRACT_CONTROLLER_ONLINE = $41b;    //分控器在线
  MINOR_DISTRACT_CONTROLLER_OFFLINE = $41c;    //分控器离线
  MINOR_ID_CARD_READER_NOT_CONNECT = $41d;    //身份证阅读器未连接（智能专用）
  MINOR_ID_CARD_READER_RESUME = $41e;    //身份证阅读器连接恢复（智能专用）
  MINOR_FINGER_PRINT_MODULE_NOT_CONNECT = $41f;    //指纹模组未连接（智能专用）
  MINOR_FINGER_PRINT_MODULE_RESUME = $420;    //指纹模组连接恢复（智能专用）
  MINOR_CAMERA_NOT_CONNECT = $421;    //摄像头未连接
  MINOR_CAMERA_RESUME = $422;    //摄像头连接恢复
  MINOR_COM_NOT_CONNECT = $423;    //COM口未连接
  MINOR_COM_RESUME = $424;    //COM口连接恢复
  MINOR_DEVICE_NOT_AUTHORIZE = $425;    //设备未授权
  MINOR_PEOPLE_AND_ID_CARD_DEVICE_ONLINE = $426;    //人证设备在线
  MINOR_PEOPLE_AND_ID_CARD_DEVICE_OFFLINE = $427;    //人证设备离线
  MINOR_LOCAL_LOGIN_LOCK = $428;    //本地登录锁定
  MINOR_LOCAL_LOGIN_UNLOCK = $429;    //本地登录解锁
  MINOR_SUBMARINEBACK_COMM_BREAK = $42a;    //与反潜回服务器通信断开
  MINOR_SUBMARINEBACK_COMM_RESUME = $42b;    //与反潜回服务器通信恢复
  MINOR_MOTOR_SENSOR_EXCEPTION = $42c;    //电机或传感器异常
  MINOR_CAN_BUS_EXCEPTION = $42d;    //CAN总线异常
  MINOR_CAN_BUS_RESUME = $42e;    //CAN总线恢复
  MINOR_GATE_TEMPERATURE_OVERRUN = $42f;    //闸机腔体温度超限
  MINOR_IR_EMITTER_EXCEPTION = $430;    //红外对射异常
  MINOR_IR_EMITTER_RESUME = $431;    //红外对射恢复
  MINOR_LAMP_BOARD_COMM_EXCEPTION = $432;    //灯板通信异常
  MINOR_LAMP_BOARD_COMM_RESUME = $433;    //灯板通信恢复
  MINOR_IR_ADAPTOR_COMM_EXCEPTION = $434;    //红外转接板通信异常
  MINOR_IR_ADAPTOR_COMM_RESUME = $435;    //红外转接板通信恢复
  MINOR_PRINTER_ONLINE = $436;    //打印机在线
  MINOR_PRINTER_OFFLINE = $437;    //打印机离线
  MINOR_4G_MOUDLE_ONLINE = $438;    //4G模块在线
  MINOR_4G_MOUDLE_OFFLINE = $439;    //4G模块离线
  MINOR_DSP_START_FAILED = $43a;    //DSP启动失败
  MINOR_SMART_REGULATION_NOT_ALLOWED = $43b;    //智能规则不支持
  MINOR_AUXILIARY_BOARD_OFFLINE = $43c;    //辅助板掉线
  MINOR_AUXILIARY_BOARD_RESUME = $43d;    //辅助板掉线恢复
  MINOR_IDCARD_SECURITY_MOUDLE_EXCEPTION = $43e;    //身份证安全模块异常
  MINOR_IDCARD_SECURITY_MOUDLE_RESUME = $43f;    //身份证安全模块恢复
  MINOR_FP_PERIPHERAL_EXCEPTION = $440;    //指纹采集外设异常
  MINOR_FP_PERIPHERAL_RESUME = $441;    //指纹采集外设恢复
  MINOR_REPLAY_ATTACK = $442;    //重复攻击
  MINOR_TLS_ABNORMAL = $443;    //TLS通信异常
  MINOR_SMART_PLATE_OFFLINE = $444;    //智盘离线
  MINOR_SMART_PLATE_ONLINE = $445;    //智盘上线
  MINOR_REFUND_LOCKED = $446;    //纠错锁定
  MINOR_CODER_ONLINE = $447;    //编码盘在线
  MINOR_CODER_OFFLINE = $448;    //编码盘离线
  MINOR_KEYBOARD_OFFLINE = $449;    //小键盘离线
  MINOR_KEYBOARD_ONLINE = $44a;    //小键盘上线
  MINOR_5G_MOUDLE_ONLINE = $44b;    //5G模块在线
  MINOR_5G_MOUDLE_OFFLINE = $44c;    //5G模块离线
  MINOR_EXTEND_MODULE_ONLINE = $44d;    //扩展模块在线（拓展模块：主要是以usb形式外接身份证读卡器、指纹传感器、蓝牙、二维码等模块，支持热插拔）
  MINOR_EXTEND_MODULE_OFFLINE = $44e;    //扩展模块离线（拓展模块：主要是以usb形式外接身份证读卡器、指纹传感器、蓝牙、二维码等模块，支持热插拔）
  MINOR_INTERLOCK_SERVER_DISCONNECTED = $44f;    //与多门互锁服务器通信断开
  MINOR_INTERLOCK_SERVER_CONNECTED = $450;    //与多门互锁服务器通信恢复
  MINOR_QRCODE_READER_OFFLINE = $451;    //二维码阅读器离线
  MINOR_QRCODE_READER_ONLINE = $452;    //二维码阅读器在线
  MINOR_HEALTH_INFO_ABNORMAL_LOCK = $453;    //健康信息异常锁定
  MINOR_HEALTH_INFO_ABNORMAL_UNLOCK = $454;    //健康信息异常解锁

const
  MINOR_EXCEPTION_CUSTOM1 = $900;    //门禁自定义异常1
  MINOR_EXCEPTION_CUSTOM2 = $901;    //门禁自定义异常2
  MINOR_EXCEPTION_CUSTOM3 = $902;    //门禁自定义异常3
  MINOR_EXCEPTION_CUSTOM4 = $903;    //门禁自定义异常4
  MINOR_EXCEPTION_CUSTOM5 = $904;    //门禁自定义异常5
  MINOR_EXCEPTION_CUSTOM6 = $905;    //门禁自定义异常6
  MINOR_EXCEPTION_CUSTOM7 = $906;    //门禁自定义异常7
  MINOR_EXCEPTION_CUSTOM8 = $907;    //门禁自定义异常8
  MINOR_EXCEPTION_CUSTOM9 = $908;    //门禁自定义异常9
  MINOR_EXCEPTION_CUSTOM10 = $909;    //门禁自定义异常10
  MINOR_EXCEPTION_CUSTOM11 = $90a;    //门禁自定义异常11
  MINOR_EXCEPTION_CUSTOM12 = $90b;    //门禁自定义异常12
  MINOR_EXCEPTION_CUSTOM13 = $90c;    //门禁自定义异常13
  MINOR_EXCEPTION_CUSTOM14 = $90d;    //门禁自定义异常14
  MINOR_EXCEPTION_CUSTOM15 = $90e;    //门禁自定义异常15
  MINOR_EXCEPTION_CUSTOM16 = $90f;    //门禁自定义异常16
  MINOR_EXCEPTION_CUSTOM17 = $910;    //门禁自定义异常17
  MINOR_EXCEPTION_CUSTOM18 = $911;    //门禁自定义异常18
  MINOR_EXCEPTION_CUSTOM19 = $912;    //门禁自定义异常19
  MINOR_EXCEPTION_CUSTOM20 = $913;    //门禁自定义异常20
  MINOR_EXCEPTION_CUSTOM21 = $914;    //门禁自定义异常21
  MINOR_EXCEPTION_CUSTOM22 = $915;    //门禁自定义异常22
  MINOR_EXCEPTION_CUSTOM23 = $916;    //门禁自定义异常23
  MINOR_EXCEPTION_CUSTOM24 = $917;    //门禁自定义异常24
  MINOR_EXCEPTION_CUSTOM25 = $918;    //门禁自定义异常25
  MINOR_EXCEPTION_CUSTOM26 = $919;    //门禁自定义异常26
  MINOR_EXCEPTION_CUSTOM27 = $91a;    //门禁自定义异常27
  MINOR_EXCEPTION_CUSTOM28 = $91b;    //门禁自定义异常28
  MINOR_EXCEPTION_CUSTOM29 = $91c;    //门禁自定义异常29
  MINOR_EXCEPTION_CUSTOM30 = $91d;    //门禁自定义异常30
  MINOR_EXCEPTION_CUSTOM31 = $91e;    //门禁自定义异常31
  MINOR_EXCEPTION_CUSTOM32 = $91f;    //门禁自定义异常32
  MINOR_EXCEPTION_CUSTOM33 = $920;    //门禁自定义异常33
  MINOR_EXCEPTION_CUSTOM34 = $921;    //门禁自定义异常34
  MINOR_EXCEPTION_CUSTOM35 = $922;    //门禁自定义异常35
  MINOR_EXCEPTION_CUSTOM36 = $923;    //门禁自定义异常36
  MINOR_EXCEPTION_CUSTOM37 = $924;    //门禁自定义异常37
  MINOR_EXCEPTION_CUSTOM38 = $925;    //门禁自定义异常38
  MINOR_EXCEPTION_CUSTOM39 = $926;    //门禁自定义异常39
  MINOR_EXCEPTION_CUSTOM40 = $927;    //门禁自定义异常40
  MINOR_EXCEPTION_CUSTOM41 = $928;    //门禁自定义异常41
  MINOR_EXCEPTION_CUSTOM42 = $929;    //门禁自定义异常42
  MINOR_EXCEPTION_CUSTOM43 = $92a;    //门禁自定义异常43
  MINOR_EXCEPTION_CUSTOM44 = $92b;    //门禁自定义异常44
  MINOR_EXCEPTION_CUSTOM45 = $92c;    //门禁自定义异常45
  MINOR_EXCEPTION_CUSTOM46 = $92d;    //门禁自定义异常46
  MINOR_EXCEPTION_CUSTOM47 = $92e;    //门禁自定义异常47
  MINOR_EXCEPTION_CUSTOM48 = $92f;    //门禁自定义异常48
  MINOR_EXCEPTION_CUSTOM49 = $930;    //门禁自定义异常49
  MINOR_EXCEPTION_CUSTOM50 = $931;    //门禁自定义异常50
  MINOR_EXCEPTION_CUSTOM51 = $932;    //门禁自定义异常51
  MINOR_EXCEPTION_CUSTOM52 = $933;    //门禁自定义异常52
  MINOR_EXCEPTION_CUSTOM53 = $934;    //门禁自定义异常53
  MINOR_EXCEPTION_CUSTOM54 = $935;    //门禁自定义异常54
  MINOR_EXCEPTION_CUSTOM55 = $936;    //门禁自定义异常55
  MINOR_EXCEPTION_CUSTOM56 = $937;    //门禁自定义异常56
  MINOR_EXCEPTION_CUSTOM57 = $938;    //门禁自定义异常57
  MINOR_EXCEPTION_CUSTOM58 = $939;    //门禁自定义异常58
  MINOR_EXCEPTION_CUSTOM59 = $93a;    //门禁自定义异常59
  MINOR_EXCEPTION_CUSTOM60 = $93b;    //门禁自定义异常60
  MINOR_EXCEPTION_CUSTOM61 = $93c;    //门禁自定义异常61
  MINOR_EXCEPTION_CUSTOM62 = $93d;    //门禁自定义异常62
  MINOR_EXCEPTION_CUSTOM63 = $93e;    //门禁自定义异常63
  MINOR_EXCEPTION_CUSTOM64 = $93f;    //门禁自定义异常64
  MINOR_SWITCH_WIRED_NETWORK = $950;    //切换有线网络
  MINOR_SWITCH_WIRELESS_NETWORK = $951;    //切换无线网络
  MINOR_LOCK_ONLINE_RESUME = $952;    //智能锁恢复上线
  MINOR_USB_ONLINE = $953;    //USB摄像头上线
  MINOR_USB_OFFLINE = $954;    //USB摄像头掉线



//2018-04-23 通用物联网关异常日志类型
const
  MINOR_ALARMHOST_WDT_RESET = $1003;    //WDT 复位
  MINOR_ALARMHOST_RTC_EXCEPTION = $1007;    //RTC实时时钟异常

const
  MINOR_ALARMHOST_TEL_LINE_CONNECT_FAILURE = $100a;    //电话线连接断
  MINOR_ALARMHOST_TEL_LINE_CONNECT_RESTORE = $100b;    //电话线连接恢复
  MINOR_ALARMHOST_EXPANDER_BUS_LOSS = $100c;    //扩展总线模块掉线
  MINOR_ALARMHOST_EXPANDER_BUS_RESTORE = $100d;    //扩展总线模块掉线恢复
  MINOR_ALARMHOST_KEYPAD_BUS_LOSS = $100e;    //键盘总线模块掉线
  MINOR_ALARMHOST_KEYPAD_BUS_RESTORE = $100f;    //键盘总线模块掉线恢复
  MINOR_ALARMHOST_SENSOR_FAILURE = $1010;    //模拟量传感器故障
  MINOR_ALARMHOST_SENSOR_RESTORE = $1011;    //模拟量传感器恢复
  MINOR_ALARMHOST_RS485_CONNECT_FAILURE = $1012;    //RS485通道连接断
  MINOR_ALARMHOST_RS485_CONNECT_RESTORE = $1013;    //RS485通道连接断恢复

//“有线网络异常”和“有线网络异常恢复”这两个日志跟“网络连接断”“网络连接恢复”这两个日志时一样的，且没有设备支持“有线网络异常”和“有线网络异常恢复”这两种类型。
const
  MINOR_ALARMHOST_WIRED_NETWORK_ABNORMAL = $1015;    //有线网络异常
  MINOR_ALARMHOST_WIRED_NETWORK_RESTORE = $1016;    //有线网络恢复正常
  MINOR_ALARMHOST_GPRS_ABNORMAL = $1017;    //GPRS通信异常
  MINOR_ALARMHOST_GPRS_RESTORE = $1018;    //GPRS恢复正常
  MINOR_ALARMHOST_3G_ABNORMAL = $1019;    //3G通信异常
  MINOR_ALARMHOST_3G_RESTORE = $101a;    //3G恢复正常
  MINOR_ALARMHOST_SIM_CARD_ABNORMAL = $101b;    //SIM卡异常
  MINOR_ALARMHOST_SIM_CARD_RESTORE = $101c;    //SIM卡恢复正常

const
  MINOR_FORMAT_HDD_ERROR = $1026;    //远程格式化硬盘失败
  MINOR_USB_ERROR = $1027;    //USB通信故障
  MINOR_USB_RESTORE = $1028;    //USB通信故障恢复
  MINOR_PRINT_ERROR = $1029;    //打印机故障
  MINOR_PRINT_RESTORE = $1030;    //打印机故障恢复
  MINOR_ALARMHOST_SUBSYSTEM_COMMUNICATION_ERROR = $1031;    //子板通讯错误

const
  MINOR_MCU_RESTART = $1035;    //MCU重启
  MINOR_GPRS_MODULE_FAULT = $1036;    //GPRS模块故障
  MINOR_TELEPHONE_MODULE_FAULT = $1037;    //电话模块故障
  MINOR_WIFI_ABNORMAL = $1038;    //WIFI通信异常
  MINOR_WIFI_RESTORE = $1039;    //WIFI恢复正常
  MINOR_RF_ABNORMAL = $103a;    //RF信号异常
  MINOR_RF_RESTORE = $103b;    //RF信号恢复正常
  MINOR_DETECTOR_ONLINE = $103c;    //探测器在线
  MINOR_DETECTOR_OFFLINE = $103d;    //探测器离线
  MINOR_DETECTOR_BATTERY_NORMAL = $103e;    //探测器电量正常
  MINOR_DETECTOR_BATTERY_LOW = $103f;    //探测器电量欠压
  MINOR_DATA_TRAFFIC_OVERFLOW = $1040;    //流量超额
  MINOR_ALARMHOST_ZONE_MODULE_LOSS = $1041;    //防区模块掉线
  MINOR_ALARMHOST_ZONE_MODULE_RESTORE = $1042;    //防区模块掉线恢复
  MINOR_WIRELESS_OUTPUT_LOSS = $1043;    //无线输出模块离线
  MINOR_WIRELESS_OUTPUT_RESTORE = $1044;    //无线输出模块恢复在线
  MINOR_WIRELESS_REPEATER_LOSS = $1045;    //无线中继器离线
  MINOR_WIRELESS_REPEATER_RESTORE = $1046;    //无线中继器恢复在线
  MINOR_ALARMHOST_TRIGGER_MODULE_LOSS = $1047;    //触发器模块掉线
  MINOR_ALARMHOST_TRIGGER_MODULE_RESTORE = $1048;    //触发器模块掉线恢复
  MINOR_ALARMHOST_WIRELESS_SIREN_LOSS = $1049;    //无线警号离线
  MINOR_ALARMHOST_WIRELESS_SIREN_RESTORE = $104a;    //无线警号恢复在线
  MINOR_TX1_SUB_SYSTEM_EXCEPTION = $1050;    //TX1子系统异常
  MINOR_TX1_REBOOT_EXCEPTION = $1051;    //TX1系统异常重启
  MINOR_TX1_SUB_SYSTEM_LOSS = $1052;    //智能子系统异常离线
  MINOR_TX1_SUB_SYSTEM_RESTORE = $1053;    //智能子系统离线恢复
  MINOR_WIRELESS_SPEED_EXCEPTION = $1054;    //无线传输速率异常
  MINOR_SUB_BOARD_HEARTBEAT_EXCEPTION = $1055;    //子板心跳异常
  MINOR_HOTSTANDBY__EXCEPTION = $1056;    //热备异常
  MINOR_PRODUCTIONDATA_EXCEPTION = $1057;    //生产数据异常


//LED 异常次类型 0x1201~0x1300
const
  MINOR_LED_SYSTEM_EXCEPTION = $1201;    //LED系统异常
  MINOR_FLASH_NOTENOUGH_EXCEPTION = $1202;    //FLASH空间不足

const
  MINOR_LOG_EXCEPTION = $1301;    //日志盘异常

//[add]by silujie 2013-3-22 14:16
//0x2000~0x3fff 为设备报警日志
//0x4000~0x5000 为设备异常日志
const
  MINOR_SUBSYSTEM_IP_CONFLICT = $4000;    //子板IP冲突
  MINOR_SUBSYSTEM_NET_BROKEN = $4001;    //子板断网
  MINOR_FAN_ABNORMAL = $4002;    //风扇异常
  MINOR_BACKPANEL_TEMPERATURE_ABNORMAL = $4003;    //背板温度异常

const
  MINOR_SDCARD_ABNORMAL = $4004;    //SD卡不健康
  MINOR_SDCARD_DAMAGE = $4005;    //SD卡损坏
  MINOR_POC_ABNORMAL = $4006;    //设备POC模块异常
  MINOR_MAIN_POWER_FAULT = $4007;    //主电故障
  MINOR_BACK_UP_POWER_FAULT = $4008;    //备电故障
  MINOR_TAMPER_FAULT = $4009;    //防拆故障
  MINOR_RS232_FAULT = $400a;    //232总线故障
  MINOR_RS485_FAULT = $400b;    //485总线故障
  MINOR_LAN_STATUS_FAULT = $400c;    //LAN网线接入状态故障
  MINOR_LAN_LINK1_FAULT = $400d;    //LAN链路1故障
  MINOR_LAN_LINK2_FAULT = $400e;    //LAN链路2故障
  MINOR_SIM_CARD_STATUS_FAULT = $400f;    //4G-SIM卡状态故障
  MINOR_4G_LINK1_FAULT = $4010;    //4G链路1故障
  MINOR_4G_LINK2_FAULT = $4011;    //4G链路2故障
  MINOR_OTHER_FAULT = $4012;    //其他故障
  MINOR_FIRE_CONTROL_CONNECT_FAULT = $4013;    //与消控主机连接故障
  MINOR_SENSOR_SHORT_CIRCUIT = $4014;    //传感器短路
  MINOR_SENSOR_OPEN_CIRCUIT = $4015;    //传感器断路
  MINOR_SENSOR_MIS_CONNECT = $4016;    //传感器错接
  MINOR_SENSOR_FAULT_RESTORE = $4017;    //传感器故障恢复
  MINOR_DEVICE_FAULT = $4018;    //设备故障
  MINOR_OVERVOLTAGE = $4019;    //电源电压过高
  MINOR_UNDERVOLTAGE = $401a;    //电源电压过低
  MINOR_PANLOCKING = $401b;    //云台水平堵转
  MINOR_TILTLOCKING = $401c;    //云台垂直堵转
  MINOR_SUBBOARD_TEMPERATURE_ABNORMAL = $401d;    //子板温度异常
  MINOR_EZVIZ_UPGRADE_EXCEPTION = $401e;    //萤石升级异常

//萤石相关操作异常日志
const
  MINOR_EZVIZ_OPERATION_ABNORMAL = $4020;    //萤石操作异常

const
  MINOR_IFRAME_IS_TOO_LARGE = $4030;    //预览/回放时I帧过大

// 操作 
//主类型
const
  MAJOR_OPERATION = $3;    

//次类型
const
  MINOR_VCA_MOTIONEXCEPTION = $29;    //智能侦测异常
  MINOR_START_DVR = $41;    // 开机 
  MINOR_STOP_DVR = $42;    // 关机 
  MINOR_STOP_ABNORMAL = $43;    // 异常关机 
  MINOR_REBOOT_DVR = $44;    //本地重启设备

const
  MINOR_LOCAL_LOGIN = $50;    // 本地登陆 
  MINOR_LOCAL_LOGOUT = $51;    // 本地注销登陆 
  MINOR_LOCAL_CFG_PARM = $52;    // 本地配置参数 
  MINOR_LOCAL_PLAYBYFILE = $53;    // 本地按文件回放或下载 
  MINOR_LOCAL_PLAYBYTIME = $54;    // 本地按时间回放或下载
  MINOR_LOCAL_START_REC = $55;    // 本地开始录像 
  MINOR_LOCAL_STOP_REC = $56;    // 本地停止录像 
  MINOR_LOCAL_PTZCTRL = $57;    // 本地云台控制 
  MINOR_LOCAL_PREVIEW = $58;    // 本地预览 (保留不使用)
  MINOR_LOCAL_MODIFY_TIME = $59;    // 本地修改时间(保留不使用) 
  MINOR_LOCAL_UPGRADE = $5a;    // 本地升级 
  MINOR_LOCAL_RECFILE_OUTPUT = $5b;    // 本地备份录象文件 
  MINOR_LOCAL_FORMAT_HDD = $5c;    // 本地初始化硬盘 
  MINOR_LOCAL_CFGFILE_OUTPUT = $5d;    // 导出本地配置文件 
  MINOR_LOCAL_CFGFILE_INPUT = $5e;    // 导入本地配置文件 
  MINOR_LOCAL_COPYFILE = $5f;    // 本地备份文件 
  MINOR_LOCAL_LOCKFILE = $60;    // 本地锁定录像文件 
  MINOR_LOCAL_UNLOCKFILE = $61;    // 本地解锁录像文件 
  MINOR_LOCAL_DVR_ALARM = $62;    // 本地手动清除和触发报警
  MINOR_IPC_ADD = $63;    // 本地添加IPC 
  MINOR_IPC_DEL = $64;    // 本地删除IPC 
  MINOR_IPC_SET = $65;    // 本地设置IPC 
  MINOR_LOCAL_START_BACKUP = $66;    // 本地开始备份 
  MINOR_LOCAL_STOP_BACKUP = $67;    // 本地停止备份
  MINOR_LOCAL_COPYFILE_START_TIME = $68;    // 本地备份开始时间
  MINOR_LOCAL_COPYFILE_END_TIME = $69;    // 本地备份结束时间
  MINOR_LOCAL_ADD_NAS = $6a;    //本地添加网络硬盘 （nfs、iscsi）
  MINOR_LOCAL_DEL_NAS = $6b;    // 本地删除nas盘 （nfs、iscsi）
  MINOR_LOCAL_SET_NAS = $6c;    // 本地设置nas盘 （nfs、iscsi）
  MINOR_LOCAL_RESET_PASSWD = $6d;    // 本地恢复管理员默认密码

const
  MINOR_REMOTE_LOGIN = $70;    // 远程登录 
  MINOR_REMOTE_LOGOUT = $71;    // 远程注销登陆 
  MINOR_REMOTE_START_REC = $72;    // 远程开始录像 
  MINOR_REMOTE_STOP_REC = $73;    // 远程停止录像 
  MINOR_START_TRANS_CHAN = $74;    // 开始透明传输 
  MINOR_STOP_TRANS_CHAN = $75;    // 停止透明传输 
  MINOR_REMOTE_GET_PARM = $76;    // 远程获取参数 
  MINOR_REMOTE_CFG_PARM = $77;    // 远程配置参数 
  MINOR_REMOTE_GET_STATUS = $78;    // 远程获取状态 
  MINOR_REMOTE_ARM = $79;    // 远程布防 
  MINOR_REMOTE_DISARM = $7a;    // 远程撤防 
  MINOR_REMOTE_REBOOT = $7b;    // 远程重启 
  MINOR_START_VT = $7c;    // 开始语音对讲 
  MINOR_STOP_VT = $7d;    // 停止语音对讲 
  MINOR_REMOTE_UPGRADE = $7e;    // 远程升级 
  MINOR_REMOTE_PLAYBYFILE = $7f;    // 远程按文件回放或下载 
  MINOR_REMOTE_PLAYBYTIME = $80;    // 远程按时间回放或下载 
  MINOR_REMOTE_PTZCTRL = $81;    // 远程云台控制 
  MINOR_REMOTE_FORMAT_HDD = $82;    // 远程格式化硬盘 
  MINOR_REMOTE_STOP = $83;    // 远程关机 
  MINOR_REMOTE_LOCKFILE = $84;    // 远程锁定文件 
  MINOR_REMOTE_UNLOCKFILE = $85;    // 远程解锁文件 
  MINOR_REMOTE_CFGFILE_OUTPUT = $86;    // 远程导出配置文件 
  MINOR_REMOTE_CFGFILE_INTPUT = $87;    // 远程导入配置文件 
  MINOR_REMOTE_RECFILE_OUTPUT = $88;    // 远程导出录象文件 
  MINOR_REMOTE_DVR_ALARM = $89;    // 远程手动清除和触发报警
  MINOR_REMOTE_IPC_ADD = $8a;    // 远程添加IPC 
  MINOR_REMOTE_IPC_DEL = $8b;    // 远程删除IPC 
  MINOR_REMOTE_IPC_SET = $8c;    // 远程设置IPC 
  MINOR_REBOOT_VCA_LIB = $8d;    //重启智能库
  MINOR_REMOTE_ADD_NAS = $8e;    // 远程添加nas盘 （nfs、iscsi）
  MINOR_REMOTE_DEL_NAS = $8f;    // 远程删除nas盘 （nfs、iscsi）
  MINOR_REMOTE_SET_NAS = $90;    // 远程设置nas盘 （nfs、iscsi）
  MINOR_LOCAL_OPERATE_LOCK = $9d;    // 本地操作锁定             
  MINOR_LOCAL_OPERATE_UNLOCK = $9e;    // 本地操作解除锁定         
  MINOR_REMOTE_DELETE_HDISK = $9a;    // 远程删除异常不存在的硬盘 
  MINOR_REMOTE_LOAD_HDISK = $9b;    // 远程加载硬盘             
  MINOR_REMOTE_UNLOAD_HDISK = $9c;    // 远程卸载硬盘   
  MINOR_SCHEDULE_ANGLECALIBRATION = $139;    //定期倾角校准
  MINOR_OTHER_OPERATE = $200;    // 其他操作 

//2010-05-26 增加审讯DVR日志类型
const
  MINOR_LOCAL_START_REC_CDRW = $91;    // 本地开始讯问 
  MINOR_LOCAL_STOP_REC_CDRW = $92;    // 本地停止讯问 
  MINOR_REMOTE_START_REC_CDRW = $93;    // 远程开始讯问 
  MINOR_REMOTE_STOP_REC_CDRW = $94;    // 远程停止讯问 

const
  MINOR_LOCAL_PIC_OUTPUT = $95;    // 本地备份图片文件 
  MINOR_REMOTE_PIC_OUTPUT = $96;    // 远程备份图片文件 

//2011-07-26 增加81审讯DVR日志类型
const
  MINOR_LOCAL_INQUEST_RESUME = $97;    // 本地恢复审讯事件
  MINOR_REMOTE_INQUEST_RESUME = $98;    // 远程恢复审讯事件

//2013-01-23 增加86高清审讯NVR操作日志
const
  MINOR_LOCAL_ADD_FILE = $99;    //本地导入文件
  MINOR_LOCAL_DEL_FILE = $9f;    //本地删除审讯
  MINOR_REMOTE_INQUEST_ADD_FILE = $100;    //远程导入文件

//2009-12-16 增加视频综合平台日志类型
const
  MINOR_SUBSYSTEMREBOOT = $a0;    //视频综合平台：dm6467 正常重启
  MINOR_MATRIX_STARTTRANSFERVIDEO = $a1;    //视频综合平台：矩阵切换开始传输图像
  MINOR_MATRIX_STOPTRANSFERVIDEO = $a2;    //视频综合平台：矩阵切换停止传输图像
  MINOR_REMOTE_SET_ALLSUBSYSTEM = $a3;    //视频综合平台：设置所有6467子系统信息
  MINOR_REMOTE_GET_ALLSUBSYSTEM = $a4;    //视频综合平台：获取所有6467子系统信息
  MINOR_REMOTE_SET_PLANARRAY = $a5;    //视频综合平台：设置计划轮巡组
  MINOR_REMOTE_GET_PLANARRAY = $a6;    //视频综合平台：获取计划轮巡组
  MINOR_MATRIX_STARTTRANSFERAUDIO = $a7;    //视频综合平台：矩阵切换开始传输音频
  MINOR_MATRIX_STOPRANSFERAUDIO = $a8;    //视频综合平台：矩阵切换停止传输音频
  MINOR_LOGON_CODESPITTER = $a9;    //视频综合平台：登陆码分器
  MINOR_LOGOFF_CODESPITTER = $aa;    //视频综合平台：退出码分器

//2010-01-22 增加视频综合平台中解码器操作日志
const
  MINOR_START_DYNAMIC_DECODE = $b0;    //开始动态解码
  MINOR_STOP_DYNAMIC_DECODE = $b1;    //停止动态解码
  MINOR_GET_CYC_CFG = $b2;    //获取解码器通道轮巡配置
  MINOR_SET_CYC_CFG = $b3;    //设置解码通道轮巡配置
  MINOR_START_CYC_DECODE = $b4;    //开始轮巡解码
  MINOR_STOP_CYC_DECODE = $b5;    //停止轮巡解码
  MINOR_GET_DECCHAN_STATUS = $b6;    //获取解码通道状态
  MINOR_GET_DECCHAN_INFO = $b7;    //获取解码通道当前信息
  MINOR_START_PASSIVE_DEC = $b8;    //开始被动解码
  MINOR_STOP_PASSIVE_DEC = $b9;    //停止被动解码
  MINOR_CTRL_PASSIVE_DEC = $ba;    //控制被动解码
  MINOR_RECON_PASSIVE_DEC = $bb;    //被动解码重连
  MINOR_GET_DEC_CHAN_SW = $bc;    //获取解码通道总开关
  MINOR_SET_DEC_CHAN_SW = $bd;    //设置解码通道总开关
  MINOR_CTRL_DEC_CHAN_SCALE = $be;    //解码通道缩放控制
  MINOR_SET_REMOTE_REPLAY = $bf;    //设置远程回放
  MINOR_GET_REMOTE_REPLAY = $c0;    //获取远程回放状态
  MINOR_CTRL_REMOTE_REPLAY = $c1;    //远程回放控制
  MINOR_SET_DISP_CFG = $c2;    //设置显示通道
  MINOR_GET_DISP_CFG = $c3;    //获取显示通道设置
  MINOR_SET_PLANTABLE = $c4;    //设置计划轮巡表
  MINOR_GET_PLANTABLE = $c5;    //获取计划轮巡表
  MINOR_START_PPPPOE = $c6;    //开始PPPoE连接
  MINOR_STOP_PPPPOE = $c7;    //结束PPPoE连接
  MINOR_UPLOAD_LOGO = $c8;    //上传LOGO
//推模式操作日志
const
  MINOR_LOCAL_PIN = $c9;    // 本地PIN功能操作 
  MINOR_LOCAL_DIAL = $ca;    // 本地手动启动断开拨号 
  MINOR_SMS_CONTROL = $cb;    // 短信控制上下线 
  MINOR_CALL_ONLINE = $cc;    // 呼叫控制上线 
  MINOR_REMOTE_PIN = $cd;    // 远程PIN功能操作 

//2010-12-16 报警板日志
const
  MINOR_REMOTE_BYPASS = $d0;    // 远程旁路
  MINOR_REMOTE_UNBYPASS = $d1;    // 远程旁路恢复
  MINOR_REMOTE_SET_ALARMIN_CFG = $d2;    // 远程设置报警输入参数
  MINOR_REMOTE_GET_ALARMIN_CFG = $d3;    // 远程获取报警输入参数
  MINOR_REMOTE_SET_ALARMOUT_CFG = $d4;    // 远程设置报警输出参数
  MINOR_REMOTE_GET_ALARMOUT_CFG = $d5;    // 远程获取报警输出参数
  MINOR_REMOTE_ALARMOUT_OPEN_MAN = $d6;    // 远程手动开启报警输出
  MINOR_REMOTE_ALARMOUT_CLOSE_MAN = $d7;    // 远程手动关闭报警输出
  MINOR_REMOTE_ALARM_ENABLE_CFG = $d8;    // 远程设置报警主机的RS485串口使能状态
  MINOR_DBDATA_OUTPUT = $d9;    // 导出数据库记录 
  MINOR_DBDATA_INPUT = $da;    // 导入数据库记录 
  MINOR_MU_SWITCH = $db;    // 级联切换 
  MINOR_MU_PTZ = $dc;    // 级联PTZ控制 
  MINOR_DELETE_LOGO = $dd;    // 删除logo 
  MINOR_REMOTE_INQUEST_DEL_FILE = $de;    //远程删除文件

const
  MINOR_LOCAL_CONF_REB_RAID = $101;    //本地配置自动重建
  MINOR_LOCAL_CONF_SPARE = $102;    //本地配置热备
  MINOR_LOCAL_ADD_RAID = $103;    //本地创建阵列
  MINOR_LOCAL_DEL_RAID = $104;    //本地删除阵列
  MINOR_LOCAL_MIG_RAID = $105;    //本地迁移阵列
  MINOR_LOCAL_REB_RAID = $106;    // 本地手动重建阵列
  MINOR_LOCAL_QUICK_CONF_RAID = $107;    //本地一键配置
  MINOR_LOCAL_ADD_VD = $108;    //本地创建虚拟磁盘
  MINOR_LOCAL_DEL_VD = $109;    //本地删除虚拟磁盘
  MINOR_LOCAL_RP_VD = $10a;    //本地修复虚拟磁盘
  MINOR_LOCAL_FORMAT_EXPANDVD = $10b;    //本地扩展虚拟磁盘扩容
  MINOR_LOCAL_RAID_UPGRADE = $10c;    //本地raid卡升级
  MINOR_LOCAL_STOP_RAID = $10d;    //本地暂停RAID操作(即安全拔盘)
  MINOR_REMOTE_CONF_REB_RAID = $111;    //远程配置自动重建
  MINOR_REMOTE_CONF_SPARE = $112;    //远程配置热备
  MINOR_REMOTE_ADD_RAID = $113;    //远程创建阵列
  MINOR_REMOTE_DEL_RAID = $114;    //远程删除阵列
  MINOR_REMOTE_MIG_RAID = $115;    //远程迁移阵列
  MINOR_REMOTE_REB_RAID = $116;    // 远程手动重建阵列
  MINOR_REMOTE_QUICK_CONF_RAID = $117;    //远程一键配置
  MINOR_REMOTE_ADD_VD = $118;    //远程创建虚拟磁盘
  MINOR_REMOTE_DEL_VD = $119;    //远程删除虚拟磁盘
  MINOR_REMOTE_RP_VD = $11a;    //远程修复虚拟磁盘
  MINOR_REMOTE_FORMAT_EXPANDVD = $11b;    //远程虚拟磁盘扩容
  MINOR_REMOTE_RAID_UPGRADE = $11c;    //远程raid卡升级
  MINOR_REMOTE_STOP_RAID = $11d;    //远程暂停RAID操作(即安全拔盘)
  MINOR_LOCAL_START_PIC_REC = $121;    //本地开始抓图
  MINOR_LOCAL_STOP_PIC_REC = $122;    //本地停止抓图
  MINOR_LOCAL_SET_SNMP = $125;    //本地配置SNMP
  MINOR_LOCAL_TAG_OPT = $126;    //本地标签操作
  MINOR_REMOTE_START_PIC_REC = $131;    //远程开始抓图
  MINOR_REMOTE_STOP_PIC_REC = $132;    //远程停止抓图
  MINOR_REMOTE_SET_SNMP = $135;    //远程配置SNMP
  MINOR_REMOTE_TAG_OPT = $136;    //远程标签操作
  MINOR_REMOTE_LOGIN_LOCK = $137;    //远程登录锁定
  MINOR_REMOTE_LOGIN_UNLOCK = $138;    //远程登录解锁
// 9000 v2.2.0
const
  MINOR_LOCAL_VOUT_SWITCH = $140;    // 本地输出口切换操作
  MINOR_STREAM_CABAC = $141;    // 码流压缩性能选项配置操作

//Netra 3.0.0
const
  MINOR_LOCAL_SPARE_OPT = $142;    //本地N+1 热备相关操作
  MINOR_REMOTE_SPARE_OPT = $143;    //远程N+1 热备相关操作
  MINOR_LOCAL_IPCCFGFILE_OUTPUT = $144;    // 本地导出ipc配置文件
  MINOR_LOCAL_IPCCFGFILE_INPUT = $145;    // 本地导入ipc配置文件 
  MINOR_LOCAL_IPC_UPGRADE = $146;    // 本地升级IPC 
  MINOR_REMOTE_IPCCFGFILE_OUTPUT = $147;    // 远程导出ipc配置文件
  MINOR_REMOTE_IPCCFGFILE_INPUT = $148;    // 远程导入ipc配置文件
  MINOR_REMOTE_IPC_UPGRADE = $149;    // 远程升级IPC 

const
  MINOR_LOCAL_UNLOAD_HDISK = $150;    //本地卸载硬盘
  MINOR_LOCAL_AUDIO_MIX = $151;    //本地配置音频混音参数
  MINOR_REMOTE_AUDIO_MIX = $152;    //远程配置音频混音参数
  MINOR_LOCAL_TRIAL_PAUSE = $153;    //本地暂停讯问
  MINOR_LOCAL_TRIAL_RESUME = $154;    //本地继续讯问
  MINOR_REMOTE_TRIAL_PAUSE = $155;    //远程暂停讯问
  MINOR_REMOTE_TRIAL_RESUME = $156;    //远程继续讯问
  MINOR_REMOTE_MODIFY_VERIFICATION_CODE = $157;    //修改平台的验证码

const
  MINOR_LOCAL_MAKECALL = $180;    //本地呼叫
  MINOR_LOCAL_REJECTCALL = $181;    //本地拒接
  MINOR_LOCAL_ANSWERCALL = $182;    //本地接听
  MINOR_LOCAL_HANGUPCALL = $183;    //本地挂断

const
  MINOR_REMOTE_MAKECALL = $188;    //远程呼叫
  MINOR_REMOTE_REJECTCALL = $189;    //远程拒接
  MINOR_REMOTE_ANSWERCALL = $18a;    //远程接听
  MINOR_REMOTE_HANGUPCALL = $18b;    //远程挂断

const
  MINOR_LOCAL_CHANNEL_ORDERED = $19b;    //本地通道排序

const
  MINOR_SET_MULTI_MASTER = $201;    //设置大屏主屏
  MINOR_SET_MULTI_SLAVE = $202;    //设置大屏子屏
  MINOR_CANCEL_MULTI_MASTER = $203;    //取消大屏主屏
  MINOR_CANCEL_MULTI_SLAVE = $204;    //取消大屏子屏

const
  MINOR_DISPLAY_LOGO = $205;    //显示LOGO
  MINOR_HIDE_LOGO = $206;    //隐藏LOGO
  MINOR_SET_DEC_DELAY_LEVEL = $207;    //解码通道延时级别设置
  MINOR_SET_BIGSCREEN_DIPLAY_AREA = $208;    //设置大屏显示区域
  MINOR_CUT_VIDEO_SOURCE = $209;    //大屏视频源切割设置
  MINOR_SET_BASEMAP_AREA = $210;    //大屏底图区域设置
  MINOR_DOWNLOAD_BASEMAP = $211;    //下载大屏底图
  MINOR_CUT_BASEMAP = $212;    //底图切割配置
  MINOR_CONTROL_ELEC_ENLARGE = $213;    //电子放大操作(放大或还原)
  MINOR_SET_OUTPUT_RESOLUTION = $214;    //显示输出分辨率设置
  MINOR_SET_TRANCSPARENCY = $215;    //图层透明度设置
  MINOR_SET_OSD = $216;    //显示OSD设置
  MINOR_RESTORE_DEC_STATUS = $217;    //恢复初始状态(场景切换时，解码恢复初始状态)

//2011-11-11 增加大屏控制器操作日志次类型
const
  MINOR_SCREEN_OPEN_SCREEN = $218;    //打开屏幕
  MINOR_SCREEN_CLOSE_SCREEN = $219;    //关闭屏幕
  MINOR_SCREEN_SWITCH_SIGNAL = $21a;    //信号源切换
  MINOR_SCREEN_MODIFY_NETWORK = $21b;    //配置网络参数
  MINOR_SCREEN_MODIFY_LEDRES = $21c;    //配置输出口LED分辨率
  MINOR_SCREEN_SHOW_NORMAL = $21d;    //配置窗口普通显示模式
  MINOR_SCREEN_SHOW_TILE = $21e;    //配置窗口平铺显示模式
  MINOR_SCREEN_DEC_NORMAL = $21f;    //配置普通解码模式
  MINOR_SCREEN_DEC_LOWLATENCY = $220;    //配置低延时解码模式
  MINOR_SCREEN_MODIFY_SELFRES = $221;    //配置信号源自定义分辨率
  MINOR_SCREEN_OUTPUT_POSITION = $222;    //输出口关联屏幕
  MINOR_SCREEN_IMAGE_ENHANCE = $223;    //图像增强
  MINOR_SCREEN_JOIN_SIGNAL = $224;    //信号源拼接
  MINOR_SCREEN_SIGNAL_OSD = $225;    //信号源字符叠加
  MINOR_SCREEN_ASSOCIATED_INTERACTION = $226;    //信号源关联多屏互动服务器
  MINOR_SCREEN_MODIFY_MATRIX = $227;    //配置矩阵参数
  MINOR_SCREEN_WND_TOP_KEEP = $228;    //窗口置顶保持
  MINOR_SCREEN_WND_OPEN_KEEP = $229;    //窗口打开保持
  MINOR_SCREEN_WALL_MIRROR = $22a;    //电视墙区域镜像
  MINOR_SCREEN_UPLOAD_BASEMAP = $22b;    //上传底图
  MINOR_SCREEN_SHOW_BASEMAP = $22c;    //显示底图
  MINOR_SCREEN_HIDE_BASEMAP = $22d;    //隐藏底图
  MINOR_SCREEN_MODIFY_SERIAL = $22e;    //配置串口参数

const
  MINOR_SCREEN_SET_INPUT = $251;    //修改输入源
  MINOR_SCREEN_SET_OUTPUT = $252;    //修改输出通道
  MINOR_SCREEN_SET_OSD = $253;    //修改虚拟LED
  MINOR_SCREEN_SET_LOGO = $254;    //修改LOGO
  MINOR_SCREEN_SET_LAYOUT = $255;    //设置布局
  MINOR_SCREEN_PICTUREPREVIEW = $256;    //回显操作


//2012-06-14 CVCS2.0, 窗口设置等操作在V1.0， V1.1中已经有了，当时在设备日志中没有定义
const
  MINOR_SCREEN_GET_OSD = $257;    //获取虚拟LED
  MINOR_SCREEN_GET_LAYOUT = $258;    //获取布局
  MINOR_SCREEN_LAYOUT_CTRL = $259;    //布局控制
  MINOR_GET_ALL_VALID_WND = $260;    //获取所有有效窗口
  MINOR_GET_SIGNAL_WND = $261;    //获取单个窗口信息
  MINOR_WINDOW_CTRL = $262;    //窗口控制
  MINOR_GET_LAYOUT_LIST = $263;    //获取布局列表
  MINOR_LAYOUT_CTRL = $264;    //布局控制
  MINOR_SET_LAYOUT = $265;    //设置布局
  MINOR_GET_SIGNAL_LIST = $266;    //获取输入信号源列表
  MINOR_GET_PLAN_LIST = $267;    //获取预案列表
  MINOR_SET_PLAN = $268;    //修改预案
  MINOR_CTRL_PLAN = $269;    //控制预案
  MINOR_CTRL_SCREEN = $270;    //屏幕控制
  MINOR_ADD_NETSIG = $271;    //添加信号源
  MINOR_SET_NETSIG = $272;    //修改信号源
  MINOR_SET_DECBDCFG = $273;    //设置解码板参数
  MINOR_GET_DECBDCFG = $274;    //获取解码板参数
  MINOR_GET_DEVICE_STATUS = $275;    //获取设备信息
  MINOR_UPLOAD_PICTURE = $276;    //底图上传
  MINOR_SET_USERPWD = $277;    //设置用户密码
  MINOR_ADD_LAYOUT = $278;    //添加布局
  MINOR_DEL_LAYOUT = $279;    //删除布局
  MINOR_DEL_NETSIG = $280;    //删除信号源
  MINOR_ADD_PLAN = $281;    //添加预案
  MINOR_DEL_PLAN = $282;    //删除预案
  MINOR_GET_EXTERNAL_MATRIX_CFG = $283;    //获取外接矩阵配置
  MINOR_SET_EXTERNAL_MATRIX_CFG = $284;    //设置外接矩阵配置
  MINOR_GET_USER_CFG = $285;    //获取用户配置
  MINOR_SET_USER_CFG = $286;    //设置用户配置
  MINOR_GET_DISPLAY_PANEL_LINK_CFG = $287;    //获取显示墙连接配置
  MINOR_SET_DISPLAY_PANEL_LINK_CFG = $288;    //设置显示墙连接配置

const
  MINOR_GET_WALLSCENE_PARAM = $289;    //获取电视墙场景
  MINOR_SET_WALLSCENE_PARAM = $28a;    //设置电视墙场景
  MINOR_GET_CURRENT_WALLSCENE = $28b;    //获取当前使用场景
  MINOR_SWITCH_WALLSCENE = $28c;    //场景切换
  MINOR_SIP_LOGIN = $28d;    //SIP注册成功
  MINOR_VOIP_START = $28e;    //VOIP对讲开始
  MINOR_VOIP_STOP = $28f;    //VOIP对讲停止
  MINOR_WIN_TOP = $290;    //电视墙窗口置顶
  MINOR_WIN_BOTTOM = $291;    //电视墙窗口置底
  MINOR_SET_USER_ADD_CFG = $292;    //增加用户
  MINOR_SET_USER_MODF_CFG = $293;    //修改用户
  MINOR_SET_USER_DEL_CFG = $294;    //删除用户

// Netra 2.2.2
const
  MINOR_LOCAL_LOAD_HDISK = $300;    //本地加载硬盘
  MINOR_LOCAL_DELETE_HDISK = $301;    //本地删除异常不存在的硬盘

//KY2013 3.0.0
const
  MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH = $302;    //本地主辅口切换
  MINOR_LOCAL_HARD_DISK_CHECK = $303;    //本地物理硬盘自检

//Netra3.1.0
const
  MINOR_LOCAL_CFG_DEVICE_TYPE = $310;    //本地配置设备类型
  MINOR_REMOTE_CFG_DEVICE_TYPE = $311;    //远程配置设备类型
  MINOR_LOCAL_CFG_WORK_HOT_SERVER = $312;    //本地配置工作机热备服务器
  MINOR_REMOTE_CFG_WORK_HOT_SERVER = $313;    //远程配置工作机热备服务器
  MINOR_LOCAL_DELETE_WORK = $314;    //本地删除工作机
  MINOR_REMOTE_DELETE_WORK = $315;    //远程删除工作机
  MINOR_LOCAL_ADD_WORK = $316;    //本地添加工作机
  MINOR_REMOTE_ADD_WORK = $317;    //远程添加工作机
  MINOR_LOCAL_IPCHEATMAP_OUTPUT = $318;    // 本地导出热度图文件      
  MINOR_LOCAL_IPCHEATFLOW_OUTPUT = $319;    // 本地导出热度流量文件      
  MINOR_REMOTE_SMS_SEND = $350;    //远程发送短信
  MINOR_LOCAL_SMS_SEND = $351;    //本地发送短信
  MINOR_ALARM_SMS_SEND = $352;    //发送短信报警
  MINOR_SMS_RECV = $353;    //接收短信
//（备注：0x350、0x351是指人工在GUI或IE控件上编辑并发送短信）
const
  MINOR_LOCAL_SMS_SEARCH = $354;    //本地搜索短信
  MINOR_REMOTE_SMS_SEARCH = $355;    //远程搜索短信
  MINOR_LOCAL_SMS_READ = $356;    //本地查看短信
  MINOR_REMOTE_SMS_READ = $357;    //远程查看短信
  MINOR_REMOTE_DIAL_CONNECT = $358;    //远程开启手动拨号
  MINOR_REMOTE_DIAL_DISCONN = $359;    //远程停止手动拨号
  MINOR_LOCAL_ALLOWLIST_SET = $35A;    //本地配置允许名单
  MINOR_REMOTE_ALLOWLIST_SET = $35B;    //远程配置允许名单
  MINOR_LOCAL_DIAL_PARA_SET = $35C;    //本地配置拨号参数
  MINOR_REMOTE_DIAL_PARA_SET = $35D;    //远程配置拨号参数
  MINOR_LOCAL_DIAL_SCHEDULE_SET = $35E;    //本地配置拨号计划
  MINOR_REMOTE_DIAL_SCHEDULE_SET = $35F;    //远程配置拨号计划
  MINOR_PLAT_OPER = $360;    // 平台操作
  MINOR_REMOTE_CFG_POE_WORK_MODE = $361;    //远程设置POE工作模式
  MINOR_LOCAL_CFG_POE_WORK_MODE = $362;    //本地设置POE工作模式
  MINOR_REMOTE_CFG_FACE_CONTRAST = $363;    //远程设置人脸比对配置
  MINOR_LOCAL_CFG_FACE_CONTRAST = $364;    //本地设置人脸比对配置
  MINOR_REMOTE_CFG_ALLOWLIST_FACE_CONTRAST = $365;    //远程设置允许名单人脸比对配置
  MINOR_LOCAL_CFG_ALLOWLIST_FACE_CONTRAST = $366;    //本地设置允许名单人脸比对配置
  MINOR_LOCAL_CHECK_TIME = $367;    //本地手动校时
  MINOR_VCA_ONEKEY_EXPORT_PICTURE = $368;    //一键导出图片
  MINOR_VCA_ONEKEY_DELETE_PICTURE = $369;    //一键删除图片
  MINOR_VCA_ONEKEY_EXPORT_VIDEO = $36a;    //一键导出录像
  MINOR_VCA_ONEKEY_DELETE_VIDEO = $36b;    //一键删除录像
  MINOR_REMOTE_CFG_WIRELESS_DIALPARAM = $36c;    //远程配置无线拨号参数
  MINOR_LOCAL_CFG_WIRELESS_DIALPARAM = $36d;    //本地配置无线拨号参数
  MINOR_REMOTE_CFG_WIRELESS_SMSPARAM = $36e;    //远程配置无线短信配置参数
  MINOR_LOCAL_CFG_WIRELESS_SMSPARAM = $36f;    //本地配置无线短信配置参数
  MINOR_REMOTE_CFG_WIRELESS_SMSSElFHELP = $370;    //远程配置无线短信自助配置参数
  MINOR_LOCAL_CFG_WIRELESS_SMSSElFHELP = $371;    //本地配置无线短信自助配置参数
  MINOR_REMOTE_CFG_WIRELESS_NETFLOWPARAM = $372;    //远程配置无线流量配置参数
  MINOR_LOCAL_CFG_WIRELESS_NETFLOWPARAM = $373;    //本地配置无线流量配置参数

//0x400-0x1000 门禁操作类型
const
  MINOR_REMOTE_OPEN_DOOR = $400;    //远程开门
  MINOR_REMOTE_CLOSE_DOOR = $401;    //远程关门(受控)
  MINOR_REMOTE_ALWAYS_OPEN = $402;    //远程常开(自由)
  MINOR_REMOTE_ALWAYS_CLOSE = $403;    //远程常关(禁用)
  MINOR_REMOTE_CHECK_TIME = $404;    //远程手动校时
  MINOR_NTP_CHECK_TIME = $405;    //NTP自动校时
  MINOR_REMOTE_CLEAR_CARD = $406;    //远程清空卡号
  MINOR_REMOTE_RESTORE_CFG = $407;    //远程恢复默认参数
  MINOR_ALARMIN_ARM = $408;    //防区布防
  MINOR_ALARMIN_DISARM = $409;    //防区撤防
  MINOR_LOCAL_RESTORE_CFG = $40a;    //本地恢复默认参数
  MINOR_REMOTE_CAPTURE_PIC = $40b;    //远程抓拍
  MINOR_MOD_NET_REPORT_CFG = $40c;    //修改网络中心参数配置
  MINOR_MOD_GPRS_REPORT_PARAM = $40d;    //修改GPRS中心参数配置
  MINOR_MOD_REPORT_GROUP_PARAM = $40e;    //修改中心组参数配置
  MINOR_UNLOCK_PASSWORD_OPEN_DOOR = $40f;    //解除码输入
  MINOR_AUTO_RENUMBER = $410;    //自动重新编号
  MINOR_AUTO_COMPLEMENT_NUMBER = $411;    //自动补充编号
  MINOR_NORMAL_CFGFILE_INPUT = $412;    //导入普通配置文件
  MINOR_NORMAL_CFGFILE_OUTTPUT = $413;    //导出普通配置文件
  MINOR_CARD_RIGHT_INPUT = $414;    //导入卡权限参数
  MINOR_CARD_RIGHT_OUTTPUT = $415;    //导出卡权限参数
  MINOR_LOCAL_USB_UPGRADE = $416;    //本地U盘升级
  MINOR_REMOTE_VISITOR_CALL_LADDER = $417;    //访客呼梯
  MINOR_REMOTE_HOUSEHOLD_CALL_LADDER = $418;    //住户呼梯
  MINOR_REMOTE_ACTUAL_GUARD = $419;    //远程实时布防
  MINOR_REMOTE_ACTUAL_UNGUARD = $41a;    //远程实时撤防
  MINOR_REMOTE_CONTROL_NOT_CODE_OPER_FAILED = $41b;    //遥控器未对码操作失败
  MINOR_REMOTE_CONTROL_CLOSE_DOOR = $41c;    //遥控器关门
  MINOR_REMOTE_CONTROL_OPEN_DOOR = $41d;    //遥控器开门
  MINOR_REMOTE_CONTROL_ALWAYS_OPEN_DOOR = $41e;    //遥控器常开门
  MINOR_M1_CARD_ENCRYPT_VERIFY_OPEN = $41f;    //M1卡加密验证功能开启
  MINOR_M1_CARD_ENCRYPT_VERIFY_CLOSE = $420;    //M1卡加密验证功能关闭
  MINOR_NFC_FUNCTION_OPEN = $421;    //NFC开门功能开启
  MINOR_NFC_FUNCTION_CLOSE = $422;    //NFC开门功能关闭
  MINOR_OFFLINE_DATA_OUTPUT = $423;    //离线采集数据导出
  MINOR_CREATE_SSH_LINK = $42d;    //建立SSH连接
  MINOR_CLOSE_SSH_LINK = $42e;    //断开SSH连接
  MINOR_LOCAL_IMPORT_USERINFO = $42f;    //本地导入人员数据（导入人员权限，模板，人脸图片都用这个事件类型）
  MINOR_LOCAL_EXPORT_USERINFO = $430;    //本地导出人员数据
  MINOR_CREATE_CERTIFICATE = $431;    //创建证书（用于SSL通信的证书，包括SDK的TLS和HTTPS等）
  MINOR_UPLOAD_CERTIFICATE = $432;    //上传证书
  MINOR_DELETE_CERTIFICATE = $433;    //删除证书
  MINOR_COMSUME_ARM = $434;    //消费布防
  MINOR_COMSUME_DISARM = $435;    //消费撤防
  MINOR_ORCODE_KEY_MODIFY = $436;    //二维码密钥修改

const
  MINOR_OPERATION_CUSTOM1 = $900;    //门禁自定义操作1
  MINOR_OPERATION_CUSTOM2 = $901;    //门禁自定义操作2
  MINOR_OPERATION_CUSTOM3 = $902;    //门禁自定义操作3
  MINOR_OPERATION_CUSTOM4 = $903;    //门禁自定义操作4
  MINOR_OPERATION_CUSTOM5 = $904;    //门禁自定义操作5
  MINOR_OPERATION_CUSTOM6 = $905;    //门禁自定义操作6
  MINOR_OPERATION_CUSTOM7 = $906;    //门禁自定义操作7
  MINOR_OPERATION_CUSTOM8 = $907;    //门禁自定义操作8
  MINOR_OPERATION_CUSTOM9 = $908;    //门禁自定义操作9
  MINOR_OPERATION_CUSTOM10 = $909;    //门禁自定义操作10
  MINOR_OPERATION_CUSTOM11 = $90a;    //门禁自定义操作11
  MINOR_OPERATION_CUSTOM12 = $90b;    //门禁自定义操作12
  MINOR_OPERATION_CUSTOM13 = $90c;    //门禁自定义操作13
  MINOR_OPERATION_CUSTOM14 = $90d;    //门禁自定义操作14
  MINOR_OPERATION_CUSTOM15 = $90e;    //门禁自定义操作15
  MINOR_OPERATION_CUSTOM16 = $90f;    //门禁自定义操作16
  MINOR_OPERATION_CUSTOM17 = $910;    //门禁自定义操作17
  MINOR_OPERATION_CUSTOM18 = $911;    //门禁自定义操作18
  MINOR_OPERATION_CUSTOM19 = $912;    //门禁自定义操作19
  MINOR_OPERATION_CUSTOM20 = $913;    //门禁自定义操作20
  MINOR_OPERATION_CUSTOM21 = $914;    //门禁自定义操作21
  MINOR_OPERATION_CUSTOM22 = $915;    //门禁自定义操作22
  MINOR_OPERATION_CUSTOM23 = $916;    //门禁自定义操作23
  MINOR_OPERATION_CUSTOM24 = $917;    //门禁自定义操作24
  MINOR_OPERATION_CUSTOM25 = $918;    //门禁自定义操作25
  MINOR_OPERATION_CUSTOM26 = $919;    //门禁自定义操作26
  MINOR_OPERATION_CUSTOM27 = $91a;    //门禁自定义操作27
  MINOR_OPERATION_CUSTOM28 = $91b;    //门禁自定义操作28
  MINOR_OPERATION_CUSTOM29 = $91c;    //门禁自定义操作29
  MINOR_OPERATION_CUSTOM30 = $91d;    //门禁自定义操作30
  MINOR_OPERATION_CUSTOM31 = $91e;    //门禁自定义操作31
  MINOR_OPERATION_CUSTOM32 = $91f;    //门禁自定义操作32
  MINOR_OPERATION_CUSTOM33 = $920;    //门禁自定义操作33
  MINOR_OPERATION_CUSTOM34 = $921;    //门禁自定义操作34
  MINOR_OPERATION_CUSTOM35 = $922;    //门禁自定义操作35
  MINOR_OPERATION_CUSTOM36 = $923;    //门禁自定义操作36
  MINOR_OPERATION_CUSTOM37 = $924;    //门禁自定义操作37
  MINOR_OPERATION_CUSTOM38 = $925;    //门禁自定义操作38
  MINOR_OPERATION_CUSTOM39 = $926;    //门禁自定义操作39
  MINOR_OPERATION_CUSTOM40 = $927;    //门禁自定义操作40
  MINOR_OPERATION_CUSTOM41 = $928;    //门禁自定义操作41
  MINOR_OPERATION_CUSTOM42 = $929;    //门禁自定义操作42
  MINOR_OPERATION_CUSTOM43 = $92a;    //门禁自定义操作43
  MINOR_OPERATION_CUSTOM44 = $92b;    //门禁自定义操作44
  MINOR_OPERATION_CUSTOM45 = $92c;    //门禁自定义操作45
  MINOR_OPERATION_CUSTOM46 = $92d;    //门禁自定义操作46
  MINOR_OPERATION_CUSTOM47 = $92e;    //门禁自定义操作47
  MINOR_OPERATION_CUSTOM48 = $92f;    //门禁自定义操作48
  MINOR_OPERATION_CUSTOM49 = $930;    //门禁自定义操作49
  MINOR_OPERATION_CUSTOM50 = $931;    //门禁自定义操作50
  MINOR_OPERATION_CUSTOM51 = $932;    //门禁自定义操作51
  MINOR_OPERATION_CUSTOM52 = $933;    //门禁自定义操作52
  MINOR_OPERATION_CUSTOM53 = $934;    //门禁自定义操作53
  MINOR_OPERATION_CUSTOM54 = $935;    //门禁自定义操作54
  MINOR_OPERATION_CUSTOM55 = $936;    //门禁自定义操作55
  MINOR_OPERATION_CUSTOM56 = $937;    //门禁自定义操作56
  MINOR_OPERATION_CUSTOM57 = $938;    //门禁自定义操作57
  MINOR_OPERATION_CUSTOM58 = $939;    //门禁自定义操作58
  MINOR_OPERATION_CUSTOM59 = $93a;    //门禁自定义操作59
  MINOR_OPERATION_CUSTOM60 = $93b;    //门禁自定义操作60
  MINOR_OPERATION_CUSTOM61 = $93c;    //门禁自定义操作61
  MINOR_OPERATION_CUSTOM62 = $93d;    //门禁自定义操作62
  MINOR_OPERATION_CUSTOM63 = $93e;    //门禁自定义操作63
  MINOR_OPERATION_CUSTOM64 = $93f;    //门禁自定义操作64
  MINOR_OPERATION_REALTIMEBROADCAST = $940;    //实时广播
  MINOR_OPERATION_PLANBROADCAST = $941;    //计划广播

const
  MINOR_SET_WIFI_PARAMETER = $950;    //设置WIFI配置参数
  MINOR_EZVIZ_LOGIN = $951;    //萤石云登陆
  MINOR_EZVIZ_LOGINOUT = $952;    //萤石云登出
  MINOR_LOCK_ADD = $953;    //智能锁添加
  MINOR_LOCK_DELETE = $954;    //智能锁删除
  MINOR_LOCK_GET_STATUS = $955;    //智能锁状态获取
  MINOR_LOCK_SET_TMP_PASSWORD = $956;    //智能锁临时密码下发
  MINOR_LOCK_SET_SILENT_MODE = $957;    //智能锁静音设置
  MINOR_LOCK_SET_LATE_WARNING = $958;    //智能锁晚归提醒设置
  MINOR_LOCK_IPC_ADD = $959;    //智能锁IPC关联
  MINOR_LOCK_IPC_REMOVE = $95a;    //智能锁IPC解除关联
  MINOR_LOCK_DETECTOR_ADD = $95b;    //智能锁探测器关联
  MINOR_LOCK_DETECTOR_REMOVE = $95c;    //智能锁探测器解除关联
  MINOR_LOCK_MESSAGE_REMINDING_OPEN = $95d;    //智能锁消息提醒打开
  MINOR_LOCK_MESSAGE_REMINDING_CLOSE = $95e;    //智能锁消息提醒关闭
  MINOR_LOCK_SET_HEART_BEAT = $95f;    //智能锁心跳设置
  MINOR_LOCK_REBOOT = $960;    //智能锁重启
  MINOR_LOCK_CLEAR_USER = $961;    //智能锁清空用户
  MINOR_LOCK_FORMAT = $962;    //智能锁格式化
  MINOR_LOCK_FINGER_CHANGE = $963;    //智能锁指纹改动
  MINOR_LOCK_PASSWORD_CHANGE = $964;    //智能锁密码改动
  MINOR_LOCK_CARD_CHANGE = $965;    //智能锁卡信息改动
  MINOR_LOCK_USER_CHANGE = $966;    //智能锁用户信息改动
  MINOR_LOCK_SYSTEM_CHANGE = $967;    //智能锁系统信息改动
  MINOR_LOCK_CHANGE_ADD_UESR = $968;    //智能锁新增用户
  MINOR_LOCK_CHANGE_DEL_UESR = $969;    //智能锁删除用户
  MINOR_LOCK_CHANGE_CUSTOM_USER_NAME = $96a;    //智能锁自定义用户用户名改动
  MINOR_LOCK_CHANGE_REMOTE_DEVICE = $96b;    //智能锁遥控器信息改动
  MINOR_LOCK_CHANGE_ADD_FP = $96c;    //智能锁新增指纹
  MINOR_LOCK_CHANGE_DEL_FP = $96d;    //智能锁删除指纹
  MINOR_LOCK_CHANGE_ADD_PASSWORD = $96e;    //智能锁新增密码
  MINOR_LOCK_CHANGE_DEL_PASSWORD = $96f;    //智能锁删除密码
  MINOR_LOCK_CHANGE_ADD_CARD = $970;    //智能锁新增卡片
  MINOR_LOCK_CHANGE_DEL_CARD = $971;    //智能锁删除卡片
  MINOR_LOCK_NETWORK_SWITCH = $972;    //智能锁网络功能开关改动
  MINOR_LOCK_CLEAR_NETWORK_DATA = $973;    //智能锁网络数据清空
  MINOR_LOCK_CLEAR_HOST_USER = $974;    //智能锁清空主人用户
  MINOR_LOCK_CLEAR_GUEST_USER = $975;    //智能锁清空客人用户
  MINOR_LOCK_CLEAN_ALL_REMOTE_DEVICE = $976;    //遥控器用户信息清空
  MINOR_LOCK_CLEAN_NORMAL_USER_FINGRT = $977;    //智能锁清空普通用户指纹
  MINOR_LOCK_CLEAN_ALL_CARD = $978;    //智能锁清空所有卡片
  MINOR_LOCK_CLEAN_ALL_PASSWORD = $979;    //智能锁清空所有密码
  MINOR_START_WIRELESSSERVER = $97a;    //开启设备热点
  MINOR_STOP_WIRELESSSERVER = $97b;    //关闭设备热点
  MINOR_EMERGENCY_CARD_AUTH_NORMAL_CARD = $97c;    //应急管理卡授权普通卡
  MINOR_CHANGE_ALWAYS_OPEN_RIGHT = $97d;    //通道模式改动
  MINOR_LOCK_DOOR_BELL_EVENT = $97e;    //门铃事件（操作锁触发）

//传显信息发布操作日志
const
  MINOR_BACKUP_DATA = $c41;    //数据备份
  MINOR_TRANSFER_DATA = $c42;    //数据迁移
  MINOR_RESTORE_DATA = $c43;    //数据还原
  MINOR_SET_INPUT_PLAN = $c44;    //设置终端定时输入切换计划
  MINOR_TERMINAL_ADB = $c45;    //终端ADB配置
  MINOR_TERMINAL_VOLUME = $c46;    //终端音量配置
  MINOR_TERMINAL_LOGO = $c47;    //终端LOGO配置
  MINOR_TERMINAL_DEFAULT_SCHEDULE = $c48;    //垫片日程使能
  MINOR_TERMINAL_PASSWORD = $c49;    //设置终端密码
  MINOR_TERMINAL_IP = $c4a;    //终端IP配置
  MINOR_TERMINAL_RELATE_IPC = $c4b;    //终端关联IPC
  MINOR_TERMINAL_SERVER = $c4c;    //终端关联服务器配置
  MINOR_TERMINAL_SADP = $c4d;    //终端SADP开关配置
  MINOR_TERMINAL_TIMEZONE = $c4e;    //终端时区配置
  MINOR_TERMINAL_TEMP_PROTECT = $c4f;    //终端温度保护配置
  MINOR_ADD_ORGANIZATION = $c50;    //添加组织
  MINOR_DELETE_ORGANIZATION = $c51;    //删除组织
  MINOR_MODIFY_ORGANIZATION = $c52;    //修改组织
  MINOR_WEATHER_FACTORY = $c53;    //天气厂商配置
  MINOR_SADP_ENABLE = $c54;    //sadp开关配置
  MINOR_SSH_ENABLE = $c55;    //SSH开关配置
  MINOR_MODIFY_MATERIAL = $c56;    //素材参数修改
  MINOR_INSERT_CHARACTER = $c57;    //插播文字消息
  MINOR_TERMINAL_BACKLIGHT = $c58;    //终端背光配置
  MINOR_DOWNLOAD_MATERIAL_THUMBNAIL = $c59;    //下载素材缩略图
  MINOR_UPLOAD_PROGRAM_THUMBNAIL = $c5a;    //上传节目缩略图
  MINOR_TDOWNLOAD_PROGRAM_THUMBNAIL = $c5b;    //下载节目缩略图
  MINOR_BATCH_DELETE_SCHEDULE_PLAN = $c5c;    //批量删除发布计划
  MINOR_REPUBLISH = $c5d;    //重新发布
  MINOR_CLEAR_TERMINAL_PLAY_INFO = $c5e;    //清空终端播放信息
  MINOR_GET_TERMINAL_RESOLUTION = $c5f;    //获取终端分辨率
  MINOR_SET_TERMINAL_RESOLUTION = $c60;    //设置终端分辨率
  MINOR_GET_BATCH_TERMINAL_UPGRATE_PROGRESS = $c61;    //批量获取终端升级进度
  MINOR_GET_BATCH_PROGRESS = $c62;    //批量获取终端发布进度
  MINOR_GET_TEMPLATE = $c64;    //获取模板
  MINOR_INIT_TEMPLATE = $c65;    //初始化模板
  MINOR_GET_TERMINAL_NTP_SERVERS = $c66;    //获取终端NTP服务
  MINOR_SET_TERMINAL_NTP_SERVERS = $c67;    //设置终端NTP服务
  MINOR_GET_RELEASE_DETAILS = $c68;    //获取发布详细信息
  MINOR_UPLOAD_TEMPLATE_THUMBNAIL = $c69;    //上传模板缩略图
  MINOR_DOWNLOAD_TEMPLATE_THUMBNAIL = $c6a;    //下载模板缩略图
  MINOR_ADD_TEMPLATE = $c6b;    //添加模板
  MINOR_DELETE_TEMPLATE = $c6c;    //删除模板
  MINOR_MODIFY_TEMPLATE = $c6d;    //修改模板
  MINOR_ADD_SCHEDULE_PLAN = $c6e;    //添加发布计划
  MINOR_MODIFY_SCHEDULE_PLAN = $c6f;    //修改发布计划
  MINOR_CANCEL_SCHEDULE_RELEASE = $c70;    //取消日程发布
  MINOR_GET_SCHEDULE = $c71;    //获取日程
  MINOR_ADD_INSERT = $c72;    //新建插播
  MINOR_CANCEL_INSERT = $c73;    //取消插播
  MINOR_SWITCH_LANGUAGE = $c74;    //切换语言
  MINOR_SET_ADMIN_INITIAL_PASSWORD = $c75;    //设置admin初始密码
  MINOR_MODIFY_PORT = $c76;    //修改端口
  MINOR_MODIFY_STORAGE_PATH = $c77;    //修改存储路径
  MINOR_EXIT_PROGRAM = $c78;    //退出程序
  MINOR_MODULE_STARTUP_SUCCESS = $c79;    //模块启动成功
  MINOR_APPROVE_SCHEDULE = $c80;    //日程审核
  MINOR_GENERAL_DATA_SEND = $c81;    //第三方数据下发
  MINOR_SET_SIGN_INTERFACE = $c82;    //配置签到界面参数
  MINOR_GET_SIGN_INTERFACE = $c83;    //获取签到界面参数
  MINOR_SET_SHOW_MODE = $c84;    //配置显示模式参数
  MINOR_GET_SHOW_MODE = $c85;    //获取显示模式参数
  MINOR_SET_SCREEN_DIRECTION = $c86;    //配置屏幕方向参数
  MINOR_GET_SCREEN_DIRECTION = $c87;    //获取屏幕方向参数
  MINOR_SET_LOCK_SCREEN = $c88;    //配置锁屏参数
  MINOR_GET_LOCK_SCREEN = $c89;    //获取锁屏参数
  MINOR_SET_FACE_DATA_LIB = $c8a;    //配置人脸库参数
  MINOR_DELETE_FACE_DATA_LIB = $c8b;    //删除人脸库
  MINOR_SET_SPEC_FACE_DATA_LIB = $c8c;    //配置指定人脸库参数
  MINOR_DELETE_SPEC_FACE_DATA_LIB = $c8d;    //删除指定人脸库参数
  MINOR_ADD_FACE_DATA = $c8e;    //添加人脸数据
  MINOR_SEARCH_FACE_DATA = $c8f;    //查询人脸数据
  MINOR_MODIFY_FACE_DATA = $c90;    //修改人脸数据
  MINOR_DELETE_FACE_DATA = $c91;    //删除人脸数据
  MINOR_DELETE_USERINFO_DETAIL = $c92;    //人员信息及权限删除
  MINOR_ADD_USERINFO = $c93;    //添加人员信息
  MINOR_MODIFY_USERINFO = $c94;    //修改人员信息
  MINOR_DELETE_USERINFO = $c95;    //删除人员信息
  MINOR_ADD_CARD_INFO = $c96;    //添加卡信息
  MINOR_MODIFY_CARD_INFO = $c97;    //修改卡信息
  MINOR_DELETE_CARD_INFO = $c98;    //删除卡信息
  MINOR_SET_USER_RIGHT_WEEK = $c99;    //人员权限周计划设置
  MINOR_SET_USER_RIGHT_HOLIDAY = $c9a;    //人员权限节日计划设置
  MINOR_SET_USER_RIGHT_HOLIDAYGROUP = $c9b;    //人员权限假日组计划设置
  MINOR_SET_USER_RIGHT_TEMPLATE = $c9c;    //人员权限计划模板设置

//2012-03-05 ITC操作日志类型
const
  MINOR_SET_TRIGGERMODE_CFG = $1001;    //设置触发模式参数
  MINOR_GET_TRIGGERMODE_CFG = $1002;    //获取触发模式参数
  MINOR_SET_IOOUT_CFG = $1003;    //设置IO输出参数
  MINOR_GET_IOOUT_CFG = $1004;    //获取IO输出参数
  MINOR_GET_TRIGGERMODE_DEFAULT = $1005;    //获取触发模式推荐参数
  MINOR_GET_ITCSTATUS = $1006;    //获取状态检测参数
  MINOR_SET_STATUS_DETECT_CFG = $1007;    //设置状态检测参数
  MINOR_GET_STATUS_DETECT_CFG = $1008;    //获取状态检测参数
  MINOR_SET_VIDEO_TRIGGERMODE_CFG = $1009;    //设置视频触发模式参数
  MINOR_GET_VIDEO_TRIGGERMODE_CFG = $100a;    //获取视频触发模式参数

//2018-04-23 通用物联网关操作日志类型
const
  MINOR_ALARMHOST_GUARD = $1010;    //普通布防(外出布防)
  MINOR_ALARMHOST_UNGUARD = $1011;    //普通撤防
  MINOR_ALARMHOST_BYPASS = $1012;    //旁路
  MINOR_ALARMHOST_DURESS_ACCESS = $1013;    //挟持

const
  MINOR_ALARMHOST_RS485_PARAM = $1018;    //修改485配置参数
  MINOR_ALARMHOST_ALARM_OUTPUT = $1019;    //控制触发器
  MINOR_ALARMHOST_ACCESS_OPEN = $101a;    //控制门禁开
  MINOR_ALARMHOST_ACCESS_CLOSE = $101b;    //控制门禁关
  MINOR_ALARMHOST_SIREN_OPEN = $101c;    //控制警号开
  MINOR_ALARMHOST_SIREN_CLOSE = $101d;    //控制警号关
  MINOR_ALARMHOST_MOD_ZONE_CONFIG = $101e;    //修改防区参数
  MINOR_ALARMHOST_MOD_ALARMOUT_CONIFG = $101f;    //修改触发器参数
  MINOR_ALARMHOST_MOD_ANALOG_CONFIG = $1020;    //修改模拟量配置
  MINOR_ALARMHOST_RS485_CONFIG = $1021;    //修改485通道配置
  MINOR_ALARMHOST_PHONE_CONFIG = $1022;    //修改拨号配置
  MINOR_ALARMHOST_ADD_ADMIN = $1023;    //增加管理员
  MINOR_ALARMHOST_MOD_ADMIN_PARAM = $1024;    //修改管理员参数
  MINOR_ALARMHOST_DEL_ADMIN = $1025;    //删除管理员
  MINOR_ALARMHOST_ADD_NETUSER = $1026;    //增加后端操作员
  MINOR_ALARMHOST_MOD_NETUSER_PARAM = $1027;    //修改后端操作员参数
  MINOR_ALARMHOST_DEL_NETUSER = $1028;    //删除后端操作员
  MINOR_ALARMHOST_ADD_OPERATORUSER = $1029;    //增加前端操作员
  MINOR_ALARMHOST_MOD_OPERATORUSER_PW = $102a;    //修改前端操作员密码
  MINOR_ALARMHOST_DEL_OPERATORUSER = $102b;    //删除前端操作员
  MINOR_ALARMHOST_ADD_KEYPADUSER = $102c;    //增加键盘/读卡器用户
  MINOR_ALARMHOST_DEL_KEYPADUSER = $102d;    //删除键盘/读卡器用户


const
  MINOR_ALARMHOST_MOD_HOST_CONFIG = $1032;    //修改主机配置
  MINOR_ALARMHOST_RESTORE_BYPASS = $1033;    //旁路恢复

const
  MINOR_ALARMHOST_ALARMOUT_OPEN = $1034;    //触发器开启
  MINOR_ALARMHOST_ALARMOUT_CLOSE = $1035;    //触发器关闭
  MINOR_ALARMHOST_MOD_SUBSYSTEM_PARAM = $1036;    //修改子系统参数配置
  MINOR_ALARMHOST_GROUP_BYPASS = $1037;    //组旁路
  MINOR_ALARMHOST_RESTORE_GROUP_BYPASS = $1038;    //组旁路恢复
  MINOR_ALARMHOST_MOD_GRPS_PARAM = $1039;    //修改GPRS参数

const
  MINOR_ALARMHOST_MOD_REPORT_MOD = $103b;    //修改上传方式配置
  MINOR_ALARMHOST_MOD_GATEWAY_PARAM = $103c;    //修改门禁参数配置

const
  MINOR_STAY_ARM = $104c;    //留守布防
  MINOR_QUICK_ARM = $104d;    //即时布防
  MINOR_AUTOMATIC_ARM = $104e;    //自动布防
  MINOR_AUTOMATIC_DISARM = $104f;    //自动撤防
  MINOR_KEYSWITCH_ARM = $1050;    //钥匙布撤防防区布防
  MINOR_KEYSWITCH_DISARM = $1051;    //钥匙布撤防防区撤防
  MINOR_CLEAR_ALARM = $1052;    //消警
  MINOR_MOD_FAULT_CFG = $1053;    //修改系统故障配置
  MINOR_MOD_EVENT_TRIGGER_ALARMOUT_CFG = $1054;    //修改事件触发触发器配置
  MINOR_SEARCH_EXTERNAL_MODULE = $1055;    //搜索外接模块
  MINOR_REGISTER_EXTERNAL_MODULE = $1056;    //重新注册外接模块
  MINOR_CLOSE_KEYBOARD_ALARM = $1057;    //关闭键盘报警提示音
  MINOR_MOD_3G_PARAM = $1058;    //修改3G参数
  MINOR_MOD_PRINT_PARAM = $1059;    //修改打印机参数
  MINOR_ALARMHOST_SD_CARD_FORMAT = $1060;    //SD卡格式化
  MINOR_ALARMHOST_SUBSYSTEM_UPGRADE = $1061;    //子板固件升级

const
  MINOR_PLAN_ARM_CFG = $1062;    //计划布撤防参数配置
  MINOR_PHONE_ARM = $1063;    //手机布防
  MINOR_PHONE_STAY_ARM = $1064;    //手机留守布防
  MINOR_PHONE_QUICK_ARM = $1065;    //手机即时布防
  MINOR_PHONE_DISARM = $1066;    //手机撤防
  MINOR_PHONE_CLEAR_ALARM = $1067;    //手机消警
  MINOR_ALLOWLIST_CFG = $1068;    //允许名单配置
  MINOR_TIME_TRIGGER_CFG = $1069;    //定时开关触发器配置
  MINOR_CAPTRUE_CFG = $106a;    //抓图参数配置
  MINOR_TAMPER_CFG = $106b;    //防区防拆参数配置

const
  MINOR_REMOTE_KEYPAD_UPGRADE = $106c;    //远程升级键盘
  MINOR_ONETOUCH_AWAY_ARMING = $106d;    //一键外出布防
  MINOR_ONETOUCH_STAY_ARMING = $106e;    //一键留守布防
  MINOR_SINGLE_PARTITION_ARMING_OR_DISARMING = $106f;    //单防区布撤防
  MINOR_CARD_CONFIGURATION = $1070;    //卡参数配置
  MINOR_CARD_ARMING_OR_DISARMING = $1071;    //刷卡布撤防
  MINOR_EXPENDING_NETCENTER_CONFIGURATION = $1072;    //扩展网络中心配置
  MINOR_NETCARD_CONFIGURATION = $1073;    //网卡配置
  MINOR_DDNS_CONFIGURATION = $1074;    //DDNS配置
  MINOR_RS485BUS_CONFIGURATION = $1075;    // 485总线参数配置
  MINOR_RS485BUS_RE_REGISTRATION = $1076;    //485总线重新注册

const
  MINOR_REMOTE_OPEN_ELECTRIC_LOCK = $1077;    //远程打开电锁
  MINOR_REMOTE_CLOSE_ELECTRIC_LOCK = $1078;    //远程关闭电锁
  MINOR_LOCAL_OPEN_ELECTRIC_LOCK = $1079;    //本地打开电锁
  MINOR_LOCAL_CLOSE_ELECTRIC_LOCK = $107a;    //本地关闭电锁
  MINOR_OPEN_ALARM_LAMP = $107b;    //打开警灯(远程)
  MINOR_CLOSE_ALARM_LAMP = $107c;    //关闭警灯(远程)


const
  MINOR_TEMPORARY_PASSWORD = $107d;    //临时密码操作记录

const
  MINOR_HIDDNS_CONFIG = $1082;    // HIDDNS配置
  MINOR_REMOTE_KEYBOARD_UPDATA = $1083;    //远程键盘升级日志
  MINOR_ZONE_ADD_DETECTOR = $1084;    //防区添加探测器
  MINOR_ZONE_DELETE_DETECTOR = $1085;    //防区删除探测器
  MINOR_QUERY_DETECTOR_SIGNAL = $1086;    //主机查询探测器信号强度
  MINOR_QUERY_DETECTOR_BATTERY = $1087;    //主机查询探测器电量
  MINOR_SET_DETECTOR_GUARD = $1088;    //探测器布防
  MINOR_SET_DETECTOR_UNGUARD = $1089;    //探测器撤防
  MINOR_WIRELESS_CONFIGURATION = $108a;    //无线参数配置
  MINOR_OPEN_VOICE = $108b;    //打开语音
  MINOR_CLOSE_VOICE = $108c;    //关闭语音
  MINOR_ENABLE_FUNCTION_KEY = $108d;    //启用功能键
  MINOR_DISABLE_FUNCTION_KEY = $108e;    //关闭功能键
  MINOR_READ_CARD = $108f;    //巡更刷卡
  MINOR_START_BROADCAST = $1090;    //打开语音广播
  MINOR_STOP_BROADCAST = $1091;    //关闭语音广播
  MINOR_REMOTE_ZONE_MODULE_UPGRADE = $1092;    //远程升级防区模块
  MINOR_NETWORK_MODULE_EXTEND = $1093;    //网络模块参数配置
  MINOR_ADD_CONTROLLER = $1094;    //添加遥控器用户
  MINOR_DELETE_CONTORLLER = $1095;    //删除遥控器用户
  MINOR_REMOTE_NETWORKMODULE_UPGRADE = $1096;    //远程升级网络模块
  MINOR_WIRELESS_OUTPUT_ADD = $1097;    //注册无线输出模块
  MINOR_WIRELESS_OUTPUT_DEL = $1098;    //删除无线输出模块
  MINOR_WIRELESS_REPEATER_ADD = $1099;    //注册无线中继器
  MINOR_WIRELESS_REPEATER_DEL = $109a;    //删除无线中继器
  MINOR_PHONELIST_CFG = $109b;    //电话名单参数配置
  MINOR_RF_SIGNAL_CHECK = $109c;    // RF信号查询
  MINOR_USB_UPGRADE = $109d;    // USB升级
  MINOR_DOOR_TIME_REMINDER_CFG = $109f;    //门磁定时提醒参数配置
  MINOR_WIRELESS_SIREN_ADD = $1100;    //注册无线警号
  MINOR_WIRELESS_SIREN_DEL = $1101;    //删除无线警号
  MINOR_OUT_SCALE_OPEN = $1102;    //辅电开启
  MINOR_OUT_SCALE_CLOSE = $1103;    //辅电关闭

const
  MINOR_ALARMHOST_4G_MODULS_START = $1108;    //4G模块启用
  MINOR_ALARMHOST_4G_MODULS_STOP = $1109;    //4G模块停用

const
  MINOR_EZVIZ_CLOUD_START = $1110;    //萤石云启用
  MINOR_EZVIZ_CLOUD_STOP = $1111;    //萤石云停用
  MINOR_SIPUA_GRID_START = $1112;    //国网B启用
  MINOR_SIPUA_GRID_STOP = $1113;    //国网B停用

const
  MINOR_MODBUS_FILE_DOWNLOAD = $1114;    //导出modbus协议配置文件
  MINOR_MODBUS_FILE_UPLOAD = $1115;    //导入modbus协议配置文件

const
  MINOR_RS485_DLL_FILE_DOWNLOAD = $1116;    //导出485协议库文件
  MINOR_RS485_DLL_FLIE_UPLOAD = $1117;    //导入485协议库文件
  MINOR_TX1_REBOOT = $1118;    //TX1系统正常重启

const
  MINOR_LORA_PARAM = $1119;    //LoRa参数
  MINOR_GB28181_PLATE_CFG_PARAM = $111a;    //国标平台接入参数配置
  MINOR_GB28181_SERVER_START = $111b;    //国标服务启用
  MINOR_GB28181_SERVER_STOP = $111c;    //国标服务停用
  MINOR_WEB_AUTHENTICATION = $111d;    //web认证方式配置
  MINOR_SADP_ENABLED = $111e;    //SADP开关配置
  MINOR_HTTPS_ENABLED = $111f;    //HTTPS开关配置
  MINOR_EZVIZ_PARAM_CFG = $1120;    //萤石云配置
  MINOR_SET_MOTION_DETECTION_CFG = $1121;    //设置移动侦测参数配置
  MINOR_GET_MOTION_DETECTION_CFG = $1122;    //获取移动侦测参数配置
  MINOR_SET_SHELTER_ALARM_CFG = $1123;    //设置遮挡报警参数配置
  MINOR_GET_SHELTER_ALARM_CFG = $1124;    //获取遮挡报警参数配置
  MINOR_SET_VIDEO_LOSS_CFG = $1125;    //设置视频丢失参数配置
  MINOR_GET_VIDEO_LOSS_CFG = $1126;    //获取视频丢失参数配置
  MINOR_SET_ABNORMAL_CFG = $1127;    //设置异常参数配置
  MINOR_GET_ABNORMAL_CFG = $1128;    //获取异常参数配置
  MINOR_SET_ALARM_LINKAGE_CFG = $1129;    //设置报警联动配置
  MINOR_GET_ALARM_LINKAGE_CFG = $112a;    //获取报警联动配置
  MINOR_SET_NETWORK_CFG = $112b;    //设置网络参数配置
  MINOR_GET_NETWORK_CFG = $112c;    //获取网络参数配置
  MINOR_SET_VIDEO_MASK_CFG = $112d;    //设置视频遮盖参数配置
  MINOR_GET_VIDEO_MASK_CFG = $112e;    //获取视频遮盖参数配置

const
  MINOR_BASIC_OPERATION_CFG = $112f;    //基本操作
  MINOR_DISPLAY_EFFECT_ADJUST_CFG = $1130;    //显示效果调节
  MINOR_DISPLAY_PROPERTY_CFG = $1131;    //显示屏属性配置
  MINOR_SIGNAL_CABLE_CFG = $1132;    //信号线缆配置
  MINOR_BASIC_CFG = $1133;    //基础配置
  MINOR_IMAGE_ADJUST_CFG = $1134;    //图像调整配置
  MINOR_IMAGE_ENHANCE_CFG = $1135;    //图像增强配置
  MINOR_NOSIGN_SCREEN_SAVER_CFG = $1136;    //无信号屏保
  MINOR_ADVANCED_OPERATION_CFG = $1137;    //高级操作
  MINOR_RECEIVE_CARD_CFG = $1138;    //接收卡配置
  MINOR_INPUT_SUPPORT_CFG = $1139;    //输入支持管理
  MINOR_SYSTEM_MAINTAIN_CFG = $113a;    //系统维护配置
  MINOR_SYSTEM_TEST_CFG = $113b;    //系统检测配置
  MINOR_JOINT_CFG = $113c;    //拼接配置
  MINOR_SHOW_MODE_CFG = $113d;    //显示模式配置
  MINOR_ADVANCED_IMAGE_CFG = $113e;    //高级图像配置
  MINOR_SHELF_SIZE_CALIBRATION = $1140;    //货架规格标定
  MINOR_CARGO_SENSOR_CALIBRATION = $1141;    //货格传感器标定
  MINOR_CARGO_PRODUCT_BIND_CFG = $1142;    //货格商品绑定配置

//2013-04-19 ITS操作日志类型
const
  MINOR_LOCAL_ADD_CAR_INFO = $2001;    //本地添加车辆信息
  MINOR_LOCAL_MOD_CAR_INFO = $2002;    //本地修改车辆信息
  MINOR_LOCAL_DEL_CAR_INFO = $2003;    //本地删除车辆信息
  MINOR_LOCAL_FIND_CAR_INFO = $2004;    //本地查找车辆信息
  MINOR_LOCAL_ADD_MONITOR_INFO = $2005;    //本地添加布防信息
  MINOR_LOCAL_MOD_MONITOR_INFO = $2006;    //本地修改布防信息
  MINOR_LOCAL_DEL_MONITOR_INFO = $2007;    //本地删除布防信息
  MINOR_LOCAL_FIND_MONITOR_INFO = $2008;    //本地查询布防信息
  MINOR_LOCAL_FIND_NORMAL_PASS_INFO = $2009;    //本地查询正常通行信息
  MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO = $200a;    //本地查询异常通行信息
  MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO = $200b;    //本地查询正常通行信息
  MINOR_LOCAL_PIC_PREVIEW = $200c;    //本地图片预览
  MINOR_LOCAL_SET_GATE_PARM_CFG = $200d;    //设置本地配置出入口参数
  MINOR_LOCAL_GET_GATE_PARM_CFG = $200e;    //获取本地配置出入口参数
  MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG = $200f;    //设置本地配置数据上传参数
  MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG = $2010;    //获取本地配置数据上传参数

//2013-11-19新增日志类型
const
  MINOR_LOCAL_DEVICE_CONTROL = $2011;    //本地设备控制(本地开关闸)
  MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO = $2012;    //本地添加外接设备信息 
  MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO = $2013;    //本地修改外接设备信息 
  MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO = $2014;    //本地删除外接设备信息 
  MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO = $2015;    //本地查询外接设备信息 
  MINOR_LOCAL_ADD_CHARGE_RULE = $2016;    //本地添加收费规则 
  MINOR_LOCAL_MOD_CHARGE_RULE = $2017;    //本地修改收费规则 
  MINOR_LOCAL_DEL_CHARGE_RULE = $2018;    //本地删除收费规则 
  MINOR_LOCAL_FIND_CHARGE_RULE = $2019;    //本地查询收费规则 
  MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO = $2020;    //本地统计正常通行信息 
  MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT = $2021;    //本地导出正常通行信息统计报表 
  MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO = $2022;    //本地统计异常通行信息 
  MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT = $2023;    //本地导出异常通行信息统计报表 
  MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO = $2024;    //本地统计行人通行信息 
  MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT = $2025;    //本地导出行人通行信息统计报表 
  MINOR_LOCAL_FIND_CAR_CHARGEINFO = $2026;    //本地查询过车收费信息 
  MINOR_LOCAL_COUNT_CAR_CHARGEINFO = $2027;    //本地统计过车收费信息 
  MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT = $2028;    //本地导出过车收费信息统计报表 
  MINOR_LOCAL_FIND_SHIFTINFO = $2029;    //本地查询交接班信息 
  MINOR_LOCAL_FIND_CARDINFO = $2030;    //本地查询卡片信息 
  MINOR_LOCAL_ADD_RELIEF_RULE = $2031;    //本地添加减免规则 
  MINOR_LOCAL_MOD_RELIEF_RULE = $2032;    //本地修改减免规则 
  MINOR_LOCAL_DEL_RELIEF_RULE = $2033;    //本地删除减免规则 
  MINOR_LOCAL_FIND_RELIEF_RULE = $2034;    //本地查询减免规则 
  MINOR_LOCAL_GET_ENDETCFG = $2035;    //本地获取出入口控制机离线检测配置 
  MINOR_LOCAL_SET_ENDETCFG = $2036;    //本地设置出入口控制机离线检测配置
  MINOR_LOCAL_SET_ENDEV_ISSUEDDATA = $2037;    //本地设置出入口控制机下发卡片信息 
  MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA = $2038;    //本地清空出入口控制机下发卡片信息 

const
  MINOR_REMOTE_DEVICE_CONTROL = $2101;    //远程设备控制
  MINOR_REMOTE_SET_GATE_PARM_CFG = $2102;    //设置远程配置出入口参数
  MINOR_REMOTE_GET_GATE_PARM_CFG = $2103;    //获取远程配置出入口参数
  MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG = $2104;    //设置远程配置数据上传参数
  MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG = $2105;    //获取远程配置数据上传参数
  MINOR_REMOTE_GET_BASE_INFO = $2106;    //远程获取终端基本信息
  MINOR_REMOTE_GET_OVERLAP_CFG = $2107;    //远程获取字符叠加参数配置
  MINOR_REMOTE_SET_OVERLAP_CFG = $2108;    //远程设置字符叠加参数配置
  MINOR_REMOTE_GET_ROAD_INFO = $2109;    //远程获取路口信息
  MINOR_REMOTE_START_TRANSCHAN = $210a;    //远程建立同步数据服务器
  MINOR_REMOTE_GET_ECTWORKSTATE = $210b;    //远程获取出入口终端工作状态
  MINOR_REMOTE_GET_ECTCHANINFO = $210c;    //远程获取出入口终端通道状态

//远程控制 2013-11-19
const
  MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO = $210d;    //远程添加外接设备信息 
  MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO = $210e;    //远程修改外接设备信息 
  MINOR_REMOTE_GET_ENDETCFG = $210f;    //远程获取出入口控制机离线检测配置 
  MINOR_REMOTE_SET_ENDETCFG = $2110;    //远程设置出入口控制机离线检测配置
  MINOR_REMOTE_ENDEV_ISSUEDDATA = $2111;    //远程设置出入口控制机下发卡片信息 
  MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA = $2112;    //远程清空出入口控制机下发卡片信息 

//ITS 0x2115~0x2120 停车场车位项目
const
  MINOR_REMOTE_ON_CTRL_LAMP = $2115;    //开启远程控制车位指示灯
  MINOR_REMOTE_OFF_CTRL_LAMP = $2116;    //关闭远程控制车位指示灯
//Netra3.1.0
const
  MINOR_SET_VOICE_LEVEL_PARAM = $2117;    //设置音量大小 
  MINOR_SET_VOICE_INTERCOM_PARAM = $2118;    //设置音量录音 
  MINOR_SET_INTELLIGENT_PARAM = $2119;    //智能配置
  MINOR_LOCAL_SET_RAID_SPEED = $211a;    //本地设置raid速度
  MINOR_REMOTE_SET_RAID_SPEED = $211b;    //远程设置raid速度
//Nerta3.1.2
const
  MINOR_REMOTE_CREATE_STORAGE_POOL = $211c;    //远程添加存储池
  MINOR_REMOTE_DEL_STORAGE_POOL = $211d;    //远程删除存储池

const
  MINOR_REMOTE_DEL_PIC = $2120;    //远程删除图片数据
  MINOR_REMOTE_DEL_RECORD = $2121;    //远程删除录像数据
  MINOR_REMOTE_CLOUD_ENABLE = $2123;    //远程设置云系统启用
  MINOR_REMOTE_CLOUD_DISABLE = $2124;    //远程设置云系统禁用
  MINOR_REMOTE_CLOUD_MODIFY_PARAM = $2125;    //远程修改存储池参数
  MINOR_REMOTE_CLOUD_MODIFY_VOLUME = $2126;    //远程修改存储池容量
  MINOR_REMOTE_GET_GB28181_SERVICE_PARAM = $2127;    //远程获取GB28181服务参数
  MINOR_REMOTE_SET_GB28181_SERVICE_PARAM = $2128;    //远程设置GB28181服务参数
  MINOR_LOCAL_GET_GB28181_SERVICE_PARAM = $2129;    //本地获取GB28181服务参数
  MINOR_LOCAL_SET_GB28181_SERVICE_PARAM = $212a;    //本地配置B28181服务参数
  MINOR_REMOTE_SET_SIP_SERVER = $212b;    //远程配置SIP SERVER
  MINOR_LOCAL_SET_SIP_SERVER = $212c;    //本地配置SIP SERVER
  MINOR_LOCAL_BLOCKALLOWFILE_OUTPUT = $212d;    //本地名单导出
  MINOR_LOCAL_BLOCKALLOWFILE_INPUT = $212e;    //本地名单导入
  MINOR_REMOTE_BLOCKALLOWCFGFILE_OUTPUT = $212f;    //远程名单导出
  MINOR_REMOTE_BLOCKALLOWCFGFILE_INPUT = $2130;    //远程名单导入


const
  MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE = $2200;    //远程创建/修改视图库空间
  MINOR_REMOTE_DELETE_VIEWLIB_FILE = $2201;    //远程删除视图库文件
  MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE = $2202;    //远程下载视图库文件
  MINOR_REMOTE_UPLOAD_VIEWLIB_FILE = $2203;    //远程上传视图库文件
  MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE = $2204;    //本地创建/修改视图库空间

const
  MINOR_LOCAL_SET_DEVICE_ACTIVE = $3000;    //本地激活设备
  MINOR_REMOTE_SET_DEVICE_ACTIVE = $3001;    //远程激活设备
  MINOR_LOCAL_PARA_FACTORY_DEFAULT = $3002;    //本地回复出厂设置
  MINOR_REMOTE_PARA_FACTORY_DEFAULT = $3003;    //远程恢复出厂设置
  MIMOR_REMOTE_DELETE_ALL_VERIFYORCAP_PICS = $3004;    //远程删除所有认证或抓拍图片
  MIMOR_LOCAL_DELETE_ALL_VERIFYORCAP_PICS = $3005;    //本地删除所有认证或抓拍图片
  MIMOR_REMOTE_DELETE_EVENTS_AT_SPECTIME = $3006;    //远程按指定时间删除事件
  MIMOR_LOCAL_DELETE_EVENTS_AT_SPECTIME = $3007;    //本地按指定时间删除事件
  MIMOR_REMOTE_OPEN_SUMMER_TIME = $3008;    //远程开启夏令时
  MIMOR_LOCAL_OPEN_SUMMER_TIME = $3009;    //本地开启夏令时
  MIMOR_REMOTE_CLOSE_SUMMER_TIME = $3010;    //远程关闭夏令时
  MIMOR_LOCAL_CLOSE_SUMMER_TIME = $3011;    //本地关闭夏令时
  MIMOR_REMOTE_EZVIZ_UNBIND = $3012;    //远程萤石云解绑
  MIMOR_LOCAL_EZVIZ_UNBIND = $3013;    //本地萤石云解绑
  MIMOR_ENTER_LOCALUI_BACKGROUND = $3014;    //进入UI后台
  MIMOR_REMOTE_DELETE_FACEBASEMAP = $3015;    //远程删除人脸底图
  MIMOR_LOCAL_DELETE_FACEBASEMAP = $3016;    //本地删除人脸底图


//信息发布服务器操作日志
const
  MINOR_UPLAOD_STATIC_MATERIAL = $2401;    //静态素材上传
  MINOR_UPLOAD_DYNAMIC_MATERIAL = $2402;    //动态素材上传
  MINOR_DELETE_MATERIAL = $2403;    //删除素材
  MINOR_DOWNLOAD_STATIC_MATERIAL = $2404;    //静态素材下载
  MINOR_COVER_STATIC_MATERIAL = $2405;    //静态素材覆盖
  MINOR_APPROVE_MATERIAL = $2406;    //素材审核
  MINOR_UPLAOD_PROGRAM = $2407;    //上传节目
  MINOR_DOWNLOAD_PROGRAM = $2408;    //下载节目
  MINOR_DELETE_PROGRAM = $2409;    //删除节目
  MINOR_MODIFY_PROGRAM = $240a;    //节目属性修改
  MINOR_APPROVE_PRAGRAM = $240b;    //节目审核
  MINOR_UPLAOD_SCHEDULE = $240c;    //上传日程
  MINOR_DOWNLOAD_SCHEDULE = $240d;    //下载日程
  MINOR_DELETE_SCHEDULE = $240e;    //删除日程
  MINOR_MODIFY_SCHEDULE = $240f;    //修改日程属性
  MINOR_RELEASE_SCHEDULE = $2410;    //发布日程
  MINOR_ADD_TERMINAL = $2411;    //添加终端
  MINOR_DELETE_TERMINAL = $2412;    //删除终端
  MINOR_MODIFY_TERMIANL_PARAM = $2413;    //修改终端参数
  MINOR_MODIFY_TERMIANL_PLAY_PARAM = $2414;    //配置终端播放参数
  MINOR_ADD_TERMIANL_GROUP = $2415;    //添加终端组
  MINOR_MODIFY_TERMINAL_GROUP_PARAM = $2416;    //修改终端组参数
  MINOR_DELETE_TERMIANL_GROUP = $2417;    //删除终端组
  MINOR_TERMINAL_PLAY_CONTROL = $2418;    //终端播放控制
  MINOR_TERMINAL_ON_OFF_LINE = $2419;    //终端上下线
  MINOR_SET_SWITCH_PLAN = $241a;    //设置终端定时开关机计划
  MINOR_SET_VOLUME_PLAN = $241b;    //设置终端定时音量计划
  MINOR_TERMINAL_SCREENSHOT = $241c;    //终端截屏
  MINOR_SYSTEM_TIME_CFG = $241d;    //系统校时
  MINOR_ADD_USER_CFG = $241e;    //添加用户配置
  MINOR_DEL_USER_CFG = $241f;    //删除用户配置
  MINOR_REMOTE_MANAGE_HDD = $2420;    //远程编辑硬盘
  MINOR_TERMINAL_UPDATE_START = $2421;    //终端升级
  MINOR_SVR_RESTORE_DEFAULT_PARAM = $2422;    //服务器远程恢复默认
  MINOR_SVR_REMOTE_RESTORE_FACTORY = $2423;    //服务器远程恢复出厂设置
  MINOR_SVR_REMOTE_REBOOT = $2424;    //服务器远程重启
  MINOR_SVR_MODIFY_NETWORK_PARAM = $2425;    //服务器网络参数修改
  MINOR_SVR_SOFTWARE_UPGRADE = $2426;    //服务器软件升级



const
  MINOR_REMOTE_CONFERENCE_CONFIG = $2501;    //MCU会议配置
  MINOR_REMOTE_TERMINAL_CONFIG = $2502;    //MCU终端配置
  MINOR_REMOTE_GROUP_CONFIG = $2503;    //MCU分组配置
  MINOR_REMOTE_CONFERENCE_CTRL = $2504;    //MCU会议控制
  MINOR_REMOTE_TERMINAL_CTRL = $2505;    //MCU终端控制
  MINOR_ADD_VIDEOWALLSCENE = $2506;    //新建电视墙场景
  MINOR_DEL_VIDEOWALLSCENE = $2507;    //删除电视墙场景
  MINOR_SAVE_VIDEOWALLSCENE = $2508;    //保存电视墙场景
  MINOR_UPLOAD_SCENECFGFILE = $2509;    //上传电视墙场景配置文件
  MINOR_DOWNLOAD_SCENECFGFILE = $250a;    //下载电视墙场景配置文件


//NVR后端
const
  MINOR_LOCAL_RESET_LOGIN_PASSWORD = $2600;    // 本地重置admin登陆密码
  MINOR_REMOTE_RESET_LOGIN_PASSWORD = $2601;    // 远程重置admin登录密码 
  MINOR_LOCAL_FACE_BASE_CREATE = $2602;    // 本地人脸对比库创建
  MINOR_REMOTE_FACE_BASE_CREATE = $2603;    // 远程人脸对比库创建
  MINOR_LOCAL_FACE_BASE_MODIFY = $2604;    // 本地人脸对比库修改
  MINOR_REMOTE_FACE_BASE_MODIFY = $2605;    // 远程人脸对比库修改
  MINOR_LOCAL_FACE_BASE_DELETE = $2606;    // 本地人脸对比库删除
  MINOR_REMOTE_FACE_BASE_DELETE = $2607;    // 远程人脸对比库删除
  MINOR_LOCAL_FACE_DATA_APPEND = $2608;    // 本地录入人脸数据
  MINOR_REMOTE_FACE_DATA_APPEND = $2609;    // 远程录入人脸数据
  MINOR_LOCAL_FACE_DATA_SEARCH = $2610;    // 本地人脸比对数据查找
  MINOR_REMOTE_FACE_DATA_SEARCH = $2611;    // 远程人脸比对数据查找
  MINOR_LOCAL_FACE_DATA_ANALYSIS = $2612;    // 本地图片分析操作
  MINOR_REMOTE_FACE_DATA_ANALYSIS = $2613;    // 远程图片分析操作
  MINOR_LOCAL_FACE_DATA_EDIT = $2614;    // 本地人脸数据修改
  MINOR_REMOTE_FACE_DATA_EDIT = $2615;    // 远程人脸数据修改

const
  MINOR_LOCAL_FACE_DATA_DELETE = $2616;    // 本地人脸数据删除
  MINOR_REMOTE_FACE_DATA_DELET = $2617;    // 远程人脸数据删除

const
  MINOR_LOCAL_VCA_ANALYSIS_CFG = $2618;    // 本地智能分析配置
  MINOR_REMOTE_VCA_ANALYSIS_CFG = $2619;    // 远程智能分析配置

const
  MINOR_LOCAL_FACE_BASE_IMPORT = $261a;    // 本地导入人脸库
  MINOR_LOCAL_FACE_BASE_EXPORT = $261b;    // 本地导出人脸库
//NVR集群
const
  MINOR_REMOTE_CLUSTER_MODE_CONFIG = $261c;    // 远程集群模式配置操作
  MINOR_LOCAL_CLUSTER_MODE_CONFIG = $261d;    // 本地集群模式配置操作
  MINOR_REMOTE_CLUSTER_NETWORK_CONFIG = $261e;    // 远程集群组网配置操作
  MINOR_LOCAL_CLUSTER_NETWORK_CONFIG = $261f;    // 本地集群组网配置操作
  MINOR_REMOTE_CLUSTER_ADD_DEVICE = $2620;    // 远程集群添加设备操作
  MINOR_LOCAL_CLUSTER_ADD_DEVICE = $2621;    // 本地集群添加设备操作
  MINOR_REMOTE_CLUSTER_DEL_DEVICE = $2622;    // 远程集群删除设备操作
  MINOR_LOCAL_CLUSTER_DEL_DEVICE = $2623;    // 本地集群删除设备操作
  MINOR_REMOTE_HFPD_CFG = $2624;    // 远程高频人员检测配置
  MINOR_REMOTE_FACE_CONTRAST_TASK = $2625;    // 远程人脸比对任务配置 
  MINOR_REMOTE_LFPD_CFG = $2626;    // 远程低频人员检测配置
  MINOR_REMOTE_IOTCFGFILE_INPUT = $2627;    //远程导入IOT配置文件
  MINOR_REMOTE_IOTCFGFILE_OUTPUT = $2628;    //远程导出IOT配置文件
  MINOR_LOCAL_IOT_ADD = $2629;    //本地添加IOT通道
  MINOR_REMOTE_IOT_ADD = $262a;    //远程添加IOT通道
  MINOR_LOCAL_IOT_DEL = $262b;    //本地删除IOT通道
  MINOR_REMOTE_IOT_DEL = $262c;    //远程删除IOT通道
  MINOR_LOCAL_IOT_SET = $262d;    //本地配置IOT通道
  MINOR_REMOTE_IOT_SET = $262e;    //远程配置IOT通道
  MINOR_LOCAL_IOTCFGFILE_INPUT = $262f;    //本地导入IOT配置文件
  MINOR_LOCAL_IOTCFGFILE_OUTPUT = $2630;    //本地导出IOT配置文件
  MINOR_LOCAL_VAD_CFG = $2631;    // 本地语音活动检测配置
  MINOR_REMOTE_VAD_CFG = $2632;    // 远程语音活动检测配置
  MINOR_LOCAL_ADDRESS_FILTER_CONFIG = $2633;    // 本地地址过滤配置
  MINOR_REMOTE_ADDRESS_FILTER_CONFIG = $2634;    // 远程地址过滤配置
  MINOR_LOCAL_POE_CFG = $2635;    // 本地POE配置
  MINOR_REMOTE_POE_CFG = $2636;    // 远程POE配置
  MINOR_LOCAL_RESET_CHANNEL_PASSWORD = $2637;    // 本地重置通道密码
  MINOR_REMOTE_RESET_CHANNEL_PASSWORD = $2638;    // 远程重置通道密码
  MINOR_LOCAL_SSD_UPGRADE_START = $2639;    // 本地SSD文件系统升级开始
  MINOR_LOCAL_SSD_UPGRADE_STOP = $2640;    // 本地SSD文件系统升级结束
  MINOR_REMOTE_SSD_UPGRADE_START = $2641;    // 远程SSD文件系统升级开始
  MINOR_REMOTE_SSD_UPGRADE_STOP = $2642;    // 远程SSD文件系统升级结束
  MINOR_LOCAL_SSD_FORMAT_START = $2643;    //本地SSD文件系统格式化开始
  MINOR_LOCAL_SSD_FORMAT_STOP = $2644;    //本地SSD文件系统格式化结束
  MINOR_REMOTE_SSD_FORMAT_START = $2645;    //远程SSD文件系统格式化开始
  MINOR_REMOTE_SSD_FORMAT_STOP = $2646;    //远程SSD文件系统格式化结束
  MINOR_LOCAL_AUTO_SWITCH_CONFIG = $2647;    // 本地自动开关机配置
  MINOR_REMOTE_AUTO_SWITCH_CONFIG = $2648;    // 远程自动开关机配置

const
  MINOR_LOCAL_SSD_INITIALIZATION_START = $264a;    // 本地SSD初始化开始
  MINOR_LOCAL_SSD_INITIALIZATION_END = $264b;    // 本地SSD初始化结束
  MINOR_REMOTE_SSD_INITIALIZATION_START = $264c;    // 远程SSD初始化开始
  MINOR_REMOTE_SSD_INITIALIZATION_END = $264d;    // 远程SSD初始化结束


//定义AI开放平台的操作日志
const
  MINOR_REMOTE_AI_MODEL_ADD = $2650;    //模型包添加
  MINOR_REMOTE_AI_MODEL_QUERY = $2651;    //模型包查询
  MINOR_REMOTE_AI_MODEL_DELETE = $2652;    //模型包删除
  MINOR_REMOTE_AI_MODEL_UPDATE = $2653;    //模型包更新
  MINOR_REMOTE_AI_PICTURE_POLLING_TASK_ADD = $2654;    //图片轮询任务增加
  MINOR_REMOTE_AI_PICTURE_POLLING_TASK_QUERY = $2655;    //图片轮询任务查询
  MINOR_REMOTE_AI_PICTURE_POLLING_TASK_DELETE = $2656;    //图片轮询任务删除
  MINOR_REMOTE_AI_PICTURE_POLLING_TASK_MODIFY = $2657;    //图片轮询任务修改
  MINOR_REMOTE_AI_VIDEO_POLLING_TASK_ADD = $2658;    //视频轮询任务增加
  MINOR_REMOTE_AI_VIDEO_POLLING_TASK_QUERY = $2659;    //视频轮询任务查询
  MINOR_REMOTE_AI_VIDEO_POLLING_TASK_DELETE = $265A;    //视频轮询任务删除
  MINOR_REMOTE_AI_VIDEO_POLLING_TASK_MODIFY = $265B;    //视频轮询任务修改
  MINOR_REMOTE_AI_PICTURE_TASK_ADD = $265C;    //图片任务增加
  MINOR_REMOTE_AI_PICTURE_TASK_QUERY = $265D;    //图片任务查询
  MINOR_REMOTE_AI_PICTURE_TASK_DELETE = $265E;    //图片任务删除
  MINOR_REMOTE_AI_PICTURE_TASK_MODIFY = $265F;    //图片任务修改
  MINOR_REMOTE_AI_VIDEO_TASK_ADD = $2660;    //视频任务增加
  MINOR_REMOTE_AI_VIDEO_TASK_QUERY = $2661;    //视频任务查询
  MINOR_REMOTE_AI_VIDEO_TASK_DELETE = $2662;    //视频任务删除
  MINOR_REMOTE_AI_VIDEO_TASK_MODIFY = $2663;    //视频任务修改
  MINOR_REMOTE_AI_RULE_CONFIG = $2664;    //AI规则配置

const
  MINOR_REMOTE_LOG_STORAGE_CONFIG = $2665;    //日志存储配置
  MINOR_REMOTE_LOG_SERVER_CONFIG = $2666;    //日志服务器参数配置

const
  MINOR_REMOTE_RESET_IPC_PASSWORD = $2670;    //NVR重置IPC密码日志

//定义萤石平台操作日志
const
  MINOR_LOCAL_EZVIZ_OPERATION = $2671;    //本地萤石操作(包括萤石参数配置和升级)
  MINOR_REMOTE_EZVIZ_OPERATION = $2672;    //远程萤石操作(包括萤石参数配置和升级)

const
  MINOR_EZVIZ_BITSTREAM_PARAMATERS_CONFIG = $2673;    // 萤石码流参数配置
  MINOR_EZVIZ_ALARM_PARAMATERS_CONFIG = $2674;    // 萤石报警参数配置
  MINOR_EZVIZ_UPGRADE = $2675;    // 萤石升级
  MINOR_EZVIZ_REGISTER = $2676;    // 萤石注册
  MINOR_EZVIZ_LOCAL_PARAMATERS_CONFIG = $2677;    // 萤石本地参数配置
  MINOR_EZVIZ_REMOTE_PARAMATERS_CONFIG = $2678;    // 萤石远程参数配置


//消防操作日志
const
  MINOR_STOP_SOUND = $2700;    //消音
  MINOR_SELF_CHECK = $2701;    //自检
  MINOR_DUTY_CHECK = $2702;    //查岗
  MINOR_SWITCH_SIMPLE_WORKMODE = $2703;    //切换至简易模式
  MINOR_SWITCH_NORMAL_WORKMODE = $2704;    //切换至标准模式
  MINOR_LOCAL_SSD_OPERATE_START = $2705;    // 本地SSD操作开始
  MINOR_LOCAL_SSD_OPERATE_STOP = $2706;    // 本地SSD操作结束
  MINOR_REMOTE_SSD_OPERATE_START = $2707;    // 远程SSD操作开始
  MINOR_REMOTE_SSD_OPERATE_STOP = $2708;    // 远程SSD操作结束

//日志附加信息
//主类型
const
  MAJOR_INFORMATION = $4;    //附加信息
//次类型
const
  MINOR_HDD_INFO = $a1;    //硬盘信息
  MINOR_SMART_INFO = $a2;    //SMART信息
  MINOR_REC_START = $a3;    //开始录像
  MINOR_REC_STOP = $a4;    //停止录像
  MINOR_REC_OVERDUE = $a5;    //过期录像删除
  MINOR_LINK_START = $a6;    //连接前端设备
  MINOR_LINK_STOP = $a7;    //断开前端设备　
  MINOR_NET_DISK_INFO = $a8;    //网络硬盘信息
  MINOR_RAID_INFO = $a9;    //raid相关信息
  MINOR_RUN_STATUS_INFO = $aa;    //系统运行状态信息

//Netra3.0.0
const
  MINOR_SPARE_START_BACKUP = $ab;    //热备系统开始备份指定工作机
  MINOR_SPARE_STOP_BACKUP = $ac;    //热备系统停止备份指定工作机
  MINOR_SPARE_CLIENT_INFO = $ad;    //热备客户机信息
  MINOR_ANR_RECORD_START = $ae;    //ANR录像开始
  MINOR_ANR_RECORD_END = $af;    //ANR录像结束
  MINOR_ANR_ADD_TIME_QUANTUM = $b0;    //ANR添加时间段
  MINOR_ANR_DEL_TIME_QUANTUM = $b1;    //ANR删除时间段

const
  MINOR_PIC_REC_START = $b3;    // 开始抓图
  MINOR_PIC_REC_STOP = $b4;    // 停止抓图
  MINOR_PIC_REC_OVERDUE = $b5;    // 过期图片文件删除 
//Netra3.1.0
const
  MINOR_CLIENT_LOGIN = $b6;    //登录服务器成功
  MINOR_CLIENT_RELOGIN = $b7;    //重新登录服务器
  MINOR_CLIENT_LOGOUT = $b8;    //退出服务器成功
  MINOR_CLIENT_SYNC_START = $b9;    //录像同步开始
  MINOR_CLIENT_SYNC_STOP = $ba;    //录像同步终止
  MINOR_CLIENT_SYNC_SUCC = $bb;    //录像同步成功
  MINOR_CLIENT_SYNC_EXCP = $bc;    //录像同步异常
  MINOR_GLOBAL_RECORD_ERR_INFO = $bd;    //全局错误记录信息
  MINOR_BUFFER_STATE = $be;    //缓冲区状态日志记录
  MINOR_DISK_ERRORINFO_V2 = $bf;    //硬盘错误详细信息V2
  MINOR_CS_DATA_EXPIRED = $c0;    //云存储数据过期
  MINOR_PLAT_INFO = $c1;    //平台操作信息
  MINOR_DIAL_STAT = $c2;    //拨号状态

const
  MINOR_UNLOCK_RECORD = $c3;    //开锁记录
  MINOR_VIS_ALARM = $c4;    //防区报警
  MINOR_TALK_RECORD = $c5;    //通话记录
  MINOR_ACCESSORIES_MESSAGE = $c6;    //配件板信息
  MINOR_KMS_EXPAMSION_DISK_INSERT = $c7;    // KMS扩容盘插入
  MINOR_IPC_CONNECT = $c8;    //  IPC连接信息
  MINOR_INTELLIGENT_BOARD_STATUS = $c9;    //  智能板状态
  MINOR_IPC_CONNECT_STATUS = $ca;    //  IPC连接状态
  MINOR_AUTO_TIMING = $cb;    //自动校时
  MINOR_EZVIZ_OPERATION = $cc;    //萤石运行状态
//NVR集群
const
  MINOR_CLUSTER_DEVICE_ONLINE = $cd;    //集群设备上线
  MINOR_CLUSTER_MGR_SERVICE_STARTUP = $ce;    //集群管理服务启动
  MINOR_CLUSTER_BUSINESS_TRANSFER = $cf;    //集群业务迁移
  MINOR_CLUSTER_STATUS = $d0;    //集群状态信息
  MINOR_CLUSTER_CS_STATUS = $d1;    //集群CS向CM发送设备状态失败，记录CS和CM的IP地址
  MINOR_CLUSTER_CM_STATUS = $d2;    //CM状态切换，记录CM转变的角色，如leader、follower、candidate
  MINOR_VOICE_START_DETECTED = $d3;    //检测到语音开始
  MINOR_VOICE_END_DETECTED = $d4;    //检测到语音结束
  MINOR_DOUBLE_VERIFICATION_PASS = $d5;    //二次认证通过
  MINOR_WIRELESS_RUNNING_STATUS = $d6;    //无线运行状态
  MINOR_SYSTEM_DATA_SYNCHRONIZATION = $d7;    //系统数据同步
  MINOR_HD_FORMAT_START = $d8;    //硬盘格式化开始
  MINOR_HD_FORMAT_STOP = $d9;    //硬盘格式化结束

//0x400-0x4ff 门禁附件信息日志类型
const
  MINOR_LIVE_DETECT_OPEN = $400;    //真人检测开启
  MINOR_LIVE_DETECT_CLOSE = $401;    //真人检测关闭
  MINOR_CLEAR_DATA_COLLECTION = $402;    //采集数据清空
  MINOR_DELETE_DATA_COLLECTION = $403;    //采集数据删除
  MINOR_EXPORT_DATA_COLLECTION = $404;    //采集数据导出
  MINOR_CARD_LEN_CONFIG = $405;    //卡长度配置
  MINOR_DATA_BASE_INIT_FAILED = $406;    //数据库初始化失败
  MINOR_DATA_BASE_PATCH_UPDATE = $407;    //数据库补丁升级
  MINOR_PSAM_CARD_INSERT = $408;    //Psam卡插入
  MINOR_PSAM_CARD_REMOVE = $409;    //Psam卡拔出
  MINOR_HARD_FAULT_REBOOT = $40a;    //硬件异常（hardfault）重启
  MINOR_PSAM_CARD_OCP = $40b;    //Psam卡过流保护
  MINOR_STACK_OVERFLOW = $40c;    //堆栈溢出
  MINOR_PARM_CFG = $40d;    //参数配置
  MINOR_CLR_USER = $40e;    //清空所有用户
  MINOR_CLR_CARD = $40f;    //清空所有卡
  MINOR_CLR_FINGER_BY_READER = $410;    //清空所有指纹(按读卡器)
  MINOR_CLR_FINGER_BY_CARD = $411;    //清空所有指纹(按卡号)
  MINOR_CLR_FINGER_BY_EMPLOYEE_ON = $412;    //清空所有指纹(按工号)
  MINOR_DEL_FINGER = $413;    //删除一个指纹
  MINOR_CLR_WEEK_PLAN = $414;    //清除权限周计划
  MINOR_SET_WEEK_PLAN = $415;    //设置权限周计划
  MINOR_SET_HOLIDAY_PLAN = $416;    //设置权限假日计划
  MINOR_CLR_HOLIDAY_PLAN = $417;    //清除权限假日计划
  MINOR_SET_HOLIDAY_GROUP = $418;    //设置权限假日组计划
  MINOR_CLR_HOLIDAY_GROUP = $419;    //清除权限假日组计划
  MINOR_CLR_TEMPLATE_PLAN = $41a;    //清除权限计划
  MINOR_SET_TEMPLATE_PLAN = $41b;    //设置权限计划
  MINOR_ADD_CARD = $41c;    //新增卡
  MINOR_MOD_CARD = $41d;    //修改卡
  MINOR_ADD_FINGER_BY_CARD = $41e;    //新增指纹(按卡号)
  MINOR_ADD_FINGER_BY_EMPLOYEE_NO = $41f;    //新增指纹(按工号)
  MINOR_MOD_FINGER_BY_CARD = $420;    //修改指纹(按卡号)
  MINOR_MOD_FINGER_BY_EMPLOYEE_NO = $421;    //修改指纹(按工号)
  MINOR_IMPORT_USER_LIST = $422;    //用户列表导入（离线采集）
  MINOR_USB_LOGIN = $423;    //USB登陆
  MINOR_USB_LOGOUT = $424;    //USB登出
  MINOR_ISAPI_HTTP_LOGIN = $425;    //ISAPI HTTP登陆
  MINOR_ISAPI_HTTP_LOGOUT = $426;    //ISAPI HTTP 登出
  MINOR_ISAPI_HTTPS_LOGIN = $427;    //ISAPI HTTPS登陆
  MINOR_ISAPI_HTTPS_LOGOUT = $428;    //ISAPI HTTPS登出
  MINOR_ISUP_ONLINE = $429;    //ISUP在线
  MINOR_ISUP_OFFLINE = $42a;    //ISUP下线
  MINOR_FP_ISSUE_REC = $42b;    //指纹发卡记录
  MINOR_FACE_ISSUE_REC = $42c;    //人脸发卡记录
  MINOR_ADD_IRIS = $42d;    //下发虹膜
  MINOR_MODIFY_IRIS = $42e;    //修改虹膜
  MINOR_DELETE_EMPLOYEE_IRIS = $42f;    //删除用户虹膜（按工号删除）
  MINOR_DELETE_WHOLE_IRIS = $430;    //删除全部虹膜
  MINOR_MODIFY_IRIS_CFG = $431;    //修改虹膜参数
  MINOR_ADD_USER_INFO = $432;    //新增人员信息（门禁人员权限）
  MINOR_MODIFY_USER_INFO = $433;    //修改人员信息（门禁人员权限）
  MINOR_CLR_USER_INFO = $434;    //删除人员信息（门禁人员权限，按工号）
  MINOR_CLR_CARD_BY_CARD_OR_EMPLOYEE = $435;    //删除卡（按卡号或工号）
  MINOR_CLR_ALL_CARD = $436;    //删除所有卡
  MINOR_SIM_CARD_INSERT = $437;    //SIM卡插入
  MINOR_SIM_CARD_PULLOUT = $438;    //SIM卡拔出
  MINOR_FINGERPRINT_RECOGNITION_OPEN = $439;    //指纹识别开启
  MINOR_FINGERPRINT_RECOGNITION_CLOSE = $43a;    //指纹识别关闭
  MINOR_FACE_RECOGNITION_OPEN = $43b;    //人脸识别开启
  MINOR_FACE_RECOGNITION_CLOSE = $43c;    //人脸识别关闭
  MINOR_RESET_ONLINE_READER = $43d;    //重置在线读卡器
  MINOR_CLEAR_IRIS_PICTURE = $43e;    //清空虹膜底图
  MINOR_ADD_VP = $43f;    //下发声纹
  MINOR_MODIFY_VP = $440;    //修改声纹
  MINOR_DELETE_EMPLOYEE_VP = $441;    //按工号删除声纹
  MINOR_DELETE_ALL_VP = $442;    //删除所有声纹


//802.1x认证操作日志
const
  MINOR_802_1X_AUTH_SUCC = $320;    //802.1x认证成功
  MINOR_802_1X_AUTH_FAIL = $321;    //802.1x认证失败

//事件
//主类型
const
  MAJOR_EVENT = $5;    //事件
//次类型
const
  MINOR_LEGAL_CARD_PASS = $01;    //合法卡认证通过
  MINOR_CARD_AND_PSW_PASS = $02;    //刷卡加密码认证通过
  MINOR_CARD_AND_PSW_FAIL = $03;    //刷卡加密码认证失败
  MINOR_CARD_AND_PSW_TIMEOUT = $04;    //数卡加密码认证超时
  MINOR_CARD_AND_PSW_OVER_TIME = $05;    //刷卡加密码超次
  MINOR_CARD_NO_RIGHT = $06;    //未分配权限
  MINOR_CARD_INVALID_PERIOD = $07;    //无效时段
  MINOR_CARD_OUT_OF_DATE = $08;    //卡号过期
  MINOR_INVALID_CARD = $09;    //无此卡号
  MINOR_ANTI_SNEAK_FAIL = $0a;    //反潜回认证失败
  MINOR_INTERLOCK_DOOR_NOT_CLOSE = $0b;    //互锁门未关闭
  MINOR_NOT_BELONG_MULTI_GROUP = $0c;    //卡不属于多重认证群组
  MINOR_INVALID_MULTI_VERIFY_PERIOD = $0d;    //卡不在多重认证时间段内
  MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL = $0e;    //多重认证模式超级权限认证失败
  MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL = $0f;    //多重认证模式远程认证失败
  MINOR_MULTI_VERIFY_SUCCESS = $10;    //多重认证成功
  MINOR_LEADER_CARD_OPEN_BEGIN = $11;    //首卡开门开始
  MINOR_LEADER_CARD_OPEN_END = $12;    //首卡开门结束
  MINOR_ALWAYS_OPEN_BEGIN = $13;    //常开状态开始
  MINOR_ALWAYS_OPEN_END = $14;    //常开状态结束
  MINOR_LOCK_OPEN = $15;    //门锁打开
  MINOR_LOCK_CLOSE = $16;    //门锁关闭
  MINOR_DOOR_BUTTON_PRESS = $17;    //开门按钮打开
  MINOR_DOOR_BUTTON_RELEASE = $18;    //开门按钮放开
  MINOR_DOOR_OPEN_NORMAL = $19;    //正常开门（门磁）
  MINOR_DOOR_CLOSE_NORMAL = $1a;    //正常关门（门磁）
  MINOR_DOOR_OPEN_ABNORMAL = $1b;    //门异常打开（门磁）
  MINOR_DOOR_OPEN_TIMEOUT = $1c;    //门打开超时（门磁）
  MINOR_ALARMOUT_ON = $1d;    //报警输出打开
  MINOR_ALARMOUT_OFF = $1e;    //报警输出关闭
  MINOR_ALWAYS_CLOSE_BEGIN = $1f;    //常关状态开始
  MINOR_ALWAYS_CLOSE_END = $20;    //常关状态结束
  MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN = $21;    //多重多重认证需要远程开门
  MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS = $22;    //多重认证超级密码认证成功事件
  MINOR_MULTI_VERIFY_REPEAT_VERIFY = $23;    //多重认证重复认证事件
  MINOR_MULTI_VERIFY_TIMEOUT = $24;    //多重认证重复认证事件
  MINOR_DOORBELL_RINGING = $25;    //门铃响
  MINOR_FINGERPRINT_COMPARE_PASS = $26;    //指纹比对通过
  MINOR_FINGERPRINT_COMPARE_FAIL = $27;    //指纹比对失败
  MINOR_CARD_FINGERPRINT_VERIFY_PASS = $28;    //刷卡加指纹认证通过
  MINOR_CARD_FINGERPRINT_VERIFY_FAIL = $29;    //刷卡加指纹认证失败
  MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT = $2a;    //刷卡加指纹认证超时
  MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS = $2b;    //刷卡加指纹加密码认证通过
  MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL = $2c;    //刷卡加指纹加密码认证失败
  MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = $2d;    //刷卡加指纹加密码认证超时
  MINOR_FINGERPRINT_PASSWD_VERIFY_PASS = $2e;    //指纹加密码认证通过
  MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL = $2f;    //指纹加密码认证失败
  MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = $30;    //指纹加密码认证超时
  MINOR_FINGERPRINT_INEXISTENCE = $31;    //指纹不存在
  MINOR_CARD_PLATFORM_VERIFY = $32;    //刷卡平台认证
  MINOR_CALL_CENTER = $33;    //呼叫中心事件
  MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN = $34;    //消防继电器导通触发门常开
  MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL = $35;    //消防继电器恢复门恢复正常
  MINOR_FACE_AND_FP_VERIFY_PASS = $36;    //人脸加指纹认证通过
  MINOR_FACE_AND_FP_VERIFY_FAIL = $37;    //人脸加指纹认证失败
  MINOR_FACE_AND_FP_VERIFY_TIMEOUT = $38;    //人脸加指纹认证超时
  MINOR_FACE_AND_PW_VERIFY_PASS = $39;    //人脸加密码认证通过
  MINOR_FACE_AND_PW_VERIFY_FAIL = $3a;    //人脸加密码认证失败
  MINOR_FACE_AND_PW_VERIFY_TIMEOUT = $3b;    //人脸加密码认证超时
  MINOR_FACE_AND_CARD_VERIFY_PASS = $3c;    //人脸加刷卡认证通过
  MINOR_FACE_AND_CARD_VERIFY_FAIL = $3d;    //人脸加刷卡认证失败
  MINOR_FACE_AND_CARD_VERIFY_TIMEOUT = $3e;    //人脸加刷卡认证超时
  MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS = $3f;    //人脸加密码加指纹认证通过
  MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL = $40;    //人脸加密码加指纹认证失败
  MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT = $41;    //人脸加密码加指纹认证超时
  MINOR_FACE_CARD_AND_FP_VERIFY_PASS = $42;    //人脸加刷卡加指纹认证通过
  MINOR_FACE_CARD_AND_FP_VERIFY_FAIL = $43;    //人脸加刷卡加指纹认证失败
  MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT = $44;    //人脸加刷卡加指纹认证超时
  MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS = $45;    //工号加指纹认证通过
  MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL = $46;    //工号加指纹认证失败
  MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT = $47;    //工号加指纹认证超时
  MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS = $48;    //工号加指纹加密码认证通过
  MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL = $49;    //工号加指纹加密码认证失败
  MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT = $4a;    //工号加指纹加密码认证超时
  MINOR_FACE_VERIFY_PASS = $4b;    //人脸认证通过
  MINOR_FACE_VERIFY_FAIL = $4c;    //人脸认证失败
  MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS = $4d;    //工号加人脸认证通过
  MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL = $4e;    //工号加人脸认证失败
  MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT = $4f;    //工号加人脸认证超时
  MINOR_FACE_RECOGNIZE_FAIL = $50;    //人脸识别失败
  MINOR_FIRSTCARD_AUTHORIZE_BEGIN = $51;    //首卡授权开始
  MINOR_FIRSTCARD_AUTHORIZE_END = $52;    //首卡授权结束
  MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT = $53;    //门锁输入短路报警
  MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT = $54;    //门锁输入断路报警
  MINOR_DOORLOCK_INPUT_EXCEPTION = $55;    //门锁输入异常报警
  MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT = $56;    //门磁输入短路报警
  MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT = $57;    //门磁输入断路报警
  MINOR_DOORCONTACT_INPUT_EXCEPTION = $58;    //门磁输入异常报警
  MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT = $59;    //开门按钮输入短路报警
  MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT = $5a;    //开门按钮输入断路报警
  MINOR_OPENBUTTON_INPUT_EXCEPTION = $5b;    //开门按钮输入异常报警
  MINOR_DOORLOCK_OPEN_EXCEPTION = $5c;    //门锁异常打开
  MINOR_DOORLOCK_OPEN_TIMEOUT = $5d;    //门锁打开超时
  MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE = $5e;    //首卡未授权开门失败
  MINOR_CALL_LADDER_RELAY_BREAK = $5f;    //呼梯继电器断开
  MINOR_CALL_LADDER_RELAY_CLOSE = $60;    //呼梯继电器闭合
  MINOR_AUTO_KEY_RELAY_BREAK = $61;    //自动按键继电器断开
  MINOR_AUTO_KEY_RELAY_CLOSE = $62;    //自动按键继电器闭合
  MINOR_KEY_CONTROL_RELAY_BREAK = $63;    //按键梯控继电器断开
  MINOR_KEY_CONTROL_RELAY_CLOSE = $64;    //按键梯控继电器闭合
  MINOR_EMPLOYEENO_AND_PW_PASS = $65;    //工号加密码认证通过
  MINOR_EMPLOYEENO_AND_PW_FAIL = $66;    //工号加密码认证失败
  MINOR_EMPLOYEENO_AND_PW_TIMEOUT = $67;    //工号加密码认证超时
  MINOR_HUMAN_DETECT_FAIL = $68;    //真人检测失败
  MINOR_PEOPLE_AND_ID_CARD_COMPARE_PASS = $69;    //人证比对通过
  MINOR_PEOPLE_AND_ID_CARD_COMPARE_FAIL = $70;    //人证比对失败
  MINOR_CERTIFICATE_BLOCKLIST = $71;    //禁止名单事件
  MINOR_LEGAL_MESSAGE = $72;    //合法短信
  MINOR_ILLEGAL_MESSAGE = $73;    //非法短信
  MINOR_DOOR_OPEN_OR_DORMANT_FAIL = $75;    //门状态常闭或休眠状态认证失败
  MINOR_AUTH_PLAN_DORMANT_FAIL = $76;    //认证计划休眠模式认证失败
  MINOR_CARD_ENCRYPT_VERIFY_FAIL = $77;    //卡加密校验失败
  MINOR_SUBMARINEBACK_REPLY_FAIL = $78;    //反潜回服务器应答失败
  MINOR_DOOR_OPEN_OR_DORMANT_OPEN_FAIL = $82;    //门常闭或休眠时开门按钮开门失败
  MINOR_HEART_BEAT = $83;    //心跳事件
  MINOR_DOOR_OPEN_OR_DORMANT_LINKAGE_OPEN_FAIL = $84;    //门常闭或休眠时开门联动开门失败
  MINOR_TRAILING = $85;    //尾随通行
  MINOR_REVERSE_ACCESS = $86;    //反向闯入
  MINOR_FORCE_ACCESS = $87;    //外力冲撞
  MINOR_CLIMBING_OVER_GATE = $88;    //翻越
  MINOR_PASSING_TIMEOUT = $89;    //通行超时
  MINOR_INTRUSION_ALARM = $8a;    //误闯报警
  MINOR_FREE_GATE_PASS_NOT_AUTH = $8b;    //闸机自由通行时未认证通过
  MINOR_DROP_ARM_BLOCK = $8c;    //摆臂被阻挡
  MINOR_DROP_ARM_BLOCK_RESUME = $8d;    //摆臂阻挡消除
  MINOR_LOCAL_FACE_MODELING_FAIL = $8e;    //设备升级本地人脸建模失败
  MINOR_STAY_EVENT = $8f;    //逗留事件
  MINOR_CERTIFICATE_ALLOWLIST_PASS = $90;    //授权名单认证通过
  MINOR_CERTIFICATE_ALLOWLIST_FALL = $91;    //授权名单认证失败
  MINOR_FACE_COLLECTION = $92;    //人脸采集事件（无认证，远程核验时上报）
  MINOR_CARD_COLLECTION = $93;    //卡采集事件（无认证，远程核验时上报）
  MINOR_PSW_ERROR_OVER_TIMES = $94;    //密码认证失败超次
  MINOR_ID_CARD_COLLECTION = $95;    //身份证采集事件（无认证，远程核验时上报）
  MINOR_PSW_VERIFY_FAIL = $96;    //密码认证失败
  MINOR_PASSWORD_MISMATCH = $97;    //密码不匹配
  MINOR_EMPLOYEE_NO_NOT_EXIST = $98;    //工号不存在
  MINOR_COMBINED_VERIFY_PASS = $99;    //组合认证通过
  MINOR_COMBINED_VERIFY_TIMEOUT = $9a;    //组合认证超时
  MINOR_VERIFY_MODE_MISMATCH = $9b;    //认证方式不匹配
  MINOR_ORCODE_VERIFY_PASS = $9c;    //二维码认证通过
  MINOR_ORCODE_VERIFY_FAIL = $9d;    //二维码认证失败
  MINOR_HOUSEHOLDER_AUTHORIZE_PASS = $9e;    //户主授权认证通过
  MINOR_BLUETOOTH_VERIFY_PASS = $9f;    //蓝牙认证通过
  MINOR_BLUETOOTH_VERIFY_FAIL = $a0;    //蓝牙认证失败

const
  MINOR_PASSPORT_VERIFY_FAIL = $a1;    //护照信息校验失败
  MINOR_INFORMAL_M1_CARD_VERIFY_FAIL = $a2;    //非正规M1卡认证失败
  MINOR_CPU_CARD_ENCRYPT_VERIFY_FAIL = $a3;    //CPU卡加密校验失败
  MINOR_NFC_DISABLE_VERIFY_FAIL = $a4;    //NFC功能关闭验证失败

const
  MINOR_LORA_MODULE_ONLINE = $a5;    //LoRa模块上线
  MINOR_LORA_MODULE_OFFLINE = $a6;    //LoRa模块下线
  MINOR_MQTT_STATUS = $a7;    //Mqtt连接状态

const
  MINOR_EM_CARD_RECOGNIZE_NOT_ENABLED = $a8;    //EM卡识别未启用
  MINOR_M1_CARD_RECOGNIZE_NOT_ENABLED = $a9;    //M1卡识别未启用
  MINOR_CPU_CARD_RECOGNIZE_NOT_ENABLED = $aa;    //CPU卡识别未启用
  MINOR_ID_CARD_RECOGNIZE_NOT_ENABLED = $ab;    //身份证识别未启用
  MINOR_CARD_SET_SECRET_KEY_FAIL = $ac;    //卡灌装密钥失败
  MINOR_LOCAL_UPGRADE_FAIL = $ad;    // 本地升级失败 
  MINOR_REMOTE_UPGRADE_FAIL = $ae;    // 远程升级失败 
  MINOR_REMOTE_EXTEND_MODULE_UPGRADE_SUCC = $af;    //远程扩展模块升级成功
  MINOR_REMOTE_EXTEND_MODULE_UPGRADE_FAIL = $b0;    //远程扩展模块升级失败
  MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_SUCC = $b1;    //远程指纹模组升级成功
  MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_FAIL = $b2;    //远程指纹模组升级失败
  MINOR_DYNAMICCODE_VERIFY_PASS = $b3;    // 动态验证码认证通过
  MINOR_DYNAMICCODE_VERIFY_FAIL = $b4;    // 动态验证码认证失败
  MINOR_PASSWD_VERIFY_PASS = $b5;    //密码认证通过
  MINOR_COMSUME_TIMEOUT = $b6;    //消费超时
  MINOR_REFUND_TIMEOUT = $b7;    //纠错超时
  MINOR_COMSUME_AMOUNT_OVERLIMIT = $b8;    //消费金额超过最大值
  MINOR_COMSUME_TIMES_OVERLIMIT = $b9;    //消费次数满
  MINOR_USER_COMSUME_ENSURE_TIMEOUT = $ba;    //用户消费确认超时
  MINOR_BLOCKLIST_REACH_THRESHOLD = $bb;    //禁止名单数量达到阈值
  MINOR_DESFIRE_CARD_ENCRYPT_VERIFY_FAIL = $bc;    //Desfire卡加密校验失败
  MINOR_DESFIRE_CARD_RECOGNIZE_NOT_ENABLED = $bd;    //Desfire卡识别未启用
  MINOR_IRIS_VERIFY_PASS = $be;    //虹膜认证通过
  MINOR_IRIS_VERIFY_FAIL = $bf;    //虹膜认证失败
  MINOR_IRIS_BIOASSAY_FAIL = $c0;    //虹膜活体检测失败
  MINOR_FULL_STAFF = $c1;    //人员满提醒事件，人员数量超过90%时产生
  MINOR_ATTENDANCE_RECORD_EXCEED_THRESHOLD = $c2;    //本地考勤记录超过设置的阈值
  MINOR_DYNAMICCODE_VERIFY_INVALID = $c3;    // 动态验证码认证过期
  MINOR_MEETING_NO_SIGNIN = $c4;    //会议未签到
  MINOR_MEETING_SIGNIN = $c5;    //会议签到
  MINOR_MEETING_LATE = $c6;    //会议迟到

const
  MINOR_INTERLOCK_SERVER_FAILED_RESPONSE = $c9;    //多门互锁服务器应答失败
  MINOR_FINGERPRINT_DISENABELD_VERIFY_FAIL = $ca;    //指纹识别未使能认证失败
  MINOR_FACE_DISENABELD_VERIFY_FAIL = $cb;    //人脸识别未使能认证失败
  MINOR_MONITOR_OPEN_DOOR = $cc;    //开门
  MINOR_READER_FACTORY_RESET = $cd;    //读卡器恢复出厂设置
  MINOR_READER_ID_CONFLICT = $ce;    //读卡器ID冲突
  MINOR_FELICA_CARD_RECOGNIZE_NOT_ENABLED = $cf;    //Felica卡识别未启用
  MINOR_PROPERTY_EXCEPTION_VERIFY_FAIL = $d0;    //属性异常认证失败（未戴口罩，安全帽，体温异常等属性异常）
  MINOR_MEETING_NO_PERSON = $d1;    //非会议人员：会议模式下，所有状态，非会议人员签到，上报该事件
  MINOR_MEETING_NOT_START = $d2;    //会议未开始：会议空闲状态，会议人员签到
  MINOR_MEETING_SIGNEDIN = $d3;    //已签到：已签到会议人员重复签到
  MINOR_AUTHENTICATION_TIMES_REACHED = $d4;    //人员认证次数已满（在权限计划的当前时间段内，达到认证次数限制）
  MINOR_FACE_MODEL_FAIL_BY_UPGRADE = $d5;    //人脸建模升级兼容失败事件

const
  MINOR_UNCLOCK_RECORD = $d6;    //设备开锁记录事件上报
  MINOR_DOOR_NOT_OPEN = $d7;    //门未开报警（对讲设备）
  MINOR_DOOR_UNCLOSED = $d8;    //门未关报警（对讲设备）
  MINOR_ORCODE_KEY_VERIFY_FAIL = $d9;    //二维码密钥验证失败
  MINOR_PERSON_PASS_THROUGH = $da;    //人员通行事件

const
  MINOR_EVENT_CUSTOM1 = $500;    //门禁自定义事件1
  MINOR_EVENT_CUSTOM2 = $501;    //门禁自定义事件2
  MINOR_EVENT_CUSTOM3 = $502;    //门禁自定义事件3
  MINOR_EVENT_CUSTOM4 = $503;    //门禁自定义事件4
  MINOR_EVENT_CUSTOM5 = $504;    //门禁自定义事件5
  MINOR_EVENT_CUSTOM6 = $505;    //门禁自定义事件6
  MINOR_EVENT_CUSTOM7 = $506;    //门禁自定义事件7
  MINOR_EVENT_CUSTOM8 = $507;    //门禁自定义事件8
  MINOR_EVENT_CUSTOM9 = $508;    //门禁自定义事件9
  MINOR_EVENT_CUSTOM10 = $509;    //门禁自定义事件10
  MINOR_EVENT_CUSTOM11 = $50a;    //门禁自定义事件11
  MINOR_EVENT_CUSTOM12 = $50b;    //门禁自定义事件12
  MINOR_EVENT_CUSTOM13 = $50c;    //门禁自定义事件13
  MINOR_EVENT_CUSTOM14 = $50d;    //门禁自定义事件14
  MINOR_EVENT_CUSTOM15 = $50e;    //门禁自定义事件15
  MINOR_EVENT_CUSTOM16 = $50f;    //门禁自定义事件16
  MINOR_EVENT_CUSTOM17 = $510;    //门禁自定义事件17
  MINOR_EVENT_CUSTOM18 = $511;    //门禁自定义事件18
  MINOR_EVENT_CUSTOM19 = $512;    //门禁自定义事件19
  MINOR_EVENT_CUSTOM20 = $513;    //门禁自定义事件20
  MINOR_EVENT_CUSTOM21 = $514;    //门禁自定义事件21
  MINOR_EVENT_CUSTOM22 = $515;    //门禁自定义事件22
  MINOR_EVENT_CUSTOM23 = $516;    //门禁自定义事件23
  MINOR_EVENT_CUSTOM24 = $517;    //门禁自定义事件24
  MINOR_EVENT_CUSTOM25 = $518;    //门禁自定义事件25
  MINOR_EVENT_CUSTOM26 = $519;    //门禁自定义事件26
  MINOR_EVENT_CUSTOM27 = $51a;    //门禁自定义事件27
  MINOR_EVENT_CUSTOM28 = $51b;    //门禁自定义事件28
  MINOR_EVENT_CUSTOM29 = $51c;    //门禁自定义事件29
  MINOR_EVENT_CUSTOM30 = $51d;    //门禁自定义事件30
  MINOR_EVENT_CUSTOM31 = $51e;    //门禁自定义事件31
  MINOR_EVENT_CUSTOM32 = $51f;    //门禁自定义事件32
  MINOR_EVENT_CUSTOM33 = $520;    //门禁自定义事件33
  MINOR_EVENT_CUSTOM34 = $521;    //门禁自定义事件34
  MINOR_EVENT_CUSTOM35 = $522;    //门禁自定义事件35
  MINOR_EVENT_CUSTOM36 = $523;    //门禁自定义事件36
  MINOR_EVENT_CUSTOM37 = $524;    //门禁自定义事件37
  MINOR_EVENT_CUSTOM38 = $525;    //门禁自定义事件38
  MINOR_EVENT_CUSTOM39 = $526;    //门禁自定义事件39
  MINOR_EVENT_CUSTOM40 = $527;    //门禁自定义事件40
  MINOR_EVENT_CUSTOM41 = $528;    //门禁自定义事件41
  MINOR_EVENT_CUSTOM42 = $529;    //门禁自定义事件42
  MINOR_EVENT_CUSTOM43 = $52a;    //门禁自定义事件43
  MINOR_EVENT_CUSTOM44 = $52b;    //门禁自定义事件44
  MINOR_EVENT_CUSTOM45 = $52c;    //门禁自定义事件45
  MINOR_EVENT_CUSTOM46 = $52d;    //门禁自定义事件46
  MINOR_EVENT_CUSTOM47 = $52e;    //门禁自定义事件47
  MINOR_EVENT_CUSTOM48 = $52f;    //门禁自定义事件48
  MINOR_EVENT_CUSTOM49 = $530;    //门禁自定义事件49
  MINOR_EVENT_CUSTOM50 = $531;    //门禁自定义事件50
  MINOR_EVENT_CUSTOM51 = $532;    //门禁自定义事件51
  MINOR_EVENT_CUSTOM52 = $533;    //门禁自定义事件52
  MINOR_EVENT_CUSTOM53 = $534;    //门禁自定义事件53
  MINOR_EVENT_CUSTOM54 = $535;    //门禁自定义事件54
  MINOR_EVENT_CUSTOM55 = $536;    //门禁自定义事件55
  MINOR_EVENT_CUSTOM56 = $537;    //门禁自定义事件56
  MINOR_EVENT_CUSTOM57 = $538;    //门禁自定义事件57
  MINOR_EVENT_CUSTOM58 = $539;    //门禁自定义事件58
  MINOR_EVENT_CUSTOM59 = $53a;    //门禁自定义事件59
  MINOR_EVENT_CUSTOM60 = $53b;    //门禁自定义事件60
  MINOR_EVENT_CUSTOM61 = $53c;    //门禁自定义事件61
  MINOR_EVENT_CUSTOM62 = $53d;    //门禁自定义事件62
  MINOR_EVENT_CUSTOM63 = $53e;    //门禁自定义事件63
  MINOR_EVENT_CUSTOM64 = $53f;    //门禁自定义事件64
  MINOR_ESD_OK = $540;    //ESD合格
  MINOR_ESD_LINKAGE_DISENABLE = $541;    //ESD不合格，不开门
  MINOR_ESD_LINKAGE_ENABLE = $542;    //ESD不合格，开门
  MINOR_ESD_OVERTIME = $543;    //ESD检测超时


const
  MINOR_LOCK_FINGER_OPEN_DOOR = $600;    //智能锁指纹开门
  MINOR_LOCK_PASSWORD_OPEN_DOOR = $601;    //智能锁密码开门
  MINOR_LOCK_CARD_OPEN_DOOR = $602;    //智能锁刷卡开门
  MINOR_LOCK_CENTER_OPEN_DOOR = $603;    //智能锁中心开门
  MINOR_LOCK_APP_OPEN_DOOR = $604;    //智能锁APP开门
  MINOR_LOCK_KEY_OPEN_DOOR = $605;    //智能锁钥匙开门
  MINOR_LOCK_REMOTE_DEVICE_OPEN_DOOR = $606;    //智能锁遥控器开门
  MINOR_LOCK_TMP_PASSWORD_OPEN_DOOR = $607;    //智能锁临时密码开门
  MINOR_LOCK_BLUETOOTH_OPEN_DOOR = $608;    //智能锁蓝牙开门
  MINOR_LOCK_MULTI_OPEN_DOOR = $609;    //智能锁多重开门


const
  MINOR_VP_ANTI_SPOOFING_FAIL = $700;    //声纹活体检测失败
  MINOR_VP_VERIFY_FAIL = $701;    //声纹认证失败


//2018-04-23 通用物联网关事件日志类型
const
  MINOR_ALARMHOST_SCHOOLTIME_IRGI_B = $1001;    //B码校时
  MINOR_ALARMHOST_SCHOOLTIME_SDK = $1002;    //SDK校时
  MINOR_ALARMHOST_SCHOOLTIME_SELFTEST = $1003;    //定制自检校时
  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALINSERT = $1004;    //子板插入
  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALPULLOUT = $1005;    //子板拔出

const
  MINOR_ALARMHOST_AUTO_ARM = $1006;    //自动布防
  MINOR_ALARMHOST_AUTO_DISARM = $1007;    //自动撤防
  MINOR_ALARMHOST_TIME_TIGGER_ON = $1008;    //定时开启触发器
  MINOR_ALARMHOST_TIME_TIGGER_OFF = $1009;    //定时关闭触发器
  MINOR_ALARMHOST_AUTO_ARM_FAILD = $100a;    //自动布防失败
  MINOR_ALARMHOST_AUTO_DISARM_FAILD = $100b;    //自动撤防失败
  MINOR_ALARMHOST_TIME_TIGGER_ON_FAILD = $100c;    //定时开启触发器失败
  MINOR_ALARMHOST_TIME_TIGGER_OFF_FAILD = $100d;    //定时关闭触发器失败
  MINOR_ALARMHOST_MANDATORY_ALARM = $100e;    //强制布防
  MINOR_ALARMHOST_KEYPAD_LOCKED = $100f;    //键盘锁定
  MINOR_ALARMHOST_USB_INSERT = $1010;    //USB插入
  MINOR_ALARMHOST_USB_PULLOUT = $1011;    //USB拔出
  MINOR_ALARMHOST_4G_MODULS_ONLINE = $1012;    //4G模块上线
  MINOR_ALARMHOST_4G_MODULS_OFFLINE = $1013;    //4G模块下线

const
  MINOR_EZVIZ_CLOUD_ONLINE = $1014;    //萤石云上线
  MINOR_EZVIZ_CLOUD_OFFLINE = $1015;    //萤石云下线

const
  MINOR_SIPUA_GRID_ONLINE = $1016;    //国网B上线
  MINOR_SIPUA_GRID_OFFLINE = $1017;    //国网B下线

const
  MINOR_INTERNET_ACCESS_CONNECTED = $1018;    //网口连接
  MINOR_INTERNET_ACCESS_BREAK = $1019;    //网口断开

const
  MINOR_WIRELESS_CONNECTED = $101a;    //无线连接
  MINOR_WIRELESS_BREAK = $101b;    //无线断开
  MINOR_PORT_LINK_DOWN = $101c;    //端口网络down
  MINOR_PORT_LINK_UP = $101d;    //端口网络up
  MINOR_POE_PORT_POWER_ON = $101e;    //POE端口power on
  MINOR_POE_PORT_POWER_OFF = $101f;    //POE端口power off
  MINOR_POE_TOTAL_POWER_MAX = $1020;    //POE总功率达到poe-max
  MINNOR_POE_TOTAL_POWER_RESUME = $1021;    //POE总功率恢复正常
  MINNOR_CARGO_ITEMS = $1022;    //货格物品取放


type
  ALARMHOST_MAJOR_TYPE =  
  (  
    MAJOR_ALARMHOST_ALARM = 1,  
    MAJOR_ALARMHOST_EXCEPTION,  
    MAJOR_ALARMHOST_OPERATION,  
    MAJ0R_ALARMHOST_EVENT  
  );

type
  ALARMHOST_MINOR_TYPE =  
  (  
    // 报警
    MINOR_SHORT_CIRCUIT = $01,  // 短路报警
    MINOR_BROKEN_CIRCUIT,  // 断路报警
    MINOR_ALARM_RESET,  // 报警复位
    MINOR_ALARM_NORMAL,  // 报警恢复正常
    MINOR_PASSWORD_ERROR,  // 密码错误（连续3次输入密码错误）
    MINOR_ID_CARD_ILLEGALLY,  // 非法感应卡ID
    MINOR_KEYPAD_REMOVE,  // 键盘防拆
    MINOR_KEYPAD_REMOVE_RESTORE,  // 键盘防拆复位
    MINOR_DEV_REMOVE,  // 设备防拆
    MINOR_DEV_REMOVE_RESTORE,  // 设备防拆复位
    MINOR_BELOW_ALARM_LIMIT1,  // 模拟量低于报警限1
    MINOR_BELOW_ALARM_LIMIT2,  // 模拟量低于报警限2
    MINOR_BELOW_ALARM_LIMIT3,  // 模拟量低于报警限3
    MINOR_BELOW_ALARM_LIMIT4,  // 模拟量低于报警限4
    MINOR_ABOVE_ALARM_LIMIT1,  // 模拟量高于报警限1
    MINOR_ABOVE_ALARM_LIMIT2,  // 模拟量高于报警限2
    MINOR_ABOVE_ALARM_LIMIT3,  // 模拟量高于报警限3
    MINOR_ABOVE_ALARM_LIMIT4,  // 模拟量高于报警限4
    MINOR_URGENCYBTN_ON,  // 紧急按钮按下
    MINOR_URGENCYBTN_OFF,  // 紧急按钮复位
    MINOR_VIRTUAL_DEFENCE_SUSPECT,  //软防区匪警
    MINOR_VIRTUAL_DEFENCE_FIRE,  //软防区火警
    MINOR_VIRTUAL_DEFENCE_URGENT,  //软防区紧急
    MINOR_ALARMHOST_MOTDET_START,  //移动侦测报警开始
    MINOR_ALARMHOST_MOTDET_STOP,  //移动侦测报警结束
    MINOR_ALARMHOST_HIDE_ALARM_START,  //遮挡报警开始
    MINOR_ALARMHOST_HIDE_ALARM_STOP,  //遮挡报警结束
    MINOR_ALARMHOST_UPS_ALARM,  //UPS报警
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM,  //电量表报警
    MINOR_ALARMHOST_SWITCH_POWER_ALARM,  //开关电源报警
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,  //气体检测系统报警
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM,  //变电器温显表报警
    MINOR_ALARMHOST_TEMP_HUMI_ALARM,  //温湿度传感器报警
    MINOR_ALARMHOST_UPS_ALARM_RESTORE,  //UPS报警恢复
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE,  //电量表报警恢复
    MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,  //开关电源报警恢复
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,  //气体检测系统报警恢复
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE,  //变电器温显表报警恢复
    MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,  //温湿度传感器报警恢复
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,  //水位传感器报警
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,  //水位传感器报警恢复
    MINOR_ALARMHOST_DUST_NOISE_ALARM,  //扬尘噪声传感器报警
    MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,  //扬尘噪声传感器报警恢复
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,  //环境采集仪报警
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,  //环境采集仪报警恢复

    MINOR_ALARMHOST_TRIGGER_TAMPER,  //探测器防拆
    MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,  //探测器防拆恢复
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM,  //紧急呼叫求助报警
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM_RESTORE,  //紧急呼叫求助报警恢复
    MINOR_ALARMHOST_CONSULTING_ALARM,  //业务咨询报警
    MINOR_ALARMHOST_CONSULTING_ALARM_RESTORE,  //业务咨询报警恢复
    MINOR_ZONE_MODULE_REMOVE,  // 防区模块防拆
    MINOR_ZONE_MODULE_RESET,  // 防区模块防拆复位

    MINOR_ALARM_WIND_SPEED_ALARM,  //风速传感器告警
    MINOR_ALARM_WIND_SPEED_ALARM_RESTORE,  //风速传感器告警恢复
    MINOR_ALARM_GENERATE_OUTPUT_ALARM,  //通用输出模块告警
    MINOR_ALARM_GENERATE_OUTPUT_RESTORE,  //通用输出模块告警恢复
    MINOR_ALARM_SOAK_ALARM,  //浸水传感器告警
    MINOR_ALARM_SOAK_ALARM_RESTORE,  //浸水传感器告警恢复
    MINOR_ALARM_SOLAR_POWER_ALARM,  //太阳能传感器告警
    MINOR_ALARM_SOLAR_POWER_ALARM_RESTORE,  //太阳能传感器告警恢复
    MINOR_ALARM_SF6_ALARM,  //SF6报警主机告警
    MINOR_ALARM_SF6_ALARM_RESTORE,  //SF6报警主机告警恢复
    MINOR_ALARM_WEIGHT_ALARM,  //称重仪告警
    MINOR_ALARM_WEIGHT_ALARM_RESTORE,  //称重仪告警恢复
    MINOR_ALARM_WEATHER_ALARM,  //气象采集系统告警
    MINOR_ALARM_WEATHER_ALARM_RESTORE,  //气象采集系统告警恢复
    MINOR_ALARM_FUEL_GAS_ALARM,  //燃气显示系统告警
    MINOR_ALARM_FUEL_GAS_ALARM_RESTORE,  //燃气显示系统告警恢复
    MINOR_ALARM_FIRE_ALARM,  //火灾报警系统告警
    MINOR_ALARM_FIRE_ALARM_RESTORE,  //火灾报警系统告警恢复

    MINOR_WIRELESS_OUTPUT_MODULE_REMOVE,  // 无线输出模块防拆
    MINOR_WIRELESS_OUTPUT_MODULE_RESET,  // 无线输出模块防拆复位
    MINOR_WIRELESS_REPEATER_MODULE_REMOVE,  // 无线中继器防拆
    MINOR_WIRELESS_REPEATER_MODULE_RESET,  // 无线中继器防拆复位
    MINOR_WIRELESS_SIREN_MODULE_REMOVE,  // 无线警号防拆
    MINOR_WIRELESS_SIREN_MODULE_RESET,  // 无线警号防拆复位
    MINOR_SOUND_INTENSITY_RISE,  // 声强陡升报警
    MINOR_SOUND_INTENSITY_RISE_RESET,  // 声强陡升报警恢复
    MINOR_SOUND_INTENSITY_DROP,  // 声强陡降报警
    MINOR_SOUND_INTENSITY_DROP_RESET,  // 声强陡降报警恢复
    MINOR_AUDIO_INPUT_EXCEPTION,  // 音频输入异常报警
    MINOR_AUDIO_INPUT_EXCEPTION_RESET,  // 音频输入异常报警恢复
    MINOR_FACE_DETECTION_ALARM,  // 人脸侦测报警
    MINOR_FACE_DETECTION_ALARM_RESTORE,  // 人脸侦测报警恢复

        // 异常
    MINOR_POWER_ON = $01,  // 上电
    MINOR_POWER_OFF,  // 掉电
    MINOR_WDT_RESET,  // WDT 复位
    MINOR_LOW_BATTERY_VOLTAGE,  // 蓄电池电压低
    MINOR_AC_LOSS,  // 交流电断电
    MINOR_AC_RESTORE,  // 交流电恢复
    MINOR_RTC_EXCEPTION,  // RTC实时时钟异常
    MINOR_NETWORK_CONNECT_FAILURE,  // 网络连接断
    MINOR_NETWORK_CONNECT_RESTORE,  // 网络连接恢复
    MINOR_TEL_LINE_CONNECT_FAILURE,  // 电话线连接断
    MINOR_TEL_LINE_CONNECT_RESTORE,  // 电话线连接恢复
    MINOR_EXPANDER_BUS_LOSS,  // 扩展总线模块掉线
    MINOR_EXPANDER_BUS_RESTORE,  // 扩展总线模块掉线恢复
    MINOR_KEYPAD_BUS_LOSS,  // 键盘总线模块掉线
    MINOR_KEYPAD_BUS_RESTORE,  // 键盘总线模块掉线恢复
    MINOR_SENSOR_FAILURE,  // 模拟量传感器故障
    MINOR_SENSOR_RESTORE,  // 模拟量传感器恢复
    MINOR_RS485_CONNECT_FAILURE,  // RS485通道连接断
    MINOR_RS485_CONNECT_RESTORE,  // RS485通道连接断恢复
    MINOR_BATTERT_VOLTAGE_RESTORE,  // 蓄电池电压恢复正常
    MINOR_WIRED_NETWORK_ABNORMAL,  //有线网络异常
    MINOR_WIRED_NETWORK_RESTORE,  //有线网络恢复正常
    MINOR_GPRS_ABNORMAL,  //GPRS通信异常
    MINOR_GPRS_RESTORE,  //GPRS恢复正常
    MINOR_3G_ABNORMAL,  //3G通信异常
    MINOR_3G_RESTORE,  //3G恢复正常
    MINOR_SIM_CARD_ABNORMAL,  //SIM卡异常
    MINOR_SIM_CARD_RESTORE,  //SIM卡恢复正常
    MINOR_ALARMHOST_VI_LOST,  // 视频信号丢失
    MINOR_ALARMHOST_ILLEGAL_ACCESS,  // 非法访问
    MINOR_ALARMHOST_HD_FULL,  // 硬盘满
    MINOR_ALARMHOST_HD_ERROR,  // 硬盘错误
    MINOR_ALARMHOST_DCD_LOST,  // MODEM 掉线(保留不使用)
    MINOR_ALARMHOST_IP_CONFLICT,  // IP地址冲突
    MINOR_ALARMHOST_NET_BROKEN,  // 网络断开
    MINOR_ALARMHOST_REC_ERROR,  // 录像出错
    MINOR_ALARMHOST_VI_EXCEPTION,  // 视频输入异常(只针对模拟通道)
    MINOR_ALARMHOST_FORMAT_HDD_ERROR,  //远程格式化硬盘失败
    MINOR_ALARMHOST_USB_ERROR,  //USB通信故障
    MINOR_ALARMHOST_USB_RESTORE,  //USB通信故障恢复
    MINOR_ALARMHOST_PRINT_ERROR,  //打印机故障
    MINOR_ALARMHOST_PRINT_RESTORE,  //打印机故障恢复
    MINOR_SUBSYSTEM_COMMUNICATION_ERROR,  //子板通讯错误
    MINOR_ALARMHOST_IPC_NO_LINK,  // IPC连接断开  
    MINOR_ALARMHOST_IPC_IP_CONFLICT,  //ipc ip 地址 冲突
    MINOR_ALARMHOST_VI_MISMATCH,  //视频制式不匹配
    MINOR_ALARMHOST_MCU_RESTART,  //MCU重启
    MINOR_ALARMHOST_GPRS_MODULE_FAULT,  //GPRS模块故障
    MINOR_ALARMHOST_TELEPHONE_MODULE_FAULT,  //电话模块故障
    MINOR_ALARMHOST_WIFI_ABNORMAL,  //WIFI通信异常
    MINOR_ALARMHOST_WIFI_RESTORE,  //WIFI恢复正常
    MINOR_ALARMHOST_RF_ABNORMAL,  //RF信号异常
    MINOR_ALARMHOST_RF_RESTORE,  //RF信号恢复正常
    MINOR_ALARMHOST_DETECTOR_ONLINE,  //探测器在线
    MINOR_ALARMHOST_DETECTOR_OFFLINE,  //探测器离线
    MINOR_ALARMHOST_DETECTOR_BATTERY_NORMAL,  //探测器电量正常
    MINOR_ALARMHOST_DETECTOR_BATTERY_LOW,  //探测器电量欠压
    MINOR_ALARMHOST_DATA_TRAFFIC_OVERFLOW,  //流量超额
    MINOR_ZONE_MODULE_LOSS,  // 防区模块掉线
    MINOR_ZONE_MODULE_RESTORE,  // 防区模块掉线恢复
    MINOR_ALARMHOST_WIRELESS_OUTPUT_LOSS,  //无线输出模块离线
    MINOR_ALARMHOST_WIRELESS_OUTPUT_RESTORE,  //无线输出模块恢复在线
    MINOR_ALARMHOST_WIRELESS_REPEATER_LOSS,  //无线中继器离线
    MINOR_ALARMHOST_WIRELESS_REPEATER_RESTORE,  //无线中继器恢复在线
    MINOR_TRIGGER_MODULE_LOSS,  // 触发器模块掉线
    MINOR_TRIGGER_MODULE_RESTORE,  // 触发器模块掉线恢复
    MINOR_WIRELESS_SIREN_LOSS,  // 无线警号离线
    MINOR_WIRELESS_SIREN_RESTORE,  // 无线警号恢复在线
    MINOR_ALARMHOST_WIRELESS_RS485_LOSS,  //无线RS485接收器模块离线
    MINOR_ALARMHOST_WIRELESS_RS485_RESTORE,  //无线RS485接收器模块恢复在线

        // 操作
    MINOR_GUARD = $01,  // 普通布防
    MINOR_UNGUARD,  // 普通撤防
    MINOR_BYPASS,  // 旁路
    MINOR_DURESS_ACCESS,  // 挟持
    MINOR_ALARMHOST_LOCAL_REBOOT,  // 本地重启
    MINOR_ALARMHOST_REMOTE_REBOOT,  // 远程重启
    MINOR_ALARMHOST_LOCAL_UPGRADE,  // 本地升级
    MINOR_ALARMHOST_REMOTE_UPGRADE,  // 远程升级
    MINOR_RECOVERY_DEFAULT_PARAM,  // 恢复默认参数
    MINOR_ALARM_OUTPUT,  // 控制报警输出
    MINOR_ACCESS_OPEN,  // 控制门禁开
    MINOR_ACCESS_CLOSE,  // 控制门禁关
    MINOR_SIREN_OPEN,  // 控制警号开
    MINOR_SIREN_CLOSE,  // 控制警号关
    MINOR_MOD_ZONE_CONFIG,  // 修改防区设置
    MINOR_MOD_ALARMOUT_CONIFG,  // 控制报警输出配置
    MINOR_MOD_ANALOG_CONFIG,  // 修改模拟量配置
    MINOR_RS485_CONFIG,  // 修改485通道配置
    MINOR_PHONE_CONFIG,  // 修改拨号配置
    MINOR_ADD_ADMIN,  // 增加管理员
    MINOR_MOD_ADMIN_PARAM,  // 修改管理员参数
    MINOR_DEL_ADMIN,  // 删除管理员
    MINOR_ADD_NETUSER,  // 增加后端操作员
    MINOR_MOD_NETUSER_PARAM,  // 修改后端操作员参数
    MINOR_DEL_NETUSER,  // 删除后端操作员
    MINOR_ADD_OPERATORUSER,  // 增加前端操作员
    MINOR_MOD_OPERATORUSER_PW,  // 修改前端操作员密码
    MINOR_DEL_OPERATORUSER,  // 删除前端操作员
    MINOR_ADD_KEYPADUSER,  // 增加键盘/读卡器用户
    MINOR_DEL_KEYPADUSER,  // 删除键盘/读卡器用户
    MINOR_REMOTEUSER_LOGIN,  // 远程用户登陆
    MINOR_REMOTEUSER_LOGOUT,  // 远程用户注销
    MINOR_REMOTE_GUARD,  // 远程布防
    MINOR_REMOTE_UNGUARD,  // 远程撤防
    MINOR_MOD_HOST_CONFIG,  // 修改主机配置
    MINOR_RESTORE_BYPASS,  // 旁路恢复
    MINOR_ALARMOUT_OPEN,  // 报警输出开启
    MINOR_ALARMOUT_CLOSE,  // 报警输出关闭
    MINOR_MOD_SUBSYSTEM_PARAM,  // 修改子系统参数配置
    MINOR_GROUP_BYPASS,  // 组旁路
    MINOR_RESTORE_GROUP_BYPASS,  // 组旁路恢复
    MINOR_MOD_GRPS_PARAM,  // 修改GPRS参数
    MINOR_MOD_NET_REPORT_PARAM,  // 修改网络上报参数配置
    MINOR_MOD_REPORT_MOD,  // 修改上传方式配置
    MINOR_MOD_GATEWAY_PARAM,  // 修改门禁参数配置
    MINOR_ALARMHOST_REMOTE_START_REC,  // 远程开始录像
    MINOR_ALARMHOST_REMOTE_STOP_REC,  // 远程停止录像
    MINOR_ALARMHOST_START_TRANS_CHAN,  // 开始透明传输
    MINOR_ALARMHOST_STOP_TRANS_CHAN,  // 停止透明传输
    MINOR_ALARMHOST_START_VT,  // 开始语音对讲
    MINOR_ALARMHOST_STOP_VTM,  // 停止语音对讲
    MINOR_ALARMHOST_REMOTE_PLAYBYFILE,  // 远程按文件回放
    MINOR_ALARMHOST_REMOTE_PLAYBYTIME,  // 远程按时间回放
    MINOR_ALARMHOST_REMOTE_PTZCTRL,  // 远程云台控制
    MINOR_ALARMHOST_REMOTE_FORMAT_HDD,  // 远程格式化硬盘
    MINOR_ALARMHOST_REMOTE_LOCKFILE,  // 远程锁定文件
    MINOR_ALARMHOST_REMOTE_UNLOCKFILE,  // 远程解锁文件
    MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // 远程导出配置文件
    MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // 远程导入配置文件
    MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // 远程导出录象文件

    MINOR_ALARMHOST_STAY_ARM,  //留守布防
    MINOR_ALARMHOST_QUICK_ARM,  //即时布防
    MINOR_ALARMHOST_AUTOMATIC_ARM,  //自动布防
    MINOR_ALARMHOST_AUTOMATIC_DISARM,  //自动撤防
    MINOR_ALARMHOST_KEYSWITCH_ARM,  //钥匙防区布防
    MINOR_ALARMHOST_KEYSWITCH_DISARM,  //钥匙防区撤防
    MINOR_ALARMHOST_CLEAR_ALARM,  //消警
    MINOR_ALARMHOST_MOD_FAULT_CFG,  //修改系统故障配置
    MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,  //修改事件触发报警输出配置
    MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,  //搜索外接模块
    MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,  //重新注册外接模块
    MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,  //关闭键盘报警提示音
    MINOR_ALARMHOST_MOD_3G_PARAM,  //修改3G参数
    MINOR_ALARMHOST_MOD_PRINT_PARAM,  //修改打印机参数
    MINOR_SD_CARD_FORMAT,  //SD卡格式化
    MINOR_SUBSYSTEM_UPGRADE,  //子板固件升级

    MINOR_ALARMHOST_PLAN_ARM_CFG,  //计划布撤防参数配置
    MINOR_ALARMHOST_PHONE_ARM,  //手机布防
    MINOR_ALARMHOST_PHONE_STAY_ARM,  //手机留守布防
    MINOR_ALARMHOST_PHONE_QUICK_ARM,  //手机即时布防
    MINOR_ALARMHOST_PHONE_DISARM,  //手机撤防
    MINOR_ALARMHOST_PHONE_CLEAR_ALARM,  //手机消警
    MINOR_ALARMHOST_ALLOWLIST_CFG,  //允许名单配置
    MINOR_ALARMHOST_TIME_TRIGGER_CFG,  //定时开关触发器配置
    MINOR_ALARMHOST_CAPTRUE_CFG,  //抓图参数配置
    MINOR_ALARMHOST_TAMPER_CFG,  //防区防拆参数配置

    MINOR_ALARMHOST_REMOTE_KEYPAD_UPGRADE,  //远程升级键盘
    MINOR_ALARMHOST_ONETOUCH_AWAY_ARMING,  //一键外出布防
    MINOR_ALARMHOST_ONETOUCH_STAY_ARMING,  //一键留守布防
    MINOR_ALARMHOST_SINGLE_PARTITION_ARMING_OR_DISARMING,  //单防区布撤防
    MINOR_ALARMHOST_CARD_CONFIGURATION,  //卡参数配置
    MINOR_ALARMHOST_CARD_ARMING_OR_DISARMING,  //刷卡布撤防
    MINOR_ALARMHOST_EXPENDING_NETCENTER_CONFIGURATION,  //扩展网络中心配置
    MINOR_ALARMHOST_NETCARD_CONFIGURATION,  //网卡配置
    MINOR_ALARMHOST_DDNS_CONFIGURATION,  //DDNS配置
    MINOR_ALARMHOST_RS485BUS_CONFIGURATION,  // 485总线参数配置
    MINOR_ALARMHOST_RS485BUS_RE_REGISTRATION,  //485总线重新注册

    MINOR_ALARMHOST_REMOTE_OPEN_ELECTRIC_LOCK,  //远程打开电锁
    MINOR_ALARMHOST_REMOTE_CLOSE_ELECTRIC_LOCK,  //远程关闭电锁
    MINOR_ALARMHOST_LOCAL_OPEN_ELECTRIC_LOCK,  //本地打开电锁
    MINOR_ALARMHOST_LOCAL_CLOSE_ELECTRIC_LOCK,  //本地关闭电锁
    MINOR_ALARMHOST_OPEN_ALARM_LAMP,  //打开警灯(远程)
    MINOR_ALARMHOST_CLOSE_ALARM_LAMP,  //关闭警灯(远程)


    MINOR_ALARMHOST_TEMPORARY_PASSWORD,  //临时密码操作记录
    MINOR_ALARMHOST_ONEKEY_AWAY_ARM,  //一键外出布防
    MINOR_ALARMHOST_ONEKEY_STAY_ARM,  //一键留守布防
    MINOR_ALARMHOST_SINGLE_ZONE_ARM,  //单防区布防
    MINOR_ALARMHOST_SINGLE_ZONE_DISARM,  //单防区撤防
    MINOR_ALARMHOST_HIDDNS_CONFIG,  // HIDDNS配置
    MINOR_ALARMHOST_REMOTE_KEYBOARD_UPDATA,  //远程键盘升级日志
    MINOR_ALARMHOST_ZONE_ADD_DETECTOR,  //防区添加探测器
    MINOR_ALARMHOST_ZONE_DELETE_DETECTOR,  //防区删除探测器
    MINOR_ALARMHOST_QUERY_DETECTOR_SIGNAL,  //主机查询探测器信号强度
    MINOR_ALARMHOST_QUERY_DETECTOR_BATTERY,  //主机查询探测器电量
    MINOR_ALARMHOST_SET_DETECTOR_GUARD,  //探测器布防
    MINOR_ALARMHOST_SET_DETECTOR_UNGUARD,  //探测器撤防
    MINOR_ALARMHOST_SET_WIFI_PARAMETER,  //设置WIFI配置参数
    MINOR_ALARMHOST_OPEN_VOICE,  //打开语音
    MINOR_ALARMHOST_CLOSE_VOICE,  //关闭语音
    MINOR_ALARMHOST_ENABLE_FUNCTION_KEY,  //启用功能键
    MINOR_ALARMHOST_DISABLE_FUNCTION_KEY,  //关闭功能键
    MINOR_ALARMHOST_READ_CARD,  //巡更刷卡
    MINOR_ALARMHOST_START_BROADCAST,  //打开语音广播
    MINOR_ALARMHOST_STOP_BROADCAST,  //关闭语音广播
    MINOR_ALARMHOST_REMOTE_ZONE_MODULE_UPGRADE,  //远程升级防区模块
    MINOR_ALARMHOST_NETWORK_MODULE_EXTEND,  //网络模块参数配置
    MINOR_ALARMHOST_ADD_CONTROLLER,  //添加遥控器用户
    MINOR_ALARMHOST_DELETE_CONTORLLER,  //删除遥控器用户
    MINOR_ALARMHOST_REMOTE_NETWORKMODULE_UPGRADE,  //远程升级网络模块
    MINOR_ALARMHOST_WIRELESS_OUTPUT_ADD,  //注册无线输出模块
    MINOR_ALARMHOST_WIRELESS_OUTPUT_DEL,  //删除无线输出模块
    MINOR_ALARMHOST_WIRELESS_REPEATER_ADD,  //注册无线中继器
    MINOR_ALARMHOST_WIRELESS_REPEATER_DEL,  //删除无线中继器
    MINOR_ALARMHOST_PHONELIST_CFG,  //电话名单参数配置
    MINOR_ALARMHOST_RF_SIGNAL_CHECK,  // RF信号查询
    MINOR_ALARMHOST_USB_UPGRADE,  // USB升级
    MINOR_ALARMHOST_DOOR_TIME_REMINDER_CFG,  //门磁定时提醒参数配置
    MINOR_ALARMHOST_WIRELESS_SIREN_ADD,  //注册无线警号
    MINOR_ALARMHOST_WIRELESS_SIREN_DEL,  //删除无线警号
    MINOR_ALARMHOST_OUT_SCALE_OPEN,  //辅电开启
    MINOR_ALARMHOST_OUT_SCALE_CLOSE,  //辅电关闭

    MINOR_ALARMHOST_TIME_ZONE_CFG,  //时区修改
    MINOR_ALARMHOST_NTP_START_AND_PARAMETERS_CFG,  //NTP启动及参数修改
    MINOR_ALARMHOST_DST_START_AND_PARAMETERS_CFG,  //DST启动及参数修改
    MINOR_ALARMHOST_DEVINFO_CFG,  //设备信息配置
    MINOR_ALARMHOST_VIDEO_OVERLAP_CFG,  //录像覆盖配置
    MINOR_ALARMHOST_SSH_CFG,  //SSH启动配置
    MINOR_ALARMHOST_PASSWORD_MANAGE_CFG,  //密码管理配置
    MINOR_ALARMHOST_RESTORE_DEFAULT_PARAMETERS,  //恢复默认参数
    MINOR_ALARMHOST_RESTORECOMPLETELY_DEFAULT_PARAMETERS,  //完全恢复默认参数
    MINOR_ALARMHOST_AUDIO_AUTO_DETECT_CFG,  //自动检测参数配置
    MINOR_ALARMHOST_AUDIO_MANUAL_DETECT_CFG,  //手动检测
    MINOR_ALARMHOST_NET_PARAMETERS_CFG,  //网络参数配置
    MINOR_ALARMHOST_MTU_CFG,  //MTU配置
    MINOR_ALARMHOST_PORT_CFG,  //端口配置
    MINOR_ALARMHOST_DEFAULT_ROUTER_CFG,  //默认路由配置
    MINOR_ALARMHOST_DNS_PARAMETERS_CFG,  //DNS参数配置
    MINOR_ALARMHOST_UNPNP_PARAMETERS_CFG,  //UNPNP参数配置
    MINOR_ALARMHOST_SIP_PARAMETERS_CFG,  //SIP参数配置
    MINOR_ALARMHOST_FLOW_LIMIT_CFG,  //流量限额参数配置
    MINOR_ALARMHOST_APN_PARAMETERS_CFG,  //APN参数配置
    MINOR_ALARMHOST_MESSAGE_TELEPHONENO_CFG,  //短信电话号码配置
    MINOR_ALARMHOST_EZVIZ_PARAMATERS_CFG,  //萤石参数配置
    MINOR_ALARMHOST_ISUP_PARAMATERS_CFG,  //ISUP参数配置
    MINOR_ALARMHOST_SIP_SWITCH_CFG,  //SIP标准协议私有协议切换
    MINOR_ALARMHOST_INFO_UPLOAD_TO_PLATFORM_CFG,  //上传平台信息配置
    MINOR_ALARMHOST_ONVIF_CONTROL,  //ONVIF控制(开启，关闭)
    MINOR_ALARMHOST_ONVIF_USER_ADD,  //onvif用户的增加
    MINOR_ALARMHOST_ONVIF_USER_MOD,  //onvif用户的修改
    MINOR_ALARMHOST_ONVIF_USER_DELETE,  //onvif用户的删除
    MINOR_ALARMHOST_TIME_OF_BELLS_CFG,  //响铃时间
    MINOR_ALARMHOST_CALL_WAITTIME_CFG,  //呼叫等待时间
    MINOR_ALARMHOST_PROMPT_PARAMATERS_CFG,  //提示音参数配置
    MINOR_ALARMHOST_MUTEPLAN_PARAMATERS_CFG,  //静音计划参数配置
    MINOR_ALARMHOST_SD_PARTITION_CFG,  //SD卡分区参数配置
    MINOR_ALARMHOST_AUDIO_PARAMETERS_CFG,  //音视频参数配置
    MINOR_ALARMHOST_VOICETALK_AUDIO_ENCODING_CFG,  //对讲音频编码
    MINOR_ALARMHOST_RECORD_PLAN_PARAMETERS_CFG,  //录像计划参数配置
    MINOR_ALARMHOST_RECORD_ADVANCE_PARAMETERS_CFG,  //录像高级参数配置
    MINOR_ALARMHOST_PICTURE_PLAN_PARAMETERS_CFG,  //抓图计划参数配置
    MINOR_ALARMHOST_PICTURE_ADVANCE_PARAMETERS_CFG,  //抓图高级参数配置
    MINOR_ALARMHOST_AUDIO_EXCEPTION_PARAMETERS_CFG,  //音频异常参数配置
    MINOR_ALARMHOST_PATROL_CARD_CFG,  //巡更卡配置
    MINOR_ALARMHOST_VOICE_VOLUME_CFG,  //声音配置
    MINOR_ALARMHOST_VOICE_MODE_CFG,  //声音模式配置（输入，输出，广播模式）
    MINOR_ALARMHOST_AUDIO_OR_MATERIALS_UPLOAD,  //音频、素材文件上传
    MINOR_ALARMHOST_AUDIO_OR_MATERIALS_DELETE,  //音频、素材文件删除
    MINOR_ALARMHOST_ALARM_LAMP_FLASH_TIME_CFG,  //闪烁时间
    MINOR_ALARMHOST_ALARM_LAMP_FLASH_PLAN_CFG,  //计划闪烁配置
    MINOR_ALARMHOST_FRONT_END_VIDEO_PARAMETERS_CFG,  //前端视频参数配置
    MINOR_ALARMHOST_WDR_CFG,  //宽动态配置
    MINOR_ALARMHOST_BPFRAME_CFG,  //PN帧配置
    MINOR_ALARMHOST_PASSWORD_RESET_CFG,  //密码重置配置
    MINOR_ALARMHOST_ACCOUNT_LOCK,  //账户锁定
    MINOR_ALARMHOST_ACCOUNT_UNLOCK,  //账户解锁
    MINOR_ALARMHOST_START_LIVEVIEW_REMOTELY,  //远程开启预览
    MINOR_ALARMHOST_STOP_LIVEVIEW_REMOTELT,  //远程关闭预览
    MINOR_ALARMHOST_TELEPHONE_CENTER_SETTINGS,  //电话中心参数配置
    MINOR_ALARMHOST_NATIONAL_STANDARD_CFG,  //国标配置
    MINOR_ALARMHOST_SUPPLEMENTLIGHT_CFG,  //补光灯配置
    MINOR_ALARMHOST_FACESNAP_CFG,  //人脸抓拍配置
    MINOR_ALARMHOST_PUBLISHMANAGE_CFG,  //发布管理配置
    MINOR_ALARMHOST_KEYDIAL_CFG,  //按键配置
    MINOR_ALARMHOST_VOICETALK_SILENT_CFG,  //对讲静音配置
    MINOR_ALARMHOST_START_VIDEO_PROTECT,  //启用视频保护
    MINOR_ALARMHOST_START_AUDIO_PROTECT,  //启用监听保护
    MINOR_ALARMHOST_START_MANUAL_ANSWER,  //启用手动接听
    MINOR_ALARMHOST_START_LOG_SERVER,  //启用安全日志
    MINOR_ALARMHOST_ADD_CARD,  //添加卡片
    MINOR_ALARMHOST_DELETE_CARD,  //删除卡片
    MINOR_ALARMHOST_MOTION_DETECTION_CFG,  //移动侦测配置
    MINOR_ALARMHOST_VIDEO_BLOCK_CFG,  //视频遮挡配置
    MINOR_ALARMHOST_FACE_DETECTION_CFG,  //人脸侦测配置
    MINOR_ALARMHOST_LOG_BACKUP,  //日志备份


    MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = $f0,  //本地激活设备
    MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = $f1,  //远程激活设备
    MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = $f2,  //本地回复出厂设置
    MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = $f3,  //远程恢复出厂设置

    MINOR_ADD_IPC = $f4,  //IPC添加(报警接入IPC)
    MINOR_MODIFY_IPC = $f5,  //IPC修改
    MINOR_DELETE_IPC = $f6,  //IPC删除
    MINOR_SYS_CHECK_START = $f7,  //系统检测开始
    MINOR_SYS_CHECK_STOP = $f8,  //系统检测中止
    MINOR_SYS_CHECK_FINISH = $f9,  //系统检测结束
    MINOR_DEVICE_TAMPER_CFG = $fa,  //设备防拆参数配置
    MINOR_ALARMHOST_INDICATORLIGHT_CFG = $fb,  //指示灯配置
    MINOR_ALARMHOST_WIRELESSBUTTON_CFG = $fc,  //无线按钮配置
    MINOR_ALARMHOST_IRCUTFILTER_CFG = $fd,  //日夜切换配置
    MINOR_ALARMHOST_KEYWORD_AUDIO_RECOGNITION_CFG = $fe,  //关键字语音识别配置
    MINOR_ALARMHOST_DEVICE_POWER_MODE_SWITCH_CFG = $ff,  //设备功耗模式切换


        // 事件
    MINOR_SCHOOLTIME_IRGI_B = $01,  // B码校时
    MINOR_SCHOOLTIME_SDK,  // SDK校时
    MINOR_SCHOOLTIME_SELFTEST,  // 定时自检校时
    MINOR_SUBSYSTEM_ABNORMALINSERT,  //子板插入
    MINOR_SUBSYSTEM_ABNORMALPULLOUT,  //子板拔出

    MINOR_AUTO_ARM,  //自动布防
    MINOR_AUTO_DISARM,  //自动撤防
    MINOR_TIME_TIGGER_ON,  //定时开启触发器
    MINOR_TIME_TIGGER_OFF,  //定时关闭触发器
    MINOR_AUTO_ARM_FAILD,  //自动布防失败
    MINOR_AUTO_DISARM_FAILD,  //自动撤防失败
    MINOR_TIME_TIGGER_ON_FAILD,  //定时开启触发器失败
    MINOR_TIME_TIGGER_OFF_FAILD,  //定时关闭触发器失败
    MINOR_MANDATORY_ALARM,  //强制布防
    MINOR_KEYPAD_LOCKED,  //键盘锁定
    MINOR_USB_INSERT,  //USB插入
    MINOR_USB_PULLOUT,  //USB拔出
    MINOR_KEYPAD_UNLOCK  //键盘解锁
  );


//当日志的主类型为MAJOR_OPERATION=03，次类型为MINOR_LOCAL_CFG_PARM=0x52或者MINOR_REMOTE_GET_PARM=0x76
//或者MINOR_REMOTE_CFG_PARM=0x77时，dwParaType:参数类型有效，其含义如下：
const
  PARA_VIDEOOUT = $1;    
  PARA_IMAGE = $2;    
  PARA_ENCODE = $4;    
  PARA_NETWORK = $8;    
  PARA_ALARM = $10;    
  PARA_EXCEPTION = $20;    
  PARA_DECODER = $40;    //解码器
  PARA_RS232 = $80;    
  PARA_PREVIEW = $100;    
  PARA_SECURITY = $200;    
  PARA_DATETIME = $400;    
  PARA_FRAMETYPE = $800;    //帧格式
  PARA_DETECTION = $1000;    //侦测配置
  PARA_VCA_RULE = $1001;    //行为规则
  PARA_VCA_CTRL = $1002;    //配置智能控制信息
  PARA_VCA_PLATE = $1003;    // 车牌识别

const
  PARA_CODESPLITTER = $2000;    //码分器参数
//2010-01-22 增加视频综合平台日志信息次类型
const
  PARA_RS485 = $2001;    // RS485配置信息
  PARA_DEVICE = $2002;    // 设备配置信息
  PARA_HARDDISK = $2003;    // 硬盘配置信息 
  PARA_AUTOBOOT = $2004;    // 自动重启配置信息
  PARA_HOLIDAY = $2005;    // 节假日配置信息
  PARA_IPC = $2006;    // IP通道配置 
//************************参数配置命令 end******************************


//******************查找文件和日志函数返回值************************
const
  NET_DVR_FILE_SUCCESS = 1000;    //获得文件信息
  NET_DVR_FILE_NOFIND = 1001;    //没有文件
  NET_DVR_ISFINDING = 1002;    //正在查找文件
  NET_DVR_NOMOREFILE = 1003;    //查找文件时没有更多的文件
  NET_DVR_FILE_EXCEPTION = 1004;    //查找文件时异常
  NET_DVR_FIND_TIMEOUT = 1005;    //查找文件超时

//********************回调函数类型 begin***********************

//报警回调命令
const
  COMM_ALARM = $1100;    //8000报警信息主动上传

//对应NET_VCA_RULE_ALARM
const
  COMM_ALARM_RULE = $1102;    //异常行为检测报警信息
  COMM_ALARM_PDC = $1103;    //人数统计报警信息
  COMM_ALARM_VIDEOPLATFORM = $1104;    //视频综合平台报警
  COMM_ALARM_ALARMHOST = $1105;    //网络报警主机报警
  COMM_ALARM_FACE = $1106;    //人脸检测识别报警信息
  COMM_RULE_INFO_UPLOAD = $1107;    // 事件数据信息上传
  COMM_ALARM_AID = $1110;    //交通事件报警信息
  COMM_ALARM_TPS = $1111;    //交通参数统计报警信息
//智能人脸抓拍结果上传
const
  COMM_UPLOAD_FACESNAP_RESULT = $1112;    //人脸识别结果上传
  COMM_ALARM_TFS = $1113;    //交通取证报警信息
  COMM_ALARM_TPS_V41 = $1114;    //交通参数统计报警信息扩展
  COMM_ALARM_AID_V41 = $1115;    //交通事件报警信息扩展
  COMM_ALARM_VQD_EX = $1116;    //视频质量诊断报警
  COMM_ALARM_NOTIFICATION_REPORT = $1117;    //通知事件上报
  COMM_SENSOR_VALUE_UPLOAD = $1120;    //模拟量数据实时上传
  COMM_SENSOR_ALARM = $1121;    //模拟量报警上传
  COMM_SWITCH_ALARM = $1122;    //开关量报警
  COMM_ALARMHOST_EXCEPTION = $1123;    //报警主机故障报警
  COMM_ALARMHOST_OPERATEEVENT_ALARM = $1124;    //操作事件报警上传
  COMM_ALARMHOST_SAFETYCABINSTATE = $1125;    //防护舱状态
  COMM_ALARMHOST_ALARMOUTSTATUS = $1126;    //报警输出口/警号状态
  COMM_ALARMHOST_CID_ALARM = $1127;    //报告报警上传
  COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM = $1128;    //报警主机外接设备报警上传
  COMM_ALARMHOST_DATA_UPLOAD = $1129;    //报警数据上传
  COMM_FACECAPTURE_STATISTICS_RESULT = $112a;    //人脸抓拍统计上传
  COMM_ALARM_WIRELESS_INFO = $122b;    // 无线网络信息上传
  COMM_SCENECHANGE_DETECTION_UPLOAD = $1130;    //场景变更报警上传(布防)2013-7-16
  COMM_CROSSLINE_ALARM = $1131;    //压线报警(监听) 2013-09-27
  COMM_UPLOAD_VIDEO_INTERCOM_EVENT = $1132;    //可视对讲事件记录上传
  COMM_ALARM_VIDEO_INTERCOM = $1133;    //可视对讲报警上传
  COMM_UPLOAD_NOTICE_DATA = $1134;    //可视对讲公告信息上传
  COMM_ALARM_AUDIOEXCEPTION = $1150;    //声音报警信息
  COMM_ALARM_DEFOCUS = $1151;    //虚焦报警信息
  COMM_ALARM_BUTTON_DOWN_EXCEPTION = $1152;    //按钮按下报警信息
  COMM_ALARM_ALARMGPS = $1202;    //GPS报警信息上传
  COMM_TRADEINFO = $1500;    //ATMDVR主动上传交易信息
  COMM_UPLOAD_PLATE_RESULT = $2800;    //上传车牌信息
  COMM_ITC_STATUS_DETECT_RESULT = $2810;    //实时状态检测结果上传(智能高清IPC)
  COMM_IPC_AUXALARM_RESULT = $2820;    //PIR报警、无线报警、呼救报警上传
  COMM_UPLOAD_PICTUREINFO = $2900;    //上传图片信息
  COMM_SNAP_MATCH_ALARM = $2902;    //禁止名单比对结果上传
  COMM_ITS_PLATE_RESULT = $3050;    //终端图片上传
  COMM_ITS_TRAFFIC_COLLECT = $3051;    //终端统计数据上传
  COMM_ITS_GATE_VEHICLE = $3052;    //出入口车辆抓拍数据上传
  COMM_ITS_GATE_FACE = $3053;    //出入口人脸抓拍数据上传
  COMM_ITS_GATE_COSTITEM = $3054;    //出入口过车收费明细 2013-11-19
  COMM_ITS_GATE_HANDOVER = $3055;    //出入口交接班数据 2013-11-19
  COMM_ITS_PARK_VEHICLE = $3056;    //停车场数据上传
  COMM_ITS_BLOCKLIST_ALARM = $3057;    //禁止名单报警上传

const
  COMM_VEHICLE_CONTROL_LIST_DSALARM = $3058;    //名单数据需要同步报警2013-11-04
  COMM_VEHICLE_CONTROL_ALARM = $3059;    //车辆报警2013-11-04
  COMM_FIRE_ALARM = $3060;    //消防报警2013-11-04

const
  COMM_ITS_GATE_ALARMINFO = $3061;    //出入口控制机数据上传

const
  COMM_VEHICLE_RECOG_RESULT = $3062;    //车辆二次识别结果上传 2014-11-12
  COMM_PLATE_RESULT_V50 = $3063;    //车牌上传 V50

const
  COMM_GATE_CHARGEINFO_UPLOAD = $3064;    //出入口付费信息上传
  COMM_TME_VEHICLE_INDENTIFICATION = $3065;    //TME车辆抓图上传
  COMM_GATE_CARDINFO_UPLOAD = $3066;    //出入口卡片信息上传
  COMM_LOADING_DOCK_OPERATEINFO = $3067;    //月台作业上传

const
  COMM_ALARM_SENSORINFO_UPLOAD = $3077;    //传感器上传信息
  COMM_ALARM_CAPTURE_UPLOAD = $3078;    //抓拍图片上传

const
  COMM_ITS_RADARINFO = $3079;    //雷达报警上传

const
  COMM_SIGNAL_LAMP_ABNORMAL = $3080;    //信号灯异常检测上传

const
  COMM_ALARM_TPS_REAL_TIME = $3081;    //TPS实时过车数据上传
  COMM_ALARM_TPS_STATISTICS = $3082;    //TPS统计过车数据上传

const
  COMM_ALARM_V30 = $4000;    //9000报警信息主动上传
  COMM_IPCCFG = $4001;    //9000设备IPC接入配置改变报警信息主动上传
  COMM_IPCCFG_V31 = $4002;    //9000设备IPC接入配置改变报警信息主动上传扩展 9000_1.1
  COMM_IPCCFG_V40 = $4003;    // IVMS 2000 编码服务器 NVR IPC接入配置改变时报警信息上传
  COMM_ALARM_DEVICE = $4004;    //设备报警内容，由于通道值大于256而扩展
  COMM_ALARM_CVR = $4005;    //CVR 2.0.X外部报警类型
  COMM_ALARM_HOT_SPARE = $4006;    //热备异常报警（N+1模式异常报警）
  COMM_ALARM_V40 = $4007;    //移动侦测，视频丢失，遮挡，IO信号量等报警信息主动上传，报警数据为可变长

const
  COMM_UPLOAD_HEATMAP_RESULT = $4008;    //热度图报警上传 2014-03-21
  COMM_ALARM_DEVICE_V40 = $4009;    //设备报警内容扩展
  COMM_ALARM_FACE_DETECTION = $4010;    //人脸侦测报警
  COMM_ALARM_TARGET_LEFT_REGION = $4011;    //检测目标离开检测区域报警(教师走向学生报警(用于联动切换录播主机控制检测学生的球机))
  COMM_GISINFO_UPLOAD = $4012;    //GIS信息上传
  COMM_VANDALPROOF_ALARM = $4013;    //上传防破坏报警信息
  COMM_PEOPLE_DETECTION_UPLOAD = $4014;    //人员侦测信息上传
  COMM_ALARM_STORAGE_DETECTION = $4015;    //存储智能检测报警上传
  COMM_MVM_REGISTER = $4016;    //地磁管理器（Magnetic Vehicle Manager）注册
  COMM_MVM_STATUS_INFO = $4017;    //地磁管理器（Magnetic Vehicle Manager）状态上报
  COMM_UPLOAD_HEATMAP_RESULT_PDC = $4018;    //热度图按人数统计数据上传事件
  COMM_UPLOAD_HEATMAP_RESULT_DURATION = $4019;    //热度图按人员停留时间统计数据上传事件
  COMM_UPLOAD_HEATMAP_RESULT_INTERSECTION = $4020;    //路口分析热度值结果上传
  COMM_UPLOAD_AIOP_VIDEO = $4021;    //设备支持AI开放平台接入，上传视频检测数据
  COMM_UPLOAD_AIOP_PICTURE = $4022;    //设备支持AI开放平台接入，上传图片检测数据
  COMM_UPLOAD_AIOP_POLLING_SNAP = $4023;    //设备支持AI开放平台接入，上传轮巡抓图图片检测数据 对应的结构体(NET_AIOP_POLLING_PICTURE_HEAD)
  COMM_UPLOAD_AIOP_POLLING_VIDEO = $4024;    //设备支持AI开放平台接入，上传轮巡视频检测数据 对应的结构体(NET_AIOP_POLLING_VIDEO_HEAD)
  COMM_UPLOAD_AIOP_HISTORY_VIDEO = $4025;    //设备支持AI开放平台接入，上传历史视频任务检测数据 对应的结构体(NET_AIOP_HISTORY_VIDEO_HEAD)


const
  COMM_ITS_ROAD_EXCEPTION = $4500;    //路口设备异常报警
  COMM_ITS_EXTERNAL_CONTROL_ALARM = $4520;    //外控报警
  COMM_ALARM_SHIPSDETECTION = $4521;    // 船只检测报警信息

const
  COMM_VCA_DBD_ALARM = $4550;    //驾驶行为报警信息
  COMM_VCA_ADAS_ALARM = $4551;    //高级辅助驾驶报警信息
  COMM_VEH_REALTIME_INFO = $4552;    //行车实时数据信息
  COMM_VCA_ATTEND_ALARM = $4553;    //考勤事件报警信息

const
  COMM_FIREDETECTION_ALARM = $4991;    //火点检测报警
  COMM_ALARM_DENSEFOGDETECTION = $4992;    //大雾检测报警信息
  COMM_VCA_ALARM = $4993;    //智能检测报警
  COMM_FACE_THERMOMETRY_ALARM = $4994;    //人脸测温报警

const
  COMM_TAPE_ARCHIVE_ALARM = $4996;    //磁带库归档报警

const
  COMM_SCREEN_ALARM = $5000;    //多屏控制器报警类型
  COMM_DVCS_STATE_ALARM = $5001;    //分布式大屏控制器报警上传
  COMM_ALARM_ACS = $5002;    //门禁主机报警
  COMM_ALARM_FIBER_CONVERT = $5003;    //光纤收发器报警
  COMM_ALARM_SWITCH_CONVERT = $5004;    //交换机报警
  COMM_ALARM_DEC_VCA = $5010;    //智能解码报警
  COMM_ALARM_LCD = $5011;    //屏幕报警
  COMM_CONFERENCE_CALL_ALARM = $5012;    //会议呼叫告警

const
  COMM_ALARM_WALL_CONFERNECE = $5015;    //MCU单个已开会的会议信息报警

const
  COMM_DIAGNOSIS_UPLOAD = $5100;    //诊断服务器VQD报警上传
  COMM_HIGH_DENSITY_UPLOAD = $5101;    //人员聚集密度输出报警上传

const
  COMM_ID_INFO_ALARM = $5200;    //身份证信息上传
  COMM_PASSNUM_INFO_ALARM = $5201;    //通行人数上报
  COMM_PASSPORT_ALARM = $5202;    //护照信息上传

const
  COMM_THERMOMETRY_DIFF_ALARM = $5211;    //温差报警上传
  COMM_THERMOMETRY_ALARM = $5212;    //温度报警上传
  COMM_PANORAMIC_LINKAGE_ALARM = $5213;    //全景联动到位上传
  COMM_TAG_INFO_ALARM = $5215;    // 标签信息上传
  COMM_ALARM_VQD = $6000;    //VQD主动报警上传
  COMM_PUSH_UPDATE_RECORD_INFO = $6001;    //推模式录像信息上传
  COMM_SWITCH_LAMP_ALARM = $6002;    //开关灯检测
  COMM_INQUEST_ALARM = $6005;    // 审讯主机报警上传
  COMM_VIDEO_PARKING_POLE_ALARM = $6006;    //视频桩报警
  COMM_GPS_STATUS_ALARM = $6010;    // GPS状态上传
  COMM_BASE_STATION_INFO_ALARM = $6011;    //基站信息上传
  COMM_ALARM_SUBSCRIBE_EVENT = $6012;    //订阅结果上报

const
  COMM_FACESNAP_RAWDATA_ALARM = $6015;    //人脸比对报警（数据透传方式）
  COMM_CLUSTER_ALARM = $6020;    //集群报警上传

const
  COMM_ISAPI_ALARM = $6009;    

//PJ01C20170209084超脑录播NVS软件功能开发定制项目专用
const
  COMM_FRAMES_PEOPLE_COUNTING_ALARM = $6069;    //单帧画面人数统计结果上传

const
  COMM_SIGN_ABNORMAL_ALARM = $6120;    //体征异常报警
  COMM_HFPD_ALARM = $6121;    //高频人员检测报警

const
  COMM_HCU_ALARM = $6150;    //车载智能盒子报警（本报警SDK库不实现，用作设备和DVR通信协议，占位防止冲突）

const
  COMM_DEV_STATUS_CHANGED = $7000;    //设备状态改变报警上传

const
  COMM_ALARM_EXCEPTION = $7fff;    //报警异常类型

//************操作异常类型(消息方式, 回调方式(保留))***************
const
  EXCEPTION_EXCHANGE = $8000;    //用户交互时异常
  EXCEPTION_AUDIOEXCHANGE = $8001;    //语音对讲异常
  EXCEPTION_ALARM = $8002;    //报警异常
  EXCEPTION_PREVIEW = $8003;    //网络预览异常
  EXCEPTION_SERIAL = $8004;    //透明通道异常
  EXCEPTION_RECONNECT = $8005;    //预览时重连
  EXCEPTION_ALARMRECONNECT = $8006;    //报警时重连
  EXCEPTION_SERIALRECONNECT = $8007;    //透明通道重连
  SERIAL_RECONNECTSUCCESS = $8008;    //透明通道重连成功
  EXCEPTION_PLAYBACK = $8010;    //回放异常
  EXCEPTION_DISKFMT = $8011;    //硬盘格式化
  EXCEPTION_PASSIVEDECODE = $8012;    //被动解码异常
  EXCEPTION_EMAILTEST = $8013;    //邮件测试异常
  EXCEPTION_BACKUP = $8014;    //备份异常
  PREVIEW_RECONNECTSUCCESS = $8015;    //预览时重连成功
  ALARM_RECONNECTSUCCESS = $8016;    //报警时重连成功
  RESUME_EXCHANGE = $8017;    //用户交互恢复
  NETWORK_FLOWTEST_EXCEPTION = $8018;    //网络流量检测异常
  EXCEPTION_PICPREVIEWRECONNECT = $8019;    //图片预览重连
  PICPREVIEW_RECONNECTSUCCESS = $8020;    //图片预览重连成功
  EXCEPTION_PICPREVIEW = $8021;    //图片预览异常
  EXCEPTION_MAX_ALARM_INFO = $8022;    //报警信息缓存已达上限
  EXCEPTION_LOST_ALARM = $8023;    //报警丢失
  EXCEPTION_PASSIVETRANSRECONNECT = $8024;    //被动转码重连
  PASSIVETRANS_RECONNECTSUCCESS = $8025;    //被动转码重连成功
  EXCEPTION_PASSIVETRANS = $8026;    //被动转码异常
  SUCCESS_PUSHDEVLOGON = $8030;    //推模式设备注册成功
  EXCEPTION_RELOGIN = $8040;    //用户重登陆
  RELOGIN_SUCCESS = $8041;    //用户重登陆成功
  EXCEPTION_PASSIVEDECODE_RECONNNECT = $8042;    //被动解码重连
  EXCEPTION_CLUSTER_CS_ARMFAILED = $8043;    //集群报警异常

const
  EXCEPTION_RELOGIN_FAILED = $8044;    //重登陆失败，停止重登陆
  EXCEPTION_PREVIEW_RECONNECT_CLOSED = $8045;    //关闭预览重连功能
  EXCEPTION_ALARM_RECONNECT_CLOSED = $8046;    //关闭报警重连功能
  EXCEPTION_SERIAL_RECONNECT_CLOSED = $8047;    //关闭透明通道重连功能
  EXCEPTION_PIC_RECONNECT_CLOSED = $8048;    //关闭回显重连功能
  EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED = $8049;    //关闭被动解码重连功能
  EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED = $804a;    //关闭被动转码重连功能
  EXCEPTION_VIDEO_DOWNLOAD = $804b;    // [add] by yangzheng 2019/11/09 录像下载异常

//*******************预览回调函数********************
const
  NET_DVR_SYSHEAD = 1;    //系统头数据
  NET_DVR_STREAMDATA = 2;    //视频流数据（包括复合流和音视频分开的视频流数据）
  NET_DVR_AUDIOSTREAMDATA = 3;    //音频流数据
  NET_DVR_STD_VIDEODATA = 4;    //标准视频流数据
  NET_DVR_STD_AUDIODATA = 5;    //标准音频流数据
  NET_DVR_SDP = 6;    //SDP信息(Rstp传输时有效)
  NET_DVR_CHANGE_FORWARD = 10;    //码流改变为正放
  NET_DVR_CHANGE_REVERSE = 11;    //码流改变为倒放
  NET_DVR_PLAYBACK_ALLFILEEND = 12;    //回放文件结束标记
  NET_DVR_VOD_DRAW_FRAME = 13;    //回放抽帧码流
  NET_DVR_VOD_DRAW_DATA = 14;    //拖动平滑码流
  NET_DVR_HLS_INDEX_DATA = 15;    //HLS索引数据
  NET_DVR_PLAYBACK_NEW_POS = 16;    //回放重置(按时间定位命令NET_DVR_PLAYSETTIME和NET_DVR_PLAYSETTIME_V50接口返回成功后，还需要等待收到该回调类型后才可认为操作成功)
  NET_DVR_METADATA_DATA = 107;    //Metadata数据
  NET_DVR_PRIVATE_DATA = 112;    //私有数据,包括智能信息

//设备型号(DVR类型)
// 设备类型 
const
  DVR = 1;    //对尚未定义的dvr类型返回DVR
  ATMDVR = 2;    //atm dvr
  DVS = 3;    //DVS
  DEC = 4;    // 6001D 
  ENC_DEC = 5;    // 6001F 
  DVR_HC = 6;    //8000HC
  DVR_HT = 7;    //8000HT
  DVR_HF = 8;    //8000HF
  DVR_HS = 9;    // 8000HS DVR(no audio) 
  DVR_HTS = 10;    // 8016HTS DVR(no audio) 
  DVR_HB = 11;    // HB DVR(SATA HD) 
  DVR_HCS = 12;    // 8000HCS DVR 
  DVS_A = 13;    // 带ATA硬盘的DVS 
  DVR_HC_S = 14;    // 8000HC-S 
  DVR_HT_S = 15;    // 8000HT-S 
  DVR_HF_S = 16;    // 8000HF-S 
  DVR_HS_S = 17;    // 8000HS-S 
  ATMDVR_S = 18;    // ATM-S 
  DVR_7000H = 19;    //7000H系列
  DEC_MAT = 20;    //多路解码器
  DVR_MOBILE = 21;    // mobile DVR 
  DVR_HD_S = 22;    // 8000HD-S 
  DVR_HD_SL = 23;    // 8000HD-SL 
  DVR_HC_SL = 24;    // 8000HC-SL 
  DVR_HS_ST = 25;    // 8000HS_ST 
  DVS_HW = 26;    // 6000HW 
  DS630X_D = 27;    // 多路解码器 
  DS640X_HD = 28;    //640X高清解码器
  DS610X_D = 29;    //610X解码器
  IPCAM = 30;    //IP 摄像机
  MEGA_IPCAM = 31;    //高清IP摄像机
  IPCAM_X62MF = 32;    //862MF可以接入9000设备
  ITCCAM = 35;    //智能高清网络摄像机
  IVS_IPCAM = 36;    //智能分析高清网络摄像机
  ZOOMCAM = 38;    //一体机
  IPDOME = 40;    //IP 标清球机
  IPDOME_MEGA200 = 41;    //IP 200万高清球机
  IPDOME_MEGA130 = 42;    //IP 130万高清球机
  IPDOME_AI = 43;    //IP 高清智能快球
  TII_IPCAM = 44;    //红外热成像摄像机
  IPTC_DOME = 45;    //红外热成像双目球机
  DS_2DP_Z = 46;    //球型鹰眼（大）
  DS_2DP = 47;    //非球型鹰眼（小）
  ITS_WMS = 48;    //称重数据管理服务器
  IPMOD = 50;    //IP 模块
  TRAFFIC_YTDOME = 51;    //交通智能云台（不带雷达测速）
  TRAFFIC_RDDOME = 52;    //交通智能云台（带雷达测速）
  IDS6501_HF_P = 60;    // 6501 车牌
  IDS6101_HF_A = 61;    //智能ATM
  IDS6002_HF_B = 62;    //双机：DS6002-HF/B
  IDS6101_HF_B = 63;    //异常行为检测：DS6101-HF/B DS6101-HF/B_SATA
  IDS52XX = 64;    //智能分析仪IVMS
  IDS90XX = 65;    // 9000智能
  IDS8104_AHL_S_HX = 66;    // 海鑫人脸识别 ATM
  IDS8104_AHL_S_H = 67;    // 私有人脸识别 ATM
  IDS91XX = 68;    // 9100智能
  IIP_CAM_B = 69;    // 智能行为IP摄像机
  IIP_CAM_F = 70;    //智能人脸IP摄像机
  DS71XX_H = 71;    // DS71XXH_S 
  DS72XX_H_S = 72;    // DS72XXH_S 
  DS73XX_H_S = 73;    // DS73XXH_S 
  DS72XX_HF_S = 74;    //DS72XX_HF_S
  DS73XX_HFI_S = 75;    //DS73XX_HFI_S
  DS76XX_H_S = 76;    // DVR,e.g. DS7604_HI_S 
  DS76XX_N_S = 77;    // NVR,e.g. DS7604_NI_S 
  DS_TP3200_EC = 78;    //机柜智能检测仪
  DS81XX_HS_S = 81;    // DS81XX_HS_S 
  DS81XX_HL_S = 82;    // DS81XX_HL_S 
  DS81XX_HC_S = 83;    // DS81XX_HC_S 
  DS81XX_HD_S = 84;    // DS81XX_HD_S 
  DS81XX_HE_S = 85;    // DS81XX_HE_S 
  DS81XX_HF_S = 86;    // DS81XX_HF_S 
  DS81XX_AH_S = 87;    // DS81XX_AH_S 
  DS81XX_AHF_S = 88;    // DS81XX_AHF_S 
  DS90XX_HF_S = 90;    //DS90XX_HF_S
  DS91XX_HF_S = 91;    //DS91XX_HF_S
  DS91XX_HD_S = 92;    //91XXHD-S(MD)
  IDS90XX_A = 93;    // 9000智能 ATM
  IDS91XX_A = 94;    // 9100智能 ATM
  DS95XX_N_S = 95;    //DS95XX_N_S NVR 不带任何输出
  DS96XX_N_SH = 96;    //DS96XX_N_SH NVR
  DS90XX_HF_SH = 97;    //DS90XX_HF_SH 
  DS91XX_HF_SH = 98;    //DS91XX_HF_SH 
  DS_B10_XY = 100;    //视频综合平台设备型号(X:编码板片数，Y:解码板片数)
  DS_6504HF_B10 = 101;    //视频综合平台内部编码器
  DS_6504D_B10 = 102;    //视频综合平台内部解码器
  DS_1832_B10 = 103;    //视频综合平台内部码分器
  DS_6401HFH_B10 = 104;    //视频综合平台内部光纤板
  DS_65XXHC = 105;    //65XXHC DVS
  DS_65XXHC_S = 106;    //65XXHC-SATA DVS
  DS_65XXHF = 107;    //65XXHF DVS
  DS_65XXHF_S = 108;    //65XXHF-SATA DVS
  DS_6500HF_B = 109;    //65 rack DVS
  IVMS_6200_C = 110;    // iVMS-6200(/C)
  IVMS_6200_B = 111;    // iVMS-6200(/B)
  DS_72XXHV_ST15 = 112;    //72XXHV_ST  海思3515平台 DVR
  DS_72XXHV_ST20 = 113;    //72XXHV_ST  海思3520平台 DVR
  IVMS_6200_T = 114;    // IVMS-6200(/T)
  IVMS_6200_BP = 115;    // IVMS-6200(/BP)
  DS_81XXHC_ST = 116;    //DS_81XXHC_ST
  DS_81XXHS_ST = 117;    //DS_81XXHS_ST
  DS_81XXAH_ST = 118;    //DS_81XXAH_ST
  DS_81XXAHF_ST = 119;    //DS_81XXAHF_ST
  DS_66XXDVS = 120;    //66XX DVS

const
  DS_1964_B10 = 121;    //视频综合平台内部报警器
  DS_B10N04_IN = 122;    //视频综合平台内部级联输入
  DS_B10N04_OUT = 123;    //视频综合平台内部级联输出
  DS_B10N04_INTEL = 124;    //视频综合平台内部智能
  DS_6408HFH_B10E_RM = 125;    //V6高清
  DS_B10N64F1_RTM = 126;    //V6级联不带DSP
  DS_B10N64F1D_RTM = 127;    //V6级联带DSP
  DS_B10_SDS = 128;    //视频综合平台子域控制器
  DS_B10_DS = 129;    //视频综合平台域控制器
  DS_6401HFH_B10V = 130;    //VGA高清编码器
  DS_6504D_B10B = 131;    //视频综合平台内部标清解码器
  DS_6504D_B10H = 132;    //视频综合平台内部高清解码器
  DS_6504D_B10V = 133;    //视频综合平台内部VGA解码器
  DS_6408HFH_B10S = 134;    //视频综合平台SDI子板
  DS_18XX_N = 135;    // 矩阵接入网关
  DS_6504HF_B10F_CLASS = 136;    //光端机SD
  DS_18XX_PTZ = 141;    //网络码分类产品
  DS_19AXX = 142;    //通用报警主机类产品
  DS_19BXX = 143;    //家用报警主机
  DS_19CXX = 144;    //自助银行报警主机
  DS_19DXX = 145;    //动环布防报警主机
  DS_19XX = 146;    //1900系列报警主机
  DS_19SXX = 147;    //视频报警主机
  DS_1HXX = 148;    {CS类产品}//防护舱
  DS_PEAXX = 149;    //一键式紧急报警产品
  DS_PWXX = 150;    //无线报警主机产品
  DS_PMXX = 151;    //4G网络模块
  DS_19DXX_S = 152;    //视频动环布防主机
  DS_PWAXX = 153;    // Axiom Hub无线报警主机 
  DS_PHAXX = 154;    // Axiom Hybrid混合报警主机 
  DS_PHAProXX = 155;    // Axiom Hybrid Pro混合报警主机


//2011-11-30
const
  DS_C10H = 161;    //多屏控制器
  DS_C10N_BI = 162;    //BNC处理器
  DS_C10N_DI = 163;    //rbg处理器
  DS_C10N_SI = 164;    //码流处理器
  DS_C10N_DO = 165;    //显示处理器
  DS_C10N_SERVER = 166;    //分布式服务器


const
  IDS_8104_AHFL_S_H = 171;    // 8104ATM
  IDS_65XX_HF_A = 172;    // 65 ATM
  IDS90XX_HF_RH = 173;    // 9000 智能RH
  IDS91XX_HF_RH = 174;    // 9100 智能RH设备
  IDS_65XX_HF_B = 175;    // 65 异常行为检测
  IDS_65XX_HF_P = 176;    // 65 车牌识别
  IVMS_6200_F = 177;    // IVMS-6200(/F)
  IVMS_6200_A = 178;    //iVMS-6200(/A)
  IVMS_6200_F_S = 179;    // IVMS-6200(/F_S)人脸后检索分析仪

const
  DS90XX_HF_RH = 181;    // 9000 RH    648
  DS91XX_HF_RH = 182;    // 9100 RH设备 648
  DS78XX_S = 183;    // 78系列设备 6446
  DS81XXHW_S = 185;    // 81 Resolution 960 KY2011
  DS81XXHW_ST = 186;    // DS81XXHW_ST  KY2011
  DS91XXHW_ST = 187;    // DS91XXHW_ST  KY2011
  DS91XX_ST = 188;    // DS91XX_ST netra
  DS81XX_ST = 189;    // DS81XX_ST netra
  DS81XXHX_ST = 190;    // DS81XXHDI_ST,DS81XXHE_ST ky2012
  DS73XXHX_ST = 191;    // DS73XXHI_ST ky2012
  DS81XX_SH = 192;    // 审讯81SH,81SHF
  DS81XX_SN = 193;    // 审讯81SNL

const
  DS96XXN_ST = 194;    //NVR:DS96xxN_ST
  DS86XXN_ST = 195;    //NVR:DS86xxN_ST
  DS80XXHF_ST = 196;    //DVR:DS80xxHF_ST
  DS90XXHF_ST = 197;    //DVR:DS90xxHF_ST
  DS76XXN_ST = 198;    //NVR:DS76xxN_ST

const
  DS_9664N_RX = 199;    //NVR:DS_9664N_RX
  ENCODER_SERVER = 200;    // 编码卡服务器
  DECODER_SERVER = 201;    // 解码卡服务器
  PCNVR_SERVER = 202;    // PCNVR存储服务器
  CVR_SERVER = 203;    // 邦诺CVR，他给自己定的类型为DVR_S-1
  DS_91XXHFH_ST = 204;    // 91系列HD-SDI高清DVR
  DS_66XXHFH = 205;    // 66高清编码器
  TRAFFIC_TS_SERVER = 210;    //终端服务器
  TRAFFIC_VAR = 211;    //视频分析记录仪
  IPCALL = 212;    //IP可视对讲分机
  SAN_SERVER = 213;    //与CVR_SERVER相同的程序，只是模式不同

const
  DS_B11_M_CLASS = 301;    //视频综合平台设备型号
  DS_B12_M_CLASS = 302;    //视频综合平台设备型号
  DS_6504HF_B11_CLASS = 303;    //视频综合平台内部编码器
  DS_6504HF_B12_CLASS = 304;    //视频综合平台内部编码器
  DS_6401HFH_B11V_CLASS = 305;    //VGA高清
  DS_6401HFH_B12V_CLASS = 306;    //VGA高清
  DS_6408HFH_B11S_CLASS = 307;    //SDI
  DS_6408HFH_B12S_CLASS = 308;    //SDI
  DS_6504D_B11H_CLASS = 309;    //视频综合平台内部高清解码器
  DS_6504D_B11B_CLASS = 310;    //视频综合平台内部标清解码器
  DS_6504D_B12B_CLASS = 311;    //视频综合平台内部标清解码器
  DS_6504D_B11V_CLASS = 312;    //视频综合平台内部VGA解码器
  DS_6504D_B12V_CLASS = 313;    //视频综合平台内部VGA解码器
//B10新增
const
  DS_6401HFH_B10R_CLASS = 314;    //B10 RGB高清
  DS_6401HFH_B10D_CLASS = 315;    //B10 DVI高清
  DS_6401HFH_B10H_CLASS = 316;    //B10 HDMI高清
//B11新增
const
  DS_6401HFH_B11R_CLASS = 317;    //B11 RGB高清
  DS_6401HFH_B11D_CLASS = 318;    //B11 DVI高清
  DS_6401HFH_B11H_CLASS = 319;    //B11 HDMI高清
//B12新增
const
  DS_6401HFH_B12R_CLASS = 320;    //B12 RGB高清
  DS_6401HFH_B12D_CLASS = 321;    //B12 DVI高清
  DS_6401HFH_B12H_CLASS = 322;    //B12 HDMI高清
  DS_65XXD_B10Ex_CLASS = 323;    //netra高清解码

//B10 V2.1新增
const
  DS_6516HW_B10_CLASS = 324;    //netra高线编码
  DS_6401HFH_B10F_RX_CLASS = 326;    //高清光端机接入（支持1/2路光端机接入）
  DS_6502HW_B10F_RX_CLASS = 327;    //960H光端机接入（支持1/4/8路光端机接入）
//2012-5-16新增
const
  DS_6504D_B11Ex_CLASS = 328;    //netra高清解码
  DS_6504D_B12Ex_CLASS = 329;    //netra高清解码
  DS_6512_B11_CLASS = 330;    //netra高线编码
  DS_6512_B12_CLASS = 331;    //netra高线编码
  DS_6504D_B10H_CLASS = 332;    //视频综合平台内部高清解码器

const
  DS_65XXT_B10_CLASS = 333;    //视频综合平台转码子系统
  DS_65XXD_B10_CLASS = 335;    //视频综合平台解码板
  DS_IVMSE_B10X_CLASS = 336;    //X86服务器子系统
  DS_6532D_B10ES_CLASS = 337;    //增强型解码板_SDI(B10)
  DS_6508HFH_B10ES_CLASS = 338;    //SDI输入编码子系统
  DS_82NCG_CLASS = 340;    //联网网关中的子系统
  DS_82VAG_CLASS = 341;    //联网网关中的子系统
  DS_1802XXF_B10_CLASS = 342;    //光口交换子系统
  iDS_6504_B10EVAC_CLASS = 343;    //智能子系统
  iDS_6504_B10EDEC_CLASS = 344;    //智能子系统
  DS_6402HFH_B10EV_CLASS = 345;    //netra编码(VGA)
  DS_6402HFH_B10ED_CLASS = 346;    //netra编码(DVI)
  DS_6402HFH_B10EH_CLASS = 347;    //netra编码(HDMI)
  DS_6404HFH_B10T_RX_CLASS = 348;    //光纤接入编码
  DS_6504D_AIO_CLASS = 349;    //netra高清解码
  DS_IVMST_B10_CLASS = 350;    //X86转码子系统
  DS_6402_AIO_CLASS = 351;    //netra编码
  DS_iVMSE_AIO_CLASS = 352;    //x86服务器子系统
  DS_AIO_M_CLASS = 353;    //一体机


const
  DS_6508HF_B10E_CLASS = 355;    //BNC输入编码子系统
  DS_6404HFH_B10ES_CLASS = 356;    //SDI输入编码子系统
  DS_6402HFH_B10ER_CLASS = 358;    //RGB输入编码子系统
  DS_6404HFH_B10T_RM_CLASS = 361;    //光纤输入编码子系统
  DS_6516D_B10EB_CLASS = 362;    //BNC输出解码子系统
  DS_6516D_B10ES_CLASS = 363;    //SDI输出解码子系统

//DVI/HDMI/VGA畅显解码公用一个类型
const
  DS_6508D_B10FH_CLASS = 364;    
  DS_6508D_B10FD_CLASS = 364;    
  DS_6508D_B10FV_CLASS = 364;    

const
  DS_6508_B11E_CLASS = 365;    //BNC输入编码子系统
  DS_6402_B11ES_CLASS = 366;    //SDI输入编码子系统
  DS_6402_B11EV_CLASS = 367;    //VGA输入编码子系统
  DS_6402_B11ER_CLASS = 368;    //RGB输入编码子系统
  DS_6402_B11ED_CLASS = 369;    //DVI输入编码子系统
  DS_6402_B11EH_CLASS = 370;    //HDMI输入编码子系统
  DS_6516D_B11EB_CLASS = 371;    //BNC输出解码子系统
  DS_6516D_B11ES_CLASS = 372;    //SDI输出解码子系统

const
  DS_6508_B12E_CLASS = 373;    //BNC输入编码子系统
  DS_6402_B12ES_CLASS = 375;    //SDI输入编码子系统
  DS_6402_B12EV_CLASS = 376;    //VGA输入编码子系统
  DS_6402_B12ER_CLASS = 377;    //RGB输入编码子系统
  DS_6402_B12ED_CLASS = 378;    //DVI输入编码子系统
  DS_6402_B12EH_CLASS = 379;    //HDMI输入编码子系统
  DS_6516D_B12EB_CLASS = 380;    //BNC输出解码子系统

const
  DS_iVMSE_AIO_8100x_CLASS = 381;    //金融行业一体机X86子系统
  DS_iVMSE_AIO_87x_CLASS = 382;    //智能楼宇一体机X86子系统
  DS_6532D_B11ES_CLASS = 384;    //增强型解码板_SDI(B11)
  DS_6532D_B12ES_CLASS = 385;    //增强型解码板_SDI(B12)
//B20新增
const
  DS_B20_MSU_NP = 400;    //B20主控板
  DS_6416HFH_B20S = 401;    //SDI输入编码
  DS_6416HFH_B20_RM = 402;    //光纤输入高清编码
  DS_6564D_B20D = 403;    //DVI解码
  DS_6564D_B20H = 404;    //HDMI解码
  DS_6564D_B20V = 405;    //VGA解码
  DS_B20_6516D_DEV_CLASS = 406;    //B20解码子系统
  DS_6408HFH_B20V = 407;    //VGA编码板
  DS_MMC_B20_CLASS = 408;    //B20主控
  DS_CARD_CHIP_B20_CLASS = 409;    //B20主控子板
  DS_6564D_B20B_DEV_CLASS = 410;    //BNC解码子系统
  DS_6564D_B20S_DEV_CLASS = 411;    //SDI解码子系统
  DS_6532HF_B20B_DEV_CLASS = 412;    //BNC编码子系统
  DS_6408HFH_B20D_DEV_CLASS = 413;    //DVI编码子系统
  DS_6408HFH_B20H_DEV_CLASS = 414;    //HDMI编码子系统
  DS_IVMSE_B20_CLASS = 415;    //X86服务器子系统
  DS_6402HFH_B20Y_DEV_CLASS = 416;    //YUV编码子系统
  DS_6508HW_B20_DEV_CLASS = 417;    //HW编码子系统
  DS_B20N128Fx_B20_DEV_CLASS = 418;    //DS_B20N128Fx_M级联板
  DS_AIO_MCU_NP_DEV_CLASS = 419;    //IO主控板
  DS_6402_AIO_EV_DEV_CLASS = 420;    //VGA编码
  DS_6508D_AIO_EV_DEV_CLASS = 421;    //VGA解码
  DS_6508D_AIO_ED_DEV_CLASS = 422;    //DVI解码
  DS_6508D_AIO_EH_DEV_CLASS = 423;    //HDMI解码
  DS_6508HD_B20F_DEV_CLASS = 424;    //视频增强板
  DS_6402HFH_B20ES_DEV_CLASS = 425;    //3G SID编码
  DS_6532D_B20_DEV_CLASS = 426;    //B20解码子系统
  DS_IVMST_B20_DEV_CLASS = 427;    //X86服务器子系统
  DS_6416HFH_B20DD_DEV_CLASS = 428;    //DVI双链路
  DS_6441VS_B20_DEV_CLASS = 429;    //相机拼接类型
  DS_6404HFH_B20T_CLASS = 431;    //TVI
  DS_FS22_B20_DEV_CLASS = 432;    //交换机子系统
  DS_IVMSE_B20UH_DEV_CLASS = 433;    //超高清X86输入
  IDS_6524J_B20_DEV_CLASS = 434;    
  IDS_6532B_B20_DEV_CLASS = 435;    
  DS_6404HFH_B20Fx_DEV_CLASS = 436;    //光端机接入子系统
  DS_N128x_B20Fy_CLASS = 437;    //级联子系统
  DS_181600F_B20_CLASS = 438;    //网络光纤子系统
  DS_6904UD_B20H_CLASS = 439;    //超高清解码子系统

const
  DS_B21_MCU_NP_CLASS = 440;    //B21主控
  DS_B21_S10_x_CLASS = 441;    //B21机箱 x = A/S/D
  DS_6402HFH_B21D_CLASS = 442;    //B21编码子系统
  DS_6508HD_B21D_CLASS = 443;    //B21解码子系统
  DS_iVMSE_B21HW_CLASS = 444;    //B21 X86子系统

const
  DS_C10S = 501;    //C10S 集中式大屏控制器
  DS_C3X = 502;    //集中式拼接控制器

const
  DS_C10N_SDI = 551;    //SDI处理器
  DS_C10N_BIW = 552;    //8路BNC处理器
  DS_C10N_DON = 553;    //显示处理器
  DS_C10N_TVI = 554;    //TVI输入板
  DS_C10N_DI2 = 555;    //DVI 2路输入板
  DS_C10N_AUDIO_OUT = 556;    //DVI，HDMI，VGA输出板带音频
  DS_C10N_AUDIO_IN = 557;    //DVI，HDMI，VGA输入板带音频

//软服务器版本的分布式大屏控制器
const
  DS_C20N = 570;    //分布式大屏控制器
  DS_C20N_BNC = 571;    //BNC输入设备
  DS_C20N_DVI = 572;    //DVI输入设备
  DS_C20N_DP = 573;    //DP输入设备
  DS_C20N_OUT = 574;    //输出设备

//集中式多屏控制器    5301 - 5350  （50）
const
  DS_C30 = 5301;    //C30集中式拼接控制器
  DS_C31 = 5302;    //C31集中式拼接控制器
  DS_M0804 = 5303;    //M0804经济型拼接控制器

//硬服务器版本的分布式大屏控制器
const
  DS_C20N_VWMS = 5351;    //C20N服务器
  DS_C20N_DI2 = 5352;    //两路DVI输入设备
  DS_C20N_DO2 = 5353;    //两路DVI输出设备
  DS_C20N_UHDI = 5354;    //DP/HDMI 1路4K超高清输入设备
  DS_C20N_YI2 = 5355;    //两路YPbPr输入板

const
  DS_C12N_VWMS = 5356;    //C12N服务器
  DS_C12N_DO = 5357;    //1路DVI输出
  DS_C12N_HOE = 5358;    //1路HDMI 4K输出

const
  DS_C20N_HI2 = 5359;    // HDMI输入节点(2路)
  DS_C20N_VI2 = 5360;    //VGA输入节点(2路)
  DS_C20N_SI2 = 5361;    //SDI输入节点(2路)
  DS_C20N_HO2 = 5362;    //HDMI输出节点(2路)
  DS_C20N_S24G = 5363;    //C20N专用千兆交换机(24路)
  DS_C20N_S24X = 5364;    //C20N专用万兆交换机(24路)
  DS_C12A_0104H = 5365;    //创意拼接控制器
  DS_C20N_DO2_V2 = 5366;    //两路DVI输出设备V2
  DS_C20N_HO2_V2 = 5367;    //两路HDMI输出设备V2
  DS_C21N = 5368;    //分布式大屏控制器
  DS_C21K = 5369;    //坐席KVM系统C21
  DS_68TS_A = 5370;    //触控一体机
  DS_C22N_UHDI = 5371;    //4K60输入设备(1路)
  DS_C21N_UHDI_T = 5372;    //1路4K60超高清输入节点
  DS_C22N_HI1 = 5373;    //1路HDMI高清输入
  DS_C22N_HO1 = 5374;    //1路HDMI高清输出


//全息显示设备
const
  DS_D1HXX = 5591;    //全息显示设备
  DS_60SDL_X = 5592;    //Windows双面屏终端
  DS_6043DL_B = 5593;    //安卓双面屏43寸终端
  DS_6049DL_B = 5594;    //安卓双面屏49寸终端
  DS_6055DL_B = 5595;    //安卓双面屏55寸终端

//无线传输设备
const
  ELEVATO_BRIDGE = 5751;    //无线电梯网桥
  DS_3WF01S_5NG_M = 5752;    //5.8G室外1公里无线工地网
  DS_3WF0EC_2N_D = 5753;    //2.4G室外500米网桥
  DS_3WF0EC_5ACT = 5754;    //5.8G 11ac电梯网桥
  DS_3WF03S_5AC = 5755;    //5.8G 3公里经济型网桥
  DS_3WF0ES_5AC_H = 5756;    //5.8G室外500米高穿透网桥
  DS_3WF05S_5AC_H = 5765;    //5.8G 5KM千兆网口拨码网桥
  DS_3WSXXX = 5766;    //网关路由器系列（包括AC控制器）
  DS_3WAXXX = 5767;    //吸顶、室外AP系列
  DS_3WAXXXP = 5768;    //面板AP系列
  DS_3WRXXX = 5769;    //普通无线路由器系列
  DS_3WMRXXX = 5770;    //MESH路由器系列
  DS_3WAX18 = 5881;    //室外AP

//网络设备管理类
const
  DS_3CXXXX = 5891;    //统一网络管理平台


//报警设备
const
  DS_19M00_MN = 601;    //报警主机百兆网络模块
  DS_KH8302_A = 602;    //室内机
  DS_KD8101_2 = 603;    //门口机
  DS_KM8301 = 604;    //管理机
  DS_KVXXXX_XX = 605;    //别墅门口机
  DS_LHPM1D_C = 606;    //酒店锁
  DS_KAM03 = 607;    //半数字转接模块
  DS_KDXXX = 608;    //智能交互终端，监所行业DS-KD9623-F-JP，DS-KD9623-FC-JP，DS-KD9803-F-JP医疗行业：DS-KD9803-3XF5G-HI，DS-KD9803-3XFW-HI，DS-KD9803-W-HI

const
  DS64XXHD_T = 701;    //64-T高清解码器
  DS_65XXD = 703;    //65解码器
  DS63XXD_T = 704;    //63-T标清解码器
  SCE_SERVER = 705;    //抓屏服务器
  DS_64XXHD_S = 706;    //64XXHD-S高清解码器
  DS_68XXT = 707;    //多功能视音频转码器
  DS_65XXD_T = 708;    //65D-T解码器
  DS_65XXHD_T = 709;    //65HD-T解码器
  DS_69XXUD = 710;    //69XXUD超高清解码器
  DS_65XXUD = 711;    //65XXUD解码器
  DS_65XXUD_L = 712;    //65XXUD_L解码器
  DS_65XXUD_T = 713;    //65XXUD_T解码器


const
  DS_D20XX = 750;    //LCD屏幕 解码卡
//SDI矩阵
const
  DS_C50S = 751;    //SDI矩阵
  DS_D50XX = 752;    //LCD屏幕 解码卡

const
  DS_D40 = 760;    //LED屏发送卡

const
  DS_65VMXX = 770;    //视频会议服务器
  DS_65VTXX = 771;    //视频会议终端
  DS_65VTA = 772;    //视频会议一体式终端
  DS_65VT_RX = 773;    //互动教学终端
  DS_65VM_MCU_NP = 774;    //大容量MCU


const
  DS_CS_SERVER = 800;    //虚拟屏服务器
  DS_68GAP_MCU = 831;    //视频网闸
  DS_K260X = 850;    //门禁主机
  DS_K1TXXX = 851;    //指纹一体机
  DS_K280X = 852;    //经济型门禁主机
  DS_K281X = 853;    //门禁主机DS-K281X系列
  DS_K1T80X = 854;    //经济型门禁一体机
  RAC_6X00 = 856;    //汉军指纹门禁一体机
  DS_K2602_AX = 857;    //人员通道主机
  DS_K1T803F = 858;    //经济型指纹门禁产品
  DS_K2700 = 859;    //分布式三层架构门禁主机
  DS_K270X = 860;    //分布式三层架构就地控制器
  DS_K1T500S = 861;    //视屏门禁一体机
  DS_K1A801F = 862;    //经济型指纹门禁产品
  DS_K1T600X = 863;    //人脸识别门禁一体机
  DS_K22X = 864;    //梯控主控制器
  DS_K2M0016AX = 865;    //梯控分控制器
  DS_K2602S_AX = 867;    //人员通道产品
  DS_K560XX = 870;    //立式/台式智能身份识别终端
  DS_K260X_E = 873;    //低端门禁主机
  DS_K5603X = 874;    //台式/壁挂式嵌入式人证设备
  DS_K3M200X = 875;    //权限控制器
  DS_K3M100X = 879;    //通道控制器
  DS_K1T8101XT = 881;    //经销型人脸识别门禁一体机
  DS_K1T8101XX = 882;    //经销型人脸识别门禁一体机
  DS_K5604 = 883;    //5604人证设备
  DS_K1T607XXXX = 884;    //中端人脸门禁一体机DS_K1T607（M/MF/E/EF/MG/MFG?MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW）
  DS_K1A850X = 885;    //低端经销指纹考勤机
  DS_K1T800X = 886;    //低端经销指纹门禁一体机
  DS_K1T610XXXX = 887;    //中端人脸门禁一体机DS_K1T610（M/MF/E/EF/MG/MFG?MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW）
  DS_K1T8115X = 888;    //DS-K1T8115、DS-K1T8115M、DS-K1T8115M-Z 经销型人脸识别一体机
  DS_K1T815LC_M = 889;    //经销型人脸识别一体机
  DS_K1T606M_Z = 890;    //经销型人脸识别一体机
  DS_K5607_XXX = 891;    //K5607轻薄款通道人脸组件
  DS_K1T806X = 892;    //低端经销门禁一体机DS-K1T806系列
  DS_K1T950MX = 893;    //经销款人脸指纹门禁一体机
  DS_K1T331XX = 894;    //低端人脸门禁考勤一体机
  DS_K1T671T = 895;    //人脸门禁一体机
  DS_K1T671 = 896;    //人脸门禁一体机
  DS_K5671 = 897;    //轻薄款通道人脸组件
  DS_K1T640 = 898;    //4.3寸人脸门禁一体机
  DS_K1A802A = 899;    //经济型指纹考勤机

const
  DS_6800M = 900;    //68M合码器
  DS_68NTH = 901;    //信息发布主机
  DS_D60S = 902;    //信息发布服务器
  DS_D60W = 903;    //信息发布Windows终端
  DS_D10 = 931;    //背投显示设备
  DS_3K0X_NM = 951;    //光纤收发器
  DS_3E2328 = 952;    //百兆交换机
  DS_3E1528 = 953;    //千兆交换机
  SCREEN_LINK_SERVER = 971;    //屏幕服务器
  DS_D51OPSXX = 972;    //OPS电脑盒
//一体化云台
const
  IP_PTSYS_MEGA200 = 1001;    //IP 200万一体化云台
  IPCAM_FISHEYE = 1002;    //鱼眼摄像机
  IPCAM_FISHEYE_E = 1003;    //经济型鱼眼摄像机

//68xx系列双目3D相机
const
  IPCAM_BINOCULAR = 1004;    //双目摄像机

const
  IPCAM_365 = 1010;    //支持365的平台的IPC CAM
  IPCAM_R0 = 1011;    //支持A5S的平台的IPC CAM
  IPCAM_R1 = 1012;    //支持385的平台的IPC CAM
  IPCAM_R2 = 1013;    //支持R2的平台的IPC CAM
  IPCAM_R3 = 1014;    //支持8127的平台的IPC CAM
  IPCAM_R4 = 1015;    //支持S2的平台的IPC CAM

const
  IPDOME_365 = 1110;    //支持365的平台的IPD CAM
  IPDOME_R0 = 1111;    //支持A5S的平台的IPD CAM
  IPDOME_R1 = 1112;    //支持385的平台的IPD CAM
  IPDOME_R2 = 1113;    //支持R2的平台的IPD CAM
  IPDOME_R3 = 1114;    //支持8127的平台的IPD CAM
  IPDOME_R4 = 1115;    //支持S2的平台的IPD CAM
  ITCCAM_R3 = 1211;    //支持8127的平台的ITCCAM

//无人机业务设备（1300~1350）
const
  UAV_S = 1300;    //无人机基站设备 （Ummanned Aerial Vehicle C Station）

//新增设备类型 2013-11-19
const
  TRAFFIC_ECT = 1400;    //ECT设备类型
  TRAFFIC_PARKING_SERVER = 1401;    //停车场服务器
  TRAFFIC_TME = 1402;    //出入口控制机
// DVR
const
  DS90XXHW_ST = 2001;    // DS90XXHW_ST混合DVR
  DS72XXHX_SH = 2002;    // DS-72xxHV_SH, DS-72xxHF-SH
  DS_92XX_HF_ST = 2003;    // DS-92XX-HF-ST
  DS_91XX_HF_XT = 2004;    // 9100DVR_HF_XT
  DS_90XX_HF_XT = 2005;    // 9000DVR_HF_XT
  DS_73XXHX_SH = 2006;    // 7300DVR_HX_SH
  DS_72XXHFH_ST = 2007;    // 7200DVR_HFH_ST
//DS_67系列

const
  DS_67XXHF_SATA = 2008;    // DS-67XXHF-SATA
  DS_67XXHW = 2009;    // DS-67XXHW
  DS_67XXHW_SATA = 2010;    // DS-67XXHW-SATA
  DS_67XXHF = 2011;    // DS-67XXHF

//Netra2.3
const
  DS_72XXHF_SV = 2012;    // DS-72xxHF-SV
  DS_72XXHW_SV = 2013;    // DS-72xxHW-SV

const
  DS_81XXHX_SH = 2014;    // 8100DVR_HX_SH

const
  DS_71XXHX_SL = 2015;    //小型DVR

const
  DS_76XXH_ST = 2016;    //DS_76XXH_ST


const
  DS_73XXHFH_ST = 2017;    //73HFH系列
  DS_81XXHFH_ST = 2018;    //81HFH系列 ST

const
  DS_72XXHFH_SL = 2019;    //hi3521
  DS_FDXXCGA_FLT = 2020;    //2盘位ATM

const
  IDS_91XX_HF_ST_A = 2100;    //iDS-9100HF-ST/A
  IDS_91XX_HF_ST_B = 2101;    //iDS-9100HF-ST/B
  IDS_90XX_HF_ST_A = 2102;    //iDS-9000HF-ST/A
  IDS_90XX_HF_ST_B = 2103;    //iDS-9000HF-ST/B
  IDS_81XX_HF_ST_A = 2104;    //iDS-8100HF-ST/A
  IDS_81XX_HF_ST_B = 2105;    //iDS-8100HF-ST/B
  IDS_80XX_HF_ST_A = 2106;    //iDS-8000HF-ST/A
  IDS_80XX_HF_ST_B = 2107;    //iDS-8000HF-ST/B
  IDS_8104_AHFL_ST = 2108;    //智能混合ATM机
  IDS_2CD6812F_C = 2109;    //垂直双目相机


// NVR
const
  DS_77XXN_ST = 2201;    //  NVR DS-77XXHF-ST
  DS_95XX_N_ST = 2202;    //  95XXN_ST NVR
  DS_85XX_N_ST = 2203;    //  85XXN_ST NVR
  DS_96XX_N_XT = 2204;    // 9600NVR_N_XT
  DS_76XX_N_SE = 2205;    // 7600NVR_N_SE

//高清审讯机
const
  DS_86XXSN_SX = 2206;    // 8608NVR_SX，包括4中类型DS-8608SNL-SP、DS-8608SNL-ST、DS-8608SN-SP、DS-8608SN-ST，L表示带LCD，P表POE

//#define DS_96XX_N_RX                2207  //DS-96XX-N-RX
const
  DS_71XXN_SL = 2208;    //DS-71XXN-SL 民用产品
  CS_N1_1XX = 2209;    //CS_N1_1XX，民用事业部所用

const
  DS_71XXN_SN = 2210;    //71XX_N_SN  经济型民用产品
  CS_N1_2XX = 2211;    //N1_2XX        民用事业部所用
  DS_76XX_N_SHT = 2212;    //76XX_N_SHT  后端基线产品
  DS_96XXX_N_E = 2213;    //高新性能NVR(256)

const
  DS_76XXN_EX = 2214;    // 76 78系列NVR，注：包括 4 8 16路的E1一盘位， 8 16 32路 E2两盘位； /N /P设备
  DS_77XXN_E4 = 2215;    // 77系列NVR，   注：包括8 16 32路， /N /P设备
  DS_86XXN_E8 = 2216;    // 86系列NVR，   注：包括8 16 32路， /N /P设备
  DS_9616N_H8 = 2217;    //DS_9616N_H8
  DS_72XXHX_EX_GXY = 2218;    //表示72系列无线DVR产品，其中72后面的xx表示通道数，H后的X目前仅有HW,为了后续扩展保留，E后面的X表示的是盘位数，G XY表示的是无线类型
  DS_76XXN_EX_GXY = 2219;    //表示是76系列无线NVR产品，其中76后面的xx表示通道数，E后面的X表示的是盘位数，G XY表示的是无线类型
  DS_72XXHXH_SH_21 = 2220;    //  72XXHXH_SH_21
  DS_72XXHXH_SH_31 = 2221;    //  72XXHXH_SH_31
  DS_73XXHXH_SH_31 = 2222;    // 73XXHXH_SH_31
  DS_81XXHXH_SH_31 = 2223;    //  81XXHXH_SH_31
  DS_71XXHXH_SH_21 = 2224;    // 71XXHXH_SH_21
  DS_71XXHXH_SH_31 = 2225;    // 71XXHXH_SH_31
  DS_NBXX_N_E1_X = 2226;    //便携式主机
  DS_96XXN_FX = 2230;    
  DS_86XXN_FX = 2231;    
  DS_96XXXN_HX = 2232;    //96系列设备


const
  DS_86XXN_I = 2233;    //DS_86XXN_I
  DS_77XX_N_I = 2234;    //DS_77XX_N_I
  DS_76XX_N_I = 2235;    //DS_76XX_N_I
  DS_78XX_N_I = 2236;    //DS_78XX_N_I
  DS_96XXXN_IX = 2237;    //DS-96XXX_N_I（DS-96128N-I16、DS-96128N-I24、DS-96256N-I16、DS-96256N-I24）

const
  DS_90XXHXH_XT = 2238;    //DS_90XXHXH_XT（DS-9016HQH-XT）

const
  DS_NVR_ALL = 2239;    //NVR设备统一类型码，后续所有NVR产品（包括已定义系列）都使用DS_NVR_ALL
  DS_DVR_ALL = 2240;    //DVR设备统一类型码，后续所有DVR产品（包括已定义系列）都使用DS_DVR_ALL

//PCNVR
const
  PCNVR_IVMS_4200 = 2301;    // PCNVR_IVMS_4200


//智能分析仪
const
  IVMS_6200_TP = 2401;    //IVMS-6200 交通诱导分析仪
  IVMS_6200_TF = 2402;    //IVMS-6200 交通取证分析仪
  IVMS_6200_D = 2403;    //iVMS-6200(/D)
  IDS_81XXAHW_ST = 2405;    //iDS-81xxAHW-ST
  IDS_81XXAHW_SP = 2406;    //iDS-81xxAHW-SP
  IDS_81XXAHWL_ST = 2407;    //iDS-81xxAHWL-ST
  IDS_81XXAHWL_SP = 2408;    //iDS-81xxAHWL-SP
  IDS_9616N_H8 = 2409;    //iDS_9616N_H8
  IVMS_6200_SMD = 2500;    //IVMS_6200_SMD
//HISI3531平台混合ATM DVR， 其中L表示带液晶屏，P表示带poe
const
  DS_81XXAHW_ST = 2501;    
  DS_81XXAHW_SP = 2502;    
  DS_81XXAHWL_ST = 2503;    
  DS_81XXAHWL_SP = 2504;    

//TVI ATM
const
  DS_81XXAHGH_E4 = 2601;    //DS_81XXAHGH_E4

//**********************************************************************
// 传输与显示产品设备类型start（不包含老的设备类型）                    
//**********************************************************************

//* B20系列（4001-4100） 

const
  DS_6904UD_AIOE_H_CLASS = 4002;    //B20一体机
  DS_6402HFH_B21B_CLASS = 4005;    //B21 编码
  DS_6902UD_B21H_CLASS = 4006;    //B21 HDMI解码
  DS_6902UD_B21D_CLASS = 4007;    //B21 DVI解码
  DS_6902UD_B21V_CLASS = 4008;    //B21 VGA解码
  DS_6904UD_B20D_CLASS = 4010;    //B20 DVI解码
  DS_6904UD_B20V_CLASS = 4011;    //B20 VGA解码
  DS_B30_MCU = 4012;    //B30主控板
  DS_B30_SW = 4013;    //B30交换板
  DS_B30_04XI = 4014;    //B30编码输入板
  DS_B30_04XO = 4015;    //B30解码输出板
  DS_B31 = 4016;    //B31一体机

//B21一体机设备型号
const
  DS_AIOH_MCU_NP = 4042;    //主控板
  DS_6404HFH_AIOH_D = 4043;    //4路DVI输入板
  DS_6908UD_AIOH_D = 4044;    //4路DVI输出板
  DS_6908UD_AIOH_H = 4045;    //4路HDMI输出板

//解码一体机设备型号
const
  DS_69XXUD_B = 4046;    //解码一体机
  DS_6404HFH_I = 4047;    //4路DVI输入板
  DS_6904UD_O = 4048;    //8路HDMI输出板


//集中式拼控器
const
  DS_C12L_0204H = 4060;    //经济型小型拼控器

//AR一体机  4101 - 4120 （20）
const
  DS_D1A24FDI = 4101;    //AR教育一体机

//解码器5001-5050
const
  DS_69XXHD = 5001;    //69XXHD解码器
  DS_69UD_V2 = 5002;    //69UD超高清解码器V2
  DS_69UD_T = 5003;    //6输入超高清解码器
  DS_6AUD = 5004;    //超高清解码器网络版
  DS_6AUD_V3 = 5005;    //超高清解码器V3

//转码器    5401 - 5450  （50）
const
  DS_68VTG = 5401;    //综合转码网关

//视频会议设备    5571 - 5590  （20）
const
  DS_65VT0010 = 5571;    //一体式终端
  DS_65VM_MCU = 5572;    //高密度MCU主控板
  DS_65VM_MPC = 5573;    //高密度MCU媒体资源板
  DS_65VT2XXYR_SF = 5574;    //司法提讯终端
  DS_65VT0XXY = 5575;    //视频会议大终端
  DS_65VT0010Z = 5576;    //智能一体式终端
  DS_65VT0050Z = 5577;    //智能分体式终端
  DS_65VS0XXXS = 5878;    //opensips服务器设备
  DS_65VS0XXXM = 5579;    //视频会议会控平台设备
  DS_65VM00XX_X = 5580;    //视频会议X86系统MCU
  DS_65VA800_BOX = 5581;    //视频会议麦克风
  DS_65VT0020S = 5582;    //一体式单目智能会议终端
  DS_65VT0020D = 5583;    //一体式双目智能会议终端
  DS_65VM00XX_G = 5584;    //视频会议MCU服务器
  DS_65VM0000_GPU = 5585;    //视频会议媒体处理卡
  DS_65VTA011 = 5586;    //单目高集成终端
  DS_65VCP1100M_S = 5587;    //4K单目相机(智能会议终端)
  Z_MINISMC_01 = 5588;    //4K USB相机

const
  DS_65VCAXX = 5590;    //高集成摄像机

const
  DS_65VTR00X0 = 5791;    //分体式信创会议终端
  DS_65VA800AM_S = 5792;    //视频会议列阵麦克风
  DS_65VAM0100UB = 5793;    //视频会议麦克风扬声器
  DS_65VA800SW = 5794;    //音频转换器
  DS_65VTA22XX_X = 5795;    //SmartEye A2200
  DS_65VCAXXXX = 5796;    //Smart Meeting Bar

//视频云模方（Y10系列）
const
  DS_Y10_MCU = 5771;    //主控板
  DS_Y10_SW1 = 5772;    //交换板
  DS_6516UD_Y10D = 5773;    //8路DVI显示接口解码板
  DS_6532UD_Y10D = 5774;    //16路DVI显示接口解码板
  DS_6E2724_Y10 = 5775;    //24个万兆接口编码接入板
  DS_68SAA_AA_Y10 = 5776;    //双路2620、内存32G业务板
  DS_68SBA_AA_Y10 = 5777;    //双路2630、内存32G业务板
  DS_68SCA_AA_Y10 = 5778;    //双路2650、内存32G业务板
  DS_68GPU_A1_Y10 = 5779;    //P4显卡版
  DS_CPU_SERVER = 5780;    //CPU服务板
  DS_GPU_SERVER = 5781;    //GPU服务板
  DS_BIGDATA_SERVER = 5782;    //大数据服务板


//安监一体机系列
const
  DS_B80_MCU = 5821;    //主控板
  DS_B80_SW = 5822;    //交换板
  DS_B80_SR_01 = 5823;    //服务板
  DS_B80_AI04 = 5824;    //智能分析板，支持4路分析能力
  DS_B80_ST = 5825;    //存储板，支持4个2.5寸2T硬盘
  DS_B80_D04 = 5826;    //数据采集业务板
  DS_B80_BNC08 = 5827;    //标清编码板
  DS_B80_SDI08 = 5828;    //高清编码板
  DS_B80_VP = 5829;    //转码/合码板
  DS_B80_VO02 = 5830;    //视频输出板
  DS_B81_MCU = 5831;    //B81主控模块
  DS_B81_AI = 5832;    //B81智能分析模块
  DS_B81_TVI = 5833;    //B81 模拟视频输入模块（TVI/BNC）
  DS_B81_APL = 5834;    //B81服务模块 X86平台
  DS_B81_D08T = 5835;    //B81 生产数据采集模块
  DS_B85 = 5836;    //B85小型物联网主机
  DS_B86 = 5837;    //B86物联中控主机
  AX_GW100_V16A00M = 5838;    //B81主机（非隔离），OEM设备
  DS_B81_AT_M = 5839;    //B81主机（非隔离）

//网关类
const
  DS_3LGCX = 5841;    //通用物联网关
  DS_3LGRX = 5842;    //LoRa网关
  DS_3LGT4 = 5843;    //电梯网关设备
  DS_3LGT40_N = 5844;    //NB-IoT电梯网关
  DS_3LGS_I = 5845;    //智能网关


//交换机
const
  DS_3E11XX = 5681;    //百兆交换机
  DS_3E13XX = 5682;    //千兆上行交换机
  DS_3E15XX = 5683;    //千兆交换机
  DS_3E11XXP = 5684;    //百兆POE交换机
  DS_3E13XXP = 5685;    //千兆上行POE交换机
  DS_3E15XXP = 5686;    //千兆POE交换机
  DS_3E1520U = 5687;    //USB充电柜
  DS_3EODM_H = 5688;    //华三交换机
  DS_3EODM_W = 5689;    //恒茂交换机
  DS_3T1XXX = 5690;    //DS-3T1XXX系列交换机
  DS_3E2XXX = 5861;    //二层全网管交换机
  DS_3E2XXXP = 5862;    //二层全网管交换机-POE
  DS_3E3XXX = 5863;    //三层全网管交换机
  DS_3E3XXXP = 5864;    //三层全网管交换机-POE

//光纤收发器
const
  DS_3D01R_NM = 5691;    //收发器接收卡
  DS_3D01T_NM = 5692;    //收发器发送机
  DS_3K02_RNM = 5693;    //收发器网管卡


//**********************************************************************
// 传输与显示产品设备类型end（不包含老的设备类型）                      
//**********************************************************************

const
  IDS_90XX_HXH_XX_S = 6001;    //超脑人体DVR产品
  IDS_90XX_HXH_XX_FA = 6002;    //超脑人脸DVR产品

const
  DS_81XX_SHXL_K4 = 6101;    //KY2017平台审讯机DS-8104SHFH（L）-K4/4P

const
  DS_8116THFHL_F4 = 6201;    //标准庭审主机DS-8116THFHL-F4

const
  DS_81XXAHQ_E4 = 6301;    //DS_81XXAHQ_E4(TVI ATM)
  IDS_81XXAHQ_E4 = 6302;    //IDS_81XXAHQ_E4(智能TVI ATM)

const
  IDS_86XX_NX_A = 7501;    //超脑智能ATM NVR(iDS-8632NX-I8/A)
  IDS_96XX_NX_S = 7502;    //人体超脑智能NVR
  IDS_96XX_NX_V = 7503;    //超脑加油站NVR
  IDS_96XX_NX_FA = 7504;    //人脸超脑智能NVR iDS-9632NX-I8/FA
  IDS_86XX_NX_IX_B = 7505;    //86系列安全帽检测NVR产品
  IDS_67XX_NX_S_X = 7506;    //人脸超脑智能安检产品NVR(IDS_67XX_NX/S_X)
  NP_ST204_X_ = 7507;    //第二代智能安检分析仪（NP_ST204_S:NP_ST204_D:NP_ST204_D_4G）
  NP_ST_ANJIAN = 7508;    //安检机

const
  IDS_ECDXX_HE = 8001;    //学生三目相机
  IDS_ECDXX_HT = 8002;    //教师三目相机

const
  IDS_ECDXX_E = 8101;    //4K半球

const
  IDS_EPTXX_HF = 8201;    //二代人脸抓拍机


const
  DS_2CD69XXX_I = 8351;    //3200W全景拼接IPC型号
  DS_TRIXX = 8471;    //超高频固定式读卡器DS_TRI900

const
  DS_K1F600_D6EXX = 10501;    //多功能采集仪
  DS_K1T341 = 10502;    //经销人脸门禁
  DS_K1T641XXX = 10503;    //中端通用人脸门禁
  DS_K1T642XXX = 10504;    //中端通用人脸门禁
  DS_K1T601 = 10505;    //酒店人脸产品
  DS_K1T672XXX = 10506;    //室内7寸超薄款人脸门禁产品
  DS_K56A0X = 10507;    //安卓中端人证
  DS_K56Q_F70 = 10508;    //低端人脸组件（经销型)
  DS_K1T6Q_F70M = 10509;    //F70系列人脸识别一体机（经销型)
  DS_K1T6Q_F40X = 10510;    //F40系列人脸识别一体机（经销型)
  DS_K5604A_XXX = 10511;    //中低端人脸组件
  DS_K1A330X = 10512;    //超低端人脸考勤机（经销型)
  DS_K1T804A = 10513;    //经济型指纹门禁一体机
  DS_K1T202 = 10514;    //经济型指纹门禁一体机
  DS_K1T343MX = 10515;    //人脸门禁一体机（经销型)
  DS_K1T331W_D = 10516;    //低端人脸门禁考勤一体机（DS-K1T331W(D)）
  DS_K1T671WX_D = 10517;    //人脸门禁一体机（DS-K1T671M(D) DS-K1T671MW(D) DS-K1T671MG(D)）
  DS_K1T680X = 10518;    //8.0寸室内外人脸门禁（DS-K1T680M DS-K1T680D）
  DS_K1T640A = 10519;    //智能门禁一体机（DS-K1T640AM DS-K1T640AMW）
  DS_K1F600U_D6E_X = 10520;    //多功能采集仪(DS-K1F600U-D6E DS-K1F600U-D6E-F DS-K1F600U-D6E-IF)
  DS_K1T671AMX = 10521;    //人脸门禁一体机(DS-K1T671AM DS-K1T671AMW DS-K1T671AM-5G)
  DS_VISITORXX = 10530;    //访客机
  DS_FACE_PAYMENT_TERMINALXX = 10531;    //人脸消费机
  DS_K1T341B_T = 10532;    //人脸门禁一体机,支持测温（DS-K1T341BMWI-T  DS-K1T341BMI-T）
  DS_K1T343 = 10533;    //F1Pro平台4.3寸人脸门禁一体机（经销）（DS-K1T343M/MX/MW/MWX/MF/MFX/MFW/MFWX/EX/EWX/EFX/EFWX,D10,D10W/F/FW）
  DS_K1T673 = 10534;    //F1Plus平台7寸人脸门禁一体机（行业）(DS_K1T673M/MG/MW/TMW/TMG/DX/DWX/TDX/TDWX/TDGX)
  DS_K1T981 = 10535;    //虹膜识别一体机
  DS_K5680X = 10536;    //K5680系列8寸桌面人证设备
  DS_K5022A_X = 10537;    //5022A系列安卓访客机
  DS_K1T342 = 10538;    //F1Pro平台4.3寸人脸门禁一体机（经销）（DS-K1T342M/MX/MW/MWX/MF/MFX/MFW/MFWX/EX/EWX/EFWX/DX/DWX,D11,D11S/Pro/Plus）
  DS_K1T690 = 10539;    //DS_K1T690
  DS_K1T340 = 10540;    //DS_K1T340
  DS_K1T6QT_F72 = 10541;    //F72系列人脸识别一体机（经销型)
  DS_K1T641A = 10542;    //F1Plus平台4.3寸人脸门禁一体机l，641系列
  DS_K1TACS = 10543;    //门禁产品大类值，用于ISAPI登录是在设备信息结构体的wDevType字段返回
  DS_K1T6_GS3 = 10544;    //行业人脸识别一体机DS-K1T6-GS3系列
  DS_K1T6Q_F41_3XF = 10545;    //经销人脸识别一体机DS_K1T6Q_F41_3XF系列
  DS_K56A1X = 10546;    //K56A1系列桌面人证设备
  DS_K1T320MFW = 10547;    //F2 Pro平台2.4寸超低端经销人脸门禁机一体机
  DS_K5033X = 10548;    //5033系列安卓桌面式访客机

const
  DS_K1T681X = 10550;    //A2S平台8寸人脸门禁一体机（DS-K1T681M 、DS-K1T681MW、 DS-K1T681MG、 DS-K1T681M-3D等）
  DS_K5670X = 10551;    //F2pro低端7寸工地明眸K5670系列
  DS_K1T670X = 10552;    //中端行业一体式测温DS-K1T670系列

//访客机10530，10601-10650
const
  DS_K3501 = 10601;    //经销访客机K3501系列
//消费机10531，10651-10700
const
  DS_K6600X = 10651;    //K6600系列商超收银机

//智能柜10701-10750
const
  DS_KL_CABINET = 10701;    //智能柜产品大类值，用于ISAPI登录是在设备信息结构体的wDevType字段返回

//梯控主机10751-10800

//人员通道10801-10850
const
  DS_K3B961 = 10801;    //人员通道产品大类值，用于ISAPI登录是在设备信息结构体的wDevType字段返回

const
  DS_KBS6XXX_WX = 11001;    //音箱DS-KBS6100-WV/DS-KBS6101-W/DS-KBS6100-W/DS-KBS6101-W/DS-KBS6200-W/DS-KBS6201-W
  DS_KBC6XXX_X = 11002;    //音柱DS-KBC6300/DS-KBC6600
  DS_KBI6000_P = 11003;    //寻呼话筒DS-KBI6000-P
  DS_KBA6XXX = 11004;    //功放设备(扩音器)DS-KBA6120/DS-KBA6240/DS-KBA6360/DS-KBA6650/DS-KBA6400-2/DS-KBA6800-2

const
  DS_IEXX_E_J = 11501;    //监所智能服务器

const
  IDS_67XX_NX_A = 12501;    //67系列NVS产品(iDS-6704NX/A)
  IDS_67XX_NX_L = 12502;    //67系列录播NVS产品
  IDS_ENIXX_XHE = 12503;    //录播NVS行业专业产品
  IDS_67XX_NX_V = 12504;    //超脑加油站NVS
  IDS_67XX_NX_B = 12505;    //67系列安全帽检测NVS产品

//智能中心类设备
const
  DS_IE63XX_E_FA = 13001;    //脸谱单机
  DS_DS_GPKIA = 13002;    //猎鹰服务器
  DS_DS_PURE = 13003;    //脸谱纯分析
  DS_DS_FS = 13004;    //人脸静态数据服务器
  DS_DS_FD = 13005;    //抓拍检测服务器
  DS_DS_BLADE = 13006;    //刀锋
  DS_DS_HMCP = 13007;    //模型对比服务器

//智能锁设备
const
  DS_LNX_RF = 13501;    //智能锁盒子

//雷达设备    13551-14000（500）
const
  DS_PA_RADAR = 13551;    //PA雷达
  DS_PERIMETER_RADAR = 13552;    //周界雷达
  DS_SECURITY_RADAR = 13553;    //120米安防雷达
  DS_IMAGING_RADAR_PANEL = 13554;    //成像雷达主机

//消防设备    14001-14500（500）
const
  DS_N1104X = 14001;    //消防网关
  DS_N1103X = 14002;    //用户信息传输设备
  NP_FSC201 = 14003;    //用水设备
  NP_FDC240 = 14004;    //组合式电气火灾探测器
  DS_N1107 = 14005;    //物联网网关
  NP_FAXXX = 14006;    //消防分析仪
  NP_FVY100 = 14007;    //视频烟感
  NP_FVW100 = 14008;    //安消智能相机
  NP_FVG100 = 14009;    //安消联动相机
  NP_FVY300 = 14010;    //经济型视频烟感
  NP_FVR212_P = 14011;    //三合一火灾探测器
  NP_FVR213_P = 14012;    //三合一火灾探测器(自研)

//安检设备 14501-15000（500）
const
  NP_ST204_X = 14501;    //第二代智能安检分析仪
  ISD_SG2XXL_X = 14502;    //安检门(ISD-SG206L ISD-SG218L ISD-SG218L-F)
  ISD_SL300T = 14503;    //液体分析仪

//模拟和音频设备 15001-15500（500）
const
  IPA = 15001;    
//*********************设备类型 end**********************
//*********************设备大类 begin*********************

// dvr相关 1-50 
const
  DEV_CLASS_DVR = 1;    //普通dvr类型
  DEV_CLASS_INTERROGATION = 2;    //审讯机
  DEV_CLASS_SIMPLE_TRAIL = 3;    //简易庭审主机
  DEV_CLASS_TRAIL = 4;    //标准庭审主机
  DEV_CLASS_RECORD_PLAY = 5;    //录播主机
  DEV_CLASS_ATM = 6;    //ATM机

// dvs相关 51-100 
const
  DEV_CLASS_DVS = 51;    //普通dvs

// nvr相关 101-150 
const
  DEV_CLASS_NVR = 101;    //普通nvr

// ipc相关 151-200 
const
  DEV_CLASS_GUN = 151;    //ipc枪机
  DEV_CLASS_BALL = 152;    //ipc球机
  DEV_CLASS_SNAP = 153;    //抓拍机
  DEV_CLASS_INTELLI_TILT = 154;    //智能云台
  DEV_CLASS_FISH_EYE = 155;    //鱼眼
  DEV_CLASS_2DP_Z = 156;    //大鹰眼
  DEV_CLASS_2DP = 157;    //小鹰眼
  DEV_CLASS_PT = 158;    //全景细节相机
  DEV_CLASS_TRI = 159;    //超高频固定式读卡器

// CVR相关 201 - 250
const
  DEV_CLASS_CVR = 201;    //CVR

// 传显相关 251 - 300
const
  DEV_CLASS_B20 = 251;    //传显B20系列
  DEV_CLASS_B10 = 252;    //传显B10系列
  DEV_CLASS_DECODER = 253;    //解码器
  DEV_CLASS_MATRIXMANAGEDEVICE = 254;    //矩阵接入网关
  DEV_CLASS_OTICAL = 255;    //光端机
  DEV_CLASS_CODESPITTER = 256;    //码分器
  DEV_CLASS_ALARMHOST = 257;    //行业报警主机
  DEV_CLASS_MOVING_RING = 258;    //动环设备
  DEV_CLASS_CVCS = 259;    //集中式多屏控制器
  DEV_CLASS_DVCS = 260;    //分布式多屏控制器
  DEV_CLASS_TRANSCODER = 261;    //转码器
  DEV_CLASS_LCD_SCREEN = 262;    //LCD屏幕
  DEV_CLASS_LED_SCREEN = 263;    //LED屏幕
  DEV_CLASS_MATRIX = 264;    //矩阵
  DEV_CLASS_CONFERENCE_SYSTEM = 265;    //视频会议设备
  DEV_CLASS_INFORMATION_RELEASE_EQUIPMENT = 266;    //信息发布设备
  DEV_CLASS_NET_GAP = 267;    //网闸
  DEV_CLASS_MERGE = 268;    //合码器
  DEV_CLASS_REAR_PROJECTION = 269;    //背投显示设备
  DEV_CLASS_SWITCH = 270;    //交换机
  DEV_CLASS_FIBER_CONVERTER = 271;    //光纤收发器
  DEV_CLASS_SCREEN_SERVER = 272;    //屏幕服务器
  DEV_CLASS_SCE_SERVER = 273;    //抓屏服务器
  DEV_CLASS_WIRELESS_TRANS = 274;    //无线传输设备
  DEV_CLASS_Y10_SERIES = 275;    //Y10系列
  DEV_CLASS_SAFETY_MAVHINE = 276;    //安监一体机
  DEV_CLASS_IOTGATEWAY = 277;    //物联网关类
  DEV_CLASS_NET_MANAGEMENT_EQUIPMENT = 278;    //网络设备管理类
  DEV_CLASS_PUBLISH_SIGNAGE = 279;    //电子班牌
  DEV_CLASS_AR_MACHINE = 280;    //AR一体机
// 报警主机相关 301 - 350
const
  DEV_CLASS_VIDEO_ALARM_HOST = 301;    //视频报警主机
  DEV_CLASS_NET_ALARM_HOST = 302;    //网络报警主机
  DEV_CLASS_ONE_KEY_ALARM = 303;    //一键式报警产品
  DEV_CLASS_WIRELESS_ALARM_HOST = 304;    //无线报警主机
  DEV_CLASS_ALARM_MODULE = 305;    //报警模块
  DEV_CLASS_HOME_ALARM_HOST = 306;    //家用报警主机
  DEV_CLASS_HYBRID_ALARM_HOST = 307;    //混合报警主机
  DEV_CLASS_NETWORK_RECEIVER = 308;    //网络接警机产品

// 门禁相关 351 - 400
const
  DEV_CLASS_ACCESS_CONTROL = 351;    //门禁产品
  DEV_CLASS_VISITOR = 352;    //访客机产品
  DEV_CLASS_FACE_PAYMENT_TERMINALXX = 353;    //人脸消费机产品
  DEV_CLASS_CABINET = 354;    //智能柜
  DEV_CLASS_LADDER_CONTROL = 355;    //梯控主机
  DEV_CLASS_PERSONNEL_CHANNEL = 356;    //人员通道

// 可视对讲 401 - 450
const
  DEV_CLASS_VIDEO_INTERCOM = 401;    //可视对讲

// 无人机 451 - 500
const
  DEV_CLASS_UMMANNED_AERIAL_VEHICLE = 451;    //无人机产品

// 移动产品: 501-550
const
  DEV_CLASS_MOBILE = 501;    //移动产品

// 移动车载设备: 551-600
const
  DEV_CLASS_MOBILE_VEHICLE = 551;    //移动车载设备

//智能分析仪：601-650
const
  DEV_CLASS_INTELLIGENT_ANALYZER = 601;    //智能分析仪

//智能交通服务器：651-700
const
  DEV_CLASS_INTELLIGENT_TRAFFIC_SERVER = 651;    //智能交通服务器
  DS_TP2200_EC = 652;    //经济型机柜显示仪

// nvs相关 701-750 
const
  DEV_CLASS_NVS = 701;    //普通nvs

//有源RFID系列 751-800
const
  DS_TRI21A_1_P = 751;    //有源RFID读取器

// 数据中心设备801-850 
const
  DS_CLASS_FA = 801;    //脸谱单机
  DS_CLASS_PURE = 802;    //脸谱纯分析
  DS_CLASS_FS = 803;    //人脸静态数据服务器
  DS_CLASS_FD = 804;    //抓拍检测服务器
  DS_CLASS_HAWK = 805;    //猎鹰服务器
  DS_CLASS_BLADE = 806;    //刀锋
  DS_CLASS_HMCP = 807;    //模型对比服务器

// 智能锁相关 851 - 900
const
  DEV_CLASS_SMART_LOCK = 851;    //智能锁盒子

// 雷达相关 901 - 950
const
  DEV_CLASS_RADAR = 901;    //雷达产品

// 智慧消防相关 951 - 1000
const
  DEV_CLASS_FIRE_CONTROL = 951;    //消防产品

// 安检相关 1001 - 1050
const
  DEV_CLASS_SECURITY_CHECK = 1001;    //安检产品

const
  DEV_CLASS_CONFERENCE_TABLET = 1051;    //会议平板

const
  DEV_CLASS_JUDICIAL_TABLET = 1101;    //司法平板

//全景细节相机： 8451-8470
const
  iDS_PT = 8451;    //全景细节相机

//网络接警机产品 9851 - 9900
const
  DS_XCM1_IP = 9851;    //网络接警机

// 其他设备类型 65534 
const
  DEV_CLASS_DEFAULT = 65534;    //默认设备类型
//*********************设备大类 end*********************

//*****************************能力集获取********************************
//能力获取命令
const
  DEVICE_SOFTHARDWARE_ABILITY = $001;    //设备软硬件能力
  DEVICE_NETWORK_ABILITY = $002;    //设备网络能力
  DEVICE_ENCODE_ALL_ABILITY = $003;    //设备所有编码能力
  DEVICE_ENCODE_CURRENT = $004;    //设备当前编码能力
  IPC_FRONT_PARAMETER = $005;    //ipc前端参数1.0
  IPC_UPGRADE_DESCRIPTION = $006;    //ipc升级信息
  DEVICE_RAID_ABILITY = $007;    //RAID能力
  DEVICE_ENCODE_ALL_ABILITY_V20 = $008;    //设备所有编码能力2.0
  IPC_FRONT_PARAMETER_V20 = $009;    //ipc前端参数2.0
  DEVICE_ALARM_ABILITY = $00a;    //辅助报警能力
  DEVICE_DYNCHAN_ABILITY = $00b;    //设备数字通道能力
  DEVICE_USER_ABILITY = $00c;    //设备用户管理参数能力
  DEVICE_NETAPP_ABILITY = $00d;    //设备网络应用参数能力
  DEVICE_VIDEOPIC_ABILITY = $00e;    //设备图像参数能力
  DEVICE_JPEG_CAP_ABILITY = $00f;    //设备JPEG抓图能力
  DEVICE_SERIAL_ABILITY = $010;    //RS232和RS485串口能力
  DEVICE_ABILITY_INFO = $011;    //设备通用能力类型，具体能力根据发送的能力节点来区分
  STREAM_ABILITY = $012;    //流能力
  SYSTEM_MANAGEMENT_ABILITY = $013;    //设备系统管理能力
  IP_VIEW_DEV_ABILITY = $014;    //IP可视对讲分机能力
  VCA_DEV_ABILITY = $100;    //设备智能分析的总能力
  VCA_CHAN_ABILITY = $110;    //异常行为检测能力
  TRANSFER_ABILITY = $120;    
  MATRIXDECODER_ABILITY = $200;    //多路解码器显示、解码能力
  VIDEOPLATFORM_ABILITY = $210;    //视频综合平台能力集
  VIDEOPLATFORM_SBUCODESYSTEM_ABILITY = $211;    //视频综合平台编码子系统能力集
  WALL_ABILITY = $212;    //电视墙能力集
  MATRIX_ABILITY = $213;    //SDI矩阵能力
  DECODECARD_ABILITY = $220;    //解码卡服务器能力集
  VIDEOPLATFORM_ABILITY_V40 = $230;    //视频综合平台能力集
  MATRIXMANAGEDEVICE_ABILITY = $240;    //矩阵接入网关能力集
  MATRIXDECODER_ABILITY_V41 = $260;    //解码器能力集
  DECODER_ABILITY = $261;    //解码器xml能力集
  DECODECARD_ABILITY_V41 = $270;    //解码卡服务器能力集V41
  CODECARD_ABILITY = $271;    //编码卡能力集
  SNAPCAMERA_ABILITY = $300;    //抓拍机能力集
  ITC_TRIGGER_MODE_ABILITY = $301;    //智能IPC设备的触发模式能力
  COMPRESSIONCFG_ABILITY = $400;    //获取压缩参数能力集合
  COMPRESSION_LIMIT = $401;    //获取主子码流压缩参数能力限制
  PIC_CAPTURE_ABILITY = $402;    //获图片分辨率能力集合
  ALARMHOST_ABILITY = $500;    //网络报警主机能力集
  IT_DEVICE_ABILITY = $501;    //智能交通能力集
  SCREENCONTROL_ABILITY = $600;    //大屏控制器能力集
  SCREENSERVER_ABILITY = $610;    //大屏服务器能力集
  FISHEYE_ABILITY = $700;    //鱼眼能力集
  LCD_SCREEN_ABILITY = $800;    //LCD屏幕能力 2013-10-12
  ACS_ABILITY = $801;    //门禁能力
  MERGEDEV_ABILITY = $802;    //合码器能力集
  CAM_FUSION_ABILITY = $803;    //相机拼接能力
  OPTICAL_DEV_ACCESS_ABILITY = $805;    //光端机接入能力
  NET_RING_ABILITY = $806;    //环网能力集
  LED_ABILITY = $807;    //LED屏能力集
  PUBLISHDEV_ABILITY = $80a;    //信息发布能力
  SCREEN_EXCHANGE_ABILITY = $80b;    //屏幕互动能力
  REMOTE_NETMGR_FOT_ABILITY = $80e;    //远端网管收发器能力
{************************************************
参数配置结构、参数(其中_V30为9000新增)
*************************************************}

//子板异常信息
//主类型
const
  EXCEPTION_MAJOR_MAINBOARD_BOOT = $1;    //主板启动类型
//次类型
const
  EXCEPTION_MINOR_PCIE_SCAN = $1;    // pcie链路扫描异常
  EXCEPTION_MINOR_DOWNLOAD_SUBBOARD = $a;    //下载子板完成异常

//主类型
const
  EXCEPTION_MAJOR_SUBBOARD_BOOT = $2;    //子板启动类型
//次类型
const
  EXCEPTION_MINOR_INEXISTENCE = $1;    //PCI-E扫不到或当前子板不存在
  EXCEPTION_MINOR_UBOOT_DOWNLOAD = $a;    // uboot下载异常
  EXCEPTION_MINOR_UBOOT_INIT = $e;    //uboot初始化异常
  EXCEPTION_MINOR_ROOTFS_DOWNLOAD = $14;    //rootfs.img下载异常
  EXCEPTION_MINOR_UIMAGE_DOWNLOAD = $19;    //uImage下载异常
  EXCEPTION_MINOR_UBOOT_SETBOOTFLAG = $1e;    // uboot启动标志位置位异常
  EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD = $23;    // rootfs启动异常
  EXCEPTION_MINOR_NEED_FILE_FINISH = $28;    //子板所需文件传输异常

//主类型
const
  EXCEPTION_MAJOR_SUBBOARD_HARDWARE = $3;    //子板硬件类型
//次类型
const
  EXCEPTION_MINOR_AD = $1;    //AD异常
  EXCEPTION_MINOR_DA = $a;    // DA异常
  EXCEPTION_MINOR_TIMER = $b;    //时钟异常

//主类型
const
  EXCEPTION_MAJOR_FPGA = $4;    //FPGA类型
//次类型
const
  EXCEPTION_MINOR_IDLE = $1;    //无法IDLE
  EXCEPTION_MINOR_LANE = $a;    // LANE OK失败
  EXCEPTION_MINOR_REGISTER_ALL_F = $e;    //FPGA寄存器全F
  EXCEPTION_MINOR_MEMORY_INIT_FAIL = $14;    //FPGA内存初始化失败
//主类型
const
  EXCEPTION_MAJOR_DSP = $5;    //DSP类型

//主类型
const
  EXCEPTION_MAJOR_ARM = $6;    //ARM类型

//主类型
const
  EXCEPTION_MAJOR_BACKBOARD = $7;    //背板类型
//次类型
const
  EXCEPTION_MINOR_BACKBOARD_TYPE = $1;    //获取背板类型异常
  EXCEPTION_MINOR_SERDES = $a;    //视频交换芯片
  EXCEPTION_MINOR_CLOCK = $e;    //时钟故障
  EXCEPTION_MINOR_SYNCH = $14;    //同步信号故障

//主类型
const
  EXCEPTION_MAJOR_SUBBOARD_NET = $8;    //子板网络
//次类型
const
  EXCEPTION_MINOR_IP_CONFLICT = $1;    //IP冲突
  EXCEPTION_MINOR_DISCONNECT = $14;    // 断网

//[add]by zengxiaole 2017-09-27 DS-19D2000-S v2.0
const
  MAX_FIRE_ALARM_ZONE = 12;    //最大消防主机报警分区个数
  MAX_FIRE_ALARM_POINT_ZONE = 32;    //最大消防主机报警火点个数


type
  CHAR_ENCODE_TYPE =  
  (  
    ENUM_MEM_CHAR_ENCODE_ERR = -1,  //Error
    ENUM_MEM_CHAR_ENCODE_NO = 0,  //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN = 1,  //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK = 2,  //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,  //BIG5
    ENUM_MEM_CHAR_ENCODE_JP = 4,  //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR = 5,  //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,  //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1 = 7,  //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
    ENUM_MEM_CHAR_ENCODE_UNICODE = 8  //Unicode
  );


/////////////////////////////////////////////////////////////////////////
//校时结构参数
type
  NET_DVR_TIME = record 
    dwYear: DWORD;  //年
    dwMonth: DWORD;  //月
    dwDay: DWORD;  //日
    dwHour: DWORD;  //时
    dwMinute: DWORD;  //分
    dwSecond: DWORD;  //秒
  end;
  LPNET_DVR_TIME = ^NET_DVR_TIME;

type
  NET_DVR_TIME_V30 = record 
    wYear: WORD;  
    byMonth: BYTE;  
    byDay: BYTE;  
    byHour: BYTE;  
    byMinute: BYTE;  
    bySecond: BYTE;  
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    wMilliSec: WORD;  //毫秒，精度不够，默认为0
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45，+表示东区，byISO8601为1时有效
  end;
  LPNET_DVR_TIME_V30 = ^NET_DVR_TIME_V30;

type
  NET_DVR_TIME_SEARCH = record 
    wYear: WORD;  //年，设备OSD时间
    byMonth: BYTE;  //月，设备OSD时间
    byDay: BYTE;  //日，设备OSD时间
    byHour: BYTE;  //时，设备OSD时间
    byMinute: BYTE;  //分，设备OSD时间
    bySecond: BYTE;  //秒，设备OSD时间
    cTimeDifferenceH: AnsiChar;  //与国际标准时间的时差（小时），-12 ... +14
    cTimeDifferenceM: AnsiChar;  //与国际标准时间的时差（分钟），-30, 0, 30, 45
    byLocalOrUTC: BYTE;  //0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
    wMillisecond: WORD;  //毫秒，精度不够，默认为0
  end;
  LPNET_DVR_TIME_SEARCH = ^NET_DVR_TIME_SEARCH;

type
  NET_DVR_TIME_SEARCH_COND = record 
    wYear: WORD;  //年
    byMonth: BYTE;  //月
    byDay: BYTE;  //日
    byHour: BYTE;  //时
    byMinute: BYTE;  //分
    bySecond: BYTE;  //秒
    byLocalOrUTC: BYTE;  //0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
    wMillisecond: WORD;  //毫秒，精度不够，默认为0
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14，+表示东区，byLocalOrUTC为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byLocalOrUTC为1时有效
  end;
  LPNET_DVR_TIME_SEARCH_COND = ^NET_DVR_TIME_SEARCH_COND;


type
  NET_DVR_TIME_V50 = record 
    wYear: WORD;  //年
    byMonth: BYTE;  //月
    byDay: BYTE;  //日
    byHour: BYTE;  //时
    byMinute: BYTE;  //分
    bySecond: BYTE;  //秒
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    wMillisecond: WORD;  //毫秒，精度不够，默认为0
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14，+表示东区，byISO8601为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byISO8601为1时有效
  end;
  LPNET_DVR_TIME_V50 = ^NET_DVR_TIME_V50;



type
  NET_DVR_CALIBRATE_TIME = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME;  
    wMilliSec: WORD;  
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_CALIBRATE_TIME = ^NET_DVR_CALIBRATE_TIME;

const
  MAX_TIMESIGN_LEN = 32;    //自定义校时标记信息长度
type
  NET_DVR_TIMESIGN_CFG = record 
    dwSize: DWORD;  
    byCustomSetTimeSign: array[0..MAX_TIMESIGN_LEN{32}-1] of BYTE;  //自定义校时标记
    byRes: array[0..96-1] of BYTE;  
  end;
  LPNET_DVR_TIMESIGN_CFG = ^NET_DVR_TIMESIGN_CFG;


type
  NET_DVR_TIME_EX = record 
    wYear: WORD;  
    byMonth: BYTE;  
    byDay: BYTE;  
    byHour: BYTE;  
    byMinute: BYTE;  
    bySecond: BYTE;  
    byRes: BYTE;  
  end;
  LPNET_DVR_TIME_EX = ^NET_DVR_TIME_EX;

//时间段(子结构)
type
  NET_DVR_SCHEDTIME = record 

    //开始时间
    byStartHour: BYTE;  
    byStartMin: BYTE;  
    //结束时间
    byStopHour: BYTE;  
    byStopMin: BYTE;  
  end;
  LPNET_DVR_SCHEDTIME = ^NET_DVR_SCHEDTIME;

//设备报警和异常处理方式
//设备报警和异常处理方式
const
  NOACTION = $0;    //无响应
  WARNONMONITOR = $1;    //显示器上警告
  WARNONAUDIOOUT = $2;    //声音警告
  UPTOCENTER = $4;    //上传中心
  TRIGGERALARMOUT = $8;    //触发报警输出
  TRIGGERCATPIC = $10;    //触发抓图并上传E-mail
  SEND_PIC_FTP = $200;    //抓图并上传ftp

type
  NET_DVR_STRUCTHEAD = record 
    wLength: WORD;  //结构长度
    byVersion: BYTE;  //高低4位分别代表高低版本，后续根据版本和长度进行扩展，不同的版本的长度进行限制
    byRes: BYTE;  
  end;
  LPNET_DVR_STRUCTHEAD = ^NET_DVR_STRUCTHEAD;

type
  NET_DVR_HANDLEEXCEPTION_V41 = record 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0
    //0x800: PTZ联动(球机目标)
    //0x4000:白光灯报警
    //0x10000:短信报警
    //0x20000:指示灯报警
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40-1] of DWORD;  //触发报警通道
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_HANDLEEXCEPTION_V41 = ^NET_DVR_HANDLEEXCEPTION_V41;

type
  NET_DVR_HANDLEEXCEPTION_V40 = record 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x80: 报警触发录像(目前只有PCNVR支持) 
    //0x100: 报警触发云台预置点 (目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0
    //0x800: PTZ联动(球机目标)
    //0x1000:抓图上传到云
    //0x2000:短信报警
    //0x4000:白光灯报警
    //0x8000:语音报警
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数 实际支持数
    dwRelAlarmOut: array[0..MAX_CHANNUM_V30-1] of DWORD;  //触发报警通道
    byWhiteLightDurationTime: BYTE;  //白光灯闪烁持续时长，1~60s(当开启了白光灯报警时生效)
    byBrightness: BYTE;  //白光灯亮度，范围0-100，默认50
    byAudioType: BYTE;  //声音报警类型
    byTimes: BYTE;  //声音报警次数，范围：0-9，默认2, 0xff-持续
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_HANDLEEXCEPTION_V40 = ^NET_DVR_HANDLEEXCEPTION_V40;

//报警和异常处理结构(子结构)(多处使用)(9000扩展)
type
  NET_DVR_HANDLEEXCEPTION_V30 = record 
    dwHandleType: DWORD;  //处理方式,处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x2000:短信报警
    byRelAlarmOut: array[0..MAX_ALARMOUT_V30-1] of BYTE;  
    //报警触发的输出通道,报警触发的输出,为1表示触发该输出
  end;
  LPNET_DVR_HANDLEEXCEPTION_V30 = ^NET_DVR_HANDLEEXCEPTION_V30;

//报警和异常处理结构(子结构)(多处使用)
type
  NET_DVR_HANDLEEXCEPTION = record 
    dwHandleType: DWORD;  //处理方式,处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: Jpeg抓图并上传EMail
    byRelAlarmOut: array[0..MAX_ALARMOUT-1] of BYTE;  //报警触发的输出通道,报警触发的输出,为1表示触发该输出
  end;
  LPNET_DVR_HANDLEEXCEPTION = ^NET_DVR_HANDLEEXCEPTION;

//DVR设备参数
type
  NET_DVR_DEVICECFG = record 
    dwSize: DWORD;  
    sDVRName: array[0..NAME_LEN-1] of BYTE;  //DVR名称
    dwDVRID: DWORD;  //DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
    dwRecycleRecord: DWORD;  //是否循环录像,0:不是; 1:是
    //以下不可更改
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    dwSoftwareVersion: DWORD;  //软件版本号,高16位是主版本,低16位是次版本
    dwSoftwareBuildDate: DWORD;  //软件生成日期,0xYYYYMMDD
    dwDSPSoftwareVersion: DWORD;  //DSP软件版本,高16位是主版本,低16位是次版本
    dwDSPSoftwareBuildDate: DWORD;  // DSP软件生成日期,0xYYYYMMDD
    dwPanelVersion: DWORD;  // 前面板版本,高16位是主版本,低16位是次版本
    dwHardwareVersion: DWORD;  // 硬件版本,高16位是主版本,低16位是次版本
    byAlarmInPortNum: BYTE;  //DVR报警输入个数
    byAlarmOutPortNum: BYTE;  //DVR报警输出个数
    byRS232Num: BYTE;  //DVR 232串口个数
    byRS485Num: BYTE;  //DVR 485串口个数
    byNetworkPortNum: BYTE;  //网络口个数
    byDiskCtrlNum: BYTE;  //DVR 硬盘控制器个数
    byDiskNum: BYTE;  //DVR 硬盘个数
    byDVRType: BYTE;  //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    byChanNum: BYTE;  //DVR 通道个数
    byStartChan: BYTE;  //起始通道号,例如DVS-1,DVR - 1
    byDecordChans: BYTE;  //DVR 解码路数
    byVGANum: BYTE;  //VGA口的个数
    byUSBNum: BYTE;  //USB口的个数
    byAuxoutNum: BYTE;  //辅口的个数
    byAudioNum: BYTE;  //语音口的个数
    byIPChanNum: BYTE;  //最大数字通道数
  end;
  LPNET_DVR_DEVICECFG = ^NET_DVR_DEVICECFG;

{
IP地址
}
type
  NET_DVR_IPADDR = record 
    sIpV4: array[0..16-1] of AnsiChar;  // IPv4地址 
    byIPv6: array[0..128-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPADDR = ^NET_DVR_IPADDR;

type
  NET_DVR_IPADDR_UNION = record 
    case Byte of
    0: (szIPv4: array[0..16-1] of AnsiChar);  //IPv4地址
    1: (szIPv6: array[0..256-1] of AnsiChar);  //IPv6地址
  end;
  LPNET_DVR_IPADDR_UNION = ^NET_DVR_IPADDR_UNION;

type
  NET_DVR_ADDRESS = record 
    struIP: NET_DVR_IPADDR;  //IP地址
    wPort: WORD;  //端口号
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_ADDRESS = ^NET_DVR_ADDRESS;

{
网络数据结构(子结构)(9000扩展)
}
type
  NET_DVR_ETHERNET_V30 = record 
    struDVRIP: NET_DVR_IPADDR;  //DVR IP地址
    struDVRIPMask: NET_DVR_IPADDR;  //DVR IP地址掩码
    dwNetInterface: DWORD;  //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
    wDVRPort: WORD;  //端口号
    wMTU: WORD;  //增加MTU设置，默认1500。
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址
    byEthernetPortNo: BYTE;  //网口号，0-无效，1-网口0，2-网口1以此类推，只读
    byRes: array[0..1-1] of BYTE;  //保留
  end;
  LPNET_DVR_ETHERNET_V30 = ^NET_DVR_ETHERNET_V30;

{
网络数据结构(子结构)
}
type
  NET_DVR_ETHERNET = record 
    sDVRIP: array[0..16-1] of AnsiChar;  //DVR IP地址
    sDVRIPMask: array[0..16-1] of AnsiChar;  //DVR IP地址掩码
    dwNetInterface: DWORD;  //网络接口 1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
    wDVRPort: WORD;  //端口号
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //服务器的物理地址
  end;
  LPNET_DVR_ETHERNET = ^NET_DVR_ETHERNET;

//pppoe结构
type
  NET_DVR_PPPOECFG = record 
    dwPPPOE: DWORD;  //0-不启用,1-启用
    sPPPoEUser: array[0..NAME_LEN-1] of BYTE;  //PPPoE用户名
    sPPPoEPassword: array[0..PASSWD_LEN-1] of AnsiChar;  // PPPoE密码
    struPPPoEIP: NET_DVR_IPADDR;  //PPPoE IP地址
  end;
  LPNET_DVR_PPPOECFG = ^NET_DVR_PPPOECFG;

//网络配置结构(9000扩展)
type
  NET_DVR_NETCFG_V30 = record 
    dwSize: DWORD;  
    struEtherNet: array[0..MAX_ETHERNET-1] of NET_DVR_ETHERNET_V30;  //以太网口
    struRes1: array[0..2-1] of NET_DVR_IPADDR;  //保留
    struAlarmHostIpAddr: NET_DVR_IPADDR;  // 报警主机IP地址 
    byRes2: array[0..4-1] of BYTE;  // 保留 
    wAlarmHostIpPort: WORD;  // 报警主机端口号 
    byUseDhcp: BYTE;  // 是否启用DHCP 0xff-无效 0-不启用 1-启用
    byIPv6Mode: BYTE;  //IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
    struDnsServer1IpAddr: NET_DVR_IPADDR;  // 域名服务器1的IP地址 
    struDnsServer2IpAddr: NET_DVR_IPADDR;  // 域名服务器2的IP地址 
    byIpResolver: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // IP解析服务器域名或IP地址 
    wIpResolverPort: WORD;  // IP解析服务器端口号 
    wHttpPortNo: WORD;  // HTTP端口号 
    struMulticastIpAddr: NET_DVR_IPADDR;  // 多播组地址 
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    struPPPoE: NET_DVR_PPPOECFG;  
    byEnablePrivateMulticastDiscovery: BYTE;  //私有多播搜索，0~默认，1~启用，2-禁用
    byEnableOnvifMulticastDiscovery: BYTE;  //Onvif多播搜索，0~默认，1~启用，2-禁用
    byEnableDNS: BYTE;  //DNS自动使能, 0-保留，1-打开，2-关闭
    byRes: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_NETCFG_V30 = ^NET_DVR_NETCFG_V30;

//多网卡配置网卡结构
type
  NET_DVR_ETHERNET_MULTI = record 
    struDVRIP: NET_DVR_IPADDR;  //DVR IP地址
    struDVRIPMask: NET_DVR_IPADDR;  //DVR IP地址掩码
    dwNetInterface: DWORD;  //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M/1000M自适应
    byCardType: BYTE;  //网卡类型，0-普通网卡，1-内网网卡，2-外网网卡
    byEnableDNS: BYTE;  //DNS是否自动使能，0-保留，1-打开, 0-关闭
    wMTU: WORD;  //增加MTU设置，默认1500。
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理地址，只用于显示
    byEthernetPortNo: BYTE;  //网口号，0-无效，1-网口0，2-网口1以此类推，只读
    bySilkScreen: BYTE;  //丝印信息，0-无效，1-GE1，2-GE2，3-G1，4-G2，只读
    byUseDhcp: BYTE;  // 是否启用DHCP 
    byRes3: array[0..3-1] of BYTE;  
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    struDnsServer1IpAddr: NET_DVR_IPADDR;  // 域名服务器1的IP地址 
    struDnsServer2IpAddr: NET_DVR_IPADDR;  // 域名服务器2的IP地址 
  end;
  LPNET_DVR_ETHERNET_MULTI = ^NET_DVR_ETHERNET_MULTI;

//多网卡网络配置结构
type
  NET_DVR_NETCFG_MULTI = record 
    dwSize: DWORD;  
    byDefaultRoute: BYTE;  //默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
    byNetworkCardNum: BYTE;  //设备实际可配置的网卡数目
    byWorkMode: BYTE;  //0-普通多网卡模式，1-内外网隔离模式
    byRes: BYTE;  //保留
    struEtherNet: array[0..MAX_NETWORK_CARD-1] of NET_DVR_ETHERNET_MULTI;  //以太网口
    struManageHost1IpAddr: NET_DVR_IPADDR;  // 主管理主机IP地址 
    struManageHost2IpAddr: NET_DVR_IPADDR;  // 辅管理主机IP地址 
    struAlarmHostIpAddr: NET_DVR_IPADDR;  // 报警主机IP地址 
    wManageHost1Port: WORD;  // 主管理主机端口号 
    wManageHost2Port: WORD;  // 辅管理主机端口号 
    wAlarmHostIpPort: WORD;  // 报警主机端口号 
    byIpResolver: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // IP解析服务器域名或IP地址 
    wIpResolverPort: WORD;  // IP解析服务器端口号 
    wDvrPort: WORD;  //通讯端口 默认8000
    wHttpPortNo: WORD;  // HTTP端口号 
    wDvrPort2: WORD;  //通讯端口2
    byRes2: array[0..4-1] of BYTE;  
    struMulticastIpAddr: NET_DVR_IPADDR;  // 多播组地址 
    struPPPoE: NET_DVR_PPPOECFG;  
    byRes3: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_NETCFG_MULTI = ^NET_DVR_NETCFG_MULTI;

//网络配置结构
type
  NET_DVR_NETCFG = record 
    dwSize: DWORD;  
    struEtherNet: array[0..MAX_ETHERNET-1] of NET_DVR_ETHERNET;  // 以太网口 
    sManageHostIP: array[0..16-1] of AnsiChar;  //远程管理主机地址
    wManageHostPort: WORD;  //远程管理主机端口号
    sIPServerIP: array[0..16-1] of AnsiChar;  //IPServer服务器地址
    sMultiCastIP: array[0..16-1] of AnsiChar;  //多播组地址
    sGatewayIP: array[0..16-1] of AnsiChar;  //网关地址
    sNFSIP: array[0..16-1] of AnsiChar;  //NFS主机IP地址
    sNFSDirectory: array[0..PATHNAME_LEN-1] of BYTE;  //NFS目录
    dwPPPOE: DWORD;  //0-不启用,1-启用
    sPPPoEUser: array[0..NAME_LEN-1] of BYTE;  //PPPoE用户名
    sPPPoEPassword: array[0..PASSWD_LEN-1] of AnsiChar;  // PPPoE密码
    sPPPoEIP: array[0..16-1] of AnsiChar;  //PPPoE IP地址(只读)
    wHttpPort: WORD;  //HTTP端口号
  end;
  LPNET_DVR_NETCFG = ^NET_DVR_NETCFG;

//网络配置结构(V50)
type
  NET_DVR_NETCFG_V50 = record 
    dwSize: DWORD;  
    struEtherNet: array[0..MAX_ETHERNET-1] of NET_DVR_ETHERNET_V30;  //以太网口
    struRes1: array[0..2-1] of NET_DVR_IPADDR;  //保留
    struAlarmHostIpAddr: NET_DVR_IPADDR;  // 报警主机IP地址 
    byRes2: array[0..4-1] of BYTE;  // 保留 
    wAlarmHostIpPort: WORD;  // 报警主机端口号 
    byUseDhcp: BYTE;  // 是否启用DHCP 0xff-无效 0-不启用 1-启用
    byIPv6Mode: BYTE;  //IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
    struDnsServer1IpAddr: NET_DVR_IPADDR;  // 域名服务器1的IP地址 
    struDnsServer2IpAddr: NET_DVR_IPADDR;  // 域名服务器2的IP地址 
    byIpResolver: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // IP解析服务器域名或IP地址 
    wIpResolverPort: WORD;  // IP解析服务器端口号 
    wHttpPortNo: WORD;  // HTTP端口号 
    struMulticastIpAddr: NET_DVR_IPADDR;  // 多播组地址 
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    struPPPoE: NET_DVR_PPPOECFG;  
    byEnablePrivateMulticastDiscovery: BYTE;  //私有多播搜索，0~默认，1~启用，2-禁用
    byEnableOnvifMulticastDiscovery: BYTE;  //Onvif多播搜索，0~默认，1~启用，2-禁用
    wAlarmHost2IpPort: WORD;  // 报警主机2端口号 
    struAlarmHost2IpAddr: NET_DVR_IPADDR;  // 报警主机2 IP地址 
    byEnableDNS: BYTE;  //DNS使能, 0-关闭，1-打开
    byRes: array[0..599-1] of BYTE;  
  end;
  LPNET_DVR_NETCFG_V50 = ^NET_DVR_NETCFG_V50;

//sip配置
type
  NET_DVR_SIP_CFG = record 
    dwSize: DWORD;  
    byEnableAutoLogin: BYTE;  //使能自动注册，0-不使能，1-使能
    byLoginStatus: BYTE;  //注册状态，0-未注册，1-已注册，此参数只能获取
    byRes1: array[0..2-1] of BYTE;  
    stuServerIP: NET_DVR_IPADDR;  //SIP服务器IP
    wServerPort: WORD;  //SIP服务器端口
    byRes2: array[0..2-1] of BYTE;  
    byUserName: array[0..NAME_LEN-1] of BYTE;  //注册用户名
    byPassWord: array[0..PASSWD_LEN-1] of BYTE;  //注册密码
    byLocalNo: array[0..MAX_NUMBER_LEN-1] of BYTE;  
    byDispalyName: array[0..MAX_NAME_LEN-1] of BYTE;  //设备显示名称
    wLocalPort: WORD;  //本地端口
    byLoginCycle: BYTE;  //注册周期，1-99分钟
    byType: BYTE;  //0-IP/IPV6,1-域名
    byDomainName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //域名
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SIP_CFG = ^NET_DVR_SIP_CFG;

type
  NET_DVR_SIP_CFG_V50 = record 
    dwSize: DWORD;  
    byEnableAutoLogin: BYTE;  //使能自动注册，0-不使能，1-使能
    byLoginStatus: BYTE;  //注册状态，0-未注册，1-已注册，此参数只能获取
    byRes1: array[0..2-1] of BYTE;  
    stuServerIP: NET_DVR_IPADDR;  //SIP服务器IP
    wServerPort: WORD;  //SIP服务器端口
    byRes2: array[0..2-1] of BYTE;  
    byUserName: array[0..NAME_LEN-1] of BYTE;  //注册用户名
    byPassWord: array[0..PASSWD_LEN-1] of BYTE;  //注册密码
    byLocalNo: array[0..MAX_NUMBER_LEN-1] of BYTE;  
    byDispalyName: array[0..MAX_NAME_LEN-1] of BYTE;  //设备显示名称
    wLocalPort: WORD;  //本地端口
    byLoginCycle: BYTE;  //注册周期，1-99分钟
    byRes3: BYTE;  
    bySIPServerDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //sip服务器域名（IP和域名只需要填其一，都有值时IP优先）
    stuSTUNServerIP: NET_DVR_IPADDR;  // STUN服务器IP
    bySTUNServerDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //STUN服务器域名 （IP和域名只需要填其一，都有值时IP优先）
    wSTUNServerPort: WORD;  // STUN服务器端口
    byRes4: array[0..2-1] of BYTE;  
    stuProxyServerIP: NET_DVR_IPADDR;  //代理服务器IP
    byProxyServerDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //代理服务器域名 （IP和域名只需要填其一，都有值时IP优先）
    wProxyServerPort: WORD;  // 代理服务器端口
    byNetWork: BYTE;  //表示网络类型，0-无效，1-有线网络1， 2-有线网络2，3-无线网络
    byRes5: BYTE;  
    byCalledTargetName: array[0..NET_SDK_MAX_CALLEDTARGET_NAME-1] of BYTE;  
    byRes: array[0..224-1] of BYTE;  
  end;
  LPNET_DVR_SIP_CFG_V50 = ^NET_DVR_SIP_CFG_V50;

//IP可视对讲分机配置
type
  NET_DVR_IP_VIEW_DEVCFG = record 
    dwSize: DWORD;  
    byDefaultRing: BYTE;  //默认铃音，范围1-6
    byRingVolume: BYTE;  //铃音音量，范围0-9
    byInputVolume: BYTE;  //输入音量值，范围0-6
    byOutputVolume: BYTE;  //输出音量值，范围0-9
    wRtpPort: WORD;  //Rtp端口
    byRes1: array[0..2-1] of BYTE;  
    dwPreviewDelayTime: DWORD;  //预览延时配置，0-30秒
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_IP_VIEW_DEVCFG = ^NET_DVR_IP_VIEW_DEVCFG;

//Ip可视对讲音频相关参数配置
type
  NET_DVR_IP_VIEW_AUDIO_CFG = record 
    dwSize: DWORD;  
    byAudioEncPri1: BYTE;  //音频编码优先级1，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    byAudioEncPri2: BYTE;  //音频编码优先级2，当sip服务器不支持音频编码1时会使用音频编码2，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    wAudioPacketLen1: WORD;  //音频编码1数据包长度
    wAudioPacketLen2: WORD;  //音频编码2数据包长度
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_IP_VIEW_AUDIO_CFG = ^NET_DVR_IP_VIEW_AUDIO_CFG;

//IP分机呼叫对讲参数配置结构体
type
  NET_DVR_IP_VIEW_CALL_CFG = record 
    dwSize: DWORD;  
    byEnableAutoResponse: BYTE;  //使能自动应答,0-不使能，1-使能
    byAudoResponseTime: BYTE;  //自动应答时间，0-30秒
    byRes1: array[0..2-1] of BYTE;  
    byEnableAlarmNumber1: BYTE;  //启动报警号码1，0-不启动，1-启动
    byRes2: array[0..3-1] of BYTE;  
    byAlarmNumber1: array[0..MAX_NUMBER_LEN-1] of BYTE;  //呼叫号码1
    byEnableAlarmNumber2: BYTE;  //启动报警号码2，0-不启动，1-启动
    byRes3: array[0..3-1] of BYTE;  
    byAlarmNumber2: array[0..MAX_NUMBER_LEN-1] of BYTE;  //呼叫号码2，呼叫号码1失败会尝试呼叫号码2
    byRes4: array[0..72-1] of BYTE;  
  end;
  LPNET_DVR_IP_VIEW_CALL_CFG = ^NET_DVR_IP_VIEW_CALL_CFG;

//通道图象结构
//移动侦测(子结构)(按组方式扩展)
type
  NET_DVR_RECORDCHAN = record 
    dwMaxRecordChanNum: DWORD;  //设备支持的最大关联录像通道数-只读
    dwCurRecordChanNum: DWORD;  //当前实际已配置的关联录像通道数
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  // 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - MAX_CHANNUM_V30-1有效，如果中间遇到0xffffffff,则后续无效
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORDCHAN = ^NET_DVR_RECORDCHAN;

//移动侦测(子结构)(9000扩展)
type
  NET_DVR_MOTION_V30 = record 
    byMotionScope: array[0..64-1, 0..96-1] of BYTE;  //侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是
    byMotionSensitive: BYTE;  //移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭
    byEnableHandleMotion: BYTE;  // 是否处理移动侦测 0－否 1－是
    byEnableDisplay: BYTE;  //启用移动侦测高亮显示，0-否，1-是
    reservedData: AnsiChar;  
    struMotionHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 报警触发的录象通道
  end;
  LPNET_DVR_MOTION_V30 = ^NET_DVR_MOTION_V30;

//移动侦测(子结构)
type
  NET_DVR_MOTION = record 
    byMotionScope: array[0..18-1, 0..22-1] of BYTE;  //侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是
    byMotionSensitive: BYTE;  //移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
    byEnableHandleMotion: BYTE;  // 是否处理移动侦测 
    byEnableDisplay: BYTE;  //启用移动侦测高亮显示，0-否，1-是
    reservedData: AnsiChar;  
    strMotionHandleType: NET_DVR_HANDLEEXCEPTION;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
  end;
  LPNET_DVR_MOTION = ^NET_DVR_MOTION;

//遮挡报警(子结构)(9000扩展)  区域大小704*576
type
  NET_DVR_HIDEALARM_V30 = record 
    dwEnableHideAlarm: DWORD;  // 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
    wHideAlarmAreaTopLeftX: WORD;  // 遮挡区域的x坐标 
    wHideAlarmAreaTopLeftY: WORD;  // 遮挡区域的y坐标 
    wHideAlarmAreaWidth: WORD;  // 遮挡区域的宽 
    wHideAlarmAreaHeight: WORD;  //遮挡区域的高
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
  end;
  LPNET_DVR_HIDEALARM_V30 = ^NET_DVR_HIDEALARM_V30;
//遮挡报警(子结构)  区域大小704*576
type
  NET_DVR_HIDEALARM = record 
    dwEnableHideAlarm: DWORD;  // 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
    wHideAlarmAreaTopLeftX: WORD;  // 遮挡区域的x坐标 
    wHideAlarmAreaTopLeftY: WORD;  // 遮挡区域的y坐标 
    wHideAlarmAreaWidth: WORD;  // 遮挡区域的宽 
    wHideAlarmAreaHeight: WORD;  //遮挡区域的高
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间
  end;
  LPNET_DVR_HIDEALARM = ^NET_DVR_HIDEALARM;

//信号丢失报警(子结构)(9000扩展)
type
  NET_DVR_VILOST_V30 = record 
    byEnableHandleVILost: BYTE;  // 是否处理信号丢失报警 
    strVILostHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
  end;
  LPNET_DVR_VILOST_V30 = ^NET_DVR_VILOST_V30;

//信号丢失报警(子结构)
type
  NET_DVR_VILOST = record 
    byEnableHandleVILost: BYTE;  // 是否处理信号丢失报警 
    strVILostHandleType: NET_DVR_HANDLEEXCEPTION;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间
  end;
  LPNET_DVR_VILOST = ^NET_DVR_VILOST;

//遮挡区域(子结构)
type
  NET_DVR_SHELTER = record 
    wHideAreaTopLeftX: WORD;  // 遮挡区域的x坐标 
    wHideAreaTopLeftY: WORD;  // 遮挡区域的y坐标 
    wHideAreaWidth: WORD;  // 遮挡区域的宽 
    wHideAreaHeight: WORD;  //遮挡区域的高
  end;
  LPNET_DVR_SHELTER = ^NET_DVR_SHELTER;

type
  NET_DVR_COLOR = record 
    byBrightness: BYTE;  //亮度,0-255
    byContrast: BYTE;  //对比度,0-255
    bySaturation: BYTE;  //饱和度,0-255
    byHue: BYTE;  //色调,0-255
  end;
  LPNET_DVR_COLOR = ^NET_DVR_COLOR;

type
  NET_DVR_RGB_COLOR = record 
    byRed: BYTE;  //RGB颜色三分量中的红色
    byGreen: BYTE;  //RGB颜色三分量中的绿色
    byBlue: BYTE;  //RGB颜色三分量中的蓝色
    byRes: BYTE;  //保留
  end;
  LPNET_DVR_RGB_COLOR = ^NET_DVR_RGB_COLOR;

//坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位
//点坐标结构
type
  NET_VCA_POINT = record 
    fX: FLOAT;  // X轴坐标, 0.000~1
    fY: FLOAT;  //Y轴坐标, 0.000~1
  end;
  LPNET_VCA_POINT = ^NET_VCA_POINT;

//通道图象结构(9000扩展)
type
  NET_DVR_PICCFG_V30 = record 
    dwSize: DWORD;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  
    dwVideoFormat: DWORD;  // 只读 视频制式 1-NTSC 2-PAL
    byReservedData: array[0..64-1] of BYTE;  //保留
    dwShowChanName: DWORD;  // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    wShowNameTopLeftX: WORD;  // 通道名称显示位置的x坐标 
    wShowNameTopLeftY: WORD;  // 通道名称显示位置的y坐标 
    //视频信号丢失报警
    struVILost: NET_DVR_VILOST_V30;  
    struRes: NET_DVR_VILOST_V30;  //保留
    //    BYTE byRes1[328];
    //移动侦测
    struMotion: NET_DVR_MOTION_V30;  
    //遮挡报警
    struHideAlarm: NET_DVR_HIDEALARM_V30;  
    //遮挡  区域大小704*576
    dwEnableHide: DWORD;  // 是否启动遮挡 ,0-否,1-是
    struShelter: array[0..MAX_SHELTERNUM-1] of NET_DVR_SHELTER;  
    //OSD
    dwShowOsd: DWORD;  // 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    wOSDTopLeftX: WORD;  // OSD的x坐标 
    wOSDTopLeftY: WORD;  // OSD的y坐标 
    byOSDType: BYTE;  // OSD类型(主要是年月日格式) 
    // 0: XXXX-XX-XX 年月日 
    // 1: XX-XX-XXXX 月日年 
    // 2: XXXX年XX月XX日 
    // 3: XX月XX日XXXX年 
    // 4: XX-XX-XXXX 日月年
    // 5: XX日XX月XXXX年 
    //6: xx/xx/xxxx(月/日/年) 
    //7: xxxx/xx/xx(年/月/日) 
    //8: xx/xx/xxxx(日/月/年)
    byDispWeek: BYTE;  // 是否显示星期 
    byOSDAttrib: BYTE;  // OSD属性:透明，闪烁 
    // 1: 透明,闪烁 
    // 2: 透明,不闪烁 
    // 3: 闪烁,不透明 
    // 4: 不透明,不闪烁 
    byHourOSDType: BYTE;  // OSD小时制:0-24小时制,1-12小时制 
    byFontSize: BYTE;  //字体大小，16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 7-80*80(中)/40*80(英) 8-112*112(中)/56*112(英) 0xff-自适应(adaptive)
    byOSDColorType: BYTE;  //0-默认（黑白）；1-自定义；2-勾边
    {当对齐方式选择国标模式时，可以分别对右下角、左下角两个区域做字符叠加。
    右下角区域：
    共支持6行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第0至第5个下标的值。叠加字符的方式为从下到上的方式。
    左下角区域：
    共支持2行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第6和第7个下标的值。叠加字符的方式为从下到上的方式。
    }
    byAlignment: BYTE;  //对齐方式 0-自适应，1-右对齐, 2-左对齐,3-国标模式, 4-全部右对齐(包含叠加字符、时间以及标题等所有OSD字符)，5-全部左对齐(包含叠加字符、时间以及标题等所有OSD字符)
    byOSDMilliSecondEnable: BYTE;  //视频叠加时间支持毫秒；0~不叠加, 1-叠加
    struOsdColor: NET_DVR_RGB_COLOR;  //OSD颜色
    dwBoundary: DWORD;  //边界值，左对齐，右对齐以及国标模式的边界值，0-表示默认值，单位：像素
    struOsdBkColor: NET_DVR_RGB_COLOR;  //自定义OSD背景色
    byOSDBkColorMode: BYTE;  //OSD背景色模式，0-默认，1-自定义OSD背景色
    byUpDownBoundary: BYTE;  //上下最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
    byLeftRightBoundary: BYTE;  //左右最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
    byAngleEnabled: BYTE;  //OSD是否叠加俯仰角信息,0~不叠加, 1-叠加
    wTiltAngleTopLeftX: WORD;  // 俯仰角信息显示位置的x坐标 
    wTiltAngleTopLeftY: WORD;  // 俯仰角信息显示位置的y坐标 
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_PICCFG_V30 = ^NET_DVR_PICCFG_V30;

//通道图象结构SDK_V14扩展
type
  NET_DVR_PICCFG_EX = record 
    dwSize: DWORD;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  
    dwVideoFormat: DWORD;  // 只读 视频制式 1-NTSC 2-PAL
    byBrightness: BYTE;  //亮度,0-255
    byContrast: BYTE;  //对比度,0-255
    bySaturation: BYTE;  //饱和度,0-255 
    byHue: BYTE;  //色调,0-255
    //显示通道名
    dwShowChanName: DWORD;  // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    wShowNameTopLeftX: WORD;  // 通道名称显示位置的x坐标 
    wShowNameTopLeftY: WORD;  // 通道名称显示位置的y坐标 
    //信号丢失报警
    struVILost: NET_DVR_VILOST;  
    //移动侦测
    struMotion: NET_DVR_MOTION;  
    //遮挡报警
    struHideAlarm: NET_DVR_HIDEALARM;  
    //遮挡  区域大小704*576
    dwEnableHide: DWORD;  // 是否启动遮挡 ,0-否,1-是
    struShelter: array[0..MAX_SHELTERNUM-1] of NET_DVR_SHELTER;  
    //OSD
    dwShowOsd: DWORD;  // 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    wOSDTopLeftX: WORD;  // OSD的x坐标 
    wOSDTopLeftY: WORD;  // OSD的y坐标 
    byOSDType: BYTE;  // OSD类型(主要是年月日格式) 
    // 0: XXXX-XX-XX 年月日 
    // 1: XX-XX-XXXX 月日年 
    // 2: XXXX年XX月XX日 
    // 3: XX月XX日XXXX年 
    // 4: XX-XX-XXXX 日月年
    // 5: XX日XX月XXXX年 
    //6: xx/xx/xxxx(月/日/年) 
    //7: xxxx/xx/xx(年/月/日) 
    //8: xx/xx/xxxx(日/月/年)
    byDispWeek: BYTE;  // 是否显示星期 
    byOSDAttrib: BYTE;  // OSD属性:透明，闪烁 
    // 1: 透明,闪烁 
    // 2: 透明,不闪烁 
    // 3: 闪烁,不透明 
    // 4: 不透明,不闪烁 
    byHourOsdType: BYTE;  // OSD小时制:0-24小时制,1-12小时制 
  end;
  LPNET_DVR_PICCFG_EX = ^NET_DVR_PICCFG_EX;

//通道图象结构(SDK_V13及之前版本)
type
  NET_DVR_PICCFG = record 
    dwSize: DWORD;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  
    dwVideoFormat: DWORD;  // 只读 视频制式 1-NTSC 2-PAL
    byBrightness: BYTE;  //亮度,0-255
    byContrast: BYTE;  //对比度,0-255
    bySaturation: BYTE;  //饱和度,0-255 
    byHue: BYTE;  //色调,0-255
    //显示通道名
    dwShowChanName: DWORD;  // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    wShowNameTopLeftX: WORD;  // 通道名称显示位置的x坐标 
    wShowNameTopLeftY: WORD;  // 通道名称显示位置的y坐标 
    //信号丢失报警
    struVILost: NET_DVR_VILOST;  
    //移动侦测
    struMotion: NET_DVR_MOTION;  
    //遮挡报警
    struHideAlarm: NET_DVR_HIDEALARM;  
    //遮挡  区域大小704*576
    dwEnableHide: DWORD;  // 是否启动遮挡 ,0-否,1-是
    wHideAreaTopLeftX: WORD;  // 遮挡区域的x坐标 
    wHideAreaTopLeftY: WORD;  // 遮挡区域的y坐标 
    wHideAreaWidth: WORD;  // 遮挡区域的宽 
    wHideAreaHeight: WORD;  //遮挡区域的高
    //OSD
    dwShowOsd: DWORD;  // 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    wOSDTopLeftX: WORD;  // OSD的x坐标 
    wOSDTopLeftY: WORD;  // OSD的y坐标 
    byOSDType: BYTE;  // OSD类型(主要是年月日格式) 
    // 0: XXXX-XX-XX 年月日 
    // 1: XX-XX-XXXX 月日年 
    // 2: XXXX年XX月XX日 
    // 3: XX月XX日XXXX年 
    // 4: XX-XX-XXXX 日月年
    // 5: XX日XX月XXXX年 
    //6: xx/xx/xxxx(月/日/年) 
    //7: xxxx/xx/xx(年/月/日) 
    //8: xx/xx/xxxx(日/月/年)
    byDispWeek: BYTE;  // 是否显示星期 
    byOSDAttrib: BYTE;  // OSD属性:透明，闪烁 
    // 1: 透明,闪烁 
    // 2: 透明,不闪烁 
    // 3: 闪烁,不透明 
    // 4: 不透明,不闪烁 
    reservedData2: AnsiChar;  
  end;
  LPNET_DVR_PICCFG = ^NET_DVR_PICCFG;

type
  BITRATE_ENCODE_INDEX =  
  (  
    BITRATE_ENCODE_def = 0,  
    BITRATE_ENCODE_8kps = 1,  
    BITRATE_ENCODE_16kps = 2,  
    BITRATE_ENCODE_32kps = 3,  
    BITRATE_ENCODE_64kps = 4,  
    BITRATE_ENCODE_128kps = 5,  
    BITRATE_ENCODE_192kps = 6,  
    BITRATE_ENCODE_40kps = 7,  
    BITRATE_ENCODE_48kps = 8,  
    BITRATE_ENCODE_56kps = 9,  
    BITRATE_ENCODE_80kps = 10,  
    BITRATE_ENCODE_96kps = 11,  
    BITRATE_ENCODE_112kps = 12,  
    BITRATE_ENCODE_144kps = 13,  
    BITRATE_ENCODE_160kps = 14,  
    BITRATE_ENCODE_224kps = 15,  
    BITRATE_ENCODE_256kps = 16,  
    BITRATE_ENCODE_320kps = 17  
  );

//码流压缩参数(子结构)(9000扩展)
type
  NET_DVR_COMPRESSION_INFO_V30 = record 
    byStreamType: BYTE;  //码流类型 0-视频流, 1-复合流, 表示事件压缩参数时最高位表示是否启用压缩参数
                            {分辨率0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,
                            4-2CIF                      5（保留）,                 6-QVGA(320*240),        7-QQVGA(160*120),
                            12-384*288                  13-576*576,
                            16-VGA（640*480）,          17-UXGA（1600*1200）,      18-SVGA(800*600),       19-HD720p(1280*720）,
                            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,
                            24-1920*1920,               27-HD1080i,
                            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,
                            32-2448*1200,               33-2448*800,               34-XGA（1024*768），    35-SXGA（1280*1024）,
                            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),
                            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,
                            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,
                            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,
                            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
                            56-2304*1296                57-WXGA(1280*800),         58-1600*600,               59-1600*900,
                            60-2752*2208,                61-保留,                   62-4000*3000,           63-4096*2160,
                            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
                            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
                            72-160*128,                 73-324*240,                74-324*256,             75-336*256,
                            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216,
                            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
                            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
                            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
                            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
                            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
                            100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
                            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
                            108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
                            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
                            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
                            120-480*768,                121-768*480,               122-320*512,             123-512*320,
                            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
                            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
                            132-2720*1192,              133-3MP(1920*1536/2048*1536)，                     134-5MP(2560*1944)，
                            135-2560*960,               136-2064*1544              137-4096*1200,
                            138-3840*1080               139-2720*800               140-512*232             141-704*200,
                            142-512*152,                143-2048*896               144-2048*600            145-1280*376,
                            146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
                            150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
                            154-480*720,                155-800*450,               156-480*270,            157-2560*1536,
                            160-3264*2448,              161-288*320,               162-144*176,            163-480*640,
                            164-240*320,                165-120*160,               166-576*720,            167-720*1280,
                            168-576*960,                169-2944*1656,             170-432*240,            171-2160*3840,
                            172-1080*1920,              173-7008*1080,             174-3504*540,           175-1752*270,
                            176-876*135,                177-4096*1440,             178-4096*1080,          179-1536*864,
                            180-180*240,                181-360*480,               182-540*720,            183-720*960,
                            184-960*1280,               185-1080*1440,
                            186-3200*1800,              187-1752*272,              188-872*136,            189-1280*1440,
                            190-3520*544,               191-1728*256,              192-864*128,            193-5470*3684,
                            194-2560*750,               195-1600*480,              196-1024*300,           197-848*480,
       198-8160*3616,    199-8160*2304,             200-4064*2560,          201-1400*1050,
                            202-2688*1512,              203-704*288,               204-1560*656,           205-3072*1280,
                            206-4320*1808,              207-6120*2560,              208-1280*960,          209-3000*3000,
                            210-2032*3616,              211-7680*4320,             212-5760*3240,          213-3264*1836,
                            214-2712*1536,              215-1080*720(占位，未测试),  216-360x640(占位，未测试),217-1440*812,
                            218-8160*2416,              219-5760*1712,               220-4080*1200,          221-6144*2560,
                            222-1568*656,               223-4096*1808,               224-2720*1200,          225-2896*848
                            226-2048*608                227-3840*1120                228-2720*784            229-1920*560,
                            230-1360*400                231-704*208                  232-496*144             233-352*128,
                            234-512*240                 235-512*160                  236-368*128            237-256*128
                            238-2048*592                239-1456*416                 240-1024*304            241-1280*368
                            242-912*256                 243-640*192                  244-252*112 （未使用）            245-(576*704[P制]/480*704[N制])

                            254-表示超出该字段范围，使用NET_DVR_MULTI_STREAM_COMPRESSIONCFG中的dwResolution表示分辨率
                            0xff-Auto(使用当前码流分辨率)
                            256-3888*1696                257-2784*1200               258-496*224              259-352*160
                            260-912*400                  261-640*288                 262-1456*640             263-1024*448
                            264-2896*1280                265-2544*1080               266-2736*768             267-1920*544
                            268-3840*1696                269-2880*848                270-5424*2400            271-5520*1600
                            272-848*376                  273-912*272                 274-1360*600             275-1456*432
                            276-2736*1200                277-5760*1696               278-8160*2400            279-5520*2400
                            280-4608*2592                281-4944*3280               282-6016*4008            283-720*480
                            284-3200*2400                285-2784*800                286-1968*848             287-1392*608
                            288-2736*1184                289-1920*848                290-2560*2880            291-1944*1212
                            292-1920*2400                293-384*384                 294-768*768              295-4800*2688
                            296-6480*1080                297-8640*1440               298-4800*800             299-6720*1200
                            300-3600*600                 301-4800*840                302-2400*400             303-3072*540
                            304-1440*810                 305-1920*320                306-2688*480             307-1440*240
                            308-4800*1792                309-3360*1264               310-2304*880             311-3840*1440
                            312-2688*1008                313-1824*704                314-1248*496             315-1920*720
                            316-1344*496                 317-912*336                 318-1280*480             319-864*336
                            320-576*224                  321-2704*1008               322-1904*704             323-1808*672
                            324-1264*464                 325-944*336                 326-2400*1344            327-2032*1440
                            328-4064*1792                329-304*112                 330-960*360              331-672*240
                            332-464*160                  333-896*336                 334-624*224              335-640*240
                            336-448*160                  337-4976*1452               338-1968*560             339-2736*784
                            340-3888*1136                341-6120*1800               342-4320*1280            343-3056*896
                            344-1776*528                 345-1392*400                346-7256*1520            347-512*288
                            348-1936*1210                349-640*400                 350-2688*1792            351-2464*2056
                            352-2720*1600                353-4800*1600               354-3600*1200            355-未定义
                            356-2400*800                 357-1200*400                358-4096*3008            359-7680*4096
                            360-1080*1520                361-6656*3744               362-5120*1400            363-2560*704
                            364-2688*3040                365-1280*352                366-3376*1008            367-1688*504
                            368-5120*1440                369-1920*2160               370-4080*1808            371-4080*1152
                            372-2688*3888                373-3840*2880               374-2464*3520            375-4416*1696
                            376-1408*540                 377-3456*1080               378-1728*540             379-704*1152
                            380-1408*1152                381-5120*2880               382-720*576              383-3984*1168
                            384-1920*1440                385-3840*4096               386-1920*536             387-1536*432
                            388-3072*864                 389-1440*1080               390-720*540              391-960*544
                            392-720*544                  393-5430*3054               394-8000*6000            395-6560*3690
                            396-2688*1944                397-960*272                 398-960*368              399-960*304
                            400-3632*1632                401-1200*536                402-960*432              403-1920*3264
                            404-3040*1368                405-1704*2896               406-768*216              407-360*272
                            408-960*536                  409-720*536                 410-848*240              411-368*272
                            412-4096*2460                413-536*240                 414-2560*1168            415-1920*864
                            416-752*336                  417-752*416                 418-560*416              419-592*272
                            420-448*336                  421-832*464                 422-624*464              423-672*304
                            424-672*368                  425-496*368                 426-832*368              427-592*336
                            428-8032*6032                429-4096*2464               430-8128*2304            431-1480*1664
                            432-1280*1944                433-1024*600                434-1520*2736            435-5328*3040
                            436-192*256                  437-8112*2304               438-720x576              439-704*576
                            440-2560*480                 441-2048*384                442-8160*3922            443-6128*1800
                            444-3680*1656                445-2048*1152               446-4096*576             447-2048*288
                            448-240*240                  449-1200*900                450-8112*2416            451-5472*1600
                            452-2880*2160                453-1920*540                454-4032*1200            455-3792*1120
                            456-2688*794                 457-4096*768
    }
    byResolution: BYTE;  
    byBitrateType: BYTE;  //码率类型 0:变码率, 1:定码率,0xfe:自动，和源一致
    byPicQuality: BYTE;  //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差,自动，和源一致
                            {视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
                                13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
                                24-3072K 25-4096K 26-8192K 27-16384K (28-30 Reserved) 31-12288K}
    dwVideoBitrate: DWORD;  
    dwVideoFrameRate: DWORD;  //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; V2.0版本中新加14-15; 15-18; 16-22;
    //17-25；18-30；19-35；20-40；21-45；22-50；23-55；24-60；25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,33-8.3,0xfffffffe-自动，和源一致
    wIntervalFrameI: WORD;  //I帧间隔,0xfffe 自动，和源一致
    byIntervalBPFrame: BYTE;  //0-BBP帧; 1-BP帧; 2-单P帧(2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题)；0xfe-自动，和源一致
    byres1: BYTE;  //保留
    byVideoEncType: BYTE;  //视频编码类型 0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，9-SVAC, 10-标准h265, 0xfe-自动（和源一致），0xff-无效
    byAudioEncType: BYTE;  //音频编码类型 0-G722;1-G711_U;2-G711_A;5-MP2L2;6-G276;7-AAC;8-PCM;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;0xff-无效
    byVideoEncComplexity: BYTE;  //视频编码复杂度，0-低，1-中，2高,0xfe:自动，和源一致
    byEnableSvc: BYTE;  //0 - 不启用SVC功能；1- 启用SVC功能; 2-自动启用SVC功能
    byFormatType: BYTE;  //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP,9-RTP+PS（国标：GB28181），0xff-无效
    byAudioBitRate: BYTE;  //音频码率 参考 BITRATE_ENCODE_INDEX
    byStreamSmooth: BYTE;  //码流平滑 1～100（1等级表示清晰(Clear)，100表示平滑(Smooth)）
    byAudioSamplingRate: BYTE;  //音频采样率0-默认,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
    bySmartCodec: BYTE;  ///*bit0-快速编码 0-关闭，1-打开，bit1 - 低码率模式 0 - 关闭，1 - 打开}
    byDepthMapEnable: BYTE;  // 深度图使能开关，0-关闭，1-打开；如果开启后，第二通道的子码流（双目）的视频参数都不能配置，默认输出 960*540 的深度图；
    //平均码率（在SmartCodec使能开启下生效）, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
    //最高位(15位)置成1表示是自定义码流, 0-14位表示码流值(MIN- 0 K)。
    wAverageVideoBitrate: WORD;  
  end;
  LPNET_DVR_COMPRESSION_INFO_V30 = ^NET_DVR_COMPRESSION_INFO_V30;

//通道压缩参数(9000扩展)
type
  NET_DVR_COMPRESSIONCFG_V30 = record 
    dwSize: DWORD;  
    struNormHighRecordPara: NET_DVR_COMPRESSION_INFO_V30;  //录像 对应8000的普通
    struRes: NET_DVR_COMPRESSION_INFO_V30;  //保留 char reserveData[28];
    struEventRecordPara: NET_DVR_COMPRESSION_INFO_V30;  //事件触发压缩参数
    struNetPara: NET_DVR_COMPRESSION_INFO_V30;  //网传(子码流)
  end;
  LPNET_DVR_COMPRESSIONCFG_V30 = ^NET_DVR_COMPRESSIONCFG_V30;

//码流压缩参数(子结构)
type
  NET_DVR_COMPRESSION_INFO = record 
    byStreamType: BYTE;  //码流类型0-视频流,1-复合流,表示压缩参数时最高位表示是否启用压缩参数
    byResolution: BYTE;  //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    byBitrateType: BYTE;  //码率类型0:变码率，1:定码率，2：低码率
    byPicQuality: BYTE;  //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    dwVideoBitrate: DWORD;  {视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
                                13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
                                24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K 31-12288K}
    dwVideoFrameRate: DWORD;  //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20;
  end;
  LPNET_DVR_COMPRESSION_INFO = ^NET_DVR_COMPRESSION_INFO;

//通道压缩参数
type
  NET_DVR_COMPRESSIONCFG = record 
    dwSize: DWORD;  
    struRecordPara: NET_DVR_COMPRESSION_INFO;  //录像/事件触发录像
    struNetPara: NET_DVR_COMPRESSION_INFO;  //网传/保留
  end;
  LPNET_DVR_COMPRESSIONCFG = ^NET_DVR_COMPRESSIONCFG;

//码流压缩参数(子结构)(扩展) 增加I帧间隔
type
  NET_DVR_COMPRESSION_INFO_EX = record 
    byStreamType: BYTE;  //码流类型0-视频流, 1-复合流
    byResolution: BYTE;  //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    byBitrateType: BYTE;  //码率类型0:变码率，1:定码率，2：低码率
    byPicQuality: BYTE;  //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    dwVideoBitrate: DWORD;  {视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
                                13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
                                24-3072K 25-4096K 26-8192K 27-16384K (28-30 Reserved) 31-12288K}
    dwVideoFrameRate: DWORD;  //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    wIntervalFrameI: WORD;  //I帧间隔
    //2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
    byIntervalBPFrame: BYTE;  //0-BBP帧; 1-BP帧; 2-单P帧
    byRes: BYTE;  
  end;
  LPNET_DVR_COMPRESSION_INFO_EX = ^NET_DVR_COMPRESSION_INFO_EX;

//通道压缩参数(扩展)
type
  NET_DVR_COMPRESSIONCFG_EX = record 
    dwSize: DWORD;  
    struRecordPara: NET_DVR_COMPRESSION_INFO_EX;  //录像
    struNetPara: NET_DVR_COMPRESSION_INFO_EX;  //网传
  end;
  LPNET_DVR_COMPRESSIONCFG_EX = ^NET_DVR_COMPRESSIONCFG_EX;


//时间段录像参数配置(子结构)
type
  NET_DVR_RECORDSCHED = record 
    struRecordTime: NET_DVR_SCHEDTIME;  
    byRecordType: BYTE;  //0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警, 5:命令触发, 6: 智能录像,10-PIR报警，11-无线报警，12-呼救报警，13-所有报警,14-智能交通事件，15越界侦测，16区域入侵侦测，17音频异常侦测
    reservedData: array[0..3-1] of AnsiChar;  
  end;
  LPNET_DVR_RECORDSCHED = ^NET_DVR_RECORDSCHED;

//全天录像参数配置(子结构)
type
  NET_DVR_RECORDDAY = record 
    wAllDayRecord: WORD;  // 是否全天录像 0-否 1-是
    byRecordType: BYTE;  { 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 智能录像,
                                                                    10-PIR报警，11-无线报警，12-呼救报警，13-移动|报警输入|PIR|无线报警|呼救报警,14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
                                    18-场景变更侦测,19-智能侦测（越界侦测|区域入侵|进入区域|离开区域|人脸识别）,20－人脸侦测, 21-POS录像}
    reservedData: AnsiChar;  
  end;
  LPNET_DVR_RECORDDAY = ^NET_DVR_RECORDDAY;

//通道录像参数配置(9000扩展)
type
  NET_DVR_RECORD_V30 = record 
    dwSize: DWORD;  
    dwRecord: DWORD;  //是否录像 0-否 1-是
    struRecAllDay: array[0..MAX_DAYS-1] of NET_DVR_RECORDDAY;  
    struRecordSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_RECORDSCHED;  
    dwRecordTime: DWORD;  // 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
    dwPreRecordTime: DWORD;  // 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) 
    dwRecorderDuration: DWORD;  // 录像保存的最长时间 
    byRedundancyRec: BYTE;  //是否冗余录像,重要数据双备份：0/1
    byAudioRec: BYTE;  //录像时复合流编码时是否记录音频数据：国外有此法规
    byStreamType: BYTE;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    byPassbackRecord: BYTE;  // 0:不回传录像 1：回传录像
    wLockDuration: WORD;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    byRecordBackup: BYTE;  // 0:录像不存档 1：录像存档
    bySVCLevel: BYTE;  //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    byRecordManage: BYTE;  //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    byExtraSaveAudio: BYTE;  //音频单独另存0-非单独另存，1-单独另存
    //开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的
    byIntelligentRecord: BYTE;  //是否开启智能录像功能 0-否 1-是
    byReserve: BYTE;  
  end;
  LPNET_DVR_RECORD_V30 = ^NET_DVR_RECORD_V30;

//时间段录像参数配置(子结构)
type
  NET_DVR_RECORDSCHED_V40 = record 
    struRecordTime: NET_DVR_SCHEDTIME;  
    {录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
    6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
    15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
    19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
    22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
    28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
    35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时，46-人脸抓拍，47-非法摆摊,48-目标抓拍,
    49-剧烈运动，50离岗检测，51-起立，52人数变化 53-废气排放显示 54-灰度报警}
    byRecordType: BYTE;  
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_RECORDSCHED_V40 = ^NET_DVR_RECORDSCHED_V40;

//全天录像参数配置(子结构)
type
  NET_DVR_RECORDDAY_V40 = record 
    byAllDayRecord: BYTE;  // 是否全天录像 0-否 1-是
                         {录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
                         6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
                         15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
                         19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
                         22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
                         28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
                         35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时,46-人脸抓拍,47-非法摆摊,48-目标抓拍,
                         49-剧烈运动，50离岗检测，51-起立，52人数变化  53-废气排放显示  54-灰度报警}
    byRecordType: BYTE;  
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_RECORDDAY_V40 = ^NET_DVR_RECORDDAY_V40;

type
  NET_DVR_RECORD_V40 = record 
    dwSize: DWORD;  
    dwRecord: DWORD;  //是否录像 0-否 1-是
    struRecAllDay: array[0..MAX_DAYS-1] of NET_DVR_RECORDDAY_V40;  
    struRecordSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_RECORDSCHED_V40;  
    dwRecordTime: DWORD;  // 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
    dwPreRecordTime: DWORD;  // 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) 
    dwRecorderDuration: DWORD;  // 录像保存的最长时间 
    byRedundancyRec: BYTE;  //是否冗余录像,重要数据双备份：0/1
    byAudioRec: BYTE;  //录像时复合流编码时是否记录音频数据：国外有此法规
    byStreamType: BYTE;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    byPassbackRecord: BYTE;  // 0:不回传录像 1：回传录像
    wLockDuration: WORD;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    byRecordBackup: BYTE;  // 0:录像不存档 1：录像存档
    bySVCLevel: BYTE;  //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    byRecordManage: BYTE;  //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    byExtraSaveAudio: BYTE;  //音频单独存储
    //开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的
    byIntelligentRecord: BYTE;  //是否开启智能录像功能 0-否 1-是
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_RECORD_V40 = ^NET_DVR_RECORD_V40;

//通道录像参数配置
type
  NET_DVR_RECORD = record 
    dwSize: DWORD;  
    dwRecord: DWORD;  //是否录像 0-否 1-是
    struRecAllDay: array[0..MAX_DAYS-1] of NET_DVR_RECORDDAY;  
    struRecordSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_RECORDSCHED;  
    dwRecordTime: DWORD;  // 录象时间长度 
    dwPreRecordTime: DWORD;  // 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) 
  end;
  LPNET_DVR_RECORD = ^NET_DVR_RECORD;

//云台协议表结构配置
type
  NET_DVR_PTZ_PROTOCOL = record 
    dwType: DWORD;  //解码器类型值
    byDescribe: array[0..DESC_LEN-1] of BYTE;  //解码器的描述符，和8000中的一致
  end;
  LPNET_DVR_PTZ_PROTOCOL = ^NET_DVR_PTZ_PROTOCOL;

type
  NET_DVR_PTZCFG = record 
    dwSize: DWORD;  
    struPtz: array[0..PTZ_PROTOCOL_NUM-1] of NET_DVR_PTZ_PROTOCOL;  //最大200中PTZ协议
    dwPtzNum: DWORD;  //有效的ptz协议数目，从0开始(即计算时加1)
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PTZCFG = ^NET_DVR_PTZCFG;

//**************************云台类型(end)*****************************
type
  NET_DVR_SERIALSTART_V40 = record //透明通道
    dwSize: DWORD;  //结构体大小
    dwSerialType: DWORD;  //串口号（1-232串口，2-485串口）
    bySerialNum: BYTE;  //串口编号
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_SERIALSTART_V40 = ^NET_DVR_SERIALSTART_V40;

//通道解码器(云台)参数配置 扩展
type
  NET_DVR_DECODERCFG_V40 = record 
    dwSize: DWORD;  //结构体大小
    dwBaudRate: DWORD;  //波特率 0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  //数据有几位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  //停止位 0－1位，1－2位
    byParity: BYTE;  //校验 0－无校验，1－奇校验，2－偶校验
    byFlowcontrol: BYTE;  //0－无，1－软流控,2-硬流控
    wDecoderType: WORD;  //解码器类型}
    wDecoderAddress: WORD;  //解码器地址，0-255
    bySetPreset: array[0..MAX_PRESET_V30-1] of BYTE;  //预置点是否设置,0-没有设置,1-设置
    bySetCruise: array[0..MAX_CRUISE_V30-1] of BYTE;  //巡航是否设置: 0-没有设置,1-设置
    bySetTrack: array[0..MAX_TRACK_V30-1] of BYTE;  //是否设置,0-没有设置,1-设置
    bySerialNO: BYTE;  //串口编号
    byWorkMode: BYTE;  //工作模式， 1-矩阵串口控制，2-屏幕控制，3-透明通道模式 4-PPP模式 5-控制台模式 6-串口直连 7-键盘控制 8-布防板管理 9-控制云台 12-LED显示，13-触发抓拍数据传输
    byRes: array[0..254-1] of BYTE;  //保留
  end;
  LPNET_DVR_DECODERCFG_V40 = ^NET_DVR_DECODERCFG_V40;

type
  NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO = record 
    fMaxTemperature: FLOAT;  //最高温，精确到小数点后一位
    fMinTemperature: FLOAT;  //最低温，精确到小数点后一位
    fAverageTemperature: FLOAT;  //平均温，精确到小数点后一位
    struHighestPoint: NET_VCA_POINT;  //最高温度位置坐标
    struLowestPoint: NET_VCA_POINT;  //最低温度位置坐标
    byIsFreezedata: BYTE;  //是否数据冻结 0-否 1-是
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO = ^NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO;

//通道解码器(云台)参数配置(9000扩展)
type
  NET_DVR_DECODERCFG_V30 = record 
    dwSize: DWORD;  
    dwBaudRate: DWORD;  //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  // 停止位 0－1位，1－2位;
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验;
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控
    wDecoderType: WORD;  //解码器类型, 从0开始，对应ptz协议列表从NET_DVR_IPC_PROTO_LIST得到
    wDecoderAddress: WORD;  //解码器地址:0 - 255
    bySetPreset: array[0..MAX_PRESET_V30-1] of BYTE;  // 预置点是否设置,0-没有设置,1-设置
    bySetCruise: array[0..MAX_CRUISE_V30-1] of BYTE;  // 巡航是否设置: 0-没有设置,1-设置 
    bySetTrack: array[0..MAX_TRACK_V30-1] of BYTE;  // 是否设置,0-没有设置,1-设置
  end;
  LPNET_DVR_DECODERCFG_V30 = ^NET_DVR_DECODERCFG_V30;

//通道解码器(云台)参数配置
type
  NET_DVR_DECODERCFG = record 
    dwSize: DWORD;  
    dwBaudRate: DWORD;  //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  // 停止位 0－1位，1－2位;
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验;
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控
    wDecoderType: WORD;  //解码器类型  NET_DVR_IPC_PROTO_LIST中得到
    wDecoderAddress: WORD;  //解码器地址:0 - 255
    bySetPreset: array[0..MAX_PRESET-1] of BYTE;  // 预置点是否设置,0-没有设置,1-设置
    bySetCruise: array[0..MAX_CRUISE-1] of BYTE;  // 巡航是否设置: 0-没有设置,1-设置 
    bySetTrack: array[0..MAX_TRACK-1] of BYTE;  // 是否设置,0-没有设置,1-设置
  end;
  LPNET_DVR_DECODERCFG = ^NET_DVR_DECODERCFG;

//ppp参数配置(子结构)
type
  NET_DVR_PPPCFG_V30 = record 
    struRemoteIP: NET_DVR_IPADDR;  //远端IP地址
    struLocalIP: NET_DVR_IPADDR;  //本地IP地址
    sLocalIPMask: array[0..16-1] of AnsiChar;  //本地IP地址掩码
    sUsername: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    byPPPMode: BYTE;  //PPP模式, 0－主动，1－被动
    byRedial: BYTE;  //是否回拨 ：0-否,1-是
    byRedialMode: BYTE;  //回拨模式,0-由拨入者指定,1-预置回拨号码
    byDataEncrypt: BYTE;  //数据加密,0-否,1-是
    dwMTU: DWORD;  //MTU
    sTelephoneNumber: array[0..PHONENUMBER_LEN-1] of AnsiChar;  //电话号码
  end;
  LPNET_DVR_PPPCFG_V30 = ^NET_DVR_PPPCFG_V30;

//ppp参数配置(子结构)
type
  NET_DVR_PPPCFG = record 
    sRemoteIP: array[0..16-1] of AnsiChar;  //远端IP地址
    sLocalIP: array[0..16-1] of AnsiChar;  //本地IP地址
    sLocalIPMask: array[0..16-1] of AnsiChar;  //本地IP地址掩码
    sUsername: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    byPPPMode: BYTE;  //PPP模式, 0－主动，1－被动
    byRedial: BYTE;  //是否回拨 ：0-否,1-是
    byRedialMode: BYTE;  //回拨模式,0-由拨入者指定,1-预置回拨号码
    byDataEncrypt: BYTE;  //数据加密,0-否,1-是
    dwMTU: DWORD;  //MTU
    sTelephoneNumber: array[0..PHONENUMBER_LEN-1] of AnsiChar;  //电话号码
  end;
  LPNET_DVR_PPPCFG = ^NET_DVR_PPPCFG;

//RS232串口参数配置(9000扩展)
type
  NET_DVR_SINGLE_RS232 = record 
    dwBaudRate: DWORD;  //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位 
    byStopBit: BYTE;  // 停止位 0－1位，1－2位 
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验 
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控 
    dwWorkMode: DWORD;  //工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道 3- ptz模式,审讯温湿度传感器, 4-报警盒模式  5-矩阵串口控制 6-屏幕控制 7-串口直连 8-键盘控制 9-布防板管理 10-控制云台
  end;
  LPNET_DVR_SINGLE_RS232 = ^NET_DVR_SINGLE_RS232;

type
  NET_DVR_USB_RS232 = record 
    dwBaudRate: DWORD;  //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位 
    byStopBit: BYTE;  // 停止位 0－1位，1－2位 
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验 
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控 
    byVirtualSerialPort: BYTE;  //虚拟串口编号
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_USB_RS232 = ^NET_DVR_USB_RS232;

//RS232串口参数配置(9000扩展)
type
  NET_DVR_RS232CFG_V30 = record 
    dwSize: DWORD;  
    struRs232: array[0..MAX_SERIAL_PORT-1] of NET_DVR_SINGLE_RS232;  //注意：此结构修改了，原来是单个结构，现在修改为了数组结构
    struPPPConfig: NET_DVR_PPPCFG_V30;  
  end;
  LPNET_DVR_RS232CFG_V30 = ^NET_DVR_RS232CFG_V30;

//RS232串口参数配置
type
  NET_DVR_RS232CFG = record 
    dwSize: DWORD;  
    dwBaudRate: DWORD;  //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  // 停止位 0－1位，1－2位;
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验;
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控
    dwWorkMode: DWORD;  // 工作模式，0－窄带传输(232串口用于PPP拨号)，1－控制台(232串口用于参数控制)，2－透明通道
    struPPPConfig: NET_DVR_PPPCFG;  
  end;
  LPNET_DVR_RS232CFG = ^NET_DVR_RS232CFG;


type
  NET_DVR_PRESETCHAN_INFO = record 
    dwEnablePresetChan: DWORD;  //启用预置点的通道, 0xfffffff表示不调用预置点
    dwPresetPointNo: DWORD;  //调用预置点通道对应的预置点序号, 0xfffffff表示不调用预置点。
  end;
  LPNET_DVR_PRESETCHAN_INFO = ^NET_DVR_PRESETCHAN_INFO;

type
  NET_DVR_CRUISECHAN_INFO = record 
    dwEnableCruiseChan: DWORD;  //启用巡航的通道
    dwCruiseNo: DWORD;  //巡航通道对应的巡航编号, 0xfffffff表示无效
  end;
  LPNET_DVR_CRUISECHAN_INFO = ^NET_DVR_CRUISECHAN_INFO;

type
  NET_DVR_PTZTRACKCHAN_INFO = record 
    dwEnablePtzTrackChan: DWORD;  //启用云台的通道
    dwPtzTrackNo: DWORD;  //云台通道对应的编号, 0xfffffff表示无效
  end;
  LPNET_DVR_PTZTRACKCHAN_INFO = ^NET_DVR_PTZTRACKCHAN_INFO;

type
  NET_DVR_PTZ_NOTIFICATION_COND = record 
    dwSize: DWORD;  
    {
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22- humanRecognition
    23- faceContrast
    }
    byEventType: WORD;  
    byRes: array[0..2-1] of BYTE;  
    dwChannel: DWORD;  
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_NOTIFICATION_COND = ^NET_DVR_PTZ_NOTIFICATION_COND;

type
  NET_DVR_PTZ_NOTIFICATION_CFG = record 
    dwSize: DWORD;  
    dwEnablePresetChanNum: DWORD;  //当前已启用预置点的数目
    struPresetChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PRESETCHAN_INFO;  //启用的预置点信息(关联联动类型 ptz)
    dwEnableCruiseChanNum: DWORD;  //当前已启用巡航的通道数目
    struCruiseChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_CRUISECHAN_INFO;  //启用巡航功能通道的信息(关联联动类型 ptz)
    dwEnablePtzTrackChanNum: DWORD;  //当前已启用云台的通道数目
    struPtzTrackInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PTZTRACKCHAN_INFO;  //调用云台的通道信息(关联联动类型 ptz)
    byRes1: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_NOTIFICATION_CFG = ^NET_DVR_PTZ_NOTIFICATION_CFG;


type
  NET_DVR_PTZ_NOTIFICATION = record 
    dwSize: DWORD;  
    {
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection，
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22- humanRecognition
    }
    byEventType: WORD;  
    byRes: array[0..62-1] of BYTE;  
    dwEnablePresetChanNum: DWORD;  //当前已启用预置点的数目
    struPresetChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PRESETCHAN_INFO;  //启用的预置点信息(关联联动类型 ptz)
    dwEnableCruiseChanNum: DWORD;  //当前已启用巡航的通道数目
    struCruiseChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_CRUISECHAN_INFO;  //启用巡航功能通道的信息(关联联动类型 ptz)
    dwEnablePtzTrackChanNum: DWORD;  //当前已启用云台的通道数目
    struPtzTrackInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PTZTRACKCHAN_INFO;  //调用云台的通道信息(关联联动类型 ptz)
    byRes1: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_NOTIFICATION = ^NET_DVR_PTZ_NOTIFICATION;

const
  NET_SDK_MAX_EVENT_NUM = 64;    //组合事件最大支持个数

//报警输入参数配置(256路NVR扩展)
type
  NET_DVR_ALARMINCFG_V40 = record 
    dwSize: DWORD;  
    sAlarmInName: array[0..NAME_LEN-1] of BYTE;  // 名称 
    byAlarmType: BYTE;  //报警器类型,0：常开,1：常闭
    byAlarmInHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byChannel: BYTE;  // 报警输入触发智能识别通道
    byInputType: BYTE;  //输入类型  0-开关量方式  1-信号量方式
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x1000:抓图上传到云
    //0x2000:短信报警
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数 实际支持数
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40-1] of DWORD;  //触发报警通道
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    //触发的录像通道
    dwMaxRecordChanNum: DWORD;  //设备支持的最大关联录像通道数-只读
    dwCurRecordChanNum: DWORD;  //当前实际已配置的关联录像通道数
    dwRelRecordChan: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwCurRecordChanNum -1有效，如果中间遇到0xffffffff,则后续无效
    dwMaxEnablePtzCtrlNun: DWORD;  //最大可启用的云台控制总数(只读)
    dwEnablePresetChanNum: DWORD;  //当前已启用预置点的数目
    struPresetChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PRESETCHAN_INFO;  //启用的预置点信息
    byPresetDurationTime: array[0..MAX_CHANNUM_V40-1] of BYTE;  //预置点停留时间 范围0-20s，默认10s；
    byRes2: array[0..4-1] of BYTE;  //保留
    dwEnableCruiseChanNum: DWORD;  //当前已启用巡航的通道数目
    struCruiseChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_CRUISECHAN_INFO;  //启用巡航功能通道的信息
    dwEnablePtzTrackChanNum: DWORD;  //当前已启用巡航的通道数目
    struPtzTrackInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PTZTRACKCHAN_INFO;  //调用云台的通道信息
    wEventType: array[0..NET_SDK_MAX_EVENT_NUM{64}-1] of WORD;  //组合事件类型，每一个位对应一个事件类型
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMINCFG_V40 = ^NET_DVR_ALARMINCFG_V40;

//报警输入参数配置(9000扩展)
type
  NET_DVR_ALARMINCFG_V30 = record 
    dwSize: DWORD;  
    sAlarmInName: array[0..NAME_LEN-1] of BYTE;  // 名称 
    byAlarmType: BYTE;  //报警器类型,0：常开,1：常闭
    byAlarmInHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byChannel: BYTE;  // 报警输入触发智能识别通道
    byInputType: BYTE;  //输入类型  0-开关量方式  1-信号量方式
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byEnablePreset: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 是否调用预置点 0-否,1-是
    byPresetNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
    byRes2: array[0..192-1] of BYTE;  //保留
    byEnableCruise: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 是否调用巡航 0-否,1-是
    byCruiseNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 巡航 
    byEnablePtzTrack: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 是否调用 0-否,1-是
    byPTZTrack: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 调用的云台的序号 
    byRes3: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_ALARMINCFG_V30 = ^NET_DVR_ALARMINCFG_V30;


type
  NET_DVR_ALRAM_FIXED_HEADER = record 

    {0-信号量报警,1-硬盘满,2-信号丢失，3－移动侦测，4－硬盘未格式化,5-写硬盘出错,6-遮挡报警，
    7-制式不匹配, 8-非法访问，9-视频信号异常，10-录像异常，11-智能场景变化，12-阵列异常，13-前端/录像分辨率不匹配,
    14-申请解码资源失败,15-智能侦测报警, 16-热备异常，17-录播主机报警，18-语音对讲请求报警,19-音频丢失，20-开启录像，
    21-关闭录像，22-车辆检测算法异常，23-脉冲报警,24-人脸库硬盘异常,25-人脸库变更,26-人脸库图片变更,27-POC异常,28-相机视角异常，
    30-缺少SD卡,32-云台堵转异常，34-异常重启}
    dwAlarmType: DWORD;  //报警类型
    struAlarmTime: NET_DVR_TIME_EX;  //发生报警的时间
    uStruAlarm: record 
      case Byte of
      0: (byUnionLen: array[0..116-1] of BYTE);  //分出去8个字节用于扩展时区
      1: (struIOAlarm: record
        dwAlarmInputNo: DWORD;  //发生报警的报警输入通道号，一次只有一个
        dwTrigerAlarmOutNum: DWORD;  //触发的报警输出个数，用于后面计算变长数据部分中所有触发的报警输出通道号，四字节表示一个
        dwTrigerRecordChanNum: DWORD;  //触发的录像通道个数，用于后面计算变长数据部分中所有触发的录像通道号，四字节表示一个
      end);  // 报警类型dwAlarmType为0时有效
      2: (struAlarmChannel: record
        dwAlarmChanNum: DWORD;  //发生报警通道数据个数，用于后面计算变长数据部分中所有发生的报警通道号，四字节表示一个
        dwPicLen: DWORD;  //Jpeg图片长度
        byPicURL: BYTE;  //图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
        byTarget: BYTE;  //0-不区分识别目标，1-识别目标为人，2-识别目标为车
        byRes1: array[0..2-1] of BYTE;  //保留
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
        pDataBuff: PAnsiChar;  //报警图片或者图片URL
{$ELSE}
        pDataBuff: PAnsiChar;  //报警图片或者图片URL
        byRes3: array[0..4-1] of BYTE;  
{$ENDIF}
      end);  // dwAlarmType为2，3，6，9，10、13或28时有效
      3: (struAlarmHardDisk: record
        dwAlarmHardDiskNum: DWORD;  //发生报警的硬盘数据长度，用于后面计算变长数据部分中所有发生报警的硬盘号，四节表示一个
      end);  // dwAlarmType为1,4,5时有效
      4: (struRecordingHost: record
        bySubAlarmType: BYTE;  //报警子类型，1-一键延迟录像；
        byRes1: array[0..3-1] of BYTE;  //保留
        struRecordEndTime: NET_DVR_TIME_EX;  //录播结束时间
      end);  //录播主机专用报警
      5: (struVoltageInstable: record
        fVoltageValue: FLOAT;  //电源电压值,单位V,精确到0.1
        byVoltageAlarmType: BYTE;  //电源电压报警类型，0-电源电压过高，1-电源电压过低
        byRes1: array[0..3-1] of BYTE;  //保留字节
      end);  //dwAlarmType=31时有效

      6: (struPTLocking: record
        fTemperature: FLOAT;  //传感器温度，精确到小数点后1位
        dwCustomInfoLength: DWORD;  //自定义信息长度
        pCustomInfo: PBYTE;  //自定义信息
        byType: BYTE;  //云台堵转类型 1-水平堵转 2-垂直堵转
        byDeicingEnabled: BYTE;  // 云台除冰加热使能 0-关闭 1-开启
        byRes2: array[0..2-1] of BYTE;  //保留
        dwChannel: DWORD;  //通道号
      end);  //云台堵转异常 dwAlarmType=32时有效

      7: (struLogException: record
        byExceptionType: BYTE;  //异常类型,0-保留, 1- 日志存储异常，2-日志盘满
      end);  //dwAlarmType=33时有效,日志异常信息

      8: (struAbnormalReboot: record
        struAlarmTime: NET_DVR_TIME_EX;  //重启时间，设备本地时间
        byExceptionType: BYTE;  //重启具体类型 0-保留 1- 线程 2-无码流  当前0、1、2 以外为其他
        byRes1: array[0..3-1] of BYTE;  //保留字节
      end);  //异常重启 dwAlarmType=34时有效

    end;  
    pRes: PDWORD;  //用于兼容64位下结构体字节不对齐问题
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byRes: BYTE;  //保留
    wDevInfoIvmsChannel: WORD;  //增加后端透传前端时的通道号
    byRes2: array[0..2-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARM_FIXED_HEADER = ^NET_DVR_ALRAM_FIXED_HEADER;

//上传报警信息(256路NVR扩展)
type
  NET_DVR_ALARMINFO_V40 = record 
    struAlarmFixedHeader: NET_DVR_ALRAM_FIXED_HEADER;  //报警固定部分
    pAlarmData: PDWORD;  //报警可变部分内容
  end;
  LPNET_DVR_ALARMINFO_V40 = ^NET_DVR_ALARMINFO_V40;

//报警输入参数配置
type
  NET_DVR_ALARMINCFG = record 
    dwSize: DWORD;  
    sAlarmInName: array[0..NAME_LEN-1] of BYTE;  // 名称 
    byAlarmType: BYTE;  //报警器类型,0：常开,1：常闭
    byAlarmInHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byChannel: BYTE;  // 报警输入触发智能识别通道
    byRes: BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byEnablePreset: array[0..MAX_CHANNUM-1] of BYTE;  // 是否调用预置点 0-否,1-是
    byPresetNo: array[0..MAX_CHANNUM-1] of BYTE;  // 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
    byEnableCruise: array[0..MAX_CHANNUM-1] of BYTE;  // 是否调用巡航 0-否,1-是
    byCruiseNo: array[0..MAX_CHANNUM-1] of BYTE;  // 巡航 
    byEnablePtzTrack: array[0..MAX_CHANNUM-1] of BYTE;  // 是否调用 0-否,1-是
    byPTZTrack: array[0..MAX_CHANNUM-1] of BYTE;  // 调用的云台的序号 
  end;
  LPNET_DVR_ALARMINCFG = ^NET_DVR_ALARMINCFG;

//模拟报警输入参数配置
type
  NET_DVR_ANALOG_ALARMINCFG = record 
    dwSize: DWORD;  
    byEnableAlarmHandle: BYTE;  //处理报警输入
    byRes1: array[0..3-1] of BYTE;  
    byAlarmInName: array[0..NAME_LEN-1] of BYTE;  //模拟报警输入名称
    wAlarmInUpper: WORD;  //模拟输入电压上限，实际值乘10，范围0~360
    wAlarmInLower: WORD;  //模拟输入电压下限，实际值乘10，范围0~360
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //被触发的录像通道
    byRes2: array[0..100-1] of BYTE;  
  end;
  LPNET_DVR_ANALOG_ALARMINCFG = ^NET_DVR_ANALOG_ALARMINCFG;

//上传报警信息(9000扩展)
type
  NET_DVR_ALARMINFO_V30 = record 
    dwAlarmType: DWORD;  {0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常,
                      10-录像异常,11- 智能场景变化,12-阵列异常,13-前端/录像分辨率不匹配,14-申请解码资源失败,15-智能侦测, 16-POE供电异常报警,17-闪光灯异常,
    18-磁盘满负荷异常报警,19-音频丢失，20-开启录像，21-关闭录像，22-车辆检测算法异常，23-脉冲报警,24-人脸库硬盘异常,25-人脸库变更,26-人脸库图片变更,27-POC异常
    28-相机视角异常,29-电量低，30-缺少SD卡}
    dwAlarmInputNumber: DWORD;  //报警输入端口
    byAlarmOutputNumber: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //触发的输出端口，为1表示对应输出
    byAlarmRelateChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道
    byChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //dwAlarmType为2或3,6,9,10,14,19,28时，表示哪个通道，dwChannel[0]对应第1个通道
    byDiskNumber: array[0..MAX_DISKNUM_V30-1] of BYTE;  //dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘
    {$IFDEF SDK_CHEZAI} //#ifdef SDK_CHEZAI
    GPS_pos: NET_DVR_ADDIT_POSITION;  // GPS定位信息 
    {$ENDIF}
  end;
  LPNET_DVR_ALARMINFO_V30 = ^NET_DVR_ALARMINFO_V30;

type
  NET_DVR_ALARM_HOT_SPARE = record 
    dwSize: DWORD;  //结构体
    dwExceptionCase: DWORD;  //报警原因   0-网络异常
    struDeviceIP: NET_DVR_IPADDR;  //产生异常的设备IP地址
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARM_HOT_SPARE = ^NET_DVR_ALARM_HOT_SPARE;

type
  NET_DVR_ALARMINFO = record 
    dwAlarmType: DWORD;  //0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化
    dwAlarmInputNumber: DWORD;  //报警输入端口
    dwAlarmOutputNumber: array[0..MAX_ALARMOUT-1] of DWORD;  //触发的输出端口，哪一位为1表示对应哪一个输出
    dwAlarmRelateChannel: array[0..MAX_CHANNUM-1] of DWORD;  //触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道
    dwChannel: array[0..MAX_CHANNUM-1] of DWORD;  //dwAlarmType为2或3,6,9,10时，表示哪个通道，dwChannel[0]位对应第1个通道
    dwDiskNumber: array[0..MAX_DISKNUM-1] of DWORD;  //dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘
  end;
  LPNET_DVR_ALARMINFO = ^NET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IPC接入参数配置
// IP设备结构 
type
  NET_DVR_IPDEVINFO = record 
    dwEnable: DWORD;  // 该IP设备是否启用 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    struIP: NET_DVR_IPADDR;  // IP地址 
    wDVRPort: WORD;  // 端口号 
    byRes: array[0..34-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPDEVINFO = ^NET_DVR_IPDEVINFO;

const
  DEV_ID_LEN = 32;    //设备ID长度

//ipc接入设备信息扩展，支持ip设备的域名添加
type
  NET_DVR_IPDEVINFO_V31 = record 
    byEnable: BYTE;  //该IP设备是否有效
    byProType: BYTE;  //协议类型，0-私有协议，1-松下协议，2-索尼
    byEnableQuickAdd: BYTE;  // 0 不支持快速添加  1 使用快速添加
    // 快速添加需要设备IP和协议类型，其他信息由设备默认指定
    byCameraType: BYTE;  //通道接入的相机类型，值为 0-无意义，1-聚焦老师，2-聚焦学生，3-老师全景，4-学生全景，5-多媒体，6C教师定位,7-学生定位,8-板书定位,9-板书相机
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码
    byDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备域名
    struIP: NET_DVR_IPADDR;  //IP地址
    wDVRPort: WORD;  // 端口号
    szDeviceID: array[0..DEV_ID_LEN-1] of BYTE;  //设备ID
    byEnableTiming: BYTE;  //0-保留，1-不启用NVR对IPC自动校时，2-启用NVR对IPC自动校时
    byCertificateValidation: BYTE;  //证书验证
    // byCertificateValidation:bit0: 0-不启用证书验证 1-启用证书验证
    // byCertificateValidation:bit1: 0-不启用默认通信端口 1-启用默认通信端口
  end;
  LPNET_DVR_IPDEVINFO_V31 = ^NET_DVR_IPDEVINFO_V31;

// IP通道匹配参数 
type
  NET_DVR_IPCHANINFO = record 
    byEnable: BYTE;  // 该通道是否在线 
    byIPID: BYTE;  //IP设备ID低8位，当设备ID为0时表示通道不可用
    byChannel: BYTE;  // 通道号 
    byIPIDHigh: BYTE;  // IP设备ID的高8位
    byTransProtocol: BYTE;  //传输协议类型0-TCP/auto(具体有设备决定)，1-UDP 2-多播 3-仅TCP 4-auto
    byGetStream: BYTE;  // 是否对该通道取流，0-是，1-否
    byres: array[0..30-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPCHANINFO = ^NET_DVR_IPCHANINFO;

// IP接入配置结构 
type
  NET_DVR_IPPARACFG = record 
    dwSize: DWORD;  // 结构大小 
    struIPDevInfo: array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO;  // IP设备 
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM-1] of BYTE;  // 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 
    struIPChanInfo: array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;  // IP通道 
  end;
  LPNET_DVR_IPPARACFG = ^NET_DVR_IPPARACFG;
// 扩展IP接入配置结构 
type
  NET_DVR_IPPARACFG_V31 = record 
    dwSize: DWORD;  // 结构大小 
    struIPDevInfo: array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO_V31;  // IP设备 
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM-1] of BYTE;  // 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 
    struIPChanInfo: array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;  // IP通道 
  end;
  LPNET_DVR_IPPARACFG_V31 = ^NET_DVR_IPPARACFG_V31;

type
  NET_DVR_IPSERVER_STREAM = record 
    byEnable: BYTE;  // 是否在线
    byRes: array[0..3-1] of BYTE;  // 保留字节
    struIPServer: NET_DVR_IPADDR;  //IPServer 地址
    wPort: WORD;  //IPServer 端口
    wDvrNameLen: WORD;  // DVR 名称长度
    byDVRName: array[0..NAME_LEN-1] of BYTE;  // DVR名称
    wDVRSerialLen: WORD;  // 序列号长度
    byRes1: array[0..2-1] of WORD;  // 保留字节
    byDVRSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  // DVR序列号长度
    byUserName: array[0..NAME_LEN-1] of BYTE;  // DVR 登陆用户名
    byPassWord: array[0..PASSWD_LEN-1] of BYTE;  // DVR登陆密码
    byChannel: BYTE;  // DVR 通道
    byRes2: array[0..11-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_IPSERVER_STREAM = ^NET_DVR_IPSERVER_STREAM;

//流媒体服务器基本配置
type
  NET_DVR_STREAM_MEDIA_SERVER_CFG = record 
    byValid: BYTE;  //是否可用
    byRes1: array[0..3-1] of BYTE;  
    struDevIP: NET_DVR_IPADDR;  
    wDevPort: WORD;  //流媒体服务器端口
    byTransmitType: BYTE;  //传输协议类型 0-TCP，1-UDP
    byRes2: array[0..69-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_MEDIA_SERVER_CFG = ^NET_DVR_STREAM_MEDIA_SERVER_CFG;

//设备通道信息
type
  NET_DVR_DEV_CHAN_INFO = record 
    struIP: NET_DVR_IPADDR;  //DVR IP地址
    wDVRPort: WORD;  //端口号
    byChannel: BYTE;  //通道号
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    byDeviceType: BYTE;  //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    byDispChan: BYTE;  //显示通道号,智能配置使用
    bySubDispChan: BYTE;  //显示通道子通道号，智能配置时使用
    byResolution: BYTE;  //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    byRes: array[0..2-1] of BYTE;  
    byDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备域名
    sUserName: array[0..NAME_LEN-1] of BYTE;  //布防主机登陆帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //布防主机密码
  end;
  LPNET_DVR_DEV_CHAN_INFO = ^NET_DVR_DEV_CHAN_INFO;

//直接通过流媒体取流
type
  NET_DVR_PU_STREAM_CFG = record 
    dwSize: DWORD;  
    struStreamMediaSvrCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO;  
  end;
  LPNET_DVR_PU_STREAM_CFG = ^NET_DVR_PU_STREAM_CFG;

type
  NET_DVR_DDNS_STREAM_CFG = record 
    byEnable: BYTE;  // 是否启用
    byRes1: array[0..3-1] of BYTE;  
    struStreamServer: NET_DVR_IPADDR;  //流媒体服务器地址
    wStreamServerPort: WORD;  //流媒体服务器端口
    byStreamServerTransmitType: BYTE;  //流媒体传输协议类型 0-TCP，1-UDP
    byRes2: BYTE;  
    struIPServer: NET_DVR_IPADDR;  //IPSERVER地址
    wIPServerPort: WORD;  //IPserver端口号
    byRes3: array[0..2-1] of BYTE;  
    sDVRName: array[0..NAME_LEN-1] of BYTE;  //DVR名称
    wDVRNameLen: WORD;  // DVR名称长度
    wDVRSerialLen: WORD;  // 序列号长度
    sDVRSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  // DVR序列号
    sUserName: array[0..NAME_LEN-1] of BYTE;  // DVR 登陆用户名
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // DVR登陆密码
    wDVRPort: WORD;  //DVR端口号
    byRes4: array[0..2-1] of BYTE;  
    byChannel: BYTE;  // DVR 通道
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
  end;
  LPNET_DVR_DDNS_STREAM_CFG = ^NET_DVR_DDNS_STREAM_CFG;

const
  URL_LEN = 240;    //URL长度
type
  NET_DVR_PU_STREAM_URL = record 
    byEnable: BYTE;  
    strURL: array[0..URL_LEN-1] of BYTE;  
    byTransPortocol: BYTE;  // 传输协议类型 0-tcp  1-UDP
    wIPID: WORD;  //设备ID号，wIPID = iDevInfoIndex + iGroupNO*64 +1
    byChannel: BYTE;  //通道号
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_PU_STREAM_URL = ^NET_DVR_PU_STREAM_URL;

type
  NET_DVR_HKDDNS_STREAM = record 
    byEnable: BYTE;  // 是否在线
    byRes: array[0..3-1] of BYTE;  // 保留字节
    byDDNSDomain: array[0..64-1] of BYTE;  // hiDDNS服务器
    wPort: WORD;  // hiDDNS 端口
    wAliasLen: WORD;  // 别名长度
    byAlias: array[0..NAME_LEN-1] of BYTE;  // 别名
    wDVRSerialLen: WORD;  // 序列号长度
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    byDVRSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  // DVR序列号
    byUserName: array[0..NAME_LEN-1] of BYTE;  // DVR 登陆用户名
    byPassWord: array[0..PASSWD_LEN-1] of BYTE;  // DVR登陆密码
    byChannel: BYTE;  // DVR通道
    byRes2: array[0..11-1] of BYTE;  // 保留字
  end;
  LPNET_DVR_HKDDNS_STREAM = ^NET_DVR_HKDDNS_STREAM;

type
  NET_DVR_IPCHANINFO_V40 = record 
    byEnable: BYTE;  // 该通道是否在线 
    byRes1: BYTE;  
    wIPID: WORD;  //IP设备ID
    dwChannel: DWORD;  //通道号
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP，2- 多播，3-RTSP，0xff- auto(自动)
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    byRes: BYTE;  
    strURL: array[0..URL_LEN{240}-1] of BYTE;  //RTSP协议取流URL （仅RTSP协议时有效）
  end;
  LPNET_DVR_IPCHANINFO_V40 = ^NET_DVR_IPCHANINFO_V40;

// 邦诺CVR
const
  MAX_ID_COUNT = 256;    
  MAX_STREAM_ID_COUNT = 1024;    
  STREAM_ID_LEN = 32;    
  PLAN_ID_LEN = 32;    
  DEVICE_NO_LEN = 24;    
  MAX_VOLUMENAME_LEN = 32;    //录像卷名称
  MAX_VAG_CHANNO_LEN = 32;    //VAG协议取流时通道号编码长度

const
  MAX_STREAM_ID_NUM = 30;    //最大流ID数目

// 流信息 - 72字节长
type
  NET_DVR_STREAM_INFO = record 
    dwSize: DWORD;  
    byID: array[0..STREAM_ID_LEN-1] of BYTE;  //ID数据
    dwChannel: DWORD;  //关联设备通道，等于0xffffffff时，表示不关联
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_STREAM_INFO = ^NET_DVR_STREAM_INFO;

type
  NET_DVR_RTSP_PROTOCAL_CFG = record 
    byEnable: BYTE;  
    byLocalBackUp: BYTE;  //是否本地备份
    byRes: array[0..2-1] of BYTE;  
    strURL: array[0..URL_LEN_V40-1] of BYTE;  
    dwProtocalType: DWORD;  //协议类型
    sUserName: array[0..NAME_LEN-1] of BYTE;  //设备登陆用户名
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // 设备登陆密码
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //前端IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    wPort: WORD;  
    byRes1: array[0..122-1] of BYTE;  //保留
  end;
  LPNET_DVR_RTSP_PROTOCAL_CFG = ^NET_DVR_RTSP_PROTOCAL_CFG;

type
  NET_DVR_GET_STREAM_UNION = record 
    case Byte of
    0: (struChanInfo: NET_DVR_IPCHANINFO);  //IP通道信息
    1: (struIPServerStream: NET_DVR_IPSERVER_STREAM);  // IPServer去流
    2: (struPUStream: NET_DVR_PU_STREAM_CFG);  //  通过前端设备获取流媒体去流
    3: (struDDNSStream: NET_DVR_DDNS_STREAM_CFG);  //通过IPServer和流媒体取流
    4: (struStreamUrl: NET_DVR_PU_STREAM_URL);  //通过流媒体到url取流
    5: (struHkDDNSStream: NET_DVR_HKDDNS_STREAM);  //通过hiDDNS去取流
    6: (struIPChan: NET_DVR_IPCHANINFO_V40);  //直接从设备取流（扩展）
  end;
  LPNET_DVR_GET_STREAM_UNION = ^NET_DVR_GET_STREAM_UNION;

type
  GET_STREAM_TYPE =  
  (  
    NET_SDK_IP_DEVICE = 0,  
    NET_SDK_STREAM_MEDIA,  
    NET_SDK_IPSERVER,  
    NET_SDK_DDNS_STREAM_CFG,  
    NET_SDK_STREAM_MEDIA_URL,  
    NET_SDK_HKDDNS,  
    NET_SDK_IP_DEVICE_ADV,  
    NET_SDK_IP_DEVICE_V40,  
    NET_SDK_RTSP  
  );

type
  NET_DVR_STREAM_MODE = record 
    byGetStreamType: BYTE;  //取流方式GET_STREAM_TYPE，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流,3.通过IPServer找到设备，再通过流媒体去设备的流
    //4-通过流媒体由URL去取流,5-通过hkDDNS取流，6-直接从设备取流(扩展)，使用NET_DVR_IPCHANINFO_V40结构, 7-通过RTSP协议方式进行取流
    byRes: array[0..3-1] of BYTE;  //保留字节
    uGetStream: NET_DVR_GET_STREAM_UNION;  // 不同取流方式结构体
  end;
  LPNET_DVR_STREAM_MODE = ^NET_DVR_STREAM_MODE;

//扩展IP接入配置设备
type
  NET_DVR_IPPARACFG_V40 = record 
    dwSize: DWORD;  // 结构大小 
    dwGroupNum: DWORD;  //     设备支持的总组数
    dwAChanNum: DWORD;  //最大模拟通道个数
    dwDChanNum: DWORD;  //数字通道个数
    dwStartDChan: DWORD;  //起始数字通道
    byAnalogChanEnable: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 模拟通道是否启用，从低到高表示1-64通道，0表示无效 1有效 
    struIPDevInfo: array[0..MAX_IP_DEVICE_V40-1] of NET_DVR_IPDEVINFO_V31;  // IP设备 
    struStreamMode: array[0..MAX_CHANNUM_V30-1] of NET_DVR_STREAM_MODE;  
    byRes2: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_IPPARACFG_V40 = ^NET_DVR_IPPARACFG_V40;


//为CVR扩展的报警类型
type
  NET_DVR_ALARMINFO_DEV = record 
    dwAlarmType: DWORD;  //0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；
    //3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；
    //6-编码器(通道)移动侦测报警；7-编码器(通道)遮挡报警。；8-录像丢失报警; 9-视频实时显示报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    struTime: NET_DVR_TIME;  //报警时间
    byRes: array[0..32-1] of BYTE;  //保留
    dwNumber: DWORD;  //数目
    pNO: PWORD;  //dwNumber个WORD; 每个WORD表示一个通道号，或者磁盘号, 无效时为0
  end;
  LPNET_DVR_ALARMINFO_DEV = ^NET_DVR_ALARMINFO_DEV;

// 报警输出参数 
type
  NET_DVR_IPALARMOUTINFO = record 
    byIPID: BYTE;  // IP设备ID取值1- MAX_IP_DEVICE 
    byAlarmOut: BYTE;  // 报警输出号 
    byRes: array[0..18-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPALARMOUTINFO = ^NET_DVR_IPALARMOUTINFO;

// IP报警输出配置结构 
type
  NET_DVR_IPALARMOUTCFG = record 
    dwSize: DWORD;  // 结构大小 
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;  // IP报警输出 
  end;
  LPNET_DVR_IPALARMOUTCFG = ^NET_DVR_IPALARMOUTCFG;

// IP报警输出参数 
type
  NET_DVR_IPALARMOUTINFO_V40 = record 
    dwIPID: DWORD;  // IP设备ID 
    dwAlarmOut: DWORD;  // IP设备ID对应的报警输出号 
    byRes: array[0..32-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPALARMOUTINFO_V40 = ^NET_DVR_IPALARMOUTINFO_V40;//报警输出参数

type
  NET_DVR_IPALARMOUTCFG_V40 = record 
    dwSize: DWORD;  //结构体长度
    dwCurIPAlarmOutNum: DWORD;  
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT_V40-1] of NET_DVR_IPALARMOUTINFO_V40;  //IP报警输出
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_IPALARMOUTCFG_V40 = ^NET_DVR_IPALARMOUTCFG_V40;//IP报警输出

// 报警输入参数 
type
  NET_DVR_IPALARMININFO = record 
    byIPID: BYTE;  // IP设备ID取值1- MAX_IP_DEVICE 
    byAlarmIn: BYTE;  // 报警输入号 
    byRes: array[0..18-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPALARMININFO = ^NET_DVR_IPALARMININFO;

// IP报警输入配置结构 
type
  NET_DVR_IPALARMINCFG = record 
    dwSize: DWORD;  // 结构大小 
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;  // IP报警输入 
  end;
  LPNET_DVR_IPALARMINCFG = ^NET_DVR_IPALARMINCFG;

// IP报警输入参数 
type
  NET_DVR_IPALARMININFO_V40 = record 
    dwIPID: DWORD;  // IP设备ID 
    dwAlarmIn: DWORD;  // IP设备ID对应的报警输入号 
    byRes: array[0..32-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_IPALARMININFO_V40 = ^NET_DVR_IPALARMININFO_V40;// 报警输入参数 

type
  NET_DVR_IPALARMINCFG_V40 = record 
    dwSize: DWORD;  //结构体长度
    dwCurIPAlarmInNum: DWORD;  //当前报警输入口数
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN_V40-1] of NET_DVR_IPALARMININFO_V40;  // IP报警输入
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_IPALARMINCFG_V40 = ^NET_DVR_IPALARMINCFG_V40;//IP报警输入资源

//ipc alarm info
type
  NET_DVR_IPALARMINFO = record 
    struIPDevInfo: array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO;  // IP设备 
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM-1] of BYTE;  // 模拟通道是否启用，0-未启用 1-启用 
    struIPChanInfo: array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;  // IP通道 
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;  // IP报警输入 
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;  // IP报警输出 
  end;
  LPNET_DVR_IPALARMINFO = ^NET_DVR_IPALARMINFO;

//ipc配置改变报警信息扩展 9000_1.1
type
  NET_DVR_IPALARMINFO_V31 = record 
    struIPDevInfo: array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO_V31;  // IP设备 
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM-1] of BYTE;  // 模拟通道是否启用，0-未启用 1-启用 
    struIPChanInfo: array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;  // IP通道 
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;  // IP报警输入 
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;  // IP报警输出 
  end;
  LPNET_DVR_IPALARMINFO_V31 = ^NET_DVR_IPALARMINFO_V31;

type
  NET_DVR_IPALARMINFO_V40 = record 
    struIPDevInfo: array[0..MAX_IP_DEVICE_V40-1] of NET_DVR_IPDEVINFO_V31;  // IP设备
    byAnalogChanEnable: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 模拟通道是否启用，0-未启用 1-启用 
    struIPChanInfo: array[0..MAX_CHANNUM_V30-1] of NET_DVR_IPCHANINFO;  // IP通道 
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;  // IP报警输入 
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;  // IP报警输出 
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_IPALARMINFO_V40 = ^NET_DVR_IPALARMINFO_V40;

type
  HD_STAT =  
  (  
    HD_STAT_OK = 0,  // 正常 
    HD_STAT_UNFORMATTED = 1,  // 未格式化 
    HD_STAT_ERROR = 2,  // 错误 
    HD_STAT_SMART_FAILED = 3,  // SMART状态 
    HD_STAT_MISMATCH = 4,  // 不匹配 
    HD_STAT_IDLE = 5,  // 休眠
    NET_HD_STAT_OFFLINE = 6,  // 网络盘处于未连接状态 
    HD_RIADVD_EXPAND = 7,  // 虚拟磁盘可扩容 
    HD_STAT_REPARING = 10,  // 硬盘正在修复(9000 2.0) 
    HD_STAT_FORMATING = 11  // 硬盘正在格式化(9000 2.0) 
  );


//本地硬盘信息配置
type
  NET_DVR_SINGLE_HD = record 
    dwHDNo: DWORD;  //硬盘号, 取值0~MAX_DISKNUM_V30-1
    dwCapacity: DWORD;  //硬盘容量(不可设置)
    dwFreeSpace: DWORD;  //硬盘剩余空间(不可设置)
    dwHdStatus: DWORD;  //硬盘状态(不可设置) HD_STAT 0-正常, 1-未格式化, 2-错误, 3-SMART状态,
    //4-不匹配, 5-休眠 6-网络硬盘不在线 7-虚拟磁盘可扩容 10-硬盘正在修复
    //11-硬盘正在格式化 12-硬盘正在等待格式化 13-硬盘已卸载 14-本地硬盘不存在
    //15-正在删除(网络硬盘),16-已锁定
    byHDAttr: BYTE;  //0-普通, 1-冗余; 2-只读 3-存档（CVR专用），4-不可读写
    byHDType: BYTE;  //0-本地硬盘,1-ESATA硬盘,2-NAS硬盘,3-iSCSI硬盘 4-Array虚拟磁盘,5-SD卡,6-minSAS
    byDiskDriver: BYTE;  // 值 代表其ASCII字符
    byRes1: BYTE;  
    dwHdGroup: DWORD;  //属于哪个盘组 1-MAX_HD_GROUP
    byRecycling: BYTE;  // 是否循环利用 0：不循环利用，1：循环利用
    bySupportFormatType: BYTE;  {当前硬盘所支持的格式化类型,只读。当前该节点仅支持byHDType=5(SD卡)时;
                                  若bySupportFormatType=0,则代表设备将以自身的默认类型来格式化硬盘;
                                  bySupportFormatType:bit0: 0-代表不支持FAT32格式化类型,1-代表支持;
                                  bySupportFormatType:bit1: 0-代表不支持EXT4格式化类型,1-代表支持;}
    byFormatType: BYTE;  {当前硬盘格式化类型配置: 0-设备默认格式化类型,1-指定FAT32格式化(byHDType=5(SD卡)时生效),
                                2-指定EXT4格式化(byHDType=5(SD卡)时生效)}
    byRes2: BYTE;  
    dwStorageType: DWORD;  //按位表示 0-不支持 非0-支持
    // dwStorageType & 0x1 表示是否是普通录像专用存储盘
    // dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
    // dwStorageType & 0x4 表示是否是图片录像专用存储盘

    dwPictureCapacity: DWORD;  //硬盘图片容量(不可设置)，单位:MB
    dwFreePictureSpace: DWORD;  //剩余图片空间(不可设置)，单位:MB
    byRes3: array[0..104-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_HD = ^NET_DVR_SINGLE_HD;

type
  NET_DVR_HDCFG = record 
    dwSize: DWORD;  
    dwHDCount: DWORD;  //硬盘数(不可设置)
    struHDInfo: array[0..MAX_DISKNUM_V30-1] of NET_DVR_SINGLE_HD;  //硬盘相关操作都需要重启才能生效；
  end;
  LPNET_DVR_HDCFG = ^NET_DVR_HDCFG;

//本地硬盘信息配置
type
  NET_DVR_SINGLE_HD_V50 = record 
    dwHDNo: DWORD;  //硬盘号, 取值0~MAX_DISKNUM_V30-1
    dwCapacity: DWORD;  //硬盘容量(不可设置)
    dwFreeSpace: DWORD;  //硬盘剩余空间(不可设置)
    dwHdStatus: DWORD;  //硬盘状态(不可设置) HD_STAT 0-正常, 1-未格式化, 2-错误, 3-SMART状态,
    //4-不匹配, 5-休眠 6-网络硬盘不在线 7-虚拟磁盘可扩容 10-硬盘正在修复
    //11-硬盘正在格式化 12-硬盘正在等待格式化 13-硬盘已卸载 14-本地硬盘不存在
    //15-正在删除(网络硬盘),16-已锁定,17-警告（随时会变成坏盘）,18-坏盘（已经损坏的硬盘）,19-隐患盘（出现异常被踢出阵列，比如出现坏扇区）,20-未认证（未检测，需要到CVR中对磁盘进行检测）
    //21-未在录播主机中格式化
    byHDAttr: BYTE;  //0-普通, 1-冗余; 2-只读，3-存档，4-不可读写
    byHDType: BYTE;  //0-本地硬盘,1-ESATA硬盘,2-NAS硬盘,3-iSCSI硬盘 4-Array虚拟磁盘,5-SD卡,6-minSAS
    byDiskDriver: BYTE;  // 值 代表其ASCII字符
    byGenusGruop: BYTE;  //属组：0-保留，1-阵列，2-存储池，3-阵列踢盘，4-未初始化，5-无效盘，6-区域热备，7-全局热备，只读
    dwHdGroup: DWORD;  //属于哪个盘组 1-MAX_HD_GROUP
    byRecycling: BYTE;  // 是否循环利用 0：不循环利用，1：循环利用
    bySupportFormatType: BYTE;  {当前硬盘所支持的格式化类型,只读。当前该节点仅支持byHDType=5(SD卡)时;
                                  若bySupportFormatType=0,则代表设备将以自身的默认类型来格式化硬盘;
                                  bySupportFormatType:bit0: 0-代表不支持FAT32格式化类型,1-代表支持;
                                  bySupportFormatType:bit1: 0-代表不支持EXT4格式化类型,1-代表支持;}
    byFormatType: BYTE;  {当前硬盘格式化类型配置: 0-设备默认格式化类型,1-指定FAT32格式化(byHDType=5(SD卡)时生效),
                                2-指定EXT4格式化(byHDType=5(SD卡)时生效)}
    byRes2: BYTE;  
    dwStorageType: DWORD;  //按位表示 0-不支持 非0-支持
    // dwStorageType & 0x1 表示是否是普通录像专用存储盘
    // dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
    // dwStorageType & 0x4 表示是否是图片录像专用存储盘

    dwPictureCapacity: DWORD;  //硬盘图片容量(不可设置)，单位:MB
    dwFreePictureSpace: DWORD;  //剩余图片空间(不可设置)，单位:MB
    byDiskLocation: array[0..NET_SDK_DISK_LOCATION_LEN{16}-1] of BYTE;  //硬盘位置，具体格式见备注，只读
    bySupplierName: array[0..NET_SDK_SUPPLIER_NAME_LEN{32}-1] of BYTE;  //供应商名称，只读
    byDiskModel: array[0..NET_SDK_DISK_MODEL_LEN{64}-1] of BYTE;  //硬盘型号，只读
    szHDLocateIP: array[0..SDK_MAX_IP_LEN-1] of AnsiChar;  //磁盘所在IP信息
    byRes3: array[0..80-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_HD_V50 = ^NET_DVR_SINGLE_HD_V50;

type
  NET_DVR_HDCFG_V50 = record 
    dwSize: DWORD;  
    dwHDCount: DWORD;  //硬盘数(不可设置)
    struHDInfoV50: array[0..MAX_DISKNUM_V30-1] of NET_DVR_SINGLE_HD_V50;  //硬盘相关操作都需要重启才能生效；
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_HDCFG_V50 = ^NET_DVR_HDCFG_V50;

type
  NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO = record 
    dwSize: DWORD;  
    byHDVolumeNo: BYTE;  //硬盘卷ID(不可设置)
    byType: BYTE;  {硬盘卷类型:0-录像卷（用于保存录像），1-存档卷（用于存档录像，下发录像计划时，不能关联存档卷）,
                        2-文件卷（只用于存储客户端上传的文件，下发录像计划时，不能关联文件卷，需要过滤掉）3-图片卷（只用于存储客户端上传的图片）}
    byRes1: array[0..2-1] of BYTE;  
    dwCapacity: DWORD;  //硬盘卷容量，单位MB(不可设置)
    dwFreeSpace: DWORD;  //硬盘卷剩余空间，单位MB(不可设置) 
    byHDVolumeName: array[0..NET_SDK_DISK_VOLUME_LEN{36}-1] of BYTE;  //硬盘卷名称(不可设置)
    byLoopCover: BYTE;  //是否循环覆盖：0-非循环覆盖，1-循环覆盖（硬盘卷满了之后，循环覆盖最老的录像）
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO = ^NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO;

type
  NET_DVR_HARD_DISK_VOLUME_INFO = record 
    dwSize: DWORD;  
    dwHDVolumeCount: DWORD;  //当前硬盘卷总数(不可设置)
    struSingleVolumeInfo: array[0..NET_SDK_MAX_DISK_VOLUME{33}-1] of NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO;  //单个硬盘卷信息
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_HARD_DISK_VOLUME_INFO = ^NET_DVR_HARD_DISK_VOLUME_INFO;

//本地盘组信息配置扩展
type
  NET_DVR_SINGLE_HDGROUP_V40 = record 
    dwHDGroupNo: DWORD;  //盘组号(不可设置) 1-MAX_HD_GROUP
    dwRelRecordChan: array[0..MAX_CHANNUM_V40-1] of DWORD;  //触发的录像通道，按值表示，遇到0xffffffff时后续视为无效
    byRes: array[0..64-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_SINGLE_HDGROUP_V40 = ^NET_DVR_SINGLE_HDGROUP_V40;

type
  NET_DVR_HDGROUP_CFG_V40 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxHDGroupNum: DWORD;  //设备支持的最大盘组数-只读
    dwCurHDGroupNum: DWORD;  //当前配置的盘组数
    struHDGroupAttr: array[0..MAX_HD_GROUP-1] of NET_DVR_SINGLE_HDGROUP_V40;  //硬盘相关操作都需要重启才能生效；
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_HDGROUP_CFG_V40 = ^NET_DVR_HDGROUP_CFG_V40;

//本地盘组信息配置
type
  NET_DVR_SINGLE_HDGROUP = record 
    dwHDGroupNo: DWORD;  //盘组号(不可设置) 1-MAX_HD_GROUP
    byHDGroupChans: array[0..MAX_CHANNUM_V30-1] of BYTE;  //盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_HDGROUP = ^NET_DVR_SINGLE_HDGROUP;

type
  NET_DVR_HDGROUP_CFG = record 
    dwSize: DWORD;  
    dwHDGroupCount: DWORD;  //盘组总数(不可设置)
    struHDGroupAttr: array[0..MAX_HD_GROUP-1] of NET_DVR_SINGLE_HDGROUP;  //硬盘相关操作都需要重启才能生效；
  end;
  LPNET_DVR_HDGROUP_CFG = ^NET_DVR_HDGROUP_CFG;


//配置缩放参数的结构
type
  NET_DVR_SCALECFG = record 
    dwSize: DWORD;  
    dwMajorScale: DWORD;  // 主显示 0-不缩放，1-缩放
    dwMinorScale: DWORD;  // 辅显示 0-不缩放，1-缩放
    dwRes: array[0..2-1] of DWORD;  
  end;
  LPNET_DVR_SCALECFG = ^NET_DVR_SCALECFG;



//DVR报警输出(9000扩展)
type
  NET_DVR_ALARMOUTCFG_V30 = record 
    dwSize: DWORD;  
    sAlarmOutName: array[0..NAME_LEN-1] of BYTE;  // 名称 
    dwAlarmOutDelay: DWORD;  // 输出保持时间(-1为无限，手动关闭) 
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动,8-1秒,9-2秒,10-3秒,11-4秒
    struAlarmOutTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  // 报警输出激活时间段 
    byAlarmOutHandle: BYTE;  // 是否处理 0-处理 1-不处理
    byNormalSatus: BYTE;  // 常态 0-常开 1-常闭
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_ALARMOUTCFG_V30 = ^NET_DVR_ALARMOUTCFG_V30;

//DVR报警输出
type
  NET_DVR_ALARMOUTCFG = record 
    dwSize: DWORD;  
    sAlarmOutName: array[0..NAME_LEN-1] of BYTE;  // 名称 
    dwAlarmOutDelay: DWORD;  // 输出保持时间(-1为无限，手动关闭) 
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动, 8-1秒, 9-3秒
    struAlarmOutTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  // 报警输出激活时间段 
  end;
  LPNET_DVR_ALARMOUTCFG = ^NET_DVR_ALARMOUTCFG;

//DVR本地预览参数(9000扩展)
{切换是指在当前预览模式下切换显示画面，而不是切换预览模式。比如byPreviewNumber为0（1画面），bySwitchSeq[0][0] = 1,bySwitchSeq[0][1] = 2,bySwitchSeq[0][2] = 3
则本地画面一直是1画面，然后在输出画面按1,2,3通道顺序切换}
type
  NET_DVR_PREVIEWCFG_V30 = record 
    dwSize: DWORD;  
    byPreviewNumber: BYTE;  //预览模式,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    byEnableAudio: BYTE;  //是否声音预览,0-不预览,1-预览
    wSwitchTime: WORD;  //切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    bySwitchSeq: array[0..MAX_PREVIEW_MODE-1, 0..MAX_WINDOW_V30-1] of BYTE;  //切换顺序,如果lSwitchSeq[i]为 0xff表示不用
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEWCFG_V30 = ^NET_DVR_PREVIEWCFG_V30;

//DVR本地预览参数
type
  NET_DVR_PREVIEWCFG = record 
    dwSize: DWORD;  
    byPreviewNumber: BYTE;  //预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    byEnableAudio: BYTE;  //是否声音预览,0-不预览,1-预览
    wSwitchTime: WORD;  //切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    bySwitchSeq: array[0..MAX_WINDOW-1] of BYTE;  //切换顺序,如果lSwitchSeq[i]为 0xff表示不用
  end;
  LPNET_DVR_PREVIEWCFG = ^NET_DVR_PREVIEWCFG;

//DVR视频输出
type
  NET_DVR_VGAPARA = record 
    wResolution: WORD;  // 分辨率 
    wFreq: WORD;  // 刷新频率 
    dwBrightness: DWORD;  // 亮度 
  end;
  LPNET_DVR_VGAPARA = ^NET_DVR_VGAPARA;

{
* MATRIX输出参数结构
}
type
  NET_DVR_MATRIXPARA_V30 = record 
    wOrder: array[0..MAX_ANALOG_CHANNUM-1] of WORD;  // 预览顺序, 0xff表示相应的窗口不预览 
    wSwitchTime: WORD;  // 预览切换时间 
    res: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXPARA_V30 = ^NET_DVR_MATRIXPARA_V30;

type
  NET_DVR_MATRIXPARA = record 
    wDisplayLogo: WORD;  // 显示视频通道号 
    wDisplayOsd: WORD;  // 显示时间 
  end;
  LPNET_DVR_MATRIXPARA = ^NET_DVR_MATRIXPARA;

type
  NET_DVR_VOOUT = record 
    byVideoFormat: BYTE;  // 输出制式,0-PAL,1-NTSC 
    byMenuAlphaValue: BYTE;  // 菜单与背景图象对比度 
    wScreenSaveTime: WORD;  // 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟 
    wVOffset: WORD;  // 视频输出偏移 
    wBrightness: WORD;  // 视频输出亮度 
    byStartMode: BYTE;  // 启动后视频输出模式(0:菜单,1:预览)
    byEnableScaler: BYTE;  // 是否启动缩放 (0-不启动, 1-启动)
  end;
  LPNET_DVR_VOOUT = ^NET_DVR_VOOUT;

//DVR视频输出(9000扩展)
type
  NET_DVR_VIDEOOUT_V30 = record 
    dwSize: DWORD;  
    struVOOut: array[0..MAX_VIDEOOUT_V30-1] of NET_DVR_VOOUT;  
    struVGAPara: array[0..MAX_VGA_V30-1] of NET_DVR_VGAPARA;  // VGA参数 
    struMatrixPara: array[0..MAX_MATRIXOUT-1] of NET_DVR_MATRIXPARA_V30;  // MATRIX参数 
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOOUT_V30 = ^NET_DVR_VIDEOOUT_V30;

//DVR视频输出
type
  NET_DVR_VIDEOOUT = record 
    dwSize: DWORD;  
    struVOOut: array[0..MAX_VIDEOOUT-1] of NET_DVR_VOOUT;  
    struVGAPara: array[0..MAX_VGA-1] of NET_DVR_VGAPARA;  // VGA参数 
    struMatrixPara: NET_DVR_MATRIXPARA;  // MATRIX参数 
  end;
  LPNET_DVR_VIDEOOUT = ^NET_DVR_VIDEOOUT;


//单用户参数(子结构)(扩展)
type
  NET_DVR_USER_INFO_V40 = record 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名只能用16字节 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    byLocalRight: array[0..MAX_RIGHT-1] of BYTE;  // 本地权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    //数组6: 本地查看参数 
    //数组7: 本地管理模拟和IP camera 
    //数组8: 本地备份 
    //数组9: 本地关机/重启 
    byRemoteRight: array[0..MAX_RIGHT-1] of BYTE;  // 远程权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    //数组11: 远程查看参数 
    //数组12: 远程管理模拟和IP camera 
    //数组13: 远程关机/重启 
    dwNetPreviewRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalRecordRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetRecordRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPlaybackRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPlaybackRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPTZRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPTZRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalBackupRight: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址 
    byPriority: BYTE;  // 优先级，0xff-无，0--低，1--中，2--高 
                                        { 无……表示不支持优先级的设置
                                        低……默认权限:包括本地和远程回放,本地和远程查看日志和
                                        状态,本地和远程关机/重启
                                        中……包括本地和远程控制云台,本地和远程手动录像,本地和
                                        远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启
    高……管理员 }
    byAlarmOnRight: BYTE;  // 报警输入口布防权限 1-有权限，0-无权限
    byAlarmOffRight: BYTE;  // 报警输入口撤防权限 1-有权限，0-无权限
    byBypassRight: BYTE;  // 报警输入口旁路权限 1-有权限，0-无权限
    byRes1: array[0..2-1] of BYTE;  //四字节对齐
    byPublishRight: array[0..MAX_RIGHT-1] of BYTE;  //信息发布专有权限
    //数组0: 素材审核权限
    //数组1: 节目审核权限
    //数组2: 日程审核权限
    //数组3: 上传素材权限
    //数组4: 新建节目权限
    //数组5: 新建日程权限
    //数组6: 信息播放权限
    //数组7: 终端管理权限
    //数组8: 商业智能权限
    byRes: array[0..84-1] of BYTE;  
  end;
  LPNET_DVR_USER_INFO_V40 = ^NET_DVR_USER_INFO_V40;

//单用户参数(子结构)(扩展)
type
  NET_DVR_USER_INFO_V51 = record 
    sUserName: array[0..NAME_LEN{32}-1] of BYTE;  // 用户名只能用16字节 
    sPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  // 密码 
    byLocalRight: array[0..MAX_RIGHT{32}-1] of BYTE;  // 本地权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    //数组6: 本地查看参数 
    //数组7: 本地管理模拟和IP camera 
    //数组8: 本地备份 
    //数组9: 本地关机/重启 
    //数组10: 本地预览 
    byRemoteRight: array[0..MAX_RIGHT{32}-1] of BYTE;  // 远程权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    //数组11: 远程查看参数 
    //数组12: 远程管理模拟和IP camera 
    //数组13: 远程关机/重启 
    dwNetPreviewRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalRecordRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetRecordRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPTZRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPTZRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalBackupRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPreviewRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN{6}-1] of BYTE;  // 物理地址 
    byPriority: BYTE;  // 优先级，0xff-无，0--低，1--中，2--高 
    { 无……表示不支持优先级的设置
    低……默认权限:包括本地和远程回放,本地和远程查看日志和
    状态,本地和远程关机/重启
    中……包括本地和远程控制云台,本地和远程手动录像,本地和
    远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员 }
    byAlarmOnRight: BYTE;  // 报警输入口布防权限 1-有权限，0-无权限
    byAlarmOffRight: BYTE;  // 报警输入口撤防权限 1-有权限，0-无权限
    byBypassRight: BYTE;  // 报警输入口旁路权限 1-有权限，0-无权限
    byRes1: array[0..2-1] of BYTE;  //四字节对齐
    byPublishRight: array[0..MAX_RIGHT{32}-1] of BYTE;  //信息发布专有权限
    //数组0: 素材审核权限
    //数组1: 节目审核权限
    //数组2: 日程审核权限
    //数组3: 上传素材权限
    //数组4: 新建节目权限
    //数组5: 新建日程权限
    //数组6: 信息播放权限
    //数组7: 终端管理权限
    //数组8: 商业智能权限
    dwPasswordValidity: DWORD;  //密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
    byKeypadPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  //键盘密码
    byUserOperateType: BYTE;  //用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
    byRes: array[0..1007-1] of BYTE;  
  end;
  LPNET_DVR_USER_INFO_V51 = ^NET_DVR_USER_INFO_V51;

type
  NET_DVR_USER_V51 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxUserNum: DWORD;  //设备支持的最大用户数-只读
    struUser: array[0..MAX_USERNUM_V30{32}-1] of NET_DVR_USER_INFO_V51;  // 用户参数 
    sloginPassword: array[0..PASSWD_LEN{16}-1] of AnsiChar;  // 登陆密码确认 
    byRes: array[0..240-1] of BYTE;  //保留
  end;
  LPNET_DVR_USER_V51 = ^NET_DVR_USER_V51;

//单用户参数(子结构)(扩展)
type
  NET_DVR_USER_INFO_V52 = record 
    sUserName: array[0..NAME_LEN{32}-1] of BYTE;  // 用户名只能用16字节 
    sPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  // 密码 
    byLocalRight: array[0..MAX_RIGHT{32}-1] of BYTE;  // 本地权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    //数组6: 本地查看参数 
    //数组7: 本地管理模拟和IP camera 
    //数组8: 本地备份 
    //数组9: 本地关机/重启 
    //数组10: 本地预览 
    byRemoteRight: array[0..MAX_RIGHT{32}-1] of BYTE;  // 远程权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    //数组11: 远程查看参数 
    //数组12: 远程管理模拟和IP camera 
    //数组13: 远程关机/重启 
    dwNetPreviewRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalRecordRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetRecordRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPTZRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetPTZRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalBackupRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalPreviewRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalDoubleVerificationPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwLocalDoubleVerificationBackupRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 本地可以二次认证备份的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    dwNetDoubleVerificationPlaybackRight: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 远程可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN{6}-1] of BYTE;  // 物理地址 
    byPriority: BYTE;  // 优先级，0xff-无，0--低，1--中，2--高 
    { 无……表示不支持优先级的设置
    低……默认权限:包括本地和远程回放,本地和远程查看日志和
    状态,本地和远程关机/重启
    中……包括本地和远程控制云台,本地和远程手动录像,本地和
    远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员 }
    byAlarmOnRight: BYTE;  // 报警输入口布防权限 1-有权限，0-无权限
    byAlarmOffRight: BYTE;  // 报警输入口撤防权限 1-有权限，0-无权限
    byBypassRight: BYTE;  // 报警输入口旁路权限 1-有权限，0-无权限
    byRes1: array[0..2-1] of BYTE;  //四字节对齐
    byPublishRight: array[0..MAX_RIGHT{32}-1] of BYTE;  //信息发布专有权限
    //数组0: 素材审核权限
    //数组1: 节目审核权限
    //数组2: 日程审核权限
    //数组3: 上传素材权限
    //数组4: 新建节目权限
    //数组5: 新建日程权限
    //数组6: 信息播放权限
    //数组7: 终端管理权限
    //数组8: 商业智能权限
    dwPasswordValidity: DWORD;  //密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
    byKeypadPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  //键盘密码
    byUserOperateType: BYTE;  //用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
    byRes: array[0..1007-1] of BYTE;  
  end;
  LPNET_DVR_USER_INFO_V52 = ^NET_DVR_USER_INFO_V52;

type
  NET_DVR_USER_V52 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxUserNum: DWORD;  //设备支持的最大用户数-只读
    struUser: array[0..MAX_USERNUM_V30{32}-1] of NET_DVR_USER_INFO_V52;  // 用户参数 
    sloginPassword: array[0..PASSWD_LEN{16}-1] of AnsiChar;  // 登陆密码确认 
    byRes: array[0..240-1] of BYTE;  //保留
  end;
  LPNET_DVR_USER_V52 = ^NET_DVR_USER_V52;

//单用户参数(子结构)(9000扩展)
type
  NET_DVR_USER_INFO_V30 = record 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    byLocalRight: array[0..MAX_RIGHT-1] of BYTE;  // 本地权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    //数组6: 本地查看参数 
    //数组7: 本地管理模拟和IP camera 
    //数组8: 本地备份 
    //数组9: 本地关机/重启 
    byRemoteRight: array[0..MAX_RIGHT-1] of BYTE;  // 远程权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    //数组11: 远程查看参数 
    //数组12: 远程管理模拟和IP camera 
    //数组13: 远程关机/重启 
    byNetPreviewRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 远程可以预览的通道 0-有权限，1-无权限
    byLocalPlaybackRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 本地可以回放的通道 0-有权限，1-无权限
    byNetPlaybackRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 远程可以回放的通道 0-有权限，1-无权限
    byLocalRecordRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 本地可以录像的通道 0-有权限，1-无权限
    byNetRecordRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 远程可以录像的通道 0-有权限，1-无权限
    byLocalPTZRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 本地可以PTZ的通道 0-有权限，1-无权限
    byNetPTZRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 远程可以PTZ的通道 0-有权限，1-无权限
    byLocalBackupRight: array[0..MAX_CHANNUM_V30-1] of BYTE;  // 本地备份权限通道 0-有权限，1-无权限
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址 
    byPriority: BYTE;  // 优先级，0xff-无，0--低，1--中，2--高 
                                    {
                                    无……表示不支持优先级的设置
                                    低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启
                                    中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览
                                    本地备份,本地/远程关机/重启
                                    高……管理员
    }
    byAlarmOnRight: BYTE;  // 报警输入口布防权限
    byAlarmOffRight: BYTE;  // 报警输入口撤防权限
    byBypassRight: BYTE;  // 报警输入口旁路权限
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_USER_INFO_V30 = ^NET_DVR_USER_INFO_V30;

//单用户参数(SDK_V15扩展)(子结构)
type
  NET_DVR_USER_INFO_EX = record 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwLocalRight: array[0..MAX_RIGHT-1] of DWORD;  // 权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    dwLocalPlaybackRight: DWORD;  // 本地可以回放的通道 bit0 -- channel 1
    dwRemoteRight: array[0..MAX_RIGHT-1] of DWORD;  // 权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    dwNetPreviewRight: DWORD;  // 远程可以预览的通道 bit0 -- channel 1
    dwNetPlaybackRight: DWORD;  // 远程可以回放的通道 bit0 -- channel 1
    sUserIP: array[0..16-1] of AnsiChar;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址 
  end;
  LPNET_DVR_USER_INFO_EX = ^NET_DVR_USER_INFO_EX;

//单用户参数(子结构)
type
  NET_DVR_USER_INFO = record 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwLocalRight: array[0..MAX_RIGHT-1] of DWORD;  // 权限 
    //数组0: 本地控制云台
    //数组1: 本地手动录象
    //数组2: 本地回放
    //数组3: 本地设置参数
    //数组4: 本地查看状态、日志
    //数组5: 本地高级操作(升级，格式化，重启，关机)
    dwRemoteRight: array[0..MAX_RIGHT-1] of DWORD;  // 权限 
    //数组0: 远程控制云台
    //数组1: 远程手动录象
    //数组2: 远程回放 
    //数组3: 远程设置参数
    //数组4: 远程查看状态、日志
    //数组5: 远程高级操作(升级，格式化，重启，关机)
    //数组6: 远程发起语音对讲
    //数组7: 远程预览
    //数组8: 远程请求报警上传、报警输出
    //数组9: 远程控制，本地输出
    //数组10: 远程控制串口
    sUserIP: array[0..16-1] of AnsiChar;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址 
  end;
  LPNET_DVR_USER_INFO = ^NET_DVR_USER_INFO;

//DVR用户参数(扩展)
type
  NET_DVR_USER_V40 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxUserNum: DWORD;  //设备支持的最大用户数-只读
    struUser: array[0..MAX_USERNUM_V30-1] of NET_DVR_USER_INFO_V40;  // 用户参数 
  end;
  LPNET_DVR_USER_V40 = ^NET_DVR_USER_V40;
type
  NET_DVR_USER_V50 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxUserNum: DWORD;  //设备支持的最大用户数-只读
    struUser: array[0..MAX_USERNUM_V30-1] of NET_DVR_USER_INFO_V40;  // 用户参数 
    sloginPassword: array[0..PASSWD_LEN{16}-1] of AnsiChar;  // 登陆密码确认 
    byRes: array[0..240-1] of BYTE;  //保留
  end;
  LPNET_DVR_USER_V50 = ^NET_DVR_USER_V50;
//DVR用户参数(9000扩展)
type
  NET_DVR_USER_V30 = record 
    dwSize: DWORD;  
    struUser: array[0..MAX_USERNUM_V30-1] of NET_DVR_USER_INFO_V30;  
  end;
  LPNET_DVR_USER_V30 = ^NET_DVR_USER_V30;

//DVR用户参数(SDK_V15扩展)
type
  NET_DVR_USER_EX = record 
    dwSize: DWORD;  
    struUser: array[0..MAX_USERNUM-1] of NET_DVR_USER_INFO_EX;  
  end;
  LPNET_DVR_USER_EX = ^NET_DVR_USER_EX;

//DVR用户参数
type
  NET_DVR_USER = record 
    dwSize: DWORD;  
    struUser: array[0..MAX_USERNUM-1] of NET_DVR_USER_INFO;  
  end;
  LPNET_DVR_USER = ^NET_DVR_USER;

type
  NET_DVR_EXCEPTION_V40 = record 
    dwSize: DWORD;  //结构体大小
    dwMaxGroupNum: DWORD;  //设备支持的最大组数
    struExceptionHandle: array[0..MAX_EXCEPTIONNUM_V30-1] of NET_DVR_HANDLEEXCEPTION_V41;  
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_EXCEPTION_V40 = ^NET_DVR_EXCEPTION_V40;//异常参数配置扩展结构体

//DVR异常参数(9000扩展)
type
  NET_DVR_EXCEPTION_V30 = record 
    dwSize: DWORD;  
    struExceptionHandleType: array[0..MAX_EXCEPTIONNUM_V30-1] of NET_DVR_HANDLEEXCEPTION_V30;  
    //数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突, 4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常, 7-录像异常 8-阵列异常，9-前端/录像分辨率不匹配异常，10-行车超速(车载专用) 11-热备异常（N+1使用）12-温度，13-子系统异常，14-风扇异常, 15-POE供电异常, 16-POC异常,数组17-电源电压波动异常
  end;
  LPNET_DVR_EXCEPTION_V30 = ^NET_DVR_EXCEPTION_V30;



//DVR异常参数
type
  NET_DVR_EXCEPTION = record 
    dwSize: DWORD;  
    struExceptionHandleType: array[0..MAX_EXCEPTIONNUM-1] of NET_DVR_HANDLEEXCEPTION;  
    //数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常
  end;
  LPNET_DVR_EXCEPTION = ^NET_DVR_EXCEPTION;

//通道状态(9000扩展)
type
  NET_DVR_CHANNELSTATE_V30 = record 
    byRecordStatic: BYTE;  //通道是否在录像,0-不录像,1-录像
    bySignalStatic: BYTE;  //连接的信号状态,0-正常,1-信号丢失
    byHardwareStatic: BYTE;  //通道硬件状态,0-正常,1-异常,例如DSP死掉
    byRes1: BYTE;  //保留
    dwBitRate: DWORD;  //实际码率
    dwLinkNum: DWORD;  //客户端连接的个数
    struClientIP: array[0..MAX_LINK-1] of NET_DVR_IPADDR;  //客户端的IP地址
    dwIPLinkNum: DWORD;  //如果该通道为IP接入，那么表示IP接入当前的连接数
    byExceedMaxLink: BYTE;  // 是否超出了单路6路连接数 0 - 未超出, 1-超出
    byRes: array[0..3-1] of BYTE;  // 保留字节
    dwAllBitRate: DWORD;  //所有实际码率之和
    dwChannelNo: DWORD;  //当前的通道号，0xffffffff表示无效
  end;
  LPNET_DVR_CHANNELSTATE_V30 = ^NET_DVR_CHANNELSTATE_V30;

//通道状态
type
  NET_DVR_CHANNELSTATE = record 
    byRecordStatic: BYTE;  //通道是否在录像,0-不录像,1-录像
    bySignalStatic: BYTE;  //连接的信号状态,0-正常,1-信号丢失
    byHardwareStatic: BYTE;  //通道硬件状态,0-正常,1-异常,例如DSP死掉
    reservedData: AnsiChar;  //保留
    dwBitRate: DWORD;  //实际码率
    dwLinkNum: DWORD;  //客户端连接的个数
    dwClientIP: array[0..MAX_LINK-1] of DWORD;  //客户端的IP地址
  end;
  LPNET_DVR_CHANNELSTATE = ^NET_DVR_CHANNELSTATE;

//硬盘状态
type
  NET_DVR_DISKSTATE = record 
    dwVolume: DWORD;  //硬盘的容量
    dwFreeSpace: DWORD;  //硬盘的剩余空间
    dwHardDiskStatic: DWORD;  //硬盘的状态,按位:1-休眠,2-不正常,3-休眠硬盘出错,4-未格式化, 5-未连接状态(网络硬盘),6-硬盘正在格式化,7-硬盘满(未开启循环覆盖的情况下),8-其他异常（待设备端统计）
  end;
  LPNET_DVR_DISKSTATE = ^NET_DVR_DISKSTATE;

type
  NET_DVR_WORKSTATE_V40 = record 
    dwSize: DWORD;  //结构体大小
    dwDeviceStatic: DWORD;  //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    struHardDiskStatic: array[0..MAX_DISKNUM_V30-1] of NET_DVR_DISKSTATE;  //硬盘状态,一次最多只能获取33个硬盘信息
    struChanStatic: array[0..MAX_CHANNUM_V40{512}-1] of NET_DVR_CHANNELSTATE_V30;  //通道的状态，从前往后顺序排列
    dwHasAlarmInStatic: array[0..MAX_ALARMIN_V40{512}-1] of DWORD;  //有报警的报警输入口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    dwHasAlarmOutStatic: array[0..MAX_ALARMOUT_V40{512}-1] of DWORD;  //有报警输出的报警输出口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    dwLocalDisplay: DWORD;  //本地显示状态,0-正常,1-不正常
    byAudioInChanStatus: array[0..MAX_AUDIO_V30{2}-1] of BYTE;  //按位表示语音通道的状态 0-未使用，1-使用中，第0位表示第1个语音通道
    byRes1: array[0..2-1] of BYTE;  
    fHumidity: FLOAT;  //传感器获知的湿度,范围:0.0 ~100.0
    fTemperature: FLOAT;  //传感器获知的温度，范围：-20.0 ~ 90.0
    byRes: array[0..116-1] of BYTE;  //保留
  end;
  LPNET_DVR_WORKSTATE_V40 = ^NET_DVR_WORKSTATE_V40;//设备工作状态扩展结构体

type
  NET_DVR_GETWORKSTATE_COND = record 
    dwSize: DWORD;  //结构体长度
    byFindHardByCond: BYTE;  //0-查找全部磁盘(但一次最多只能查找33个)，此时dwFindHardStatusNum无效
    byFindChanByCond: BYTE;  //0-查找全部通道，此时dwFindChanNum无效
    byRes1: array[0..2-1] of BYTE;  //保留
    dwFindHardStatus: array[0..MAX_DISKNUM_V30{33}-1] of DWORD;  //要查找的硬盘号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 
    dwFindChanNo: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  //要查找的通道号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_GETWORKSTATE_COND = ^NET_DVR_GETWORKSTATE_COND;

//DVR工作状态(9000扩展)
type
  NET_DVR_WORKSTATE_V30 = record 
    dwDeviceStatic: DWORD;  //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    struHardDiskStatic: array[0..MAX_DISKNUM_V30-1] of NET_DVR_DISKSTATE;  
    struChanStatic: array[0..MAX_CHANNUM_V30-1] of NET_DVR_CHANNELSTATE_V30;  //通道的状态
    byAlarmInStatic: array[0..MAX_ALARMIN_V30-1] of BYTE;  //报警端口的状态,0-没有报警,1-有报警
    byAlarmOutStatic: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //报警输出端口的状态,0-没有输出,1-有报警输出
    dwLocalDisplay: DWORD;  //本地显示状态,0-正常,1-不正常
    byAudioChanStatus: array[0..MAX_AUDIO_V30-1] of BYTE;  //表示语音通道的状态 0-未使用，1-使用中, 0xff无效
    byRes: array[0..10-1] of BYTE;  
  end;
  LPNET_DVR_WORKSTATE_V30 = ^NET_DVR_WORKSTATE_V30;

//DVR工作状态
type
  NET_DVR_WORKSTATE = record 
    dwDeviceStatic: DWORD;  //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    struHardDiskStatic: array[0..MAX_DISKNUM-1] of NET_DVR_DISKSTATE;  
    struChanStatic: array[0..MAX_CHANNUM-1] of NET_DVR_CHANNELSTATE;  //通道的状态
    byAlarmInStatic: array[0..MAX_ALARMIN-1] of BYTE;  //报警端口的状态,0-没有报警,1-有报警
    byAlarmOutStatic: array[0..MAX_ALARMOUT-1] of BYTE;  //报警输出端口的状态,0-没有输出,1-有报警输出
    dwLocalDisplay: DWORD;  //本地显示状态,0-正常,1-不正常
  end;
  LPNET_DVR_WORKSTATE = ^NET_DVR_WORKSTATE;



//日志信息(9000扩展)
type
  NET_DVR_LOG_V30 = record 
    strLogTime: NET_DVR_TIME;  
    dwMajorType: DWORD;  //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    dwMinorType: DWORD;  //次类型 0-全部;
    sPanelUser: array[0..MAX_NAMELEN-1] of BYTE;  //操作面板的用户名
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    dwParaType: DWORD;  //参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
    dwChannel: DWORD;  //通道号
    dwDiskNumber: DWORD;  //硬盘号
    dwAlarmInPort: DWORD;  //报警输入端口
    dwAlarmOutPort: DWORD;  //报警输出端口
    dwInfoLen: DWORD;  
    sInfo: array[0..LOG_INFO_LEN-1] of AnsiChar;  
  end;
  LPNET_DVR_LOG_V30 = ^NET_DVR_LOG_V30;

//日志信息
type
  NET_DVR_LOG = record 
    strLogTime: NET_DVR_TIME;  
    dwMajorType: DWORD;  //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    dwMinorType: DWORD;  //次类型 0-全部;
    sPanelUser: array[0..MAX_NAMELEN-1] of BYTE;  //操作面板的用户名
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    sRemoteHostAddr: array[0..16-1] of AnsiChar;  //远程主机地址
    dwParaType: DWORD;  //参数类型
    dwChannel: DWORD;  //通道号
    dwDiskNumber: DWORD;  //硬盘号
    dwAlarmInPort: DWORD;  //报警输入端口
    dwAlarmOutPort: DWORD;  //报警输出端口
  end;
  LPNET_DVR_LOG = ^NET_DVR_LOG;


type
  NET_DVR_FIND_LOG_COND = record 
    dwSelectMode: DWORD;  // 0－全部；1－按类型；2－按时间；3－按时间和类型
    dwMainType: DWORD;  //日志主类型
    dwSubType: DWORD;  //日志次类型
    struStartTime: NET_DVR_TIME_V50;  //开始时间
    struEndTime: NET_DVR_TIME_V50;  //结束时间
    bOnlySmart: BOOL;  //是否只搜索带S.M.A.R.T信息的日志
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FIND_LOG_COND = ^NET_DVR_FIND_LOG_COND;


type
  NET_DVR_LOG_V50 = record 
    struLogTime: NET_DVR_TIME_V50;  //日志发生的时间
    dwMajorType: DWORD;  //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    dwMinorType: DWORD;  //次类型 0-全部;
    sPanelUser: array[0..MAX_NAMELEN-1] of BYTE;  //操作面板的用户名
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    dwParaType: DWORD;  //参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
    dwChannel: DWORD;  //通道号
    dwDiskNumber: DWORD;  //硬盘号
    dwAlarmInPort: DWORD;  //报警输入端口
    dwAlarmOutPort: DWORD;  //报警输出端口
    dwInfoLen: DWORD;  
    sInfo: array[0..LOG_INFO_LEN-1] of AnsiChar;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LOG_V50 = ^NET_DVR_LOG_V50;


//***********************DVR日志 end**************************

//***********************动环报警管理主机日志查找 begin***********************************************
type
  NET_DVR_ALARMHOST_SEARCH_LOG_PARAM = record 
    wMajorType: WORD;  // 主类型
    wMinorType: WORD;  // 次类型
    struStartTime: NET_DVR_TIME;  // 开始时间
    struEndTime: NET_DVR_TIME;  // 结束时间
    byRes: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM = ^NET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

type
  NET_DVR_ALARMHOST_LOG_RET = record 
    struLogTime: NET_DVR_TIME;  //  日志时间
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 操作用户
    struIPAddr: NET_DVR_IPADDR;  // 操作IP地址
    wMajorType: WORD;  // 主类型
    wMinorType: WORD;  // 次类型
    wParam: WORD;  // 操作参数
    byRes: array[0..10-1] of BYTE;  
    dwInfoLen: DWORD;  // 描述信息长度
    sInfo: array[0..LOG_INFO_LEN-1] of AnsiChar;  // 描述信息
  end;
  LPNET_DVR_ALARMHOST_LOG_RET = ^NET_DVR_ALARMHOST_LOG_RET;

//************************动环报警管理主机日志查找 end**********************************************

//报警输出状态(9000扩展)
type
  NET_DVR_ALARMOUTSTATUS_V30 = record 
    Output: array[0..MAX_ALARMOUT_V30-1] of BYTE;  
  end;
  LPNET_DVR_ALARMOUTSTATUS_V30 = ^NET_DVR_ALARMOUTSTATUS_V30;

//报警输出状态
type
  NET_DVR_ALARMOUTSTATUS = record 
    Output: array[0..MAX_ALARMOUT-1] of BYTE;  
  end;
  LPNET_DVR_ALARMOUTSTATUS = ^NET_DVR_ALARMOUTSTATUS;

//交易信息
type
  NET_DVR_TRADEINFO = record 
    m_Year: USHORT;  
    m_Month: USHORT;  
    m_Day: USHORT;  
    m_Hour: USHORT;  
    m_Minute: USHORT;  
    m_Second: USHORT;  
    DeviceName: array[0..24-1] of BYTE;  //设备名称
    dwChannelNumer: DWORD;  //通道号
    CardNumber: array[0..32-1] of BYTE;  //卡号
    cTradeType: array[0..12-1] of AnsiChar;  //交易类型
    dwCash: DWORD;  //交易金额
  end;
  LPNET_DVR_TRADEINFO = ^NET_DVR_TRADEINFO;


//ATM专用
//***************************ATM(begin)**************************
const
  NCR = 0;    
  DIEBOLD = 1;    
  WINCOR_NIXDORF = 2;    
  SIEMENS = 3;    
  OLIVETTI = 4;    
  FUJITSU = 5;    
  HITACHI = 6;    
  SMI = 7;    
  IBM = 8;    
  BULL = 9;    
  YiHua = 10;    
  LiDe = 11;    
  GDYT = 12;    
  Mini_Banl = 13;    
  GuangLi = 14;    
  DongXin = 15;    
  ChenTong = 16;    
  NanTian = 17;    
  XiaoXing = 18;    
  GZYY = 19;    
  QHTLT = 20;    
  DRS918 = 21;    
  KALATEL = 22;    
  NCR_2 = 23;    
  NXS = 24;    


//帧格式
type
  NET_DVR_FRAMETYPECODE = record 
    code: array[0..12-1] of BYTE;  // 代码 
  end;
  LPNET_DVR_FRAMETYPECODE = ^NET_DVR_FRAMETYPECODE;


//ATM参数
type
  NET_DVR_FRAMEFORMAT = record 
    dwSize: DWORD;  
    sATMIP: array[0..16-1] of AnsiChar;  // ATM IP地址 
    dwATMType: DWORD;  // ATM类型 
    dwInputMode: DWORD;  // 输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入
    dwFrameSignBeginPos: DWORD;  // 报文标志位的起始位置
    dwFrameSignLength: DWORD;  // 报文标志位的长度 
    byFrameSignContent: array[0..12-1] of BYTE;  // 报文标志位的内容 
    dwCardLengthInfoBeginPos: DWORD;  // 卡号长度信息的起始位置 
    dwCardLengthInfoLength: DWORD;  // 卡号长度信息的长度 
    dwCardNumberInfoBeginPos: DWORD;  // 卡号信息的起始位置 
    dwCardNumberInfoLength: DWORD;  // 卡号信息的长度 
    dwBusinessTypeBeginPos: DWORD;  // 交易类型的起始位置 
    dwBusinessTypeLength: DWORD;  // 交易类型的长度 
    frameTypeCode: array[0..10-1] of NET_DVR_FRAMETYPECODE;  // 类型 
  end;
  LPNET_DVR_FRAMEFORMAT = ^NET_DVR_FRAMEFORMAT;

//ATM参数(9000扩展)
type
  NET_DVR_FRAMEFORMAT_V30 = record 
    dwSize: DWORD;  
    struATMIP: NET_DVR_IPADDR;  // ATM IP地址 
    dwATMType: DWORD;  // ATM类型 
    dwInputMode: DWORD;  // 输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入
    dwFrameSignBeginPos: DWORD;  // 报文标志位的起始位置
    dwFrameSignLength: DWORD;  // 报文标志位的长度 
    byFrameSignContent: array[0..12-1] of BYTE;  // 报文标志位的内容 
    dwCardLengthInfoBeginPos: DWORD;  // 卡号长度信息的起始位置 
    dwCardLengthInfoLength: DWORD;  // 卡号长度信息的长度 
    dwCardNumberInfoBeginPos: DWORD;  // 卡号信息的起始位置 
    dwCardNumberInfoLength: DWORD;  // 卡号信息的长度 
    dwBusinessTypeBeginPos: DWORD;  // 交易类型的起始位置 
    dwBusinessTypeLength: DWORD;  // 交易类型的长度 
    frameTypeCode: array[0..10-1] of NET_DVR_FRAMETYPECODE;  // 类型 
    wATMPort: WORD;  // 卡号捕捉端口号(网络协议方式) (保留)0xffff表示该值无效
    wProtocolType: WORD;  // 网络协议类型(保留) 0xffff表示该值无效
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_FRAMEFORMAT_V30 = ^NET_DVR_FRAMEFORMAT_V30;

//SDK_V31 ATM

//过滤设置
type
  NET_DVR_FILTER = record 
    byEnable: BYTE;  //0,不启用;1,启用
    byMode: BYTE;  //0,ASCII;1,HEX
    byFrameBeginPos: BYTE;  // 需要过滤目标字符串起始位置
    byRes: BYTE;  // 保留字节
    byFilterText: array[0..16-1] of BYTE;  //过滤字符串
    byRes2: array[0..12-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_FILTER = ^NET_DVR_FILTER;

//数据包分析 数据包标识
type
  NET_DVR_IDENTIFICAT = record 
    byStartMode: BYTE;  //起始字符模式:0,ASCII;1,HEX
    byEndMode: BYTE;  //结束字符模式：0,ASCII;1,HEX
    byRes: array[0..2-1] of BYTE;  //保留字节
    struStartCode: NET_DVR_FRAMETYPECODE;  //数据包起始标识字符
    struEndCode: NET_DVR_FRAMETYPECODE;  //数据包结束标识字符
    byRes1: array[0..12-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_IDENTIFICAT = ^NET_DVR_IDENTIFICAT;

type
  NET_DVR_PACKAGE_LOCATION = record //报文信息位置
    byOffsetMode: BYTE;  //报文位置信息模式 0,token(字符标志模式);1,fix（固定模式）
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    dwOffsetPos: DWORD;  //mode为1的时候使用,固定偏移大小
    struTokenCode: NET_DVR_FRAMETYPECODE;  //标志位
    byMultiplierValue: BYTE;  //标志位多少次出现
    byEternOffset: BYTE;  //附加字符偏移量
    byCodeMode: BYTE;  //0,ASCII;1,HEX
    byRes2: array[0..9-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PACKAGE_LOCATION = ^NET_DVR_PACKAGE_LOCATION;


type
  NET_DVR_PACKAGE_LENGTH = record //报文信息长度
    byLengthMode: BYTE;  //长度类型，0,可变长度;1,固定长度;2,自助长度(从卡号中获取)
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    dwFixLength: DWORD;  //mode为1的时候使用,固定长度大小
    dwMaxLength: DWORD;  //报文信息最大长度  byLengthMode为0时使用
    dwMinLength: DWORD;  //报文信息最小长度  byLengthMode为0时使用
    byEndMode: BYTE;  //可变长度 终结符模式 0,ASCII;1,HEX
    byRes2: array[0..3-1] of BYTE;  //保留字节
    struEndCode: NET_DVR_FRAMETYPECODE;  //可变长度终结符
    dwLengthPos: DWORD;  //lengthMode为2的时候使用，卡号长度在报文中的位置
    dwLengthLen: DWORD;  //lengthMode为2的时候使用，卡号长度的长度
    byRes3: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PACKAGE_LENGTH = ^NET_DVR_PACKAGE_LENGTH;

type
  NET_DVR_OSD_POSITION = record //OSD 叠加的位置
    byPositionMode: BYTE;  //叠加风格，共2种；0，不显示；1，自定义
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    dwPosX: DWORD;  //x坐标，叠加风格为自定义时使用
    dwPosY: DWORD;  //y坐标，叠加风格为自定义时使用
    byRes2: array[0..8-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_OSD_POSITION = ^NET_DVR_OSD_POSITION;

type
  NET_DVR_DATE_FORMAT = record //日期显示格式
    byMonth: BYTE;  //Month,0.mm;1.mmm;2.mmmm
    byDay: BYTE;  //Day,0.dd;
    byYear: BYTE;  //Year,0.yy;1.yyyy
    byDateForm: BYTE;  //0~5，年月日的排列组合
    byRes: array[0..20-1] of BYTE;  // 保留字节
    chSeprator: array[0..4-1] of AnsiChar;  //分隔符
    chDisplaySeprator: array[0..4-1] of AnsiChar;  //显示分隔符
    byDisplayForm: BYTE;  //0~5，3个item的排列组合
    res: array[0..27-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DATE_FORMAT = ^NET_DVR_DATE_FORMAT;
type
  NET_DVR_TIME_FORMAT = record //时间显示格式
    byTimeForm: BYTE;  //1. HH MM SS;0. HH MM
    byRes1: array[0..23-1] of BYTE;  // 保留字节
    byHourMode: BYTE;  //0,12;1,24
    byRes2: array[0..3-1] of BYTE;  // 保留字节
    chSeprator: array[0..4-1] of AnsiChar;  //报文分隔符，暂时没用
    chDisplaySeprator: array[0..4-1] of AnsiChar;  //显示分隔符
    byDisplayForm: BYTE;  //0~5，3个item的排列组合
    byRes3: array[0..3-1] of BYTE;  // 保留字节
    byDisplayHourMode: BYTE;  //0,12;1,24
    byRes4: array[0..19-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_TIME_FORMAT = ^NET_DVR_TIME_FORMAT;

type
  NET_DVR_OVERLAY_CHANNEL = record 
    byChannel: array[0..64-1] of BYTE;  //叠加的通道 每个字节标识一个通道， 例如byChannel[0]值为1对应叠加通道1，0表示不叠加通道1。
    dwDelayTime: DWORD;  //叠加延时时间
    byEnableDelayTime: BYTE;  //是否启用叠加延时
    byRes: array[0..11-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_OVERLAY_CHANNEL = ^NET_DVR_OVERLAY_CHANNEL;

// ATM 报文行为信息
type
  NET_DVR_ATM_PACKAGE_ACTION = record 
    struPackageLocation: NET_DVR_PACKAGE_LOCATION;  // 报文位置信息
    struOsdPosition: NET_DVR_OSD_POSITION;  // OSD 叠加位置
    struActionCode: NET_DVR_FRAMETYPECODE;  //交易类型行为码
    struPreCode: NET_DVR_FRAMETYPECODE;  //叠加字符前的字符
    byActionCodeMode: BYTE;  //交易类型行为码模式0,ASCII;1,HEX
    byRes: array[0..7-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ATM_PACKAGE_ACTION = ^NET_DVR_ATM_PACKAGE_ACTION;

// ATM 报文DATA信息
type
  NET_DVR_ATM_PACKAGE_DATE = record 
    struPackageLocation: NET_DVR_PACKAGE_LOCATION;  // 日期在报文中的位置信息
    struDateForm: NET_DVR_DATE_FORMAT;  //日期显示格式
    struOsdPosition: NET_DVR_OSD_POSITION;  // OSD叠加位置信息
    res: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ATM_PACKAGE_DATE = ^NET_DVR_ATM_PACKAGE_DATE;


//ATM报文时间信息
type
  NET_DVR_ATM_PACKAGE_TIME = record 
    location: NET_DVR_PACKAGE_LOCATION;  // 时间在报文中的位置信息
    struTimeForm: NET_DVR_TIME_FORMAT;  // 时间显示格式
    struOsdPosition: NET_DVR_OSD_POSITION;  // OSD 叠加位置信息
    byRes: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ATM_PACKAGE_TIME = ^NET_DVR_ATM_PACKAGE_TIME;


// ATM 其他报文信息（卡号，交易金额，交易序号）
type
  NET_DVR_ATM_PACKAGE_OTHERS = record 
    struPackageLocation: NET_DVR_PACKAGE_LOCATION;  //报文位置信息
    struPackageLength: NET_DVR_PACKAGE_LENGTH;  //长度信息
    struOsdPosition: NET_DVR_OSD_POSITION;  // OSD叠加位置信息
    struPreCode: NET_DVR_FRAMETYPECODE;  //叠加字符前的字符
    res: array[0..8-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ATM_PACKAGE_OTHERS = ^NET_DVR_ATM_PACKAGE_OTHERS;


//用户自定义协议
type
  NET_DVR_ATM_USER_DEFINE_PROTOCOL = record 
    struIdentification: NET_DVR_IDENTIFICAT;  //报文标志
    struFilter: NET_DVR_FILTER;  //数据包过滤设置
    struCardNoPara: NET_DVR_ATM_PACKAGE_OTHERS;  //叠加卡号设置
    struTradeActionPara: array[0..MAX_ACTION_TYPE-1] of NET_DVR_ATM_PACKAGE_ACTION;  //叠加交易行为设置 0-9 依次对应InCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
    struAmountPara: NET_DVR_ATM_PACKAGE_OTHERS;  //叠加交易金额设置
    struSerialNoPara: NET_DVR_ATM_PACKAGE_OTHERS;  //叠加交易序号设置
    struOverlayChan: NET_DVR_OVERLAY_CHANNEL;  //叠加通道设置
    struRes1: NET_DVR_ATM_PACKAGE_DATE;  //叠加日期，保留
    struRes2: NET_DVR_ATM_PACKAGE_TIME;  //叠加时间，保留
    byRes3: array[0..124-1] of BYTE;  //保留
  end;
  LPNET_DVR_ATM_USER_DEFINE_PROTOCOL = ^NET_DVR_ATM_USER_DEFINE_PROTOCOL;

type
  NET_DVR_ATM_FRAMEFORMAT_V30 = record 
    dwSize: DWORD;  //结构大小
    byEnable: BYTE;  //是否启用0,不启用;1,启用
    byInputMode: BYTE;  //*输入方式:0-网络监听、1网络协议、2-串口监听、3-串口协议
    byRes1: array[0..34-1] of BYTE;  //保留字节
    struAtmIp: NET_DVR_IPADDR;  //ATM 机IP 网络监听时使用 
    wAtmPort: WORD;  // 网络协议方式时是使用
    byRes2: array[0..2-1] of BYTE;  // 保留字节
    dwAtmType: DWORD;  //ATM协议类型，从NET_DVR_ATM_PROTOCOL结构中获取，如果类型为自定义时使用用户自定义协议
    struAtmUserDefineProtocol: NET_DVR_ATM_USER_DEFINE_PROTOCOL;  //用户自定义协议，当ATM类型为自定时需要使用该定义
    byRes3: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ATM_FRAMEFORMAT_V30 = ^NET_DVR_ATM_FRAMEFORMAT_V30;

//ATM协议类型
type
  ATM_PROTO_TYPE =  
  (  
    ATM_PROTO_NCR = 0,  //NCR
    ATM_PROTO_DIEBOLD = 1,  //DIEBOLD
    ATM_PROTO_WINCOR_NIXDORF = 2,  //WINCOR-NIXDORF
    ATM_PROTO_SIEMENS = 4,  //SIEMENS
    ATM_PROTO_OLIVETTI = 5,  //OLIVETTI
    ATM_PROTO_FUJITSU = 6,  //FUJITSU
    ATM_PROTO_HITACHI = 7,  //HITACHI
    ATM_PROTO_SMI = 8,  //SMI
    ATM_PROTO_BULL = 9,  //BULL
    ATM_PROTO_YIHUA = 10,  //怡化
    ATM_PROTO_LIDE = 11,  //立德
    ATM_PROTO_GDYT = 12,  //广电运通
    ATM_PROTO_MINI_BANL = 13,  //Mini-Banl
    ATM_PROTO_GUANGLI = 14,  //广利
    ATM_PROTO_DONGXIN = 15,  //东信
    ATM_PROTO_CHENTONG = 16,  //辰通
    ATM_PROTO_NANTIAN = 17,  //南天
    ATM_PROTO_XIAOXING = 18,  //晓星
    ATM_PROTO_GZYY = 19,  //广州御银
    ATM_PROTO_QHTLT = 20,  //青湖泰利特
    ATM_PROTO_DRS918 = 21,  //DRS918
    ATM_PROTO_KALATEL = 22,  //KALATEL
    ATM_PROTO_NCR_2 = 23,  //NCR_2
    ATM_PROTO_NXS = 24,  //NXS
    ATM_PROTO_ICBC = 25,  //工商银行
    ATM_PROTO_PSBC = 26,  //中国邮政储蓄银行
    ATM_PROTO_CUSTOM = 1025  //自定义
  );

type
  NET_DVR_ATM_PROTO_TYPE = record 
    dwAtmType: DWORD;  //ATM协议类型，同时作为索引序号 ATM 配置中的dwAtmType 自定义时为1025
    chDesc: array[0..ATM_DESC_LEN-1] of AnsiChar;  //ATM协议简单描述
  end;
  LPNET_DVR_ATM_PROTO_TYPE = ^NET_DVR_ATM_PROTO_TYPE;//协议信息数据结构

type
  NET_DVR_ATM_PROTO_LIST = record //ATM 协议列表
    dwAtmProtoNum: DWORD;  // 协议列表的个数
    struAtmProtoType: array[0..MAX_ATM_PROTOCOL_NUM-1] of NET_DVR_ATM_PROTO_TYPE;  //协议列表信息
  end;
  LPNET_DVR_ATM_PROTO_LIST = ^NET_DVR_ATM_PROTO_LIST;

type
  NET_DVR_ATM_PROTOCOL = record 
    dwSize: DWORD;  
    struNetListenList: NET_DVR_ATM_PROTO_LIST;  // 网络监听协议描述
    struSerialListenList: NET_DVR_ATM_PROTO_LIST;  //串口监听协议描述
    struNetProtoList: NET_DVR_ATM_PROTO_LIST;  //网络协议描述
    struSerialProtoList: NET_DVR_ATM_PROTO_LIST;  //串口协议描述
    struCustomProto: NET_DVR_ATM_PROTO_TYPE;  //自定义协议
  end;
  LPNET_DVR_ATM_PROTOCOL = ^NET_DVR_ATM_PROTOCOL;
// SDK_V31

//****************************DS-6001D/F(begin)**************************
//DS-6001D Decoder
type
  NET_DVR_DECODERINFO = record 
    byEncoderIP: array[0..16-1] of BYTE;  //解码设备连接的服务器IP
    byEncoderUser: array[0..16-1] of BYTE;  //解码设备连接的服务器的用户名
    byEncoderPasswd: array[0..16-1] of BYTE;  //解码设备连接的服务器的密码
    bySendMode: BYTE;  //解码设备连接服务器的连接模式
    byEncoderChannel: BYTE;  //解码设备连接的服务器的通道号
    wEncoderPort: WORD;  //解码设备连接的服务器的端口号
    reservedData: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_DECODERINFO = ^NET_DVR_DECODERINFO;

type
  NET_DVR_DECODERSTATE = record 
    byEncoderIP: array[0..16-1] of BYTE;  //解码设备连接的服务器IP
    byEncoderUser: array[0..16-1] of BYTE;  //解码设备连接的服务器的用户名
    byEncoderPasswd: array[0..16-1] of BYTE;  //解码设备连接的服务器的密码
    byEncoderChannel: BYTE;  //解码设备连接的服务器的通道号
    bySendMode: BYTE;  //解码设备连接的服务器的连接模式
    wEncoderPort: WORD;  //解码设备连接的服务器的端口号
    dwConnectState: DWORD;  //解码设备连接服务器的状态
    reservedData: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_DECODERSTATE = ^NET_DVR_DECODERSTATE;

//解码设备控制码定义
const
  NET_DEC_STARTDEC = 1;    
  NET_DEC_STOPDEC = 2;    
  NET_DEC_STOPCYCLE = 3;    
  NET_DEC_CONTINUECYCLE = 4;    
//连接的通道配置
type
  NET_DVR_DECCHANINFO = record 
    sDVRIP: array[0..16-1] of AnsiChar;  // DVR IP地址 
    wDVRPort: WORD;  // 端口号 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    byChannel: BYTE;  // 通道号 
    byLinkMode: BYTE;  // 连接模式 
    byLinkType: BYTE;  // 连接类型 0－主码流 1－子码流 
  end;
  LPNET_DVR_DECCHANINFO = ^NET_DVR_DECCHANINFO;

//每个解码通道的配置
type
  NET_DVR_DECINFO = record 
    byPoolChans: BYTE;  //每路解码通道上的循环通道数量, 最多4通道 0表示没有解码
    struchanConInfo: array[0..MAX_DECPOOLNUM-1] of NET_DVR_DECCHANINFO;  
    byEnablePoll: BYTE;  //是否轮巡 0-否 1-是
    byPoolTime: BYTE;  //轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟 
  end;
  LPNET_DVR_DECINFO = ^NET_DVR_DECINFO;

//整个设备解码配置
type
  NET_DVR_DECCFG = record 
    dwSize: DWORD;  
    dwDecChanNum: DWORD;  //解码通道的数量
    struDecInfo: array[0..MAX_DECNUM-1] of NET_DVR_DECINFO;  
  end;
  LPNET_DVR_DECCFG = ^NET_DVR_DECCFG;

//2005-08-01
// 解码设备透明通道设置 
type
  NET_DVR_PORTINFO = record 
    dwEnableTransPort: DWORD;  // 是否启动透明通道 0－不启用 1－启用
    sDecoderIP: array[0..16-1] of AnsiChar;  // DVR IP地址 
    wDecoderPort: WORD;  // 端口号 
    wDVRTransPort: WORD;  // 配置前端DVR是从485/232输出，1表示232串口,2表示485串口 
    cReserve: array[0..4-1] of AnsiChar;  
  end;
  LPNET_DVR_PORTINFO = ^NET_DVR_PORTINFO;

type
  NET_DVR_PORTCFG = record 
    dwSize: DWORD;  
    struTransPortInfo: array[0..MAX_TRANSPARENTNUM-1] of NET_DVR_PORTINFO;  // 数组0表示232 数组1表示485 
  end;
  LPNET_DVR_PORTCFG = ^NET_DVR_PORTCFG;

// 控制网络文件回放 
type
  NET_DVR_PLAYREMOTEFILE = record 
    dwSize: DWORD;  
    sDecoderIP: array[0..16-1] of AnsiChar;  // DVR IP地址 
    wDecoderPort: WORD;  // 端口号 
    wLoadMode: WORD;  // 回放下载模式 1－按名字 2－按时间 
    mode_size: record 
      case Byte of
      0: (byFile: array[0..100-1] of BYTE);  // 回放的文件名 
      1: (bytime: record
        dwChannel: DWORD;  
        sUserName: array[0..NAME_LEN-1] of BYTE;  //请求视频用户名
        sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
        struStartTime: NET_DVR_TIME;  // 按时间回放的开始时间 
        struStopTime: NET_DVR_TIME;  // 按时间回放的结束时间 
      end);  
    end;  
  end;
  LPNET_DVR_PLAYREMOTEFILE = ^NET_DVR_PLAYREMOTEFILE;

//当前设备解码连接状态
type
  NET_DVR_DECCHANSTATUS = record 
    dwWorkType: DWORD;  //工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载
    sDVRIP: array[0..16-1] of AnsiChar;  //连接的设备ip
    wDVRPort: WORD;  //连接端口号
    byChannel: BYTE;  // 通道号 
    byLinkMode: BYTE;  // 连接模式 
    dwLinkType: DWORD;  //连接类型 0－主码流 1－子码流
    objectInfo: record 
      case Byte of
      0: (userInfo: record
        sUserName: array[0..NAME_LEN-1] of BYTE;  //请求视频用户名
        sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
        cReserve: array[0..52-1] of AnsiChar;  
      end);  
      1: (fileInfo: record
        fileName: array[0..100-1] of BYTE;  
      end);  
      2: (timeInfo: record
        dwChannel: DWORD;  
        sUserName: array[0..NAME_LEN-1] of BYTE;  //请求视频用户名
        sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
        struStartTime: NET_DVR_TIME;  // 按时间回放的开始时间 
        struStopTime: NET_DVR_TIME;  // 按时间回放的结束时间 
      end);  
    end;  
  end;
  LPNET_DVR_DECCHANSTATUS = ^NET_DVR_DECCHANSTATUS;

type
  NET_DVR_DECSTATUS = record 
    dwSize: DWORD;  
    struDecState: array[0..MAX_DECNUM-1] of NET_DVR_DECCHANSTATUS;  
  end;
  LPNET_DVR_DECSTATUS = ^NET_DVR_DECSTATUS;
//****************************DS-6001D/F(end)**************************

//单字符参数(子结构)
type
  NET_DVR_SHOWSTRINGINFO = record 
    wShowString: WORD;  // 预览的图象上是否显示字符,0-不显示,1-显示 整个预览画面大小704*576,单个字符的大小为32*32
    wStringSize: WORD;  // 该行字符的长度，不能大于44个字符 
    wShowStringTopLeftX: WORD;  // 字符显示位置的x坐标 
    wShowStringTopLeftY: WORD;  // 字符名称显示位置的y坐标 
    sString: array[0..44-1] of AnsiChar;  // 要显示的字符内容 
  end;
  LPNET_DVR_SHOWSTRINGINFO = ^NET_DVR_SHOWSTRINGINFO;

//叠加字符(9000扩展)
type
  NET_DVR_SHOWSTRING_V30 = record 
    dwSize: DWORD;  
    struStringInfo: array[0..MAX_STRINGNUM_V30-1] of NET_DVR_SHOWSTRINGINFO;  // 要显示的字符内容 
  end;
  LPNET_DVR_SHOWSTRING_V30 = ^NET_DVR_SHOWSTRING_V30;

//叠加字符扩展(8条字符)
type
  NET_DVR_SHOWSTRING_EX = record 
    dwSize: DWORD;  
    struStringInfo: array[0..MAX_STRINGNUM_EX-1] of NET_DVR_SHOWSTRINGINFO;  // 要显示的字符内容 
  end;
  LPNET_DVR_SHOWSTRING_EX = ^NET_DVR_SHOWSTRING_EX;

//叠加字符
type
  NET_DVR_SHOWSTRING = record 
    dwSize: DWORD;  
    struStringInfo: array[0..MAX_STRINGNUM-1] of NET_DVR_SHOWSTRINGINFO;  // 要显示的字符内容 
  end;
  LPNET_DVR_SHOWSTRING = ^NET_DVR_SHOWSTRING;

//***************************DS9000新增结构(begin)*****************************
{
EMAIL参数结构
}
type
  NET_DVR_EMAILCFG_V30 = record 
    dwSize: DWORD;  
    sAccount: array[0..NAME_LEN-1] of BYTE;  // 账号
    sPassword: array[0..MAX_EMAIL_PWD_LEN-1] of BYTE;  //密码 
    struSender: record
      sName: array[0..NAME_LEN-1] of BYTE;  // 发件人姓名 
      sAddress: array[0..MAX_EMAIL_ADDR_LEN-1] of BYTE;  // 发件人地址 
    end;  
    sSmtpServer: array[0..MAX_EMAIL_ADDR_LEN-1] of BYTE;  // smtp服务器 
    sPop3Server: array[0..MAX_EMAIL_ADDR_LEN-1] of BYTE;  // pop3服务器 
    struReceiver: array[0..3-1] of  record
      sName: array[0..NAME_LEN-1] of BYTE;  // 收件人姓名 
      sAddress: array[0..MAX_EMAIL_ADDR_LEN-1] of BYTE;  // 收件人地址 
    end;  // 最多可以设置3个收件人 
    byAttachment: BYTE;  // 是否带附件 
    bySmtpServerVerify: BYTE;  // 发送服务器要求身份验证 
    byMailInterval: BYTE;  // mail interval 
    byEnableSSL: BYTE;  //ssl是否启用9000_1.1
    wSmtpPort: WORD;  //gmail的465，普通的为25
    byEnableTLS: BYTE;  //TLS是否启用
    byStartTLS: BYTE;  //是否启用StartTLS
    byRes: array[0..72-1] of BYTE;  //保留
  end;
  LPNET_DVR_EMAILCFG_V30 = ^NET_DVR_EMAILCFG_V30;

{
DVR实现巡航数据结构
}
type
  NET_DVR_CRUISE_PARA = record 
    dwSize: DWORD;  
    byPresetNo: array[0..CRUISE_MAX_PRESET_NUMS-1] of BYTE;  // 预置点号 
    byCruiseSpeed: array[0..CRUISE_MAX_PRESET_NUMS-1] of BYTE;  // 巡航速度 
    wDwellTime: array[0..CRUISE_MAX_PRESET_NUMS-1] of WORD;  // 停留时间 
    byEnableThisCruise: BYTE;  // 是否启用 
    res: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_CRUISE_PARA = ^NET_DVR_CRUISE_PARA;
//***************************DS9000新增结构(end)*****************************

//时间点
type
  NET_DVR_TIMEPOINT = record 
    dwMonth: DWORD;  //月 0-11表示1-12个月
    dwWeekNo: DWORD;  //第几周 0－第1周 1－第2周 2－第3周 3－第4周 4－最后一周
    dwWeekDate: DWORD;  //星期几 0－星期日 1－星期一 2－星期二 3－星期三 4－星期四 5－星期五 6－星期六
    dwHour: DWORD;  //小时    开始时间0－23 结束时间1－23
    dwMin: DWORD;  //分    0－59
  end;
  LPNET_DVR_TIMEPOINT = ^NET_DVR_TIMEPOINT;

//夏令时参数
type
  NET_DVR_ZONEANDDST = record 
    dwSize: DWORD;  
    dwZoneIndex: DWORD;  //应用层软件使用NET_DVR_NTPPARA 中的cTimeDifferenceH 或cTimeDifferenceM 来设置时区，此处用获取的值填充，不对用户提供输入编辑框
    byRes1: array[0..12-1] of BYTE;  //保留
    dwEnableDST: DWORD;  //是否启用夏时制 0－不启用 1－启用
    byDSTBias: BYTE;  //夏令时偏移值，30min, 60min, 90min, 120min, 以分钟计，传递原始数值
    byRes2: array[0..3-1] of BYTE;  
    struBeginPoint: NET_DVR_TIMEPOINT;  //夏时制开始时间
    struEndPoint: NET_DVR_TIMEPOINT;  //夏时制停止时间
  end;
  LPNET_DVR_ZONEANDDST = ^NET_DVR_ZONEANDDST;

//图片质量
type
  NET_DVR_JPEGPARA = record 

{注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图，
当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
    仅支持当前分辨率的抓图}

    { 可以通过能力集获取
       0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
       6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
       11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    55-3072*2048,
       64-3840*2160,     70-2560*1440,      75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       161-288*320,   162-144*176,   163-480*640,
       164-240*320,      165-120*160,       166-576*720,   167-720*1280,  168-576*960,
       180-180*240,      181-360*480,       182-540*720,    183-720*960,  184-960*1280,
       185-1080*1440,      215-1080*720(占位，未测试),  216-360x640(占位，未测试),245-576*704(占位，未测试)
       500-384*288,
       0xff-Auto(使用当前码流分辨率)
    }
    wPicSize: WORD;  
    wPicQuality: WORD;  // 图片质量系数 0-最好 1-较好 2-一般 
  end;
  LPNET_DVR_JPEGPARA = ^NET_DVR_JPEGPARA;

//区域框结构
type
  NET_VCA_RECT = record 
    fX: FLOAT;  //边界框左上角点的X轴坐标, 0.000~1
    fY: FLOAT;  //边界框左上角点的Y轴坐标, 0.000~1
    fWidth: FLOAT;  //边界框的宽度, 0.000~1
    fHeight: FLOAT;  //边界框的高度, 0.000~1
  end;
  LPNET_VCA_RECT = ^NET_VCA_RECT;

type
  NET_DVR_JPEGPICTURE_WITH_APPENDDATA = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwJpegPicLen: DWORD;  //Jpeg图片长度
    pJpegPicBuff: PAnsiChar;  //Jpeg图片指针
    dwJpegPicWidth: DWORD;  // 图像宽度
    dwJpegPicHeight: DWORD;  //图像高度
    dwP2PDataLen: DWORD;  //全屏测温数据长度
    pP2PDataBuff: PAnsiChar;  //全屏测温数据指针
    byIsFreezedata: BYTE;  //是否数据冻结 0-否 1-是
    byRes1: array[0..3-1] of BYTE;  
    dwVisiblePicLen: DWORD;  //可见光图片长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pVisiblePicBuff: PAnsiChar;  //可见光图片指针
{$ELSE}
    pVisiblePicBuff: PAnsiChar;  //可见光图片指针
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    struThermalValidRect: NET_VCA_RECT;  //热成像有效区域
    struVisibleValidRect: NET_VCA_RECT;  //可见光有效区域
    byRes: array[0..208-1] of BYTE;  
  end;
  LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA = ^NET_DVR_JPEGPICTURE_WITH_APPENDDATA;

//抓图参数
type
  NET_DVR_PICPARAM_V50 = record 
    struParam: NET_DVR_JPEGPARA;  
    byPicFormat: BYTE;  // 设备抓图图片格式 0-Jpeg
    {
    设备抓图类型:
    0-设备通用抓图，1-鹰眼标定图片（FPJA重启刷新获取图片 最长超时3min）,2-从Flash中获取已存在鹰眼标定图片,
    3-获取鱼眼相机圆形图片,4-专用高清抓图,5-获取鱼眼相机壁装全景展开图（矩形图）
    }
    byCapturePicType: BYTE;  
    bySceneID: BYTE;  //0-不支持，1-场景1，2-场景2 ……
    byRes: array[0..253-1] of BYTE;  
  end;
  LPNET_DVR_PICPARAM_V50 = ^NET_DVR_PICPARAM_V50;
// aux video out parameter 
//辅助输出参数配置
type
  NET_DVR_AUXOUTCFG = record 
    dwSize: DWORD;  
    dwAlarmOutChan: DWORD;  // 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4 
    dwAlarmChanSwitchTime: DWORD;  // :1秒 - 10:10秒 
    dwAuxSwitchTime: array[0..MAX_AUXOUT-1] of DWORD;  // 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s 
    byAuxOrder: array[0..MAX_AUXOUT-1, 0..MAX_WINDOW-1] of BYTE;  // 辅助输出预览顺序, 0xff表示相应的窗口不预览 
  end;
  LPNET_DVR_AUXOUTCFG = ^NET_DVR_AUXOUTCFG;


//ntp
type
  NET_DVR_NTPPARA = record 
    sNTPServer: array[0..64-1] of BYTE;  // Domain Name or IP addr of NTP server 
    wInterval: WORD;  // adjust time interval(hours) 
    byEnableNTP: BYTE;  // enable NPT client 0-no，1-yes
    cTimeDifferenceH: SmallInt;  // 与国际标准时间的 小时偏移-12 ... +13 
    cTimeDifferenceM: SmallInt;  // 与国际标准时间的 分钟偏移0, 30, 45
    res1: BYTE;  
    wNtpPort: WORD;  // ntp server port 9000新增 设备默认为123
    res2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_NTPPARA = ^NET_DVR_NTPPARA;

//ddns
type
  NET_DVR_DDNSPARA = record 
    sUsername: array[0..NAME_LEN-1] of BYTE;  // DDNS账号用户名/密码 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  
    sDomainName: array[0..64-1] of BYTE;  // 域名 
    byEnableDDNS: BYTE;  //是否应用 0-否，1-是
    res: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_DDNSPARA = ^NET_DVR_DDNSPARA;


type
  NET_DVR_DDNSPARA_EX = record 
    byHostIndex: BYTE;  // 0-私有DDNS 1－Dyndns 2－PeanutHull(花生壳)
    byEnableDDNS: BYTE;  //是否应用DDNS 0-否，1-是
    wDDNSPort: WORD;  // DDNS端口号 
    sUsername: array[0..NAME_LEN-1] of BYTE;  // DDNS用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // DDNS密码 
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 设备配备的域名地址 
    sServerName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // DDNS 对应的服务器地址，可以是IP地址或域名 
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_DDNSPARA_EX = ^NET_DVR_DDNSPARA_EX;

//9000扩展
type
  NET_DVR_DDNSPARA_V30 = record 
    byEnableDDNS: BYTE;  
    byHostIndex: BYTE;  //0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
    byRes1: array[0..2-1] of BYTE;  
    struDDNS: array[0..MAX_DDNS_NUMS-1] of  record
      sUsername: array[0..NAME_LEN-1] of BYTE;  // DDNS账号用户名
      sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
      sDomainName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 设备配备的域名地址 
      sServerName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // DDNS协议对应的服务器地址，可以是IP地址或域名 
      wDDNSPort: WORD;  // 端口号 
      wCountryID: WORD;  //国家编号，仅在byHostIndex = 4时有效，0表示默认
      byStatus: BYTE;  { DDNS运行状态（只读），
                                                                    0-无意义
                                                                    1-连接服务器失败(connServerfail)、
                                                                    2-解析服务器消息失败(solveServerMesFail)、
                                                                    3-连接心跳服务器失败(connHeartSrvfail)、
                                                                    4-解析心跳服务器消息失败(solveHeartSrvMesFail)、
                                                                    5-连接域名服务器失败(connHostSrvfail)、
                                                                    6-解析域名服务器消息失败(solveHostSrvMesFail)、
                                                                    7-DDNS状态正常(updateSuccess)、
                                                                    8-未启用(disable)、
                                                                    9-注册域名成功(registHostSuccess)、
                                                                    10-DNS服务器配置错误(DNSSrvError)、
                                                                    11-域名被占用(DomainConflict)、
                                                                    12-别名(域名)不合法(invalidAlias)、
                                                                    13-鉴权失败(authenticationFail)
                                                                    14-注册服务器错误(registServerError)
                                                                    15-注册失败(registFail)
                                }
      byRes: array[0..7-1] of BYTE;  
    end;  
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_DDNSPARA_V30 = ^NET_DVR_DDNSPARA_V30;

//email
type
  NET_DVR_EMAILPARA = record 
    sUsername: array[0..64-1] of BYTE;  // 邮件账号/密码 
    sPassword: array[0..64-1] of BYTE;  
    sSmtpServer: array[0..64-1] of BYTE;  
    sPop3Server: array[0..64-1] of BYTE;  
    sMailAddr: array[0..64-1] of BYTE;  // email 
    sEventMailAddr1: array[0..64-1] of BYTE;  // 上传报警/异常等的email 
    sEventMailAddr2: array[0..64-1] of BYTE;  
    res: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_EMAILPARA = ^NET_DVR_EMAILPARA;

//网络参数配置
type
  NET_DVR_NETAPPCFG = record 
    dwSize: DWORD;  
    sDNSIp: array[0..16-1] of AnsiChar;  // DNS服务器地址 
    struNtpClientParam: NET_DVR_NTPPARA;  // NTP参数 
    struDDNSClientParam: NET_DVR_DDNSPARA;  // DDNS参数 
    res: array[0..464-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_NETAPPCFG = ^NET_DVR_NETAPPCFG;

//nfs结构配置
type
  NET_DVR_SINGLE_NFS = record 
    sNfsHostIPAddr: array[0..16-1] of AnsiChar;  
    sNfsDirectory: array[0..PATHNAME_LEN-1] of BYTE;  // PATHNAME_LEN = 128
  end;
  LPNET_DVR_SINGLE_NFS = ^NET_DVR_SINGLE_NFS;

type
  NET_DVR_NFSCFG = record 
    dwSize: DWORD;  
    struNfsDiskParam: array[0..MAX_NFS_DISK-1] of NET_DVR_SINGLE_NFS;  
  end;
  LPNET_DVR_NFSCFG = ^NET_DVR_NFSCFG;

type
  NET_DVR_ISCSI_CFG = record 
    dwSize: DWORD;  // 结构大小
    wVrmPort: WORD;  // VRM 监听端口
    byEnable: BYTE;  // 是否启用 ISCSI存储
    byRes: array[0..69-1] of BYTE;  // 保留字节
    struVrmAddr: NET_DVR_IPADDR;  // VRM ip地址 16位
    chNvtIndexCode: array[0..64-1] of AnsiChar;  //nvt index Code
  end;
  LPNET_DVR_ISCSI_CFG = ^NET_DVR_ISCSI_CFG;

//巡航点配置(私有IP快球专用)
type
  NET_DVR_CRUISE_POINT = record 
    PresetNum: BYTE;  //预置点
    Dwell: BYTE;  //停留时间
    Speed: BYTE;  //速度
    Reserve: BYTE;  //保留
  end;
  LPNET_DVR_CRUISE_POINT = ^NET_DVR_CRUISE_POINT;

type
  NET_DVR_CRUISE_RET = record 
    struCruisePoint: array[0..32-1] of NET_DVR_CRUISE_POINT;  //最大支持32个巡航点
  end;
  LPNET_DVR_CRUISE_RET = ^NET_DVR_CRUISE_RET;

//***********************************多路解码器(begin)**************************************
type
  NET_DVR_NETCFG_OTHER = record 
    dwSize: DWORD;  
    sFirstDNSIP: array[0..16-1] of AnsiChar;  
    sSecondDNSIP: array[0..16-1] of AnsiChar;  
    sRes: array[0..32-1] of AnsiChar;  
  end;
  LPNET_DVR_NETCFG_OTHER = ^NET_DVR_NETCFG_OTHER;

type
  NET_DVR_MATRIX_DECINFO = record 
    sDVRIP: array[0..16-1] of AnsiChar;  // DVR IP地址 
    wDVRPort: WORD;  // 端口号 
    byChannel: BYTE;  // 通道号 
    byTransProtocol: BYTE;  // 传输协议类型 0-TCP, 1-UDP 
    byTransMode: BYTE;  // 传输码流模式 0－主码流 1－子码流
    byRes: array[0..3-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 布防主机登陆帐号 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 布防主机密码 
  end;
  LPNET_DVR_MATRIX_DECINFO = ^NET_DVR_MATRIX_DECINFO;

//启动/停止动态解码
type
  NET_DVR_MATRIX_DYNAMIC_DEC = record 
    dwSize: DWORD;  
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;  // 动态解码通道信息 
  end;
  LPNET_DVR_MATRIX_DYNAMIC_DEC = ^NET_DVR_MATRIX_DYNAMIC_DEC;

type
  NET_DVR_MATRIX_DEC_CHAN_STATUS = record 
    dwSize: DWORD;  
    dwIsLinked: DWORD;  // 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码 
    dwStreamCpRate: DWORD;  // Stream copy rate, X kbits/second 
    cRes: array[0..64-1] of AnsiChar;  // 保留 
  end;
  LPNET_DVR_MATRIX_DEC_CHAN_STATUS = ^NET_DVR_MATRIX_DEC_CHAN_STATUS;

type
  NET_DVR_MATRIX_DEC_CHAN_INFO = record 
    dwSize: DWORD;  
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;  // 解码通道信息 
    dwDecState: DWORD;  // 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 
    StartTime: NET_DVR_TIME;  // 按时间回放开始时间 
    StopTime: NET_DVR_TIME;  // 按时间回放停止时间 
    sFileName: array[0..128-1] of AnsiChar;  // 按文件回放文件名 
  end;
  LPNET_DVR_MATRIX_DEC_CHAN_INFO = ^NET_DVR_MATRIX_DEC_CHAN_INFO;

//连接的通道配置 2007-11-05
type
  NET_DVR_MATRIX_DECCHANINFO = record 
    dwEnable: DWORD;  // 是否启用 0－否 1－启用
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;  // 轮巡解码通道信息 
  end;
  LPNET_DVR_MATRIX_DECCHANINFO = ^NET_DVR_MATRIX_DECCHANINFO;

//2007-11-05 新增每个解码通道的配置
type
  NET_DVR_MATRIX_LOOP_DECINFO = record 
    dwSize: DWORD;  
    dwPoolTime: DWORD;  //轮巡时间 
    struchanConInfo: array[0..MAX_CYCLE_CHAN-1] of NET_DVR_MATRIX_DECCHANINFO;  
  end;
  LPNET_DVR_MATRIX_LOOP_DECINFO = ^NET_DVR_MATRIX_LOOP_DECINFO;

//2007-12-22
type
  TTY_CONFIG = record 
    baudrate: BYTE;  // 波特率 
    databits: BYTE;  // 数据位 
    stopbits: BYTE;  // 停止位 
    parity: BYTE;  // 奇偶校验位 
    flowcontrol: BYTE;  // 流控 
    res: array[0..3-1] of BYTE;  
  end;
  LPTTY_CONFIG = ^TTY_CONFIG;

type
  NET_DVR_MATRIX_TRAN_CHAN_INFO = record 
    byTranChanEnable: BYTE;  // 当前透明通道是否打开 0：关闭 1：打开 
                            {
                            *    多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                            *    0 RS485
                            *    1 RS232 Console
    }
    byLocalSerialDevice: BYTE;  // Local serial device 
                                            {
                                            *    远程串口输出还是两个,一个RS232，一个RS485
                                            *    1表示232串口
                                            *    2表示485串口
    }
    byRemoteSerialDevice: BYTE;  // Remote output serial device 
    res1: BYTE;  // 保留 
    sRemoteDevIP: array[0..16-1] of AnsiChar;  // Remote Device IP 
    wRemoteDevPort: WORD;  // Remote Net Communication Port 
    res2: array[0..2-1] of BYTE;  // 保留 
    RemoteSerialDevCfg: TTY_CONFIG;  
  end;
  LPNET_DVR_MATRIX_TRAN_CHAN_INFO = ^NET_DVR_MATRIX_TRAN_CHAN_INFO;

type
  NET_DVR_MATRIX_TRAN_CHAN_CONFIG = record 
    dwSize: DWORD;  
    by232IsDualChan: BYTE;  // 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM 
    by485IsDualChan: BYTE;  // 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM 
    res: array[0..2-1] of BYTE;  // 保留 
    struTranInfo: array[0..MAX_SERIAL_NUM-1] of NET_DVR_MATRIX_TRAN_CHAN_INFO;  //同时支持建立MAX_SERIAL_NUM个透明通道
  end;
  LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG = ^NET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007-12-24 Merry Christmas Eve...
type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY = record 
    dwSize: DWORD;  
    sDVRIP: array[0..16-1] of AnsiChar;  // DVR IP地址 
    wDVRPort: WORD;  // 端口号 
    byChannel: BYTE;  // 通道号 
    byReserve: BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwPlayMode: DWORD;  // 0－按文件 1－按时间
    StartTime: NET_DVR_TIME;  
    StopTime: NET_DVR_TIME;  
    sFileName: array[0..128-1] of AnsiChar;  
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY;

// 文件播放命令 
//  NET_DVR_PLAYSTART = 1;    //开始播放
//  NET_DVR_PLAYSTOP = 2;    //停止播放
//  NET_DVR_PLAYPAUSE = 3;    //暂停播放
//  NET_DVR_PLAYRESTART = 4;    //恢复播放
//  NET_DVR_PLAYFAST = 5;    //快放
//  NET_DVR_PLAYSLOW = 6;    //慢放
//  NET_DVR_PLAYNORMAL = 7;    //正常速度
//  NET_DVR_PLAYSTARTAUDIO = 9;    //打开声音
//  NET_DVR_PLAYSTOPAUDIO = 10;    //关闭声音
//  NET_DVR_PLAYSETPOS = 12;    //改变文件回放的进度
//  NET_DVR_RESETBUFFER = 37;    //清空矩阵解码缓冲区（远程回放文件）

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = record 
    dwSize: DWORD;  
    dwPlayCmd: DWORD;  // 播放命令 见文件播放命令
    dwCmdParam: DWORD;  // 播放命令参数 
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = record 
    dwSize: DWORD;  
    dwCurMediaFileLen: DWORD;  // 当前播放的媒体文件长度 
    dwCurMediaFilePosition: DWORD;  // 当前播放文件的播放位置 
    dwCurMediaFileDuration: DWORD;  // 当前播放文件的总时间 
    dwCurPlayTime: DWORD;  // 当前已经播放的时间 
    dwCurMediaFIleFrames: DWORD;  // 当前播放文件的总帧数 
    dwCurDataType: DWORD;  // 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志 
    res: array[0..72-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

//2009-4-11 added by likui 多路解码器new
type
  NET_DVR_MATRIX_PASSIVEMODE = record 
    wTransProtol: WORD;  //传输协议，0-TCP, 1-UDP, 2-MCAST
    wPassivePort: WORD;  //UDP端口, TCP时默认
    struMcastIP: NET_DVR_IPADDR;  //TCP,UDP时无效, MCAST时为多播地址
    byStreamType: BYTE;  // 数据播放模式:REAL_TIME_STREAM(1)实时流,RECORD_STREAM(2)文件流 
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_PASSIVEMODE = ^NET_DVR_MATRIX_PASSIVEMODE;

type
  NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 = record 
    byTranChanEnable: BYTE;  // 当前透明通道是否打开 0：关闭 1：打开 
    byLocalSerialDevice: BYTE;  // Local serial device 
                                    {
                                    *  多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                                    *  0 RS485
                                    *  1 RS232 Console
                                    *  2 Dual Scom
                                    }
    byRemoteSerialDevice: BYTE;  // Remote output serial device 
                                    {
                                    *  远程串口输出还是两个,一个RS232，一个RS485
                                    *  1 表示232串口
                                    *  2 表示485串口
                                    }
    byRes1: BYTE;  // 保留 
    struRemoteDevIP: NET_DVR_IPADDR;  // Remote Device IP 
    wRemoteDevPort: WORD;  // Remote Net Communication Port 
    byIsEstablished: BYTE;  // 透明通道建立成功标志，0-没有成功，1-建立成功 
    byRes2: BYTE;  // 保留 
    RemoteSerialDevCfg: TTY_CONFIG;  
    byUsername: array[0..NAME_LEN-1] of BYTE;  
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  
    dwLocalSerialNo: DWORD;  // 本地串口 
    dwRemoteSerialNo: DWORD;  // 远程串口 
    byRes3: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30 = ^NET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

type
  NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 = record 
    dwSize: DWORD;  
    by232IsDualChan: BYTE;  // 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM 
    by485IsDualChan: BYTE;  // 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM 
    byRes: array[0..2-1] of BYTE;  // 保留 
    struTranInfo: array[0..MAX_SERIAL_NUM-1] of NET_DVR_MATRIX_TRAN_CHAN_INFO_V30;  //同时支持建立MAX_SERIAL_NUM个透明通道
  end;
  LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 = ^NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;

type
  NET_DVR_MATRIX_CHAN_INFO_V30 = record 
    dwEnable: DWORD;  // 是否启用 0－否 1－启用
    streamMediaServerCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO;  // 轮巡解码通道信息 
  end;
  LPNET_DVR_CYC_SUR_CHAN_ELE_V30 = ^NET_DVR_MATRIX_CHAN_INFO_V30;

type
  NET_DVR_MATRIX_LOOP_DECINFO_V30 = record 
    dwSize: DWORD;  
    dwPoolTime: DWORD;  //轮巡间隔
    struchanConInfo: array[0..MAX_CYCLE_CHAN_V30-1] of NET_DVR_MATRIX_CHAN_INFO_V30;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_LOOP_DECINFO_V30 = ^NET_DVR_MATRIX_LOOP_DECINFO_V30;


type
  NET_DVR_MATRIX_DEC_CHAN_INFO_V30 = record 
    dwSize: DWORD;  
    streamMediaServerCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  //流媒体服务器配置
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO;  // 解码通道信息 
    dwDecState: DWORD;  // 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 
    StartTime: NET_DVR_TIME;  // 按时间回放开始时间 
    StopTime: NET_DVR_TIME;  // 按时间回放停止时间 
    sFileName: array[0..128-1] of AnsiChar;  // 按文件回放文件名 
    dwGetStreamMode: DWORD;  //取流模式:1-主动，2-被动
    struPassiveMode: NET_DVR_MATRIX_PASSIVEMODE;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 = ^NET_DVR_MATRIX_DEC_CHAN_INFO_V30;

const
  MAX_RESOLUTIONNUM = 64;    //支持的最大分辨率数目
type
  NET_DVR_MATRIX_ABILITY = record 
    dwSize: DWORD;  
    byDecNums: BYTE;  
    byStartChan: BYTE;  
    byVGANums: BYTE;  
    byBNCNums: BYTE;  
    byVGAWindowMode: array[0..8-1, 0..12-1] of BYTE;  //VGA支持的窗口模式，VGA1可能由混合输出
    byBNCWindowMode: array[0..4-1] of BYTE;  //BNC支持的窗口模式
    byDspNums: BYTE;  
    byHDMINums: BYTE;  //HDMI显示通道个数（从25开始）
    byDVINums: BYTE;  //DVI显示通道个数（从29开始）
    byRes1: array[0..13-1] of BYTE;  
    bySupportResolution: array[0..MAX_RESOLUTIONNUM-1] of BYTE;  //按照上面的枚举定义,一个字节代表一个分辨率是//否支持，1：支持，0：不支持
    byHDMIWindowMode: array[0..4-1, 0..8-1] of BYTE;  //HDMI支持的窗口模式
    byDVIWindowMode: array[0..4-1, 0..8-1] of BYTE;  //DVI支持的窗口模式
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_ABILITY = ^NET_DVR_MATRIX_ABILITY;
//上传logo结构
type
  NET_DVR_DISP_LOGOCFG = record 
    dwCorordinateX: DWORD;  //图片显示区域X坐标
    dwCorordinateY: DWORD;  //图片显示区域Y坐标
    wPicWidth: WORD;  //图片宽
    wPicHeight: WORD;  //图片高
    byRes1: array[0..4-1] of BYTE;  
    byFlash: BYTE;  //是否闪烁1-闪烁，0-不闪烁
    byTranslucent: BYTE;  //是否半透明1-半透明，0-不半透明
    byRes2: array[0..6-1] of BYTE;  //保留
    dwLogoSize: DWORD;  //LOGO大小，包括BMP的文件头
  end;
  LPNET_DVR_DISP_LOGOCFG = ^NET_DVR_DISP_LOGOCFG;

//编码类型
const
  NET_DVR_ENCODER_UNKOWN = 0;    //未知编码格式
  NET_DVR_ENCODER_H264 = 1;    //私有 264
  NET_DVR_ENCODER_S264 = 2;    //Standard H264
  NET_DVR_ENCODER_MPEG4 = 3;    //MPEG4
  NET_DVR_ORIGINALSTREAM = 4;    //Original Stream
  NET_DVR_PICTURE = 5;    //Picture
  NET_DVR_ENCODER_MJPEG = 6;    
  NET_DVR_ENCODER_MPEG2 = 7;    
  NET_DVR_ENCODER_H265 = 8;    
  NET_DVR_ENCODER_SVAC = 9;    
  NET_DVR_ENCODER_SMART264 = 10;    //Smart 264
  NET_DVR_ENCODER_SMART265 = 11;    //Smart 265

// 打包格式 
const
  NET_DVR_STREAM_TYPE_UNKOWN = 0;    //未知打包格式
  NET_DVR_STREAM_TYPE_PRIVT = 1;    //私有格式
  NET_DVR_STREAM_TYPE_TS = 7;    // TS打包 
  NET_DVR_STREAM_TYPE_PS = 8;    // PS打包 
  NET_DVR_STREAM_TYPE_RTP = 9;    // RTP打包 
  NET_DVR_STREAM_TYPE_ORIGIN = 10;    //未打包(视频综合平台解码子系统用)

//解码通道状态
type
  NET_DVR_MATRIX_CHAN_STATUS = record 
    byDecodeStatus: BYTE;  //当前状态:0:未启动，1：启动解码
    byStreamType: BYTE;  //码流类型
    byPacketType: BYTE;  //打包方式
    byRecvBufUsage: BYTE;  //接收缓冲使用率
    byDecBufUsage: BYTE;  //解码缓冲使用率
    byFpsDecV: BYTE;  //视频解码帧率
    byFpsDecA: BYTE;  //音频解码帧率
    byCpuLoad: BYTE;  //DSP CPU使用率
    byRes1: array[0..4-1] of BYTE;  
    dwDecodedV: DWORD;  //解码的视频帧
    dwDecodedA: DWORD;  //解码的音频帧
    wImgW: WORD;  //解码器当前的图像大小,宽
    wImgH: WORD;  //高
    byVideoFormat: BYTE;  //视频制式:0-NON,NTSC--1,PAL--2
    byRes2: array[0..3-1] of BYTE;  
    dwDecChan: DWORD;  //获取全部解码通道状态时有效，设置时可填0
    byRes3: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_CHAN_STATUS = ^NET_DVR_MATRIX_CHAN_STATUS;

//显示通道状态
const
  NET_DVR_MAX_DISPREGION = 16;    //每个显示通道最多可以显示的窗口
//分辨率
//
type
  VGA_MODE =  
  (  
    //VGA
    VGA_NOT_AVALIABLE,  
    VGA_THS8200_MODE_SVGA_60HZ,  //(800*600)
    VGA_THS8200_MODE_SVGA_75HZ,  //(800*600)
    VGA_THS8200_MODE_XGA_60HZ,  //(1024*768)
    VGA_THS8200_MODE_XGA_75HZ,  //(1024*768)
    VGA_THS8200_MODE_SXGA_60HZ,  //(1280*1024)
    VGA_THS8200_MODE_720P_60HZ,  //(1280*720)
    VGA_THS8200_MODE_1080I_60HZ,  //(1920*1080)
    VGA_THS8200_MODE_1080P_30HZ,  //(1920*1080)
    VGA_THS8200_MODE_UXGA_30HZ,  //(1600*1200)
        //HDMI
    HDMI_SII9134_MODE_XGA_60HZ,  //(1024*768)
    HDMI_SII9134_MODE_SXGA_60HZ,  //(1280*1024)
    HDMI_SII9134_MODE_SXGA2_60HZ,  //(1280*960)
    HDMI_SII9134_MODE_720P_60HZ,  //(1280*720)
    HDMI_SII9134_MODE_720P_50HZ,  //(1280*720)
    HDMI_SII9134_MODE_1080I_60HZ,  //(1920*1080)
    HDMI_SII9134_MODE_1080I_50HZ,  //(1920*1080)
    HDMI_SII9134_MODE_1080P_25HZ,  //(1920*1080)
    HDMI_SII9134_MODE_1080P_30HZ,  //(1920*1080)
    HDMI_SII9134_MODE_1080P_50HZ,  //(1920*1080)
    HDMI_SII9134_MODE_1080P_60HZ,  //(1920*1080)
    HDMI_SII9134_MODE_UXGA_60HZ,  //(1600*1200)
        //DVI
    DVI_SII9134_MODE_XGA_60HZ,  //(1024*768)
    DVI_SII9134_MODE_SXGA_60HZ,  //(1280*1024)
    DVI_SII9134_MODE_SXGA2_60HZ,  //(1280*960)
    DVI_SII9134_MODE_720P_60HZ,  //(1280*720)
    DVI_SII9134_MODE_720P_50HZ,  //(1280*720)
    DVI_SII9134_MODE_1080I_60HZ,  //(1920*1080)
    DVI_SII9134_MODE_1080I_50HZ,  //(1920*1080)
    DVI_SII9134_MODE_1080P_25HZ,  //(1920*1080)
    DVI_SII9134_MODE_1080P_30HZ,  //(1920*1080)
    DVI_SII9134_MODE_1080P_50HZ,  //(1920*1080)
    DVI_SII9134_MODE_1080P_60HZ,  //(1920*1080)
    DVI_SII9134_MODE_UXGA_60HZ,  //(1600*1200)
    VGA_DECSVR_MODE_SXGA2_60HZ,  
    HDMI_DECSVR_MODE_1080P_24HZ,  
    DVI_DECSVR_MODE_1080P_24HZ,  
    YPbPr_DECSVR_MODE_720P_60HZ,  
    YPbPr_DECSVR_MODE_1080I_60HZ  
  );

//低帧率定义
const
  LOW_DEC_FPS_1_2 = 51;    
  LOW_DEC_FPS_1_4 = 52;    
  LOW_DEC_FPS_1_8 = 53;    
  LOW_DEC_FPS_1_16 = 54;    

//视频制式标准
type
  VIDEO_STANDARD =  
  (  
    VS_NON = 0,  
    VS_NTSC = 1,  
    VS_PAL = 2  
  );

type
  NET_DVR_VGA_DISP_CHAN_CFG = record 
    dwSize: DWORD;  
    byAudio: BYTE;  //音频是否开启,0-否，1-是
    byAudioWindowIdx: BYTE;  //音频开启子窗口
    byVgaResolution: BYTE;  //VGA的分辨率
    byVedioFormat: BYTE;  //1:NTSC,2:PAL,0-NULL
    dwWindowMode: DWORD;  //画面模式,从能力集获取,目前支持1,2,4,9,16
    byJoinDecChan: array[0..MAX_WINDOWS-1] of BYTE;  //各个子窗口关联的解码通道
    byEnlargeStatus: BYTE;  //是否处于放大状态，0：不放大，1：放大
    byEnlargeSubWindowIndex: BYTE;  //放大的子窗口号
    struDiff: record 
      case Byte of
      0: (byRes: array[0..16-1] of BYTE);  
      1: (struVideoPlatform: record

            //各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)
        byJoinDecoderId: array[0..MAX_WINDOWS-1] of BYTE;  
      end);  
      2: (struNotVideoPlatform: record
        byRes: array[0..16-1] of BYTE;  
      end);  
    end;  
    //区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
    byUnionType: BYTE;  
    byScale: BYTE;  //显示模式，0---真实显示，1---缩放显示( 针对BNC )
  end;
  LPNET_DVR_VGA_DISP_CHAN_CFG = ^NET_DVR_VGA_DISP_CHAN_CFG;


//显示通道状态
//  NET_DVR_MAX_DISPREGION = 16;    //每个显示通道最多可以显示的窗口
type
  NET_DVR_DISP_CHAN_STATUS = record 
    byDispStatus: BYTE;  //显示状态：0：未显示，1：启动显示
    byBVGA: BYTE;  //0-BNC，1-VGA， 2-HDMI，3-DVI
    byVideoFormat: BYTE;  //视频制式:1:NTSC,2:PAL,0-NON
    byWindowMode: BYTE;  //当前画面模式
    byJoinDecChan: array[0..MAX_WINDOWS-1] of BYTE;  //各个子窗口关联的解码通道
    byFpsDisp: array[0..NET_DVR_MAX_DISPREGION-1] of BYTE;  //每个子画面的显示帧率
    byScreenMode: BYTE;  //屏幕模式0-普通 1-大屏
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_DISP_CHAN_STATUS = ^NET_DVR_DISP_CHAN_STATUS;

const
  MAX_DECODECHANNUM = 32;    //多路解码器最大解码通道数
  MAX_DISPCHANNUM = 24;    //多路解码器最大显示通道数

//解码器设备状态
type
  NET_DVR_DECODER_WORK_STATUS = record 
    dwSize: DWORD;  
    struDecChanStatus: array[0..MAX_DECODECHANNUM-1] of NET_DVR_MATRIX_CHAN_STATUS;  //解码通道状态
    struDispChanStatus: array[0..MAX_DISPCHANNUM-1] of NET_DVR_DISP_CHAN_STATUS;  //显示通道状态
    byAlarmInStatus: array[0..MAX_ANALOG_ALARMIN-1] of BYTE;  //报警输入状态
    byAlarmOutStatus: array[0..MAX_ANALOG_ALARMOUT-1] of BYTE;  //报警输出状态
    byAudioInChanStatus: BYTE;  //语音对讲状态
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_DECODER_WORK_STATUS = ^NET_DVR_DECODER_WORK_STATUS;

//2009-12-1 增加被动解码播放控制
type
  NET_DVR_PASSIVEDECODE_CONTROL = record 
    dwSize: DWORD;  
    dwPlayCmd: DWORD;  // 播放命令 见文件播放命令
    dwCmdParam: DWORD;  // 播放命令参数 
    byRes: array[0..16-1] of BYTE;  //Reverse
  end;
  LPNET_DVR_PASSIVEDECODE_CONTROL = ^NET_DVR_PASSIVEDECODE_CONTROL;

const
  PASSIVE_DEC_PAUSE = 1;    //被动解码暂停(仅文件流有效)
  PASSIVE_DEC_RESUME = 2;    //恢复被动解码(仅文件流有效)
  PASSIVE_DEC_FAST = 3;    //快速被动解码(仅文件流有效)
  PASSIVE_DEC_SLOW = 4;    //慢速被动解码(仅文件流有效)
  PASSIVE_DEC_NORMAL = 5;    //正常被动解码(仅文件流有效)
  PASSIVE_DEC_ONEBYONE = 6;    //被动解码单帧播放(保留)
  PASSIVE_DEC_AUDIO_ON = 7;    //音频开启
  PASSIVE_DEC_AUDIO_OFF = 8;    //音频关闭
  PASSIVE_DEC_RESETBUFFER = 9;    //清空缓冲区
//2009-12-16 增加控制解码器解码通道缩放
type
  NET_DVR_MATRIX_DECCHAN_CONTROL = record 
    dwSize: DWORD;  
    byDecChanScaleStatus: BYTE;  //解码通道显示缩放控制,1表示缩放显示，0表示真实显示
    byDecodeDelay: BYTE;  //解码延时，0-默认，1-实时性好，2-实时性较好，3-实时性中，流畅性中，4-流畅性较好，5-流畅性好，0xff-自动调整
    byEnableSpartan: BYTE;  //畅显使能，0-关，1-开
    byLowLight: BYTE;  //低照度。0-关，1-8代表低照度等级，等级越高强度越大
    byNoiseReduction: BYTE;  //3D降噪，0-关，1-开，2-自动
    byDefog: BYTE;  //透雾，0-关，1-7代表透雾等级，等级越高强度越大
    byEnableVcaDec: BYTE;  //是否启用智能解码，0-不启用，非0-启用
    byEnableAudio: BYTE;  //是否开启音频，0-无效，1-开启，2-关闭
    dwAllCtrlType: DWORD;  //所有子窗口一起操作的类型，设置时有效，按位表示
    //dwAllCtrlType & 0x01,开启关闭智能解码
    byVolume: BYTE;  //volume,[0-100]
    byRes: array[0..55-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_DECCHAN_CONTROL = ^NET_DVR_MATRIX_DECCHAN_CONTROL;

//***********************************多路解码器(end)**************************************
//2009-8-19 视频综合平台接口函数
//***********************************视频综合平台(begin)**************************************
const
  MAX_SUBSYSTEM_NUM = 80;    //一个矩阵系统中最多子系统数量
  MAX_SERIALLEN = 36;    //最大序列号长度
  MAX_LOOPPLANNUM = 16;    //最大计划切换组
  DECODE_TIMESEGMENT = 4;    //计划解码每天时间段数
type
  NET_DVR_SUBSYSTEMINFO = record 
    bySubSystemType: BYTE;  //子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，0-NULL（此参数只能获取）
    byChan: BYTE;  //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    byLoginType: BYTE;  //注册类型，1-直连，2-DNS，3-花生壳
    byRes1: array[0..5-1] of BYTE;  
    struSubSystemIP: NET_DVR_IPADDR;  //IP地址（可修改）
    wSubSystemPort: WORD;  //子系统端口号（可修改）
    byRes2: array[0..6-1] of BYTE;  
    struSubSystemIPMask: NET_DVR_IPADDR;  //子网掩码
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 （此参数只能获取）
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码（此参数只能获取）
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //域名(可修改)
    sDnsAddress: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //DNS域名或IP地址
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号（此参数只能获取）
  end;
  LPNET_DVR_SUBSYSTEMINFO = ^NET_DVR_SUBSYSTEMINFO;

type
  NET_DVR_ALLSUBSYSTEMINFO = record 
    dwSize: DWORD;  
    struSubSystemInfo: array[0..MAX_SUBSYSTEM_NUM-1] of NET_DVR_SUBSYSTEMINFO;  
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ALLSUBSYSTEMINFO = ^NET_DVR_ALLSUBSYSTEMINFO;

type
  NET_DVR_LOOPPLAN_SUBCFG = record 
    dwSize: DWORD;  
    dwPoolTime: DWORD;  //轮巡间隔，单位：秒
    struChanConInfo: array[0..MAX_CYCLE_CHAN_V30-1] of NET_DVR_MATRIX_CHAN_INFO_V30;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_LOOPPLAN_SUBCFG = ^NET_DVR_LOOPPLAN_SUBCFG;

type
  NET_DVR_ALARMMODECFG = record 
    dwSize: DWORD;  
    byAlarmMode: BYTE;  //报警触发类型，1-轮巡，2-保持
    wLoopTime: WORD;  //轮巡时间, 单位：秒
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_ALARMMODECFG = ^NET_DVR_ALARMMODECFG;

type
  NET_DVR_CODESPLITTERINFO = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  //码分器IP地址
    wPort: WORD;  //码分器端口号
    byRes1: array[0..6-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码 
    byChan: BYTE;  //码分器485号
    by485Port: BYTE;  //485口地址
    byRes2: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_CODESPLITTERINFO = ^NET_DVR_CODESPLITTERINFO;

type
  NET_DVR_ASSOCIATECFG = record 
    byAssociateType: BYTE;  //关联类型，1-报警
    wAlarmDelay: WORD;  //报警延时，0－5秒；1－10秒；2－30秒；3－1分钟；4－2分钟；5－5分钟；6－10分钟；
    byAlarmNum: BYTE;  //报警号，具体的值由应用赋，相同的报警赋相同的值
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ASSOCIATECFG = ^NET_DVR_ASSOCIATECFG;

type
  NET_DVR_DYNAMICDECODE = record 
    dwSize: DWORD;  
    struAssociateCfg: NET_DVR_ASSOCIATECFG;  //触发动态解码关联结构
    struPuStreamCfg: NET_DVR_PU_STREAM_CFG;  //动态解码结构
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_DYNAMICDECODE = ^NET_DVR_DYNAMICDECODE;

type
  NET_DVR_DECODESCHED = record 
    struSchedTime: NET_DVR_SCHEDTIME;  //
    byDecodeType: BYTE;  //0-无，1-轮巡解码，2-动态解码
    byLoopGroup: BYTE;  //轮巡组号
    byRes: array[0..6-1] of BYTE;  
    struDynamicDec: NET_DVR_PU_STREAM_CFG;  //动态解码
  end;
  LPNET_DVR_DECODESCHED = ^NET_DVR_DECODESCHED;

type
  NET_DVR_PLANDECODE = record 
    dwSize: DWORD;  
    struDecodeSched: array[0..MAX_DAYS-1, 0..DECODE_TIMESEGMENT-1] of NET_DVR_DECODESCHED;  //周一作为开始，和9000一致
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PLANDECODE = ^NET_DVR_PLANDECODE;

//end
//***********************************视频综合平台(end)**************************************
type
  NET_DVR_EMAILCFG = record 
// 12 bytes 
    dwSize: DWORD;  
    sUserName: array[0..32-1] of AnsiChar;  
    sPassWord: array[0..32-1] of AnsiChar;  
    sFromName: array[0..32-1] of AnsiChar;  { Sender }//字符串中的第一个字符和最后一个字符不能是"@",并且字符串中要有"@"字符
    sFromAddr: array[0..48-1] of AnsiChar;  // Sender address 
    sToName1: array[0..32-1] of AnsiChar;  // Receiver1 
    sToName2: array[0..32-1] of AnsiChar;  // Receiver2 
    sToAddr1: array[0..48-1] of AnsiChar;  // Receiver address1 
    sToAddr2: array[0..48-1] of AnsiChar;  // Receiver address2 
    sEmailServer: array[0..32-1] of AnsiChar;  // Email server address 
    byServerType: BYTE;  // Email server type: 0-SMTP, 1-POP, 2-IMTP…
    byUseAuthen: BYTE;  // Email server authentication method: 1-enable, 0-disable 
    byAttachment: BYTE;  // enable attachment 
    byMailinterval: BYTE;  // mail interval 0-2s, 1-3s, 2-4s. 3-5s
  end;
  LPNET_DVR_EMAILCFG = ^NET_DVR_EMAILCFG;

type
  NET_DVR_COMPRESSIONCFG_NEW = record 
    dwSize: DWORD;  
    struLowCompression: NET_DVR_COMPRESSION_INFO_EX;  //定时录像
    struEventCompression: NET_DVR_COMPRESSION_INFO_EX;  //事件触发录像
  end;
  LPNET_DVR_COMPRESSIONCFG_NEW = ^NET_DVR_COMPRESSIONCFG_NEW;

//球机位置信息
type
  NET_DVR_PTZPOS = record 
    wAction: WORD;  //获取时该字段无效
    wPanPos: WORD;  //水平参数
    wTiltPos: WORD;  //垂直参数
    wZoomPos: WORD;  //变倍参数
  end;
  LPNET_DVR_PTZPOS = ^NET_DVR_PTZPOS;

//球机范围信息
type
  NET_DVR_PTZSCOPE = record 
    wPanPosMin: WORD;  //水平参数min
    wPanPosMax: WORD;  //水平参数max
    wTiltPosMin: WORD;  //垂直参数min
    wTiltPosMax: WORD;  //垂直参数max
    wZoomPosMin: WORD;  //变倍参数min
    wZoomPosMax: WORD;  //变倍参数max
  end;
  LPNET_DVR_PTZSCOPE = ^NET_DVR_PTZSCOPE;

//rtsp配置 ipcamera专用
type
  NET_DVR_RTSPCFG = record 
    dwSize: DWORD;  //长度
    wPort: WORD;  //rtsp服务器侦听端口
    byReserve1: array[0..40-1] of BYTE;  //预留
    wRtspsPort: WORD;  //rtsps服务器侦听端口
    byReserve: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_RTSPCFG = ^NET_DVR_RTSPCFG;

//*******************************接口参数结构(begin)********************************

//NET_DVR_Login()参数结构
type
  NET_DVR_DEVICEINFO = record 
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    byAlarmInPortNum: BYTE;  //DVR报警输入个数
    byAlarmOutPortNum: BYTE;  //DVR报警输出个数
    byDiskNum: BYTE;  //DVR硬盘个数
    byDVRType: BYTE;  //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    byChanNum: BYTE;  //DVR 通道个数
    byStartChan: BYTE;  //起始通道号,例如DVS-1,DVR - 1
  end;
  LPNET_DVR_DEVICEINFO = ^NET_DVR_DEVICEINFO;

//NET_DVR_Login_V30()参数结构
type
  NET_DVR_DEVICEINFO_V30 = record 
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    byAlarmInPortNum: BYTE;  //报警输入个数
    byAlarmOutPortNum: BYTE;  //报警输出个数
    byDiskNum: BYTE;  //硬盘个数
    byDVRType: BYTE;  //设备类型, 1:DVR 2:ATM DVR 3:DVS ......
    byChanNum: BYTE;  //模拟通道个数
    byStartChan: BYTE;  //起始通道号,例如DVS-1,DVR - 1
    byAudioChanNum: BYTE;  //语音通道数
    byIPChanNum: BYTE;  //最大数字通道个数，低位
    byZeroChanNum: BYTE;  //零通道编码个数 //2010-01-16
    byMainProto: BYTE;  //主码流传输协议类型 0-private, 1-rtsp,2-同时支持private和rtsp
    bySubProto: BYTE;  //子码流传输协议类型0-private, 1-rtsp,2-同时支持private和rtsp
    bySupport: BYTE;  //能力，位与结果为0表示不支持，1表示支持，
    //bySupport & 0x1, 表示是否支持智能搜索
    //bySupport & 0x2, 表示是否支持备份
    //bySupport & 0x4, 表示是否支持压缩参数能力获取
    //bySupport & 0x8, 表示是否支持多网卡
    //bySupport & 0x10, 表示支持远程SADP
    //bySupport & 0x20, 表示支持Raid卡功能
    //bySupport & 0x40, 表示支持IPSAN 目录查找
    //bySupport & 0x80, 表示支持rtp over rtsp
    bySupport1: BYTE;  // 能力集扩充，位与结果为0表示不支持，1表示支持
    //bySupport1 & 0x1, 表示是否支持snmp v30
    //bySupport1 & 0x2, 支持区分回放和下载
    //bySupport1 & 0x4, 是否支持布防优先级
    //bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
    //bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
    //bySupport1 & 0x20, 表示是否支持rtsp over http
    //bySupport1 & 0x80, 表示是否支持车牌新报警信息2012-9-28, 且还表示是否支持NET_DVR_IPPARACFG_V40结构体
    bySupport2: BYTE;  {能力，位与结果为0表示不支持，非0表示支持
                     bySupport2 & 0x1, 表示解码器是否支持通过URL取流解码
                     bySupport2 & 0x2,  表示支持FTPV40
                     bySupport2 & 0x4,  表示支持ANR
                     bySupport2 & 0x8,  表示支持CCD的通道参数配置
                     bySupport2 & 0x10,  表示支持布防报警回传信息（仅支持抓拍机报警 新老报警结构）
                     bySupport2 & 0x20,  表示是否支持单独获取设备状态子项
    bySupport2 & 0x40,  表示是否是码流加密设备}
    wDevType: WORD;  //设备型号
    bySupport3: BYTE;  //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport3 & 0x1, 表示是否支持批量配置多码流参数
    // bySupport3 & 0x4 表示支持按组配置， 具体包含 通道图像参数、报警输入参数、IP报警输入、输出接入参数、
    // 用户参数、设备工作状态、JPEG抓图、定时和时间抓图、硬盘盘组管理
    //bySupport3 & 0x8为1 表示支持使用TCP预览、UDP预览、多播预览中的"延时预览"字段来请求延时预览（后续都将使用这种方式请求延时预览）。而当bySupport3 & 0x8为0时，将使用 "私有延时预览"协议。
    //bySupport3 & 0x10 表示支持"获取报警主机主要状态（V40）"。
    //bySupport3 & 0x20 表示是否支持通过DDNS域名解析取流

    byMultiStreamProto: BYTE;  //是否支持多码流,按位表示,0-不支持,1-支持,bit1-码流3,bit2-码流4,bit7-主码流，bit-8子码流
    byStartDChan: BYTE;  //起始数字通道号,0表示无效
    byStartDTalkChan: BYTE;  //起始数字对讲通道号，区别于模拟对讲通道号，0表示无效
    byHighDChanNum: BYTE;  //数字通道个数，高位
    bySupport4: BYTE;  //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport4 & 0x02 表示是否支持NetSDK透传接口（NET_DVR_STDXMLConfig）透传表单格式
    //bySupport4 & 0x4表示是否支持拼控统一接口
    //bySupport4 & 0x80 支持设备上传中心报警使能。表示判断调用接口是 NET_DVR_PDC_RULE_CFG_V42还是 NET_DVR_PDC_RULE_CFG_V41
    byLanguageType: BYTE;  // 支持语种能力,按位表示,每一位0-不支持,1-支持
    //  byLanguageType 等于0 表示 老设备
    //  byLanguageType & 0x1表示支持中文
    //  byLanguageType & 0x2表示支持英文
    byVoiceInChanNum: BYTE;  //音频输入通道数
    byStartVoiceInChanNo: BYTE;  //音频输入起始通道号 0表示无效
    bySupport5: BYTE;  //按位表示,0-不支持,1-支持,bit0-支持多码流
    //bySupport5 &0x01表示支持wEventTypeEx ,兼容dwEventType 的事件类型（支持行为事件扩展）--先占住，防止冲突
    //bySupport5 &0x04表示是否支持使用扩展的场景模式接口
    {
       bySupport5 &0x08 设备返回该值表示是否支持计划录像类型V40接口协议(DVR_SET_RECORDCFG_V40/ DVR_GET_RECORDCFG_V40)(在该协议中设备支持类型类型13的配置)
       之前的部分发布的设备，支持录像类型13，则配置录像类型13。如果不支持，统一转换成录像类型3兼容处理。SDK通过命令探测处理)
       bySupport5 &0x10 设备返回改值表示支持超过255个预置点
    }
    bySupport6: BYTE;  //能力，按位表示，0-不支持,1-支持
    //bySupport6 0x1  表示设备是否支持压缩
    //bySupport6 0x2 表示是否支持流ID方式配置流来源扩展命令，DVR_SET_STREAM_SRC_INFO_V40
    //bySupport6 0x4 表示是否支持事件搜索V40接口
    //bySupport6 0x8 表示是否支持扩展智能侦测配置命令
    //bySupport6 0x40表示图片查询结果V40扩展
    byMirrorChanNum: BYTE;  //镜像通道个数，<录播主机中用于表示导播通道>
    wStartMirrorChanNo: WORD;  //起始镜像通道号
    bySupport7: BYTE;  //能力,按位表示,0-不支持,1-支持
    // bySupport7 & 0x1  表示设备是否支持 INTER_VCA_RULECFG_V42 扩展
    // bySupport7 & 0x2  表示设备是否支持 IPC HVT 模式扩展
    // bySupport7 & 0x04  表示设备是否支持 返回锁定时间
    // bySupport7 & 0x08  表示设置云台PTZ位置时，是否支持带通道号
    // bySupport7 & 0x10  表示设备是否支持双系统升级备份
    // bySupport7 & 0x20  表示设备是否支持 OSD字符叠加 V50
    // bySupport7 & 0x40  表示设备是否支持 主从（从摄像机）
    // bySupport7 & 0x80  表示设备是否支持 报文加密
    byRes2: BYTE;  //保留
  end;
  LPNET_DVR_DEVICEINFO_V30 = ^NET_DVR_DEVICEINFO_V30;

type
  NET_DVR_DEVICEINFO_V40 = record 
    struDeviceV30: NET_DVR_DEVICEINFO_V30;  
    bySupportLock: BYTE;  //设备支持锁定功能，该字段由SDK根据设备返回值来赋值的。bySupportLock为1时，dwSurplusLockTime和byRetryLoginTime有效
    byRetryLoginTime: BYTE;  //剩余可尝试登陆的次数，用户名，密码错误时，此参数有效
    byPasswordLevel: BYTE;  //admin密码安全等级
    //0-无效，1-默认密码，2-有效密码，3-风险较高的密码。当用户的密码为出厂默认密码（12345）或者风险较高的密码时，上层客户端需要提示用户更改密码。
    //4-管理员创建一个普通用户为其设置密码，该普通用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；
    //5-当普通用户的密码被管理员修改，该普通用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒;
    //6-管理员创建一个安装商/操作员用户为其设置密码，该用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，无法进行除修改本身密码外的其他操作;
    byProxyType: BYTE;  //代理类型，0-不使用代理, 1-使用socks5代理, 2-使用EHome代理
    dwSurplusLockTime: DWORD;  //剩余时间，单位秒，用户锁定时，此参数有效
    byCharEncodeType: BYTE;  //字符编码类型0-无字符编码信息(老设备),1-GB2312(简体中文)，2-GBK,3-BIG5(繁体中文),4-Shift_JIS(日文),5-EUC-KR(韩文),6-UTF-8,7-21:ISO8859-1---15(西欧),22-Hebrew(希伯来语)
    bySupportDev5: BYTE;  //支持v50版本的设备参数获取，设备名称和设备类型名称长度扩展为64字节
    bySupport: BYTE;  //能力集扩展，位与结果：0- 不支持，1- 支持
    // bySupport & 0x1:  保留
    // bySupport & 0x2:  0-不支持变化上报 1-支持变化上报
    byLoginMode: BYTE;  //登录模式 0-Private登录 1-ISAPI登录
    dwOEMCode: DWORD;  
    iResidualValidity: INT;  //该用户密码剩余有效天数，单位：天，返回负值，表示密码已经超期使用，例如“-3表示密码已经超期使用3天”
    byResidualValidity: BYTE;  // iResidualValidity字段是否有效，0-无效，1-有效
    bySingleStartDTalkChan: BYTE;  //独立音轨接入的设备，起始接入通道号，0-为保留字节，无实际含义，音轨通道号不能从0开始
    bySingleDTalkChanNums: BYTE;  //独立音轨接入的设备的通道总数，0-表示不支持
    byPassWordResetLevel: BYTE;  //0-无效，1-管理员创建一个非管理员用户为其设置密码，该非管理员用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；2-当非管理员用户的密码被管理员修改，该非管理员用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒。
    bySupportStreamEncrypt: BYTE;  //能力集扩展，位与结果：0- 不支持，1- 支持 bySupportStreamEncrypt & 0x1:表示是否支持RTP/TLS取流 bySupportStreamEncrypt & 0x2:  表示是否支持SRTP/UDP取流 bySupportStreamEncrypt & 0x4:  表示是否支持SRTP/MULTICAST取流
    byMarketType: BYTE;  //0-无效（未知类型）,1-经销型，2-行业型
    byTLSCap: BYTE;  //0-无效;byTLSCap & 0x1:  表示是否支持TLS链路预览;byTLSCap & 0x2:  表示是否支持TLS链路回放;byTLSCap & 0x4:  表示是否支持TLS链路下载;
    byRes2: array[0..237-1] of BYTE;  
  end;
  LPNET_DVR_DEVICEINFO_V40 = ^NET_DVR_DEVICEINFO_V40;

type
  fLoginResultCallBack = procedure(lUserID: LONG; dwResult: DWORD; lpDeviceInfo: LPNET_DVR_DEVICEINFO_V30; pUser: PVOID); stdcall;

const
  NET_DVR_DEV_ADDRESS_MAX_LEN = 129;    
  NET_DVR_LOGIN_USERNAME_MAX_LEN = 64;    
  NET_DVR_LOGIN_PASSWD_MAX_LEN = 64;    

type
  NET_DVR_USER_LOGIN_INFO = record 
    sDeviceAddress: array[0..NET_DVR_DEV_ADDRESS_MAX_LEN-1] of AnsiChar;  
    byUseTransport: BYTE;  //是否启用能力集透传，0--不启用透传，默认，1--启用透传
    wPort: WORD;  
    sUserName: array[0..NET_DVR_LOGIN_USERNAME_MAX_LEN-1] of AnsiChar;  
    sPassword: array[0..NET_DVR_LOGIN_PASSWD_MAX_LEN-1] of AnsiChar;  
    cbLoginResult: fLoginResultCallBack;  
    pUser: PVOID;  
    bUseAsynLogin: BOOL;  
    byProxyType: BYTE;  //0:不使用代理，1：使用标准代理，2：使用EHome代理
    byUseUTCTime: BYTE;  //0-不进行转换，默认,1-接口上输入输出全部使用UTC时间,SDK完成UTC时间与设备时区的转换,2-接口上输入输出全部使用平台本地时间，SDK完成平台本地时间与设备时区的转换
    byLoginMode: BYTE;  //0-Private 1-ISAPI 2-自适应
    byHttps: BYTE;  //0-不适用tls，1-使用tls 2-自适应
    iProxyID: LONG;  //代理服务器序号，添加代理服务器信息时，相对应的服务器数组下表值
    byVerifyMode: BYTE;  //认证方式，0-不认证，1-双向认证，2-单向认证；认证仅在使用TLS的时候生效;
    byRes3: array[0..119-1] of BYTE;  
  end;
  LPNET_DVR_USER_LOGIN_INFO = ^NET_DVR_USER_LOGIN_INFO;

//sdk网络环境枚举变量，用于远程升级
type
  SDK_NETWORK_ENVIRONMENT =  
  (  
    LOCAL_AREA_NETWORK = 0,  
    WIDE_AREA_NETWORK  
  );

//显示模式
type
  DISPLAY_MODE =  
  (  
    NORMALMODE = 0,  
    OVERLAYMODE  
  );

//发送模式
type
  SEND_MODE =  
  (  
    PTOPTCPMODE = 0,  
    PTOPUDPMODE,  
    MULTIMODE,  
    RTPMODE,  
    RESERVEDMODE  
  );

//抓图模式
type
  CAPTURE_MODE =  
  (  
    BMP_MODE = 0,  //BMP模式
    JPEG_MODE = 1  //JPEG模式
  );

//实时声音模式
type
  REALSOUND_MODE =  
  (  
    MONOPOLIZE_MODE = 1,  //独占模式
    SHARE_MODE = 2  //共享模式
  );

//软解码预览参数
type
  NET_DVR_CLIENTINFO = record 
    lChannel: LONG;  //通道号
    lLinkMode: LONG;  //最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式: 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP
    hPlayWnd: HWND;  //播放窗口的句柄,为NULL表示不播放图象
    sMultiCastIP: PAnsiChar;  //多播组地址
    byProtoType: BYTE;  //应用层取流协议，0-私有协议，1-RTSP协议
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_CLIENTINFO = ^NET_DVR_CLIENTINFO;

//SDK状态信息(9000新增)
type
  NET_DVR_SDKSTATE = record 
    dwTotalLoginNum: DWORD;  //当前login用户数
    dwTotalRealPlayNum: DWORD;  //当前realplay路数
    dwTotalPlayBackNum: DWORD;  //当前回放或下载路数
    dwTotalAlarmChanNum: DWORD;  //当前建立报警通道路数
    dwTotalFormatNum: DWORD;  //当前硬盘格式化路数
    dwTotalFileSearchNum: DWORD;  //当前日志或文件搜索路数
    dwTotalLogSearchNum: DWORD;  //当前日志或文件搜索路数
    dwTotalSerialNum: DWORD;  //当前透明通道路数
    dwTotalUpgradeNum: DWORD;  //当前升级路数
    dwTotalVoiceComNum: DWORD;  //当前语音转发路数
    dwTotalBroadCastNum: DWORD;  //当前语音广播路数
    dwTotalListenNum: DWORD;  //当前网络监听路数
    dwEmailTestNum: DWORD;  //当前邮件计数路数
    dwBackupNum: DWORD;  // 当前文件备份路数
    dwTotalInquestUploadNum: DWORD;  //当前审讯上传路数
    dwRes: array[0..6-1] of DWORD;  
  end;
  LPNET_DVR_SDKSTATE = ^NET_DVR_SDKSTATE;

//SDK功能支持信息(9000新增)
type
  NET_DVR_SDKABL = record 
    dwMaxLoginNum: DWORD;  //最大login用户数 MAX_LOGIN_USERS
    dwMaxRealPlayNum: DWORD;  //最大realplay路数 WATCH_NUM
    dwMaxPlayBackNum: DWORD;  //最大回放或下载路数 WATCH_NUM
    dwMaxAlarmChanNum: DWORD;  //最大建立报警通道路数 ALARM_NUM
    dwMaxFormatNum: DWORD;  //最大硬盘格式化路数 SERVER_NUM
    dwMaxFileSearchNum: DWORD;  //最大文件搜索路数 SERVER_NUM
    dwMaxLogSearchNum: DWORD;  //最大日志搜索路数 SERVER_NUM
    dwMaxSerialNum: DWORD;  //最大透明通道路数 SERVER_NUM
    dwMaxUpgradeNum: DWORD;  //最大升级路数 SERVER_NUM
    dwMaxVoiceComNum: DWORD;  //最大语音转发路数 SERVER_NUM
    dwMaxBroadCastNum: DWORD;  //最大语音广播路数 MAX_CASTNUM
    dwRes: array[0..10-1] of DWORD;  
  end;
  LPNET_DVR_SDKABL = ^NET_DVR_SDKABL;

//报警设备信息
type
  NET_DVR_ALARMER = record 
    byUserIDValid: BYTE;  // userid是否有效 0-无效，1-有效 
    bySerialValid: BYTE;  // 序列号是否有效 0-无效，1-有效 
    byVersionValid: BYTE;  // 版本号是否有效 0-无效，1-有效 
    byDeviceNameValid: BYTE;  // 设备名字是否有效 0-无效，1-有效 
    byMacAddrValid: BYTE;  // MAC地址是否有效 0-无效，1-有效 
    byLinkPortValid: BYTE;  // login端口是否有效 0-无效，1-有效 
    byDeviceIPValid: BYTE;  // 设备IP是否有效 0-无效，1-有效 
    bySocketIPValid: BYTE;  // socket ip是否有效 0-无效，1-有效 
    lUserID: LONG;  // NET_DVR_Login()返回值, 布防时有效 
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  // 序列号 
    dwDeviceVersion: DWORD;  // 版本信息 高16位表示主版本，低16位表示次版本
    sDeviceName: array[0..NAME_LEN-1] of AnsiChar;  // 设备名字 
    byMacAddr: array[0..MACADDR_LEN-1] of BYTE;  // MAC地址 
    wLinkPort: WORD;  // link port 
    sDeviceIP: array[0..128-1] of AnsiChar;  // IP地址 
    sSocketIP: array[0..128-1] of AnsiChar;  // 报警主动上传时的socket IP地址 
    byIpProtocol: BYTE;  // Ip协议 0-IPV4, 1-IPV6 
    byRes1: array[0..2-1] of BYTE;  
    bJSONBroken: BYTE;  //JSON断网续传标志。0：不续传；1：续传
    wSocketPort: WORD;  
    byRes2: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_ALARMER = ^NET_DVR_ALARMER;

//硬解码显示区域参数(子结构)
type
  NET_DVR_DISPLAY_PARA = record 
    bToScreen: long;  
    bToVideoOut: long;  
    nLeft: long;  
    nTop: long;  
    nWidth: long;  
    nHeight: long;  
    nReserved: long;  
  end;
  LPNET_DVR_DISPLAY_PARA = ^NET_DVR_DISPLAY_PARA;

//硬解码预览参数
type
  NET_DVR_CARDINFO = record 
    lChannel: LONG;  //通道号
    lLinkMode: LONG;  //最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式:0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-电话线，5－128k宽带，6－256k宽带，7－384k宽带，8－512k宽带；
    sMultiCastIP: PAnsiChar;  
    struDisplayPara: NET_DVR_DISPLAY_PARA;  
  end;
  LPNET_DVR_CARDINFO = ^NET_DVR_CARDINFO;

//录象文件参数
type
  NET_DVR_FIND_DATA = record 
    sFileName: array[0..100-1] of AnsiChar;  //文件名
    struStartTime: NET_DVR_TIME;  //文件的开始时间
    struStopTime: NET_DVR_TIME;  //文件的结束时间
    dwFileSize: DWORD;  //文件的大小
  end;
  LPNET_DVR_FIND_DATA = ^NET_DVR_FIND_DATA;

//录象文件参数(9000)
type
  NET_DVR_FINDDATA_V30 = record 
    sFileName: array[0..100-1] of AnsiChar;  //文件名
    struStartTime: NET_DVR_TIME;  //文件的开始时间
    struStopTime: NET_DVR_TIME;  //文件的结束时间
    dwFileSize: DWORD;  //文件的大小
    sCardNum: array[0..32-1] of AnsiChar;  
    byLocked: BYTE;  //9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    byFileType: BYTE;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_FINDDATA_V30 = ^NET_DVR_FINDDATA_V30;

//录象文件参数(cvr)
type
  NET_DVR_FINDDATA_V40 = record 
    sFileName: array[0..100-1] of AnsiChar;  //文件名
    struStartTime: NET_DVR_TIME;  //文件的开始时间
    struStopTime: NET_DVR_TIME;  //文件的结束时间
    dwFileSize: DWORD;  //文件的大小
    sCardNum: array[0..32-1] of AnsiChar;  
    byLocked: BYTE;  //9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    byFileType: BYTE;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    byQuickSearch: BYTE;  //0:普通查询结果，1：快速（日历）查询结果
    byRes: BYTE;  
    dwFileIndex: DWORD;  //文件索引号
    byStreamType: BYTE;  
    byRes1: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_FINDDATA_V40 = ^NET_DVR_FINDDATA_V40;

type
  NET_DVR_FINDDATA_V50 = record 
    sFileName: array[0..100-1] of AnsiChar;  
    struStartTime: NET_DVR_TIME_SEARCH;  
    struStopTime: NET_DVR_TIME_SEARCH;  
    struAddr: NET_DVR_ADDRESS;  //片段所在的地址信息，集群回放时用到
    dwFileSize: DWORD;  //文件大小 //对于大文件搜索类型时（byBigFileType为1），该值无意义
    byLocked: BYTE;  //文件是否被锁定，1－文件已锁定；0－文件未锁定
    byFileType: BYTE;  //文件类型，与V40相同
    byQuickSearch: BYTE;  //0- 普通查询结果，1- 快速（日历）查询结果
    byStreamType: BYTE;  //码流类型：0- 主码流，1- 子码流，2- 码流三
    dwFileIndex: DWORD;  //文件索引号
    sCardNum: array[0..32-1] of AnsiChar;  //卡号
    dwTotalLenH: DWORD;  // 对于大文件搜索，时间段内数据总长度，高32字节
    dwTotalLenL: DWORD;  // 对于大文件搜索，时间段内数据总长度，低32字节
    byBigFileType: BYTE;  // 0为普通片段搜索，1为大文件搜索
    byRes: array[0..247-1] of BYTE;  
  end;
  LPNET_DVR_FINDDATA_V50 = ^NET_DVR_FINDDATA_V50;

//录象文件参数(带卡号)
type
  NET_DVR_FINDDATA_CARD = record 
    sFileName: array[0..100-1] of AnsiChar;  //文件名
    struStartTime: NET_DVR_TIME;  //文件的开始时间
    struStopTime: NET_DVR_TIME;  //文件的结束时间
    dwFileSize: DWORD;  //文件的大小
    sCardNum: array[0..32-1] of AnsiChar;  
  end;
  LPNET_DVR_FINDDATA_CARD = ^NET_DVR_FINDDATA_CARD;


//录象文件查找条件结构
type
  NET_DVR_FILECOND = record 
    lChannel: LONG;  //通道号
    dwFileType: DWORD;  //录象文件类型
       //不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    //带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    dwIsLocked: DWORD;  //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    dwUseCardNo: DWORD;  //是否使用卡号
    sCardNumber: array[0..32-1] of BYTE;  //卡号
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
  end;
  LPNET_DVR_FILECOND = ^NET_DVR_FILECOND;

//云台区域选择放大缩小(私有 快球专用)
type
  NET_DVR_POINT_FRAME = record 
    xTop: INT;  //方框起始点的x坐标
    yTop: INT;  //方框结束点的y坐标
    xBottom: INT;  //方框结束点的x坐标
    yBottom: INT;  //方框结束点的y坐标
    bCounter: INT;  //保留
  end;
  LPNET_DVR_POINT_FRAME = ^NET_DVR_POINT_FRAME;

//语音对讲参数
type
  NET_DVR_COMPRESSION_AUDIO = record 
    byAudioEncType: BYTE;  //音频编码类型 0-OggVorbis(G722.1);1-G711_U;2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM;9-G722.1.C;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;16-ADPCM
    byAudioSamplingRate: BYTE;  //音频采样率 0-默认，1-16kHZ，2-32kHZ，3-48kHZ, 4- 44.1kHZ,5-8kHZ
    byAudioBitRate: BYTE;  // 音频码率 参考 BITRATE_ENCODE_INDEX
    byres: array[0..4-1] of BYTE;  //这里保留音频的压缩参数
    bySupport: BYTE;  //bySupport Bit0表示 Mp2l2前4个字节的含义表示后面内容音频数据长度
  end;
  LPNET_DVR_COMPRESSION_AUDIO = ^NET_DVR_COMPRESSION_AUDIO;

//2009-7-22


//  IW_ESSID_MAX_SIZE = 32;    
const
  WIFI_WEP_MAX_KEY_COUNT = 4;    
  WIFI_WEP_MAX_KEY_LENGTH = 33;    
  WIFI_WPA_PSK_MAX_KEY_LENGTH = 63;    
  WIFI_WPA_PSK_MIN_KEY_LENGTH = 8;    
  WIFI_MAX_AP_COUNT = 20;    
  WIFI_WPA_PSK_MAX_HEXKEY_LENGTH = 68;    //WPA16进制密钥最大长度

type
  NET_DVR_AP_INFO = record 
    sSsid: array[0..IW_ESSID_MAX_SIZE-1] of AnsiChar;  
    dwMode: DWORD;  // 0 mange 模式;1 ad-hoc模式，参见NICMODE 
    dwSecurity: DWORD;  //0 不加密；1 wep加密；2 wpa-psk;3 wpa-Enterprise;4-WPA2_PSK参见WIFISECURITY
    dwChannel: DWORD;  //1-11表示11个通道
    dwSignalStrength: DWORD;  //0-100信号由最弱变为最强
    dwSpeed: DWORD;  //速率,单位是0.01mbps
  end;
  LPNET_DVR_AP_INFO = ^NET_DVR_AP_INFO;

type
  NET_DVR_AP_INFO_LIST = record 
    dwSize: DWORD;  
    dwCount: DWORD;  //无线AP数量，不超过20
    struApInfo: array[0..WIFI_MAX_AP_COUNT-1] of NET_DVR_AP_INFO;  
  end;
  LPNET_DVR_AP_INFO_LIST = ^NET_DVR_AP_INFO_LIST;

type
  NET_DVR_WIFIETHERNET = record 
    sIpAddress: array[0..16-1] of AnsiChar;  //IP地址
    sIpMask: array[0..16-1] of AnsiChar;  //掩码
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理地址，只用来显示
    byCloseWifi: BYTE;  //是否关闭wifi连接，0-不关闭，1-关闭
    bRes: BYTE;  
    dwEnableDhcp: DWORD;  //是否启动dhcp  0不启动 1启动
    dwAutoDns: DWORD;  //如果启动dhcp是否自动获取dns,0不自动获取 1自动获取；对于有线如果启动dhcp目前自动获取dns
    sFirstDns: array[0..16-1] of AnsiChar;  //第一个dns域名
    sSecondDns: array[0..16-1] of AnsiChar;  //第二个dns域名
    sGatewayIpAddr: array[0..16-1] of AnsiChar;  // 网关地址
    bRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_WIFIETHERNET = ^NET_DVR_WIFIETHERNET;

type
  NET_DVR_WIFI_CFG_EX = record 
    struEtherNet: NET_DVR_WIFIETHERNET;  //wifi网口
    sEssid: array[0..IW_ESSID_MAX_SIZE-1] of AnsiChar;  //SSID
    dwMode: DWORD;  // 0 mange 模式;1 ad-hoc模式，参见
    dwSecurity: DWORD;  //0-不加密;1-WEP加密;2-WPA-personal; 3-WPA-enterprise;4-WPA2-personal;5-WPA2-enterprise 
    key: record 
      case Byte of
      0: (wep: record
        dwAuthentication: DWORD;  //0 -开放式 1-共享式
        dwKeyLength: DWORD;  // 0 -64位；1- 128位；2-152位
        dwKeyType: DWORD;  //0 16进制;1 ASCI 
        dwActive: DWORD;  //0 索引：0---3表示用哪一个密钥
        sKeyInfo: array[0..WIFI_WEP_MAX_KEY_COUNT-1, 0..WIFI_WEP_MAX_KEY_LENGTH-1] of AnsiChar;  
      end);  
      1: (wpa_psk: record
        dwKeyLength: DWORD;  //8-63个ASCII字符
        sKeyInfo: array[0..WIFI_WPA_PSK_MAX_KEY_LENGTH-1] of AnsiChar;  
        byEncryptType: BYTE;  //WPA/WPA2模式下加密类型,0-AES, 1-TKIP
        sNewKeyInfo: array[0..WIFI_WPA_PSK_MAX_HEXKEY_LENGTH{68}-1] of AnsiChar;  //新密钥（支持8-63个ASCII字符以及64个十六制字符密钥）
            //当byKeyType为0时，启用sKeyInfo，当byKeyType为1时，启用sNewKeyInfo
            //密钥类型；0 ~ 老密钥类型（只支持8-63个ASCII字符），1 ~新密钥类型（支持8-63个ASCII字符以及64个十六制字符密钥）
        byKeyType: BYTE;  
        byRes: array[0..7-1] of BYTE;  
      end);  
      2: (wpa_wpa2: record
        byEncryptType: BYTE;  //加密类型,0-AES, 1-TKIP
        byAuthType: BYTE;  //认证类型，0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
        byRes: array[0..2-1] of BYTE;  
        auth_param: record 
          case Byte of
          0: (EAP_TTLS: record
            byEapolVersion: BYTE;  //EAPOL版本，0-版本1，1-版本2
            byAuthType: BYTE;  //内部认证方式，0-PAP，1-MSCHAPV2
            byRes1: array[0..2-1] of BYTE;  
            byAnonyIdentity: array[0..NAME_LEN-1] of BYTE;  //匿名身份
            byUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
            byPassword: array[0..NAME_LEN-1] of BYTE;  //密码
            byRes: array[0..44-1] of BYTE;  
          end);  //WPA-enterprise/WPA2-enterpris模式适用
          1: (EAP_PEAP: record
            byEapolVersion: BYTE;  //EAPOL版本，0-版本1，1-版本2
            byAuthType: BYTE;  //内部认证方式，0-GTC，1-MD5，2-MSCHAPV2
            byPeapVersion: BYTE;  //PEAP版本，0-版本0，1-版本1
            byPeapLabel: BYTE;  //PEAP标签，0-老标签，1-新标签
            byAnonyIdentity: array[0..NAME_LEN-1] of BYTE;  //匿名身份
            byUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
            byPassword: array[0..NAME_LEN-1] of BYTE;  //密码
            byRes: array[0..44-1] of BYTE;  
          end);  //WPA-enterprise/WPA2-enterpris模式适用
          2: (EAP_TLS: record
            byEapolVersion: BYTE;  //EAPOL版本，0-版本1，1-版本2
            byRes1: array[0..3-1] of BYTE;  
            byIdentity: array[0..NAME_LEN-1] of BYTE;  //身份
            byPrivateKeyPswd: array[0..NAME_LEN-1] of BYTE;  //私钥密码
            byRes: array[0..76-1] of BYTE;  
          end);  
        end;  
      end);  //WPA-enterprise/WPA2-enterpris模式适用
    end;  
  end;
  LPNET_DVR_WIFI_CFG_EX = ^NET_DVR_WIFI_CFG_EX;

//wifi配置结构
type
  NET_DVR_WIFI_CFG = record 
    dwSize: DWORD;  
    struWifiCfg: NET_DVR_WIFI_CFG_EX;  
  end;
  LPNET_DVR_WIFI_CFG = ^NET_DVR_WIFI_CFG;

//wifi连接状态
type
  NET_DVR_WIFI_CONNECT_STATUS = record 
    dwSize: DWORD;  
    byCurStatus: BYTE;  //1-已连接，2-未连接，3-正在连接
    byRes1: array[0..3-1] of BYTE;  //保留
    dwErrorCode: DWORD;  // byCurStatus = 2时有效,1-用户名或密码错误,2-无此路由器,3-未知错误
    byRes: array[0..244-1] of BYTE;  
  end;
  LPNET_DVR_WIFI_CONNECT_STATUS = ^NET_DVR_WIFI_CONNECT_STATUS;

//wifi工作模式
type
  NET_DVR_WIFI_WORKMODE = record 
    dwSize: DWORD;  
    dwNetworkInterfaceMode: DWORD;  //0 自动切换模式　1 有线模式
  end;
  LPNET_DVR_WIFI_WORKMODE = ^NET_DVR_WIFI_WORKMODE;

//结构参数宏定义
const
  VCA_MAX_POLYGON_POINT_NUM = 10;    //检测区域最多支持10个点的多边形
  MAX_RULE_NUM = 8;    //最多规则条数
  MAX_RULE_NUM_V42 = 16;    //最多规则条数扩展
  MAX_TARGET_NUM = 30;    //最多目标个数
  MAX_CALIB_PT = 6;    //最大标定点个数
  MIN_CALIB_PT = 4;    //最小标定点个数
  MAX_TIMESEGMENT_2 = 2;    //最大时间段数
  DATA_INDEX_LEN = 64;    //数据流水号
  MAX_DEV_DATAINDEX_LEN = 64;    //设备数据流水号
  MAX_TRAFFIC_PICTURE_NUM = 8;    //交通图片数量
  MAX_LICENSE_LEN = 16;    //车牌号最大长度
  MAX_LICENSE_LEN_EX = 32;    //车牌号最大长度
  MAX_CARDNO_LEN = 48;    //卡号最大长度 2013-11-04
  MAX_OPERATE_INDEX_LEN = 32;    //操作数最大长度2014-03-03
  MAX_PLATE_NUM = 3;    //车牌个数
  MAX_MASK_REGION_NUM = 4;    //最多四个屏蔽区域
  MAX_SEGMENT_NUM = 6;    //摄像机标定最大样本线数目
  MIN_SEGMENT_NUM = 3;    //摄像机标定最小样本线数目
  MAX_REL_SNAPCHAN_NUM = 3;    //最大关联抓图通道数
  MAX_PIC_SWITCH_STORAGE_SERVER = 64;    //云存储服务器存储的最大图片类型数
  MAX_INFO_SWITCH_STORAGE_SERVER = 64;    //云存储服务器存储的最大附加信息类型数
  RTMP_URL_LEN = 128;    //RTMP URL 长度
  MAX_ID_LEN_128 = 128;    //发布文件ID长度
  MAX_DEBUGCMD_LEN = 1024;    //设备调试命令最大长度
  MAX_DEBUGINFO_LEN = 1400;    //设备调试信息最大长度
  MAX_VEHICLE_ID_LEN = 32;    //最大车辆标识长度
  LEN_PROPERTY = 128;    
type
  NET_DVR_VEHICLE_INFO_COND = record 
    dwSize: DWORD;  //本段报文长度,
    strStartTime: NET_DVR_TIME_EX;  //开始时间
    strStopTime: NET_DVR_TIME_EX;  //结束时间
    sLicense: array[0..MAX_LICENSE_LEN_EX{32}-1] of AnsiChar;  //车牌号码
    dwChannel: DWORD;  
    byRegion: BYTE;  
    byRes: array[0..127-1] of BYTE;  // 区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
  end;
  LPNET_DVR_VEHICLE_INFO_COND = ^NET_DVR_VEHICLE_INFO_COND;

type
  NET_DVR_VEHICLE_INFO_CFG = record 
    dwSize: DWORD;  
    dwIndex: DWORD;  //序号
    byDeviceID: array[0..DEVICE_ID_LEN{48}-1] of BYTE;  //设备编号
    byBelieve: BYTE;  //置信度，0-100
    byDir: BYTE;  //方向，0-无意义，1-反向，2-正向，3-未知
    byLineID: BYTE;  //车道号
    byRes1: BYTE;  
    struSnapTime: NET_DVR_TIME_EX;  //抓拍时间
    sLicense: array[0..MAX_LICENSE_LEN_EX{32}-1] of AnsiChar;  //车牌号码
    byMonitoringSiteID: array[0..MONITORSITE_ID_LEN{48}-1] of BYTE;  //显示点编号
    byCountry: BYTE;  // 国家索引值，参照枚举COUNTRY_INDEX（不支持”COUNTRY_ALL = 0xff, //ALL  全部”）
    byMatchingResult: BYTE;  //匹配结果：0-保留，1-允许名单，2-禁止名单，3-其他
    byArea: BYTE;  //区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
    byPlateType: BYTE;  //车牌类型 参考 VCA_PLATE_TYPE
    sDeviceName: array[0..NAME_LEN{32}-1] of AnsiChar;  //设备名称
    byPlateColor: BYTE;  //车牌颜色 参考 VCA_PLATE_COLOR
    byPlateSize: BYTE;  //车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
    byRes2: array[0..2-1] of BYTE;  
    sPlateCategory: array[0..MAX_CATEGORY_LEN{8}-1] of AnsiChar;  //车牌附加信息, 即车牌小字信息，(目前只有中东地区支持)
    sPlateImageURL: array[0..URL_LEN_V40{256}-1] of AnsiChar;  //车牌小图URL
    sEffectiveTime: array[0..ISO_8601_LEN{32}-1] of AnsiChar;  //车牌信息有效时间，使用ISO8601 time格式，如：2009-11-14T15:27Z
    byRes: array[0..176-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_INFO_CFG = ^NET_DVR_VEHICLE_INFO_CFG;

//智能控制信息
const
  MAX_VCA_CHAN = 16;    //最大智能通道数
type
  NET_VCA_CTRLINFO = record 
    byVCAEnable: BYTE;  //是否开启智能
    byVCAType: BYTE;  //智能能力类型，VCA_CHAN_ABILITY_TYPE
    byStreamWithVCA: BYTE;  //码流中是否带智能信息
    byMode: BYTE;  //模式，ATM能力时参照VCA_CHAN_MODE_TYPE ,TFS能力时参照TFS_CHAN_MODE_TYPE
    byControlType: BYTE;  //控制类型，按位表示，0-否，1-是
    // byControlType &1 是否启用抓拍功能
    byPicWithVCA: BYTE;  // 报警抓图叠加目标信息(目标框)：0-不叠加（默认），1-叠加；
    byRes: array[0..2-1] of BYTE;  //保留，设置为0
  end;
  LPNET_VCA_CTRLINFO = ^NET_VCA_CTRLINFO;

//智能控制信息结构
type
  NET_VCA_CTRLCFG = record 
    dwSize: DWORD;  
    struCtrlInfo: array[0..MAX_VCA_CHAN-1] of NET_VCA_CTRLINFO;  //控制信息,数组0对应设备的起始通道
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_VCA_CTRLCFG = ^NET_VCA_CTRLCFG;

//智能设备能力集
type
  NET_VCA_DEV_ABILITY = record 
    dwSize: DWORD;  //结构长度
    byVCAChanNum: BYTE;  //智能通道个数
    byPlateChanNum: BYTE;  //车牌通道个数
    byBBaseChanNum: BYTE;  //行为基本版个数
    byBAdvanceChanNum: BYTE;  //行为高级版个数
    byBFullChanNum: BYTE;  //行为完整版个数
    byATMChanNum: BYTE;  //智能ATM个数
    byPDCChanNum: BYTE;  //人数统计通道个数
    byITSChanNum: BYTE;  //交通事件通道个数
    byBPrisonChanNum: BYTE;  //行为监狱版(监舍)通道个数
    byFSnapChanNum: BYTE;  //人脸抓拍通道个数
    byFSnapRecogChanNum: BYTE;  //人脸抓拍和识别通道个数
    byFRetrievalChanNum: BYTE;  //人脸后检索个数
    bySupport: BYTE;  //能力，位与结果为0表示不支持，1表示支持
    //bySupport & 0x1，表示是否支持智能 2012-3-22
    //bySupport & 0x2，表示是否支持128路取流扩展2012-12-27
    byFRecogChanNum: BYTE;  //人脸识别通道个数
    byBPPerimeterChanNum: BYTE;  //行为监狱版(周界)通道个数
    byTPSChanNum: BYTE;  //交通诱导通道个数
    byTFSChanNum: BYTE;  //道路违章取证通道个数
    byFSnapBFullChanNum: BYTE;  //人脸抓拍和异常行为检测通道个数
    byHeatMapChanNum: BYTE;  //热度图通道个数
    bySmartVehicleNum: BYTE;  //SMART事件+车辆检测通道个数
    bySmartHVTNum: BYTE;  //SMART事件+混行检测通道个数
    bySmartNum: BYTE;  //SMART事件个数
    byVehicleNum: BYTE;  //车辆检测通道个数
    bySmartRoadDetectionNum: BYTE;  // SMART事件+道路布防通道个数
    bySmartFaceDetectionNum: BYTE;  // SMART事件+人脸侦测通道个数
    bySmartHeatMapNum: BYTE;  // SMART事件+热度图通道个数
    byHumanRecognitionNum: BYTE;  //人体识别通道个数
    byEdcationStudentNum: BYTE;  //教育录播（学生起来检测&&学生人数统计）支持的通道数
    byRoadDetectionNum: BYTE;  //道路布防通道个数
    byPersonDensityDetection: BYTE;  //人员密度检测通道个数
    bySafetyHelmetDetection: BYTE;  //安全帽检测通道个数
    byPerimeterCapture: BYTE;  //周界抓拍通道个数
    byHeelPDC: BYTE;  //倾斜客流通道个数
    by12MPLiveView: BYTE;  // 主码流 1200W@20fps预览（4000*3000）
    byTeacherBehaviorDetectNum: BYTE;  //教育录播（教师行为检测）支持的通道数
    byMixedTargetDetection: BYTE;  //混合目标检测通道个数
    byFaceContrast: BYTE;  //人脸比对检测通道个数
    byCityManagement: BYTE;  //智慧城管检测通道个数
    byMixedTargetDetectionSmart: BYTE;  //混合目标检测+Smart事件
    byRes: BYTE;  
  end;
  LPNET_VCA_DEV_ABILITY = ^NET_VCA_DEV_ABILITY;


//异常行为检测能力类型
{$WARN BOUNDS_ERROR OFF}
type
  VCA_ABILITY_TYPE =  
  (  
    TRAVERSE_PLANE_ABILITY = $01,  //穿越警戒面
    ENTER_AREA_ABILITY = $02,  //进入区域
    EXIT_AREA_ABILITY = $04,  //离开区域
    INTRUSION_ABILITY = $08,  //入侵
    LOITER_ABILITY = $10,  //徘徊
    LEFT_TAKE_ABILITY = $20,  //物品遗留拿取
    PARKING_ABILITY = $40,  //停车
    RUN_ABILITY = $80,  //快速移动
    HIGH_DENSITY_ABILITY = $100,  //人员聚集
    LF_TRACK_ABILITY = $200,  //球机
    VIOLENT_MOTION_ABILITY = $400,  //剧烈运动检测
    REACH_HIGHT_ABILITY = $800,  //攀高检测
    GET_UP_ABILITY = $1000,  //起身检测
    LEFT_ABILITY = $2000,  //物品遗留
    TAKE_ABILITY = $4000,  //物品拿取
    LEAVE_POSITION = $8000,  //离岗
    TRAIL_ABILITY = $10000,  //尾随
    KEY_PERSON_GET_UP_ABILITY = $20000,  //重点人员起身检测
    STANDUP_ABILITY = $40000,  //起立
    FALL_DOWN_ABILITY = $80000,  //倒地
    AUDIO_ABNORMAL_ABILITY = $100000,  //声强突变
    ADV_REACH_HEIGHT_ABILITY = $200000,  //折线攀高
    TOILET_TARRY_ABILITY = $400000,  //如厕超时
    YARD_TARRY_ABILITY = $800000,  //放风场滞留
    ADV_TRAVERSE_PLANE_ABILITY = $1000000,  //折线警戒面
    LECTURE_ABILITY = $2000000,  //授课
    ANSWER_ABILITY = $4000000,  //回答问题
    HUMAN_ENTER_ABILITY = $10000000,  //人靠近ATM ,只在ATM_PANEL模式下支持
    OVER_TIME_ABILITY = $20000000,  //操作超时,只在ATM_PANEL模式下支持
    STICK_UP_ABILITY = $40000000,  //贴纸条
    INSTALL_SCANNER_ABILITY = $80000000  //安装读卡器
  );
{$WARN BOUNDS_ERROR ON}

type
  VCA_ABILITY_TYPE_EX =  
  (  
    PEOPLENUM_CHANGE_ABILITY = $00000002,  //人数变化检测
    SPACING_CHANGE_ABILITY = $00000004,  //间距变化检测
    EVENT_COMBINED_ABILITY = $00000008,  //组合事件规则
    EVENT_SIT_QUIETLY = $00000010,  //一动不动
    EVENT_HIGH_DENSITY_STATUS_ABILITY = $00000020,  //人员聚集状态
    EVENT_RUNNING = $00000040,  //奔跑
    EVENT_RETENTION = $00000080,  //滞留
    EVENT_TEACHER_WRITING = $00000100,  //板书
    EVENT_FAKECARD = $00000200  //伪造卡检测
  );

//智能通道类型
type
  VCA_CHAN_ABILITY_TYPE =  
  (  
    VCA_BEHAVIOR_BASE = 1,  //异常行为检测基本版
    VCA_BEHAVIOR_ADVANCE = 2,  //异常行为检测高级版
    VCA_BEHAVIOR_FULL = 3,  //异常行为检测完整版
    VCA_PLATE = 4,  //车牌能力
    VCA_ATM = 5,  //ATM能力
    VCA_PDC = 6,  //人流量统计
    VCA_ITS = 7,  //智能 交通事件
    VCA_BEHAVIOR_PRISON = 8,  //异常行为检测监狱版(监舍)
    VCA_FACE_SNAP = 9,  //人脸抓拍能力
    VCA_FACE_SNAPRECOG = 10,  //人脸抓拍和识别能力
    VCA_FACE_RETRIEVAL = 11,  //人脸后检索能力
    VCA_FACE_RECOG = 12,  //人脸识别能力
    VCA_BEHAVIOR_PRISON_PERIMETER = 13,  // 异常行为检测监狱版 (周界)
    VCA_TPS = 14,  //交通诱导
    VCA_TFS = 15,  //道路违章取证
    VCA_BEHAVIOR_FACESNAP = 16,  //人脸抓拍和异常行为检测能力
    VCA_HEATMAP = 17,  //热度图
    VCA_SMART_VEHICLE_DETECTION = 18,  // SMART事件+车辆检测
    VCA_SMART_HVT_DETECTION = 19,  // SMART事件+混行检测
    VCA_SMART_EVENT = 20,  // SMART事件
    VCA_VEHICLE_DETECTION = 21,  // 车辆检测
    VCA_SMART_ROAD_DETECTION = 22,  // SMART事件+道路布防
    VCA_SMART_FACE_DETECTION = 23,  // SMART事件+人脸侦测
    VCA_SMART_HEATMAP = 24,  // SMART事件+热度图
    VCA_HUMAN_RECOGNITION = 25,  // 人体识别
    VCA_EDUCATION_STUDENT_DETECTION = 26,  //教育录播（学生起来检测&&学生人数统计）
    VCA_ROAD_DETECTION = 27,  //道路布防
    VCA_PERSON_DENSITY_DETECTION = 28,  //人员密度检测
    VCA_PERIMETER_CAPTURE = 29,  //周界抓拍
    VCA_SAFETY_HELMET_DETECTION = 30,  //安全帽检测
    VCA_HEEL_PDC = 31,  //倾斜客流
    VCA_12MPLIVE_VIEW = 32,  //主码流 1200W@20fps预览（4000*3000）
    VCA_TEACHER_BEHAVIOR_DETECTION = 33,  //教师行为检测
    VCA_MIXED_TARGET_DETECTION = 34,  //混合目标检测
    VCA_FACE_CONTRAST = 35,  //人脸对比检测(同时支持人脸抓拍及人脸对比功能，但是算法核心不同。算法采用人脸比对为核心，确保每次比对成功。若目标不适合对比则将舍弃对该目标进行抓拍。)
    VCA_CITY_MANAGEMENT = 36,  //智慧城管
    VCA_MIXED_TARGET_DETECTION_SMART = 37  //混合目标检测加Smart
  );

//智能ATM模式类型(ATM能力特有)
type
  VCA_CHAN_MODE_TYPE =  
  (  
    VCA_ATM_PANEL = 0,  //ATM面板
    VCA_ATM_SURROUND = 1,  //ATM环境
    VCA_ATM_FACE = 2,  //ATM人脸
    VCA_ATM_SAFETYCABIN = 3  //ATM防护舱
  );

//交通取证TFS通道模式(TFS能力特有)
type
  TFS_CHAN_MODE_TYPE =  
  (  
    TFS_CITYROAD = 0,  //TFS 城市道路
    TFS_FREEWAY = 1  //TFS 高速道路
  );

//异常行为检测场景模式
type
  BEHAVIOR_SCENE_MODE_TYPE =  
  (  
    BEHAVIOR_SCENE_DEFAULT = 0,  //系统默认
    BEHAVIOR_SCENE_WALL = 1,  //围墙
    BEHAVIOR_SCENE_INDOOR = 2  //室内
  );

//监舍模式
type
  BEHAVIOR_PRISON_MODE_TYPE =  
  (  
    BEHAVIOR_PRISON = 0,  //监所
    BEHAVIOR_HEARING = 1,  //审讯室
    BEHAVIOR_RECFIELD = 2  //放风场
  );
  LPBEHAVIOR_PRISON_MODE_TYPE = BEHAVIOR_PRISON_MODE_TYPE;


//通道能力输入参数
type
  NET_VCA_CHAN_IN_PARAM = record 
    byVCAType: BYTE;  //VCA_CHAN_ABILITY_TYPE枚举值
    byMode: BYTE;  //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE,TFS能力时参照TFS_CHAN_MODE_TYPE,当VCA_TYPE 为交通事件时参照TRAFFIC_SCENE_MODE
    byRes: array[0..2-1] of BYTE;  //保留，设置为0
  end;
  LPNET_VCA_CHAN_IN_PARAM = ^NET_VCA_CHAN_IN_PARAM;


//行为能力集结构
type
  NET_VCA_BEHAVIOR_ABILITY = record 
    dwSize: DWORD;  //结构长度
    dwAbilityType: DWORD;  //支持的能力类型，按位表示，见VCA_ABILITY_TYPE定义
    byMaxRuleNum: BYTE;  //最大规则数
    byMaxTargetNum: BYTE;  //最大目标数
    bySupport: BYTE;  // 支持的功能类型   按位表示
    // bySupport & 0x01 支持标定功能
    byRes: array[0..5-1] of BYTE;  //保留，设置为0
    dwAbilityTypeEx: DWORD;  //支持的能力类型，按位表示，见VCA_ABILITY_TYPE_EX定义
  end;
  LPNET_VCA_BEHAVIOR_ABILITY = ^NET_VCA_BEHAVIOR_ABILITY;

//场景变更数据更新参数
type
  NET_DVR_SCENE_CHANGE_UPDATE_PARAM = record 
    dwSize: DWORD;  
    byIDCount: BYTE;  //实际流ID数
    byRes1: array[0..3-1] of BYTE;  
    byStreamID: array[0..MAX_STREAM_ID_NUM-1, 0..STREAM_ID_LEN-1] of BYTE;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM = ^NET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// 交通能力集结构
type
  NET_DVR_ITS_ABILITY = record 
    dwSize: DWORD;  // 结构体大小
    dwAbilityType: DWORD;  // 支持的能力列表  参照ITS_ABILITY_TYPE
    byMaxRuleNum: BYTE;  //最大规则数
    byMaxTargetNum: BYTE;  //最大目标数
    byRes: array[0..10-1] of BYTE;  // 保留
  end;
  LPNET_DVR_ITS_ABILITY = ^NET_DVR_ITS_ABILITY;

//**********************************end******************************************

//***********************************智能参数结构********************************
//智能共用结构
//坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位

//异常行为检测事件类型
{$WARN BOUNDS_ERROR OFF}
type
  VCA_EVENT_TYPE =  
  (  
    VCA_TRAVERSE_PLANE = $1,  //穿越警戒面
    VCA_ENTER_AREA = $2,  //目标进入区域,支持区域规则
    VCA_EXIT_AREA = $4,  //目标离开区域,支持区域规则
    VCA_INTRUSION = $8,  //周界入侵,支持区域规则
    VCA_LOITER = $10,  //徘徊,支持区域规则
    VCA_LEFT_TAKE = $20,  //物品遗留拿取,支持区域规则
    VCA_PARKING = $40,  //停车,支持区域规则
    VCA_RUN = $80,  //快速移动,支持区域规则
    VCA_HIGH_DENSITY = $100,  //区域内人员聚集,支持区域规则
    VCA_VIOLENT_MOTION = $200,  //剧烈运动检测
    VCA_REACH_HIGHT = $400,  //攀高检测
    VCA_GET_UP = $800,  //起身检测
    VCA_LEFT = $1000,  //物品遗留
    VCA_TAKE = $2000,  //物品拿取
    VCA_LEAVE_POSITION = $4000,  //离岗
    VCA_TRAIL = $8000,  //尾随
    VCA_KEY_PERSON_GET_UP = $10000,  //重点人员起身检测
    VCA_STANDUP = $20000,  //起立
    VCA_FALL_DOWN = $80000,  //倒地检测
    VCA_AUDIO_ABNORMAL = $100000,  //声强突变检测
    VCA_ADV_REACH_HEIGHT = $200000,  //折线攀高
    VCA_TOILET_TARRY = $400000,  //如厕超时
    VCA_YARD_TARRY = $800000,  //放风场滞留
    VCA_ADV_TRAVERSE_PLANE = $1000000,  //折线警戒面
    VCA_LECTURE = $2000000,  //授课
    VCA_ANSWER = $4000000,  //回答问题
    VCA_HUMAN_ENTER = $10000000,  //人靠近ATM           只在ATM_PANEL模式下支持
    VCA_OVER_TIME = $20000000,  //操作超时            只在ATM_PANEL模式下支持
    VCA_STICK_UP = $40000000,  //贴纸条,支持区域规则
    VCA_INSTALL_SCANNER = $80000000  //安装读卡器,支持区域规则
  );
{$WARN BOUNDS_ERROR ON}

//异常行为检测事件类型扩展
type
  VCA_RULE_EVENT_TYPE_EX =  
  (  
    ENUM_VCA_EVENT_TRAVERSE_PLANE = 1,  //穿越警戒面
    ENUM_VCA_EVENT_ENTER_AREA = 2,  //目标进入区域,支持区域规则
    ENUM_VCA_EVENT_EXIT_AREA = 3,  //目标离开区域,支持区域规则
    ENUM_VCA_EVENT_INTRUSION = 4,  //周界入侵,支持区域规则
    ENUM_VCA_EVENT_LOITER = 5,  //徘徊,支持区域规则
    ENUM_VCA_EVENT_LEFT_TAKE = 6,  //物品遗留拿取,支持区域规则
    ENUM_VCA_EVENT_PARKING = 7,  //停车,支持区域规则
    ENUM_VCA_EVENT_RUN = 8,  //快速移动,支持区域规则
    ENUM_VCA_EVENT_HIGH_DENSITY = 9,  //区域内人员聚集,支持区域规则
    ENUM_VCA_EVENT_VIOLENT_MOTION = 10,  //剧烈运动检测
    ENUM_VCA_EVENT_REACH_HIGHT = 11,  //攀高检测
    ENUM_VCA_EVENT_GET_UP = 12,  //起身检测
    ENUM_VCA_EVENT_LEFT = 13,  //物品遗留
    ENUM_VCA_EVENT_TAKE = 14,  //物品拿取
    ENUM_VCA_EVENT_LEAVE_POSITION = 15,  //离岗
    ENUM_VCA_EVENT_TRAIL = 16,  //尾随
    ENUM_VCA_EVENT_KEY_PERSON_GET_UP = 17,  //重点人员起身检测
    ENUM_VCA_EVENT_STANDUP = 18,  //起立
    ENUM_VCA_EVENT_FALL_DOWN = 20,  //倒地检测
    ENUM_VCA_EVENT_AUDIO_ABNORMAL = 21,  //声强突变检测
    ENUM_VCA_EVENT_ADV_REACH_HEIGHT = 22,  //折线攀高
    ENUM_VCA_EVENT_TOILET_TARRY = 23,  //如厕超时
    ENUM_VCA_EVENT_YARD_TARRY = 24,  //放风场滞留
    ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //折线警戒面
    ENUM_VCA_EVENT_LECTURE = 26,  //授课（文教）
    ENUM_VCA_EVENT_ANSWER = 27,  //回答问题（文教）
    ENUM_VCA_EVENT_HUMAN_ENTER = 29,  //人靠近ATM,只在ATM_PANEL模式下支持
    ENUM_VCA_EVENT_OVER_TIME = 30,  //操作超时,只在ATM_PANEL模式下支持
    ENUM_VCA_EVENT_STICK_UP = 31,  //贴纸条,支持区域规则
    ENUM_VCA_EVENT_INSTALL_SCANNER = 32,  //安装读卡器,支持区域规则
    ENUM_VCA_EVENT_PEOPLENUM_CHANGE = 35,  //人数变化事件
    ENUM_VCA_EVENT_SPACING_CHANGE = 36,  //间距变化事件
    ENUM_VCA_EVENT_COMBINED_RULE = 37,  //组合规则事件
    ENUM_VCA_EVENT_SIT_QUIETLY = 38,  //一动不动则事件
    ENUM_VCA_EVENT_HIGH_DENSITY_STATUS = 39,  //区域内人员聚集状态
    ENUM_VCA_EVENT_RUNNING = 40,  //奔跑检测
    ENUM_VCA_EVENT_RETENTION = 41,  //滞留检测
    ENUM_VCA_EVENT_BLACKBOARD_WRITE = 42,  //板书
    ENUM_VCA_EVENT_SITUATION_ANALYSIS = 43,  //态势分析
    ENUM_VCA_EVENT_PLAY_CELLPHONE = 44,  //玩手机检测
    ENUM_VCA_EVENT_DURATION = 45,  //持续报警
    ENUM_VCA_EVENT_FAKECARD = 46  //伪造卡检测
  );

//警戒面穿越方向类型
type
  VCA_CROSS_DIRECTION =  
  (  
    VCA_BOTH_DIRECTION,  // 双向
    VCA_LEFT_GO_RIGHT,  // 由左至右
    VCA_RIGHT_GO_LEFT  // 由右至左
  );

//线结构
type
  NET_VCA_LINE = record 
    struStart: NET_VCA_POINT;  //起点
    struEnd: NET_VCA_POINT;  //终点
  end;
  LPNET_VCA_LINE = ^NET_VCA_LINE;

//多边型结构体
type
  NET_VCA_POLYGON = record 
    dwPointNum: DWORD;  //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域
    struPos: array[0..VCA_MAX_POLYGON_POINT_NUM-1] of NET_VCA_POINT;  //多边形边界点,最多十个
  end;
  LPNET_VCA_POLYGON = ^NET_VCA_POLYGON;

//警戒面参数
type
  NET_VCA_TRAVERSE_PLANE = record 
    struPlaneBottom: NET_VCA_LINE;  //警戒面底边
    dwCrossDirection: VCA_CROSS_DIRECTION;  //穿越方向: 0-双向，1-从左到右，2-从右到左
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byPlaneHeight: BYTE;  //警戒面高度
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byPriority: BYTE;  //优先级,0~低,1~中,2~高
    byAlarmConfidence: BYTE;  //报警置信度, 0-低,1-较低,2-较高,3-高
    byRecordConfidence: BYTE;  //录像置信度, 0-低,1-较低,2-较高,3-高
    byRes2: array[0..34-1] of BYTE;  //保留
  end;
  LPNET_VCA_TRAVERSE_PLANE = ^NET_VCA_TRAVERSE_PLANE;

type
  NET_VCA_SIT_QUIETLY = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    dwDuration: DWORD;  //持续时间  单位s 范围1-3600
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_VCA_SIT_QUIETLY = ^NET_VCA_SIT_QUIETLY;

//进入/离开区域参数
type
  NET_VCA_AREA = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byPriority: BYTE;  //优先级,0~低,1~中,2~高
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_AREA = ^NET_VCA_AREA;

//根据报警延迟时间来标识报警中带图片，报警间隔和IO报警一致，1秒发送一个。
//入侵参数
type
  NET_VCA_INTRUSION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //行为事件触发时间阈值: 1-120秒，建议5秒，判断是有效报警的时间  在ATM系统中触发文件阈值为 1-1000秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byRate: BYTE;  //占比：区域内所有未报警目标尺寸目标占区域面积的比重，归一化为－；
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byPriority: BYTE;  //优先级,0~低,1~中,2~高
    byAlarmConfidence: BYTE;  //报警置信度, 0-低,1-较低,2-较高,3-高
    byRecordConfidence: BYTE;  //录像置信度, 0-低,1-较低,2-较高,3-高
  end;
  LPNET_VCA_INTRUSION = ^NET_VCA_INTRUSION;

//徘徊参数
type
  NET_VCA_LOITER = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发时间阈值：1-120秒，建议10秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..1-1] of BYTE;  
    dwLoiterDistance: DWORD;  //行程总距离阈值：100-5000，默认1000cm
  end;
  LPNET_VCA_LOITER = ^NET_VCA_LOITER;

//物品遗留/物品拿取参数
type
  NET_VCA_TAKE_LEFT = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发时间阈值：1-120秒，建议10秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_TAKE_LEFT = ^NET_VCA_TAKE_LEFT;

//停车参数
type
  NET_VCA_PARKING = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发时间阈值：1-100秒，建议10秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_PARKING = ^NET_VCA_PARKING;

//快速移动参数
type
  NET_VCA_RUN = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    fRunDistance: FLOAT;  //人快速移动最大距离, 范围: [0.1, 1.00] 像素模式 实际模式(1,20)m/s
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byMode: BYTE;  // 0 像素模式  1 实际模式
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byRes: BYTE;  
  end;
  LPNET_VCA_RUN = ^NET_VCA_RUN;

//人员聚集参数
type
  NET_VCA_HIGH_DENSITY = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    fDensity: FLOAT;  //聚集比率, 范围: [0.1, 1.0]
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: BYTE;  // 保留字节
    wDuration: WORD;  // 触发人员聚集参数报警阈值 20-360s
  end;
  LPNET_VCA_HIGH_DENSITY = ^NET_VCA_HIGH_DENSITY;

//剧烈运动参数
type
  NET_VCA_VIOLENT_MOTION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发剧烈运动报警阈值：1-50秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byMode: BYTE;  //0-纯视频模式，1-音视频联合模式，2-纯音频模式
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_VIOLENT_MOTION = ^NET_VCA_VIOLENT_MOTION;

// 攀高参数
type
  NET_VCA_REACH_HIGHT = record 
    struVcaLine: NET_VCA_LINE;  //攀高警戒面
    wDuration: WORD;  //触发攀高报警阈值：1-120秒
    byRes: array[0..6-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_REACH_HIGHT = ^NET_VCA_REACH_HIGHT;

// 起床参数
type
  NET_VCA_GET_UP = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发起床报警阈值1-100 秒
    byMode: BYTE;  //起身检测模式,0-大床通铺模式,1-高低铺模式,2-大床通铺坐立起身模式
    bySensitivity: BYTE;  //灵敏度参数，范围[1,10]
    byRes: array[0..4-1] of BYTE;  //保留字节
  end;
  LPNET_VCA_GET_UP = ^NET_VCA_GET_UP;

// 物品遗留
type
  NET_VCA_LEFT = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    wDuration: WORD;  // 触发物品遗留报警阈值 10-100秒
    bySensitivity: BYTE;  // 灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_LEFT = ^NET_VCA_LEFT;

// 物品拿取
type
  NET_VCA_TAKE = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    wDuration: WORD;  // 触发物品拿取报警阈值10-100秒
    bySensitivity: BYTE;  // 灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_TAKE = ^NET_VCA_TAKE;

type
  NET_VCA_OVER_TIME = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    wDuration: WORD;  // 操作报警时间阈值 4s-60000s
    byRes: array[0..6-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_OVER_TIME = ^NET_VCA_OVER_TIME;

type
  NET_VCA_HUMAN_ENTER = record 
    dwRes: array[0..23-1] of DWORD;  //保留字节
  end;
  LPNET_VCA_HUMAN_ENTER = ^NET_VCA_HUMAN_ENTER;

//贴纸条参数
type
  NET_VCA_STICK_UP = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //触发时间阈值：4-60秒，建议10秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_STICK_UP = ^NET_VCA_STICK_UP;

//读卡器参数
type
  NET_VCA_SCANNER = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //读卡持续时间：4-60秒
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_SCANNER = ^NET_VCA_SCANNER;

//离岗事件
type
  NET_VCA_LEAVE_POSITION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wLeaveDelay: WORD;  //无人报警时间，单位：s
    wStaticDelay: WORD;  //睡觉报警时间，单位：s
    byMode: BYTE;  //模式，0-离岗事件，1-睡岗事件，2-离岗睡岗事件，3-在岗（当离岗人员回到岗位）
    byPersonType: BYTE;  //值岗人数类型，0-单人值岗，1-双人值岗
    byOnPosition: BYTE;  //在岗人数，1-10，默认1
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
  end;
  LPNET_VCA_LEAVE_POSITION = ^NET_VCA_LEAVE_POSITION;

//尾随参数
type
  NET_VCA_TRAIL = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wRes: WORD;  // 保留 
    bySensitivity: BYTE;  // 灵敏度参数，范围[1,5] 
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_TRAIL = ^NET_VCA_TRAIL;

//倒地参数
type
  NET_VCA_FALL_DOWN = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  // 触发事件阈值 1-60s
    bySensitivity: BYTE;  // 灵敏度参数，范围[1,5] 
    byHeightThreshold: BYTE;  //高度阈值，范围[0,250]，默认90，单位：厘米
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_VCA_FALL_DOWN = ^NET_VCA_FALL_DOWN;

//起立
type
  NET_VCA_STANDUP = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1,100]
    byHeightThreshold: BYTE;  //高度阈值，范围[0,250]，默认130，单位：厘米
    wDuration: WORD;  //触发事件阈值[1,3600]，默认2，单位：秒
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_STANDUP = ^NET_VCA_STANDUP;


//人数变化
type
  NET_VCA_PEOPLENUM_CHANGE = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1,100]
    byPeopleNumThreshold: BYTE;  //人数阈值，范围[0,5]，默认1
    byDetectMode: BYTE;  //检测方式，与人数阈值相比较。1-大于，2-小于，3-等于，4-不等于
    byNoneStateEffective: BYTE;  //无人状态是否有效，0-无效，1-有效
    wDuration: WORD;  //触发时间阈值[1,3600]，默认2，单位：秒
    byPeopleNum: BYTE;  //触发报警人数，只读，仅报警上报，设备返回0表示不支持本功能上报，0xff表示报警人数为0
    byRes: BYTE;  //保留
  end;
  LPNET_VCA_PEOPLENUM_CHANGE = ^NET_VCA_PEOPLENUM_CHANGE;

//间距变化
type
  NET_VCA_SPACING_CHANGE = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    fSpacingThreshold: FLOAT;  //间距阈值，范围[0,10.0]，默认1.0，单位：米
    bySensitivity: BYTE;  //灵敏度参数，范围[1,100]
    byDetectMode: BYTE;  //检测方式，与间距阈值相比较。1-大于，2-小于
    wDuration: WORD;  //触发时间阈值[1,3600]，默认2，单位：秒
  end;
  LPNET_VCA_SPACING_CHANGE = ^NET_VCA_SPACING_CHANGE;


//声强突变参数
type
  NET_VCA_AUDIO_ABNORMAL = record 
    wDecibel: WORD;  //声音强度
    bySensitivity: BYTE;  //灵敏度参数，范围[1,100]
    byAudioMode: BYTE;  //声音检测模式，0-灵敏度检测，1-分贝阈值检测，2-灵敏度与分贝阈值检测
    byEnable: BYTE;  //使能，是否开启(声强突变，陡升)
    byThreshold: BYTE;  //声音阈值[1,100]
    byRes: array[0..54-1] of BYTE;  //保留
  end;
  LPNET_VCA_AUDIO_ABNORMAL = ^NET_VCA_AUDIO_ABNORMAL;

//声强陡降 2014-03-21
type
  NET_DVR_AUDIO_STEEP_DROP = record 
    bySensitivity: BYTE;  // 灵敏度参数，范围[1,100] 
    byEnable: BYTE;  //使能，是否开启(声强突变，陡降)
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_STEEP_DROP = ^NET_DVR_AUDIO_STEEP_DROP;


type
  NET_DVR_AUDIO_EXCEPTION = record 
    dwSize: DWORD;  
    byEnableAudioInException: BYTE;  //使能，是否开启
    byRes1: array[0..3-1] of BYTE;  
    struAudioAbnormal: NET_VCA_AUDIO_ABNORMAL;  
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道 数 实际支持的数量
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  
    struAudioSteepDrop: NET_DVR_AUDIO_STEEP_DROP;  //声强陡降
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_EXCEPTION = ^NET_DVR_AUDIO_EXCEPTION;

type
  NET_VCA_TOILET_TARRY = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDelay: WORD;  //如厕超时时间[1,3600]，单位：秒
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_VCA_TOILET_TARRY = ^NET_VCA_TOILET_TARRY;

type
  NET_VCA_YARD_TARRY = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDelay: WORD;  //放风场滞留时间[1,120]，单位：秒
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_VCA_YARD_TARRY = ^NET_VCA_YARD_TARRY;

type
  NET_VCA_ADV_REACH_HEIGHT = record 
    struRegion: NET_VCA_POLYGON;  //攀高折线
    dwCrossDirection: DWORD;  //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    byRes: array[0..4-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_ADV_REACH_HEIGHT = ^NET_VCA_ADV_REACH_HEIGHT;

type
  NET_VCA_ADV_TRAVERSE_PLANE = record 
    struRegion: NET_VCA_POLYGON;  //警戒面折线
    dwCrossDirection: DWORD;  //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..3-1] of BYTE;  //保留字节
  end;
  LPNET_VCA_ADV_TRAVERSE_PLANE = ^NET_VCA_ADV_TRAVERSE_PLANE;

type
  NET_VCA_PLAY_CELLPHONE = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //玩手机超时时间[1,600]秒, 默认20秒
    byRes: array[0..6-1] of BYTE;  //保留字节
  end;
  LPNET_VCA_PLAY_CELLPHONE = ^NET_VCA_PLAY_CELLPHONE;

type
  NET_VCA_LECTURE = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    wDuration: WORD;  //行为事件触发时间阈值: 1-10秒，建议1秒，判断是有效报警的时间
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byAlarmState: BYTE;  //只读字段界面不显示；0-保留,1-报警开始,2-报警结束
    byTrackingMode: BYTE;  //模式，0-自动(默认) , 1-水平, 2-垂直
    byZoomMode: BYTE;  //变倍模式, 0-固定(默认), 1-自动
    byZoomOver: BYTE;  //0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    byTrackStatus: BYTE;  //状态 0-保留，1-开始授课（A，全景） 2-正在（2,特写），3 -丢失（2,全景）
  end;
  LPNET_VCA_LECTURE = ^NET_VCA_LECTURE;

type
  NET_VCA_ANSWER = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byAlarmState: BYTE;  //只读字段界面不显示；0-保留,1-报警开始,2-报警结束
    byZoomOver: BYTE;  //0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    byAnswerStudent: BYTE;  //0-保留，1-无学生起立，2-单个学生起立，3-多个学生起立,4-疑似学生起立, 5-单个学生走动
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_ANSWER = ^NET_VCA_ANSWER;

//关联规则结构体
type
  NET_VCA_RELATE_RULE_PARAM = record 
    byRuleID: BYTE;  //规则序号 0-表示无
    byRes: BYTE;  //保留
    wEventType: WORD;  //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX留
  end;
  LPNET_VCA_RELATE_RULE_PARAM = ^NET_VCA_RELATE_RULE_PARAM;

type
  NET_VCA_COMBINED_RULE = record 

    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    byRuleSequence: BYTE;  
    byRes: array[0..7-1] of BYTE;  
    dwMinInterval: DWORD;  //最小时间间隔，单位：秒
    dwMaxInterval: DWORD;  //最大时间间隔，单位：秒
    struRule1Raram: NET_VCA_RELATE_RULE_PARAM;  //规则1
    struRule2Raram: NET_VCA_RELATE_RULE_PARAM;  //规则2
    byRes1: array[0..36-1] of BYTE;  
  end;
  LPNET_VCA_COMBINED_RULE = ^NET_VCA_COMBINED_RULE;

//板书事件
type
  NET_VCA_BLACKBOARD_WRITE = record 
    struRegion: NET_VCA_POLYGON;  //区域范围（配置区域，报警中不含有该区域）
    byTeacherState: BYTE;  //教师状态；0~教师特写，1~教师全景，2~讲台无人状态
    byWritingState: BYTE;  //板书状态；0~板书开始，1~板书结束
    byWritingArea: BYTE;  //板书区域；0~整个板书，1~板书左边，2~板书右边
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_VCA_BLACKBOARD_WRITE = ^NET_VCA_BLACKBOARD_WRITE;

//人员聚集状态
type
  NET_VCA_HIGH_DENSITY_STATUS = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    fDensity: FLOAT;  //聚集比率, 范围: [0.1, 1.0]
    bySensitivity: BYTE;  //灵敏度参数，范围[1,5]
    byRes: array[0..3-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_HIGH_DENSITY_STATUS = ^NET_VCA_HIGH_DENSITY_STATUS;

//奔跑检测
type
  NET_VCA_RUNNING = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    dwSpeed: DWORD;  //奔跑速度，范围[1,10]
    wDuration: WORD;  // 触发报警时间阈值
    byRunMode: BYTE;  //奔跑模式，0-保留,1：单人奔跑,2:多人奔跑
    byRes: BYTE;  
  end;
  LPNET_VCA_RUNNING = ^NET_VCA_RUNNING;

// 滞留检测
type
  NET_VCA_RETENTION = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    wDuration: WORD;  //触发滞留报警阈值时间（60-3600秒）默认1800秒
    byRes: array[0..6-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_RETENTION = ^NET_VCA_RETENTION;

// 态势分析参数
type
  NET_VCA_SITUATION_ANALYSIS = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    wPeopleNum: WORD;  //区域人数
    byRes: array[0..6-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_SITUATION_ANALYSIS = ^NET_VCA_SITUATION_ANALYSIS;

//持续报警
type
  NET_VCA_DURATION = record 
    wRelationEventType: WORD;  //参考VCA_RULE_EVENT_TYPE_EX
    byRes: array[0..90-1] of BYTE;  
  end;
  LPNET_VCA_DURATION = ^NET_VCA_DURATION;

//伪造卡检测参数
type
  NET_VCA_FAKECARD = record 
    struRegion: NET_VCA_POLYGON;  // 区域范围
    bySensitivity: BYTE;  // 灵敏度参数：最小1,最大5,默认3
    byRes: array[0..7-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FAKECARD = ^NET_VCA_FAKECARD;

//警戒事件参数
type
  NET_VCA_EVENT_UNION = record 
    case Byte of
    0: (uLen: array[0..23-1] of DWORD);  //参数
    1: (struTraversePlane: NET_VCA_TRAVERSE_PLANE);  //穿越警戒面参数
    2: (struArea: NET_VCA_AREA);  //进入/离开区域参数
    3: (struIntrusion: NET_VCA_INTRUSION);  //入侵参数
    4: (struLoiter: NET_VCA_LOITER);  //徘徊参数
    5: (struTakeTeft: NET_VCA_TAKE_LEFT);  //物品遗留/物品拿取参数
    6: (struParking: NET_VCA_PARKING);  //停车参数
    7: (struRun: NET_VCA_RUN);  //快速移动参数
    8: (struHighDensity: NET_VCA_HIGH_DENSITY);  //人员聚集参数
    9: (struViolentMotion: NET_VCA_VIOLENT_MOTION);  //剧烈运动
    10: (struReachHight: NET_VCA_REACH_HIGHT);  //攀高
    11: (struGetUp: NET_VCA_GET_UP);  //起床
    12: (struLeft: NET_VCA_LEFT);  //物品遗留
    13: (struTake: NET_VCA_TAKE);  // 物品拿取
    14: (struHumanEnter: NET_VCA_HUMAN_ENTER);  //人员进入
    15: (struOvertime: NET_VCA_OVER_TIME);  //操作超时
    16: (struStickUp: NET_VCA_STICK_UP);  //贴纸条
    17: (struScanner: NET_VCA_SCANNER);  //读卡器参数
    18: (struLeavePos: NET_VCA_LEAVE_POSITION);  //离岗参数
    19: (struTrail: NET_VCA_TRAIL);  //尾随参数
    20: (struFallDown: NET_VCA_FALL_DOWN);  //倒地参数
    21: (struAudioAbnormal: NET_VCA_AUDIO_ABNORMAL);  //声强突变
    22: (struReachHeight: NET_VCA_ADV_REACH_HEIGHT);  //折线攀高参数
    23: (struToiletTarry: NET_VCA_TOILET_TARRY);  //如厕超时参数
    24: (struYardTarry: NET_VCA_YARD_TARRY);  //放风场滞留参数
    25: (struAdvTraversePlane: NET_VCA_ADV_TRAVERSE_PLANE);  //折线警戒面参数
    26: (struLecture: NET_VCA_LECTURE);  //授课事件
    27: (struAnswer: NET_VCA_ANSWER);  //回答问题事件
    28: (struStandUp: NET_VCA_STANDUP);  //起立参数
    29: (struPeopleNumChange: NET_VCA_PEOPLENUM_CHANGE);  //人数变化参数
    30: (struSpacingChange: NET_VCA_SPACING_CHANGE);  //间距变化参数
    31: (struCombinedRule: NET_VCA_COMBINED_RULE);  //组合规则参数
    32: (struSitQuietly: NET_VCA_SIT_QUIETLY);  //一动不动参数
    33: (struHighDensityStatus: NET_VCA_HIGH_DENSITY_STATUS);  //人员聚集状态
    34: (struRunning: NET_VCA_RUNNING);  //奔跑参数
    35: (struRetention: NET_VCA_RETENTION);  //滞留检测
    36: (struBlackboardWrite: NET_VCA_BLACKBOARD_WRITE);  //板书参数
    37: (struSituationAnalysis: NET_VCA_SITUATION_ANALYSIS);  //态势分析参数
    38: (struPlayCellphone: NET_VCA_PLAY_CELLPHONE);  //玩手机检测参数
    39: (struDruation: NET_VCA_DURATION);  //持续报警参数
    40: (struFakeCard: NET_VCA_FAKECARD);  //伪造卡检测
  end;
  LPNET_VCA_EVENT_UNION = ^NET_VCA_EVENT_UNION;

// 尺寸过滤器类型
type
  SIZE_FILTER_MODE =  
  (  
    IMAGE_PIX_MODE,  //根据像素大小设置
    REAL_WORLD_MODE,  //根据实际大小设置
    DEFAULT_MODE  // 默认模式
  );
//尺寸过滤器
type
  NET_VCA_SIZE_FILTER = record 
    byActive: BYTE;  //是否激活尺寸过滤器 0-否 非0-是
    byMode: BYTE;  //过滤器模式SIZE_FILTER_MODE
    byRes: array[0..2-1] of BYTE;  //保留，置0
    struMiniRect: NET_VCA_RECT;  //最小目标框,全0表示不设置
    struMaxRect: NET_VCA_RECT;  //最大目标框,全0表示不设置
  end;
  LPNET_VCA_SIZE_FILTER = ^NET_VCA_SIZE_FILTER;

//警戒规则结构
type
  NET_VCA_ONE_RULE = record 
    byActive: BYTE;  //是否激活规则,0-否,非0-是
    byRes: array[0..7-1] of BYTE;  //保留，设置为0字段
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    dwEventType: VCA_EVENT_TYPE;  //异常行为检测事件类型
    uEventParam: NET_VCA_EVENT_UNION;  //异常行为检测事件参数
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_2-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
  end;
  LPNET_VCA_ONE_RULE = ^NET_VCA_ONE_RULE;

//异常行为检测配置结构体
type
  NET_VCA_RULECFG = record 
    dwSize: DWORD;  //结构长度
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    byUpLastAlarm: BYTE;  //2011-04-06 是否先上传最近一次的报警
    byPicRecordEnable: BYTE;  //2012-3-1是否启用图片存储, 0-不启用, 1-启用
    byRes: BYTE;  
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struRule: array[0..MAX_RULE_NUM-1] of NET_VCA_ONE_RULE;  //规则数组
  end;
  LPNET_VCA_RULECFG = ^NET_VCA_RULECFG;

//前端设备地址信息，智能分析仪表示的是前端设备的地址信息，其他设备表示本机的地址
{
当接入设备模拟通道(IPC/DVR/DVS/IVMS)报警的时候，下面字段填写设备的IP地址，端口，byChannel和byIvmsChannel 均为当前的模拟通道号
eg:
struDevIP =  模拟通道对应设备的IP地址
wPort  =  模拟通道对应设备的端口
byChannel =  报警对应模拟通道的通道号
byIvmsChannel = 报警对应模拟通道的通道号

  当接入设备数字通道(DVR/DVS/IVMS)报警的时候，下面字段填写数字通道接入设备的IP地址，端口，byChannel为数字通道接入设备的通道号，byIvmsChannel为数字通道号
  eg:
  struDevIP =  数字通道接入设备的IP地址
  wPort  =  数字通道接入设备的端口
  byChannel =  数字通道接入设备的通道号
  byIvmsChannel = 数字通道号
}
type
  NET_VCA_DEV_INFO = record 
    struDevIP: NET_DVR_IPADDR;  //前端设备地址，
    wPort: WORD;  //前端设备端口号，
    byChannel: BYTE;  //前端设备通道，
    byIvmsChannel: BYTE;  // Ivms 通道
  end;
  LPNET_VCA_DEV_INFO = ^NET_VCA_DEV_INFO;

type
  NET_DVR_TARGET_LEFT_REGION_ALARM = record 
    dwSize: DWORD;  //结构大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    byTargetType: BYTE;  //检测目标类型 0-无效目标，1-教师 2-学生
    byLeftDirection: BYTE;  //检测目标离开方向类型0-保留,1-上,2-下,3-左,4-右
    byTargetStatus: BYTE;  //0-保留(不做处理)
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_TARGET_LEFT_REGION_ALARM = ^NET_DVR_TARGET_LEFT_REGION_ALARM;

// 报警图片图片信息 
type
  NET_DVR_DBD_PICTURE_INFO = record 

    {20-司机吸烟   司机报警从抽烟开始, 21-司机打电话, 22-司机疲劳驾驶, 23-司机没有目视前方（离岗）,24-司机检测不到头部, 25-司机系安全带,
    26-司机捡拾物品, 27-司机打哈欠, 28-司机吃东西或喝水, 29-司机聊天, 31-司机未穿工作服}
    dwPicType: DWORD;  // 报警图片类型 
    pPicBuf: PAnsiChar;  //图片指针
    dwPicLen: DWORD;  // 报警图片长度，为0时表示没有图片 
    dwTime: DWORD;  // 抓图时间 
    pVideoBuf: PAnsiChar;  //视频指针, xxx.mp4
    dwVideoLen: DWORD;  // 抓图视频的长度，0表示没有报警视频 20180518 
    byRes: array[0..12-1] of BYTE;  // 预留 
  end;
  LPNET_DVR_DBD_PICTURE_INFO = ^NET_DVR_DBD_PICTURE_INFO;

// 报警位置信息 
type
  NET_DVR_DBD_POSITION_INFO = record 
// 24 bytes 
    bValid: DWORD;  // 定位信息是否有效 
    dwLongitude: DWORD;  // 经度 = 实际度*3600*100+实际分*60*100+实际秒*100 
    dwLatitude: DWORD;  // 纬度 = 实际度*3600*100+实际分*60*100+实际秒*100 
    dwVehicleSpeed: DWORD;  // 速度 = 实际速度*1000*100 
    dwVehicleDirection: DWORD;  // 速度方向角 = 实际方向*100 
    dwAltitude: DWORD;  // 海拔高度(厘米) 
  end;
  LPNET_DVR_DBD_POSITION_INFO = ^NET_DVR_DBD_POSITION_INFO;

// 报警状态信息 
type
  NET_DVR_DBD_ALARM_STATE = record 
// 24 bytes 
    bySmoke: BYTE;  // 吸烟 
    byPhone: BYTE;  // 打电话 
    byTiredDriving: BYTE;  // 疲劳驾驶 
    byNoVisualFront: BYTE;  // 没有目视前方 
    byNoHead: BYTE;  // 离岗 
    byWithoutBelt: BYTE;  // 不系安全带 
    byPickingUpThing: BYTE;  // 捡拾物品 
    byYawn: BYTE;  // 打哈欠 
    byEatOrDrink: BYTE;  // 吃喝 
    byChatting: BYTE;  // 聊天 
    byTampering: BYTE;  // 遮挡IPC 
    byWithoutUniform: BYTE;  // 未穿工作服 
    byDriverCmpFail: BYTE;  // 身份识别异常
    byDriverChange: BYTE;  // 驾驶员更换
    byDriveLongTime: BYTE;  //超时驾驶
    byInfraredBlockingSunglasses: BYTE;  // 红外阻断墨镜 
    byOutOfWheel: BYTE;  // 0-保留，1-单手脱离方向盘，2-双手脱离方向盘 
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_DBD_ALARM_STATE = ^NET_DVR_DBD_ALARM_STATE;

// 驾驶行为报警信息 
type
  NET_DVR_DBD_ALRAM_INFO = record 
    dwSize: DWORD;  // 报警上传结构体大小 4
    byChannel: BYTE;  // 通道号 1
    byLevel: BYTE;  //报警等级,当前只有1
    byRes1: array[0..2-1] of BYTE;  // 保留字节 3
    struIpcInfo: NET_VCA_DEV_INFO;  // 报警IP通道信息 24
    struPosInfo: NET_DVR_DBD_POSITION_INFO;  // 报警位置信息 24
    struPicInfo: NET_DVR_DBD_PICTURE_INFO;  // 报警图片信息
    struAlarmState: NET_DVR_DBD_ALARM_STATE;  // 报警状态信息 24
    byRes2: array[0..20-1] of BYTE;  // 保留   20
  end;
  LPNET_DVR_DBD_ALRAM_INFO = ^NET_DVR_DBD_ALRAM_INFO;

// ADAS报警图片信息 
type
  NET_DVR_ADAS_PICTURE_INFO = record 
    dwPicType: DWORD;  // 报警图片类型 
    pPicBuf: PAnsiChar;  //图片指针
    dwPicLen: DWORD;  // 报警图片长度，为0时表示没有图片 
    dwTime: DWORD;  // 抓图时间 
    pVideoBuf: PAnsiChar;  //视频指针, xxx.mp4
    dwVideoLen: DWORD;  // 抓图视频的长度，0表示没有报警视频 20180518 
    byRes: array[0..12-1] of BYTE;  // 预留 
  end;
  LPNET_DVR_ADAS_PICTURE_INFO = ^NET_DVR_ADAS_PICTURE_INFO;

// ADAS报警位置信息 
type
  NET_DVR_ADAS_POSITION_INFO = record 
// 24 bytes 
    dwValid: DWORD;  // 定位信息是否有效 
    dwLongitude: DWORD;  // 经度 = 实际度*3600*100+实际分*60*100+实际秒*100 
    dwLatitude: DWORD;  // 纬度 = 实际度*3600*100+实际分*60*100+实际秒*100 
    dwVehicleSpeed: DWORD;  // 速度 = 实际速度*1000*100 
    dwVehicleDirection: DWORD;  // 速度方向角 = 实际方向*100 
    dwAltitude: DWORD;  // 海拔高度(厘米) 
  end;
  LPNET_DVR_ADAS_POSITION_INFO = ^NET_DVR_ADAS_POSITION_INFO;

// ADAS报警状态信息 
type
  NET_DVR_ADAS_ALARM_STATE = record 
// 24 bytes 
    dwFcw: BYTE;  // 前车碰撞，0无，1事件发生 
    dwLdw: BYTE;  // 车道偏离，0无，1左侧偏离，2右侧偏离 
    dwHmw: BYTE;  // 车距显示，0无，1事件发生 
    dwPcw: BYTE;  // 行人碰撞，0无，1事件发生 
    dwBsd: BYTE;  // 盲区检测，0无，1事件发生 , 2-右侧盲区报警，3-左侧盲区报警, 4-后侧盲区报警
    byAcc: BYTE;  // 急加速，0无，1事件发生 
    byBrake: BYTE;  //急减速，0无，1事件发生 
    byTurn: BYTE;  // 急转弯，0无，1右急转弯，2左急转弯 
    byRollover: BYTE;  // 侧翻，0无，1事件发生 
    byNoCourtesy: BYTE;  // 未礼让行人，0无，1事件发生 
    byTsr: BYTE;  //交通标识警告，0无，1限速，2限高，3限宽 
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_ADAS_ALARM_STATE = ^NET_DVR_ADAS_ALARM_STATE;

// ADAS驾驶行为报警信息 
type
  NET_DVR_ADAS_ALRAM_INFO = record 
    dwSize: DWORD;  // 报警上传结构体大小 4
    byChannel: BYTE;  // 通道号 1
    byRes1: array[0..3-1] of BYTE;  // 保留字节 3
    struIpcInfo: NET_VCA_DEV_INFO;  // 报警IP通道信息 28
    struPosInfo: NET_DVR_ADAS_POSITION_INFO;  // 报警位置信息 24
    struPicInfo: NET_DVR_ADAS_PICTURE_INFO;  // 报警图片信息
    struAlarmState: NET_DVR_ADAS_ALARM_STATE;  // 报警状态信息 24
    byRes2: array[0..20-1] of BYTE;  // 保留   20
  end;
  LPNET_DVR_ADAS_ALRAM_INFO = ^NET_DVR_ADAS_ALRAM_INFO;

// 行车实时数据 
type
  NET_DVR_VEH_REALTIME_DATA_INFO = record 
    dwSize: DWORD;  // 报警上传结构体大小 
    dwSpeedValue: DWORD;  // 速度值 
    dwSpeedPulse: DWORD;  // 测速脉冲 
    byUpgPercent: BYTE;  // 升级进度，正常0-100，升级失败返回255，每次开始升级时，首先需要等进度0，才表示准备开始了 20180508扩展
    byRes1: array[0..3-1] of BYTE;  
    dwVideoLostChans: DWORD;  //按位表示，0表示正常，1-表示视频丢失，第一位表示第一通道
    byRes2: array[0..44-1] of BYTE;  
  end;
  LPNET_DVR_VEH_REALTIME_DATA_INFO = ^NET_DVR_VEH_REALTIME_DATA_INFO;

const
  VCA_ATTEND_MAX_PIC_NUM = 3;    //考勤事件最大图片张数
  VCA_ATTEND_DRIVER_NAME_LEN = 64;    //分组信息司机名字长度
  VCA_ATTEND_CARD_ID_LEN = 32;    //分组信息司机证件号码长度
  VCA_ATTEND_MAX_ALARM_ID_LEN = 32;    //报警事件唯一编号的最大长度

type
  NET_DVR_VCA_ATTEND_PICDATA = record 
    dwPicLen: DWORD;  //报警图片长度，为0时表示没有图片
    pPicBuf: PAnsiChar;  //图片指针
    byRes: array[0..12-1] of BYTE;  //预留
  end;
  LPNET_DVR_VCA_ATTEND_PICDATA = ^NET_DVR_VCA_ATTEND_PICDATA;

// 考勤事件图片信息 
type
  NET_DVR_VCA_ATTEND_PICTURE_INFO = record 
    byPicNum: BYTE;  //考勤图片数量
    byRes1: array[0..3-1] of BYTE;  //预留
    struPicData: array[0..VCA_ATTEND_MAX_PIC_NUM-1] of NET_DVR_VCA_ATTEND_PICDATA;  //报警图片数据
    dwVideoLen: DWORD;  //抓图视频的长度，0表示没有报警视频
    pVideoBuf: PAnsiChar;  //视频指针
    byRes: array[0..64-1] of BYTE;  //预留
  end;
  LPNET_DVR_VCA_ATTEND_PICTURE_INFO = ^NET_DVR_VCA_ATTEND_PICTURE_INFO;

// 考勤事件上传信息
type
  NET_DVR_VCA_ATTEND_ALARM_INFO = record 
    dwSize: DWORD;  // 报警上传结构体大小
    byMethod: BYTE;  //考勤方式 0-IC卡考勤,1-人脸考勤
    byStatus: BYTE;  //考勤状态 0-保留，1-上班,2-下班（无人脸或换班）
    byCertIDType: BYTE;  //驾驶员证件类型：0-营运资格证，1-身份证
    byCertIDLen: BYTE;  //驾驶员从业资格证编码长度
    sCertId: array[0..VCA_ATTEND_CARD_ID_LEN-1] of AnsiChar;  //驾驶员从业资格证编码
    dwTime: DWORD;  //考勤时间
    sName: array[0..VCA_ATTEND_DRIVER_NAME_LEN-1] of AnsiChar;  //驾驶员姓名
    sAlarmIdNo: array[0..VCA_ATTEND_MAX_ALARM_ID_LEN-1] of AnsiChar;  //报警标识号
    struPicInfo: NET_DVR_VCA_ATTEND_PICTURE_INFO;  //报警图片信息
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VCA_ATTEND_ALARM_INFO = ^NET_DVR_VCA_ATTEND_ALARM_INFO;

//尺寸过滤策略
type
  NET_VCA_FILTER_STRATEGY = record 
    byStrategy: BYTE;  //尺寸过滤策略 0 - 不启用 1-高度和宽度过滤,2-面积过滤
    byRes: array[0..11-1] of BYTE;  //保留
  end;
  LPNET_VCA_FILTER_STRATEGY = ^NET_VCA_FILTER_STRATEGY;

//规则触发参数
type
  NET_VCA_RULE_TRIGGER_PARAM = record 
    byTriggerMode: BYTE;  //规则的触发方式，0- 不启用，1- 点 2- 目标面积
    byTriggerPoint: BYTE;  //触发点，触发方式为点时有效 0- 中,1-上,2-下
    byRes1: array[0..2-1] of BYTE;  //保留
    fTriggerArea: FLOAT;  //触发目标面积百分比 [0,100]，触发方式为目标面积时有效
    byRes2: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_RULE_TRIGGER_PARAM = ^NET_VCA_RULE_TRIGGER_PARAM;

//警戒规则结构
type
  NET_VCA_ONE_RULE_V41 = record 
    byActive: BYTE;  //是否激活规则,0-否,非0-是
    byRes1: array[0..4-1] of BYTE;  //保留，设置为0字段
    byEventTypeFlag: BYTE;  //标志行为事件类型字段的有效性，0-dwEventType有效，1-wEventTypeEx有效
    //注：此字段byEventTypeFlag只在设置参数时有效，从设备获取参数时，可直接从wEventTypeEx获取事件类型，无需判断此字段的值
    wEventTypeEx: WORD;  //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    dwEventType: VCA_EVENT_TYPE;  //行为事件类型，保留是为了兼容，后续建议使用wEventTypeEx获取事件类型
    uEventParam: NET_VCA_EVENT_UNION;  //异常行为检测事件参数
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    wAlarmDelay: WORD;  //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    byRes2: array[0..2-1] of BYTE;  //保留
    struFilterStrategy: NET_VCA_FILTER_STRATEGY;  //尺寸过滤策略
    struTriggerParam: NET_VCA_RULE_TRIGGER_PARAM;  //规则触发参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_VCA_ONE_RULE_V41 = ^NET_VCA_ONE_RULE_V41;

//异常行为检测配置结构体
type
  NET_VCA_RULECFG_V41 = record 
    dwSize: DWORD;  //结构长度
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    byUpLastAlarm: BYTE;  //2011-04-06 是否先上传最近一次的报警
    byPicRecordEnable: BYTE;  //2012-3-1是否启用图片存储, 0-不启用, 1-启用
    byRes1: BYTE;  
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struRule: array[0..MAX_RULE_NUM-1] of NET_VCA_ONE_RULE_V41;  //规则数组
    wRelSnapChan: array[0..MAX_REL_SNAPCHAN_NUM-1] of WORD;  //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    byRes: array[0..26-1] of BYTE;  
  end;
  LPNET_VCA_RULECFG_V41 = ^NET_VCA_RULECFG_V41;

//警戒规则结构
type
  NET_VCA_ONE_RULE_V42 = record 
    byActive: BYTE;  //是否激活规则, 0-否，非0-是
    byEventPriority: BYTE;  //事件优先级 0-低，1-中，2-高
    byBackgroundSuppression: BYTE;  //背景干扰抑制 0-关闭 1-开启 2-自适应
    byRes1: array[0..3-1] of BYTE;  //保留，设置为0字段
    wEventType: WORD;  //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX
    byRuleName: array[0..NAME_LEN{32}-1] of BYTE;  //规则名称
    uEventParam: NET_VCA_EVENT_UNION;  //异常行为检测事件参数
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V40;  //处理方式
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  // 报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的关联通道号无效
    wAlarmDelay: WORD;  //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    byRes2: array[0..2-1] of BYTE;  //保留
    struFilterStrategy: NET_VCA_FILTER_STRATEGY;  //尺寸过滤策略
    struTriggerParam: NET_VCA_RULE_TRIGGER_PARAM;  //规则触发参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_VCA_ONE_RULE_V42 = ^NET_VCA_ONE_RULE_V42;


type
  NET_DVR_PTZ_POSITION = record 

    // 是否启用场景，在设置场景行为规则的时候该字段无效，在设置球机本地配置场景位置信息时作为使能位
    byEnable: BYTE;  
    byRes1: array[0..3-1] of BYTE;  //保留
    byPtzPositionName: array[0..NAME_LEN-1] of BYTE;  //场景位置名称
    struPtzPos: NET_DVR_PTZPOS;  //ptz 坐标
    byRes2: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_POSITION = ^NET_DVR_PTZ_POSITION;

//异常行为检测配置结构体
type
  NET_VCA_RULECFG_V42 = record 
    dwSize: DWORD;  //结构图大小
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 1-上传
    byUpLastAlarm: BYTE;  //是否先上传最近一次的报警，0-否，1-是
    byPicRecordEnable: BYTE;  //是否启用图片存储, 0-不启用, 1-启用
    byRes1: BYTE;  
    struPicParam: NET_DVR_JPEGPARA;  //图片规格结构
    struRule: array[0..MAX_RULE_NUM_V42{16}-1] of NET_VCA_ONE_RULE_V42;  // 规则数组
    wRelSnapChan: array[0..MAX_REL_SNAPCHAN_NUM-1] of WORD;  //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    byTrackEnable: BYTE;  //是否启用
    byRes2: BYTE;  
    struPTZPosition: NET_DVR_PTZ_POSITION;  //场景位置信息
    wTrackDuration: WORD;  //持续时间，单位s
    wIntervalTime: WORD;  //单次报警间隔时间（秒）[1-7200]（默认为600）
    wHeightLimit: WORD;  //目标检测高度下限（厘米）[0-250]（默认为80cm），小于此高度的目标将不作为目标进行检测
    byRes: array[0..58-1] of BYTE;  //保留
  end;
  LPNET_VCA_RULECFG_V42 = ^NET_VCA_RULECFG_V42;


//简化目标结构体
type
  NET_VCA_TARGET_INFO = record 
    dwID: DWORD;  //目标ID ,人员聚集过高报警时为0
    struRect: NET_VCA_RECT;  //目标边界框
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_TARGET_INFO = ^NET_VCA_TARGET_INFO;

//简化的规则信息, 包含规则的基本信息
type
  NET_VCA_RULE_INFO = record 
    byRuleID: BYTE;  //规则ID,0-7
    bySceneID: BYTE;  //场景ID,返回0无效
    wEventTypeEx: WORD;  //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    dwEventType: VCA_EVENT_TYPE;  //行为事件类型，保留是为了兼容，后续建议使wEventTypeEx获取事件类型
    uEventParam: NET_VCA_EVENT_UNION;  //事件参数
  end;
  LPNET_VCA_RULE_INFO = ^NET_VCA_RULE_INFO;

//异常行为检测结果上报结构
type
  NET_VCA_RULE_ALARM = record 
    dwSize: DWORD;  //结构长度
    dwRelativeTime: DWORD;  //相对时标,历史原因，实际没用，本版本用起来当byRelativeTimeFlag为1时，表示为UTC的时间
    dwAbsTime: DWORD;  //绝对时标,历史原因，这里实际为OSD时间
    struRuleInfo: NET_VCA_RULE_INFO;  //事件规则信息
    struTargetInfo: NET_VCA_TARGET_INFO;  //报警目标信息
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwPicDataLen: DWORD;  //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据}
    byPicType: BYTE;  //  0-触发抓拍图片 1-对比图片
    byRelAlarmPicNum: BYTE;  //关联通道报警图片数量
    bySmart: BYTE;  //IDS设备返回0(默认值)，Smart Functiom Return 1
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    dwAlarmID: DWORD;  //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRelativeTimeFlag: BYTE;  //dwRelativeTime字段是否有效  0-无效， 1-有效，dwRelativeTime表示UTC时间
    byAppendInfoUploadEnabled: BYTE;  //附加信息上传使能 0-不上传 1-上传
    pAppendInfo: PBYTE;  //指向附加信息NET_VCA_APPEND_INFO的指针，byAppendInfoUploadEnabled为1时或者byTimeDiffFlag为1时有效
    pImage: PBYTE;  //指向图片的指针
  end;
  LPNET_VCA_RULE_ALARM = ^NET_VCA_RULE_ALARM;

//异常行为检测附加信息
type
  NET_VCA_APPEND_INFO = record 
    dwSize: DWORD;  //结构长度
    dwAppendPicLen: DWORD;  //附加图片长度
    pAppendPicBuff: PBYTE;  //附加图片指针
    byAppendPicType: BYTE;  //附加图片类型：0-保留;1-可见光图片;2-热成像图片;
    byUID: array[0..64-1] of BYTE;  //设备报警UID
    byApplicationScene: BYTE;  // 应用场景 0-保留 1-室内
    byRes1: array[0..2-1] of BYTE;  //保留
    dwTargetSpeed: DWORD;  //雷达检测到目标速度,单位:km/h
    dwTargetDistance: DWORD;  //雷达检测到目标距离,单位:m/米
    byAlarmType: BYTE;  //报警类型 0-视频 1-雷达
    byRadarChannel: BYTE;  //雷达通道，从1开始累加
    byBrokenNetHttp: BYTE;  // 断网续传标志位，0-不重传数据，1-重传数据
    byAppendChannelType: BYTE;  //附加通道类型：0-保留;1-可见光通道;2-热成像通道;
    dwAppendChannel: DWORD;  //附加通道通道号
    byRes: array[0..44-1] of BYTE;  //保留
  end;
  LPNET_VCA_APPEND_INFO = ^NET_VCA_APPEND_INFO;


//异常行为检测规则DSP信息叠加结构
type
  NET_VCA_DRAW_MODE = record 
    dwSize: DWORD;  
    byDspAddTarget: BYTE;  //编码是否叠加目标
    byDspAddRule: BYTE;  //编码是否叠加规则
    byDspPicAddTarget: BYTE;  //抓图是否叠加目标
    byDspPicAddRule: BYTE;  //抓图是否叠加规则
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_VCA_DRAW_MODE = ^NET_VCA_DRAW_MODE;

//物体类型
type
  OBJECT_TYPE_ENUM =  
  (  
    ENUM_OBJECT_TYPE_COAT = 1  //上衣
  );

//物体颜色条件结构体
type
  NET_DVR_OBJECT_COLOR_COND = record 
    dwChannel: DWORD;  //通道号
    dwObjType: DWORD;  //物体类型，参见OBJECT_TYPE_ENUM
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_OBJECT_COLOR_COND = ^NET_DVR_OBJECT_COLOR_COND;

//图片参数
type
  NET_DVR_PIC = record 
    byPicType: BYTE;  //图片类型，1-jpg
    byRes1: array[0..3-1] of BYTE;  //保留
    dwPicWidth: DWORD;  //图片宽度
    dwPicHeight: DWORD;  //图片高度
    dwPicDataLen: DWORD;  //图片数据实际大小
    dwPicDataBuffLen: DWORD;  //图片数据缓冲区大小
    byPicDataBuff: PBYTE;  //图片数据缓冲区
    byRes2: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_DVR_PIC = ^NET_DVR_PIC;

//颜色联合体
type
  NET_DVR_OBJECT_COLOR_UNION = record 
    case Byte of
    0: (struColor: NET_DVR_COLOR);  //颜色值
    1: (struPicture: NET_DVR_PIC);  //图片
    2: (byRes: array[0..64-1] of BYTE);  //保留
  end;
  LPNET_DVR_OBJECT_COLOR_UNION = ^NET_DVR_OBJECT_COLOR_UNION;

//物体颜色参数结构体
type
  NET_DVR_OBJECT_COLOR = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //0-不启用，1-启用
    byColorMode: BYTE;  //取色方式，1-颜色值，2-图片
    byRes1: array[0..2-1] of BYTE;  //保留
    uObjColor: NET_DVR_OBJECT_COLOR_UNION;  //物体颜色联合体，取值依赖于取色方式
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_OBJECT_COLOR = ^NET_DVR_OBJECT_COLOR;

//区域类型
type
  AREA_TYPE_ENUM =  
  (  
    ENUM_OVERLAP_REGION = 1,  //共同区域
    ENUM_BED_LOCATION = 2  //床铺位置
  );

//辅助区域
type
  NET_DVR_AUXAREA = record 
    dwAreaType: DWORD;  //区域类型，参见AREA_TYPE_ENUM
    byEnable: BYTE;  //0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  //保留
    struPolygon: NET_VCA_POLYGON;  //区域
    byRes2: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_AUXAREA = ^NET_DVR_AUXAREA;

//辅助区域列表
type
  NET_DVR_AUXAREA_LIST = record 
    dwSize: DWORD;  // 结构体大小
    struArea: array[0..MAX_AUXAREA_NUM-1] of NET_DVR_AUXAREA;  //辅助区域
    byRes2: array[0..64-1] of BYTE;  // 保留
  end;
  LPNET_DVR_AUXAREA_LIST = ^NET_DVR_AUXAREA_LIST;

//通道工作模式
type
  CHAN_WORKMODE_ENUM =  
  (  
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //独立模式
    ENUM_CHAN_WORKMODE_MASTER = 2,  //主模式
    ENUM_CHAN_WORKMODE_SLAVE = 3  //从模式
  );

//通道工作模式参数结构体
type
  NET_DVR_CHANNEL_WORKMODE = record 
    dwSize: DWORD;  //结构体大小
    byWorkMode: BYTE;  //工作模式，参见CHAN_WORKMODE_ENUM
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_CHANNEL_WORKMODE = ^NET_DVR_CHANNEL_WORKMODE;

//设备通道参数结构体
type
  NET_DVR_CHANNEL = record 
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备IP或域名
    wDVRPort: WORD;  //端口号
    byRes1: array[0..2-1] of BYTE;  //保留
    sUserName: array[0..NAME_LEN-1] of BYTE;  //主机用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //主机密码
    dwChannel: DWORD;  //通道号
    byRes2: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_CHANNEL = ^NET_DVR_CHANNEL;

//从通道信息联合体
type
  NET_DVR_SLAVE_CHANNEL_UNION = record 
    case Byte of
    0: (byRes: array[0..152-1] of BYTE);  //联合体大小
    1: (dwLocalChannel: DWORD);  //本机通道
    2: (struRemoteChannel: NET_DVR_CHANNEL);  //远程通道
  end;
  LPNET_DVR_SLAVE_CHANNEL_UNION = ^NET_DVR_SLAVE_CHANNEL_UNION;

//从通道参数结构体
type
  NET_DVR_SLAVE_CHANNEL_PARAM = record 
    byChanType: BYTE;  //从通道类型，1-本机通道，2-远程通道
    byRes1: array[0..3-1] of BYTE;  //保留
    uSlaveChannel: NET_DVR_SLAVE_CHANNEL_UNION;  //从通道联合体，取值依赖于byChanType
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_SLAVE_CHANNEL_PARAM = ^NET_DVR_SLAVE_CHANNEL_PARAM;


//从通道参数配置结构体
type
  NET_DVR_SLAVE_CHANNEL_CFG = record 
    dwSize: DWORD;  //结构体大小
    struChanParam: array[0..MAX_SLAVE_CHANNEL_NUM-1] of NET_DVR_SLAVE_CHANNEL_PARAM;  //从通道参数
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_SLAVE_CHANNEL_CFG = ^NET_DVR_SLAVE_CHANNEL_CFG;

//视频质量诊断检测事件
type
  VQD_EVENT_ENUM =  
  (  
    ENUM_VQD_EVENT_BLUR = 1,  //图像模糊
    ENUM_VQD_EVENT_LUMA = 2,  //亮度异常
    ENUM_VQD_EVENT_CHROMA = 3,  //图像偏色
    ENUM_VQD_EVENT_SNOW = 4,  //雪花干扰
    ENUM_VQD_EVENT_STREAK = 5,  //条纹干扰
    ENUM_VQD_EVENT_FREEZE = 6,  //画面冻结
    ENUM_VQD_EVENT_SIGNAL_LOSS = 7,  //信号丢失
    ENUM_VQD_EVENT_PTZ = 8,  //云台失控
    ENUM_VQD_EVENT_SCNENE_CHANGE = 9,  //场景突变
    ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10,  //视频异常
    ENUM_VQD_EVENT_VIDEO_BLOCK = 11,  //视频遮挡
    ENUM_VQD_EVENT_CLARTY = 12,  //清晰度异常
    ENUM_VQD_EVENT_JITTER = 13,  //画面抖动
    ENUM_VQD_EVENT_FLOWERS = 14,  //画屏
    ENUM_VQD_EVENT_NOISE = 15,  //噪点
    ENUM_VQD_EVENT_GHOST = 16,  //异常光斑
    ENUM_VQD_EVENT_PURPLE = 17,  //紫边
    ENUM_VQD_EVENT_ICR = 18,  // ICR检测异常
    ENUM_VQD_EVENT_PROTECTFILM = 19  //保护膜未撕
  );

//视频质量诊断事件条件结构体
type
  NET_DVR_VQD_EVENT_COND = record 
    dwChannel: DWORD;  //通道号
    dwEventType: DWORD;  //检测事件类型，参见VQD_EVENT_ENUM
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_VQD_EVENT_COND = ^NET_DVR_VQD_EVENT_COND;

//视频质量诊断事件参数
type
  NET_DVR_VQD_EVENT_PARAM = record 
    byThreshold: BYTE;  //报警阈值，范围[0,100]
    byTriggerMode: BYTE;  //1-持续触发，2-单次触发
    byUploadPic: BYTE;  //0-不上传图片，1-上传图片，无论是否上传图片，事后都可以从设备获取该事件所对应最新的一张报警图片，参见接口NET_DVR_StartDownload
    byRes1: BYTE;  //保留
    dwTimeInterval: DWORD;  //持续触发报警时间间隔，范围[0,3600] 单位：秒
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_VQD_EVENT_PARAM = ^NET_DVR_VQD_EVENT_PARAM;

//视频质量诊断事件规则
type
  NET_DVR_VQD_EVENT_RULE = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  //保留
    struEventParam: NET_DVR_VQD_EVENT_PARAM;  //视频质量诊断事件参数
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //检测时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_IVMS_IP_CHANNEL-1] of BYTE;  //报警触发的录象通道：1表示触发该通道；0表示不触发
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VQD_EVENT_RULE = ^NET_DVR_VQD_EVENT_RULE;

//基准场景参数
type
  NET_DVR_BASELINE_SCENE = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //0-不启用，1-启用
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_BASELINE_SCENE = ^NET_DVR_BASELINE_SCENE;

//基准场景操作参数结构体
type
  NET_DVR_CONTROL_BASELINE_SCENE_PARAM = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byCommand: BYTE;  //操作类型，1-此字段保留，暂不使用，2-更新基准场景
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM = ^NET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//视频质量诊断报警结构体
type
  NET_DVR_VQD_ALARM = record 
    dwSize: DWORD;  //结构体大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwEventType: DWORD;  //事件类型，参考VQD_EVENT_ENUM
    fThreshold: FLOAT;  //报警阈值[0.000,1.000]
    dwPicDataLen: DWORD;  //图片长度，为0表示没有图片
    pImage: PBYTE;  //指向图片的指针
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VQD_ALARM = ^NET_DVR_VQD_ALARM;

//标定点子结构
type
  NET_DVR_CB_POINT = record 
    struPoint: NET_VCA_POINT;  //标定点，主摄像机（枪机）
    struPtzPos: NET_DVR_PTZPOS;  //球机输入的PTZ坐标
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_CB_POINT = ^NET_DVR_CB_POINT;

//标定参数配置结构
type
  NET_DVR_TRACK_CALIBRATION_PARAM = record 
    byPointNum: BYTE;  //有效标定点个数
    byRes: array[0..3-1] of BYTE;  
    struCBPoint: array[0..MAX_CALIB_PT-1] of NET_DVR_CB_POINT;  //标定点组
  end;
  LPNET_DVR_TRACK_CALIBRATION_PARAM = ^NET_DVR_TRACK_CALIBRATION_PARAM;

//球机配置结构
type
  NET_DVR_TRACK_CFG = record 
    dwSize: DWORD;  //结构长度
    byEnable: BYTE;  //标定使能
    byFollowChan: BYTE;  // 被控制的从通道
    byDomeCalibrate: BYTE;  //设置智能球机标定，1设置 0不设置
    byRes: BYTE;  // 保留字节
    struCalParam: NET_DVR_TRACK_CALIBRATION_PARAM;  //标定点组
  end;
  LPNET_DVR_TRACK_CFG = ^NET_DVR_TRACK_CFG;

//模式
type
  TRACK_MODE =  
  (  
    MANUAL_CTRL = 0,  //手动
    ALARM_TRACK  //报警触发
  );

//手动控制结构
type
  NET_DVR_MANUAL_CTRL_INFO = record 
    struCtrlPoint: NET_VCA_POINT;  
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_MANUAL_CTRL_INFO = ^NET_DVR_MANUAL_CTRL_INFO;

//模式结构
type
  NET_DVR_TRACK_MODE = record 
    dwSize: DWORD;  //结构长度
    byTrackMode: BYTE;  //模式
    byRuleConfMode: BYTE;  //规则配置模式0-本地配置，1-远程配置
    byRes: array[0..2-1] of BYTE;  //保留，置0
    uModeParam: record 
      case Byte of
      0: (dwULen: array[0..4-1] of DWORD);  
      1: (struManualCtrl: NET_DVR_MANUAL_CTRL_INFO);  //手动结构
    end;  
  end;
  LPNET_DVR_TRACK_MODE = ^NET_DVR_TRACK_MODE;

type
  NET_DVR_ALARM_JPEG = record 
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 1-上传
    byRes: array[0..3-1] of BYTE;  //保留字节
    struPicParam: NET_DVR_JPEGPARA;  //图片规格结构
  end;
  LPNET_DVR_ALARM_JPEG = ^NET_DVR_ALARM_JPEG;

//*********************ipc/d5.3.0*******************************
type
  NET_DVR_PHY_RATIO = record 
    dwSize: DWORD;  
    dwPhysicsRatio: DWORD;  //物理倍率坐标
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_PHY_RATIO = ^NET_DVR_PHY_RATIO;

type
  NET_DVR_SLAVECAMERA_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byID: BYTE;  //主从 从摄像机ID编号[1,4]
    byRes1: array[0..3-1] of BYTE;  
    dwSceneID: DWORD;  // scene Id
    byRes: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_COND = ^NET_DVR_SLAVECAMERA_COND;

type
  NET_DVR_SLAVECAMERA_CFG = record 
    dwSize: DWORD;  
    byAddressType: BYTE;  //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    wPort: WORD;  //端口
    byLoginStatus: BYTE;  //从设备的登陆状态 0-logout,1-login
    unionServer: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //服务器地址，域名
        byRes1: array[0..80-1] of BYTE;  
      end);  
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  {IP地址}//IPv4 IPv6地址, 144字节
      end);  
    end;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64
    szUserName: array[0..NAME_LEN{32}-1] of BYTE;  //用户名
    szPassWord: array[0..PASSWD_LEN{16}-1] of BYTE;  //密码
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_CFG = ^NET_DVR_SLAVECAMERA_CFG;

type
  NET_DVR_SLAVECAMERA_PARAM = record 
    byLinkStatus: BYTE;  //连接状态 0- 未连接，1-连接
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_PARAM = ^NET_DVR_SLAVECAMERA_PARAM;

type
  NET_DVR_SLAVECAMERA_STATUS = record 
    dwSize: DWORD;  
    struSlaveCamera: array[0..MAX_SLAVECAMERA_NUM{8}-1] of NET_DVR_SLAVECAMERA_PARAM;  //数组下标0表示从摄像机ID 1,依次类推
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_STATUS = ^NET_DVR_SLAVECAMERA_STATUS;

type
  NET_PTZ_INFO = record 
    fPan: FLOAT;  
    fTilt: FLOAT;  
    fZoom: FLOAT;  
    dwFocus: DWORD;  // 聚焦参数，聚焦范围：归一化0-100000
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_PTZ_INFO = ^NET_PTZ_INFO;

type
  NET_DVR_BV_CALIB_POSITION = record 
    dwSize: DWORD;  //结构长度
    struInitialPos: NET_PTZ_INFO;  //初始坐标
    struAdjustPos: NET_PTZ_INFO;  //调整坐标
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_POSITION = ^NET_DVR_BV_CALIB_POSITION;

type
  NET_DVR_HUMAN_CALIB_CFG = record 
    dwSize: DWORD;  //结构长度
    struLeftPos: NET_VCA_POINT;  //人体左坐标点
    struRightPos: NET_VCA_POINT;  //人体右坐标点
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_HUMAN_CALIB_CFG = ^NET_DVR_HUMAN_CALIB_CFG;

type
  NET_DVR_CALIB_PARAM = record 
    struPtzInfo: NET_PTZ_INFO;  
    struCalibCoordinates: NET_VCA_POINT;  //标定坐标
    iHorValue: INT;  //双目标定 水平值 cm（手动模式下生效 双目相机配置）
    iVerValue: INT;  //双目标定 垂直值 cm（手动模式下生效 双目相机配置）
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_CALIB_PARAM = ^NET_DVR_CALIB_PARAM;

type
  NET_DVR_SLAVECAMERA_CALIB_CFG = record 
    dwSize: DWORD;  
    byCalibMode: BYTE;  //标定模式: 0-保留,1-自动标定, 2-手动标定
    byRes: array[0..3-1] of BYTE;  
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    struCalibParam: array[0..MAX_CALIB_NUM{6}-1] of NET_DVR_CALIB_PARAM;  //只在手动标定模式下生效
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_CALIB_CFG = ^NET_DVR_SLAVECAMERA_CALIB_CFG;

type
  NET_DVR_TRACKING = record 
    dwSize: DWORD;  //结构长度
    byEnable: BYTE;  //使能 0-false,1-true
    byMode: BYTE;  //模式 0-关闭，1-手动，2-自动
    wTrackingTime: WORD;  //时间：[0,60]s
    struRegion: NET_VCA_POLYGON;  //手动目标区域范围
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_TRACKING = ^NET_DVR_TRACKING;

type
  NET_DVR_SLAVECAMERA_CALIB_V50 = record 
    dwSize: DWORD;  
    byCalibMode: BYTE;  //标定模式: 0-保留,1-自动标定, 2-手动标定
    byRes: array[0..3-1] of BYTE;  
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    struCalibParam: array[0..MAX_CALIB_NUM_EX{20}-1] of NET_DVR_CALIB_PARAM;  
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_CALIB_V50 = ^NET_DVR_SLAVECAMERA_CALIB_V50;

type
  NET_DVR_SLAVECAMERA_CALIB_V51 = record 
    dwSize: DWORD;  
    byCalibMode: BYTE;  //标定模式: 0-保留,1-自动标定, 2-手动标定
    byRes: array[0..3-1] of BYTE;  
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    struCalibParam: array[0..MAX_CALIB_NUM_EX{20}-1] of NET_DVR_CALIB_PARAM;  
    byRes1: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_SLAVECAMERA_CALIB_V51 = ^NET_DVR_SLAVECAMERA_CALIB_V51;

//特殊功能抓图结果结构（鹰眼项目）
type
  NET_DVR_CAPTURE_PICTURE_RESULT = record 
    dwSize: DWORD;  //结构体大小
    dwReturnPicSize: DWORD;  //返回的图片大小
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_PICTURE_RESULT = ^NET_DVR_CAPTURE_PICTURE_RESULT;

type
  NET_DVR_GOTOSCENE_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwSceneID: DWORD;  //场景ID号
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_GOTOSCENE_COND = ^NET_DVR_GOTOSCENE_COND;

type
  NET_DVR_TRACK_INITPOSTION = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byID: BYTE;  //主从 从摄像机ID编号[1,4]
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_TRACK_INITPOSTION = ^NET_DVR_TRACK_INITPOSTION;

type
  NET_DVR_MANUAL_TRACKRATIO = record 
    dwSize: DWORD;  
    byCoefficient: BYTE;  //倍率系数[1,60]
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_MANUAL_TRACKRATIO = ^NET_DVR_MANUAL_TRACKRATIO;

//*********************ipc/d5.3.0*******************************

//分析仪异常行为检测规则结构
//警戒规则结构
type
  NET_IVMS_ONE_RULE = record 
    byActive: BYTE;  // 是否激活规则,0-否, 非0-是 
    byRes1: array[0..7-1] of BYTE;  //保留，设置为0字段
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    dwEventType: VCA_EVENT_TYPE;  //异常行为检测事件类型
    uEventParam: NET_VCA_EVENT_UNION;  //异常行为检测事件参数
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    byRes2: array[0..68-1] of BYTE;  //保留，设置为0
  end;
  LPNET_IVMS_ONE_RULE = ^NET_IVMS_ONE_RULE;

// 分析仪规则结构
type
  NET_IVMS_RULECFG = record 
    struRule: array[0..MAX_RULE_NUM-1] of NET_IVMS_ONE_RULE;  //规则数组
  end;
  LPNET_IVMS_RULECFG = ^NET_IVMS_RULECFG;

// IVMS异常行为检测配置结构
type
  NET_IVMS_BEHAVIORCFG = record 
    dwSize: DWORD;  
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    byRes: array[0..3-1] of BYTE;  
    struPicParam: NET_DVR_JPEGPARA;  //图片规格结构
    struRuleCfg: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_IVMS_RULECFG;  //每个时间段对应规则
  end;
  LPNET_IVMS_BEHAVIORCFG = ^NET_IVMS_BEHAVIORCFG;

//智能分析仪取流计划子结构
type
  NET_IVMS_DEVSCHED = record 
    struTime: NET_DVR_SCHEDTIME;  //时间参数
    struPUStream: NET_DVR_PU_STREAM_CFG;  //前端取流参数
  end;
  LPNET_IVMS_DEVSCHED = ^NET_IVMS_DEVSCHED;

//智能分析仪参数配置结构
type
  NET_IVMS_STREAMCFG = record 
    dwSize: DWORD;  
    struDevSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_IVMS_DEVSCHED;  //按时间段配置前端取流以及规则信息
  end;
  LPNET_IVMS_STREAMCFG = ^NET_IVMS_STREAMCFG;

//屏蔽区域
type
  NET_VCA_MASK_REGION = record 
    byEnable: BYTE;  //是否激活, 0-否，非0-是
    byRes: array[0..3-1] of BYTE;  //保留，置0
    struPolygon: NET_VCA_POLYGON;  //屏蔽多边形
  end;
  LPNET_VCA_MASK_REGION = ^NET_VCA_MASK_REGION;

//屏蔽区域链表结构
type
  NET_VCA_MASK_REGION_LIST = record 
    dwSize: DWORD;  //结构长度
    byRes: array[0..4-1] of BYTE;  //保留，置0
    struMask: array[0..MAX_MASK_REGION_NUM-1] of NET_VCA_MASK_REGION;  //屏蔽区域数组
  end;
  LPNET_VCA_MASK_REGION_LIST = ^NET_VCA_MASK_REGION_LIST;


//ATM进入区域参数
type
  NET_VCA_ENTER_REGION = record //防止干扰ATM检测
    dwSize: DWORD;  
    byEnable: BYTE;  //是否激活，0-否，非0-是
    byRes1: array[0..3-1] of BYTE;  
    struPolygon: NET_VCA_POLYGON;  //进入区域
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_VCA_ENTER_REGION = ^NET_VCA_ENTER_REGION;

//IVMS屏蔽区域链表
type
  NET_IVMS_MASK_REGION_LIST = record 
    dwSize: DWORD;  //结构长度
    struList: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_VCA_MASK_REGION_LIST;  
  end;
  LPNET_IVMS_MASK_REGION_LIST = ^NET_IVMS_MASK_REGION_LIST;

//IVMS的ATM进入区域参数
type
  NET_IVMS_ENTER_REGION = record 
    dwSize: DWORD;  
    struEnter: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_VCA_ENTER_REGION;  //进入区域
  end;
  LPNET_IVMS_ENTER_REGION = ^NET_IVMS_ENTER_REGION;

// ivms 报警图片上传结构
type
  NET_IVMS_ALARM_JPEG = record 
    byPicProType: BYTE;  
    byRes: array[0..3-1] of BYTE;  
    struPicParam: NET_DVR_JPEGPARA;  
  end;
  LPNET_IVMS_ALARM_JPEG = ^NET_IVMS_ALARM_JPEG;

// IVMS 后检索配置
type
  NET_IVMS_SEARCHCFG = record 
    dwSize: DWORD;  
    struRemotePlay: NET_DVR_MATRIX_DEC_REMOTE_PLAY;  // 远程回放
    struAlarmJpeg: NET_IVMS_ALARM_JPEG;  // 报警上传图片配置
    struRuleCfg: NET_IVMS_RULECFG;  //IVMS 行为规则配置
  end;
  LPNET_IVMS_SEARCHCFG = ^NET_IVMS_SEARCHCFG;

//标定参数结构体
type
  NET_DVR_TRACK_CALIBRATION_PARAM_V41 = record 
    byPointNum: BYTE;  //有效标定点个数
    byRes: array[0..3-1] of BYTE;  //保留
    struCBPoint: array[0..MAX_CALIB_PT-1] of NET_DVR_CB_POINT;  //标定点组
    struHorizonPtzPos: NET_DVR_PTZPOS;  //球机水平线PTZ坐标
    byRes2: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_TRACK_CALIBRATION_PARAM_V41 = ^NET_DVR_TRACK_CALIBRATION_PARAM_V41;

//设备配置参数
type
  NET_DVR_TRACK_DEV_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //启用此设备, 0-不启用, 1 -启用
    byTransMode: BYTE;  //通讯方式，0-网络SDK，1-485串口
    byRes1: array[0..2-1] of BYTE;  //保留
    struTrackDevChan: NET_DVR_CHANNEL;  //联动设备参数
    struCalParam: NET_DVR_TRACK_CALIBRATION_PARAM_V41;  //设备标定参数
    byRes2: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_TRACK_DEV_PARAM = ^NET_DVR_TRACK_DEV_PARAM;
//***********************************end*****************************************
//NAS认证配置
type
  NET_DVR_IDENTIFICATION_PARAM = record 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 32
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 16
    byRes1: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_IDENTIFICATION_PARAM = ^NET_DVR_IDENTIFICATION_PARAM;

type
  NET_DVR_MOUNT_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..52-1] of BYTE);  //联合体结构大小
    1: (struIdentificationParam: NET_DVR_IDENTIFICATION_PARAM);  //(SMB/CIFS时生效)
  end;
  LPNET_DVR_MOUNT_PARAM_UNION = ^NET_DVR_MOUNT_PARAM_UNION;

type
  NET_DVR_NAS_MOUNT_PARAM = record 
    byMountType: BYTE;  //0～保留,1~NFS, 2~ SMB/CIFS
    byRes: array[0..3-1] of BYTE;  
    uMountParam: NET_DVR_MOUNT_PARAM_UNION;  
  end;
  LPNET_DVR_NAS_MOUNT_PARAM = ^NET_DVR_NAS_MOUNT_PARAM;

type
  NET_DVR_MOUNTMETHOD_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..56-1] of BYTE);  //联合体结构大小
    1: (struNasMountParam: NET_DVR_NAS_MOUNT_PARAM);  //NAS挂载方式 (byNetDiskType为NFS(NAS)时生效)
  end;
  LPNET_DVR_MOUNTMETHOD_PARAM_UNION = ^NET_DVR_MOUNTMETHOD_PARAM_UNION;

//网络硬盘结构配置
type
  NET_DVR_SINGLE_NET_DISK_INFO = record 
    byNetDiskType: BYTE;  //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    byRes1: array[0..3-1] of BYTE;  //保留
    struNetDiskAddr: NET_DVR_IPADDR;  //网络硬盘地址
    sDirectory: array[0..PATHNAME_LEN-1] of BYTE;  // PATHNAME_LEN = 128
    wPort: WORD;  //iscsi有端口，现在为默认
    byRes2: array[0..2-1] of BYTE;  
    uMountMethodParam: NET_DVR_MOUNTMETHOD_PARAM_UNION;  
    byRes3: array[0..8-1] of BYTE;  //保留
  end;
  LPNET_DVR_SINGLE_NET_DISK_INFO = ^NET_DVR_SINGLE_NET_DISK_INFO;

const
  MAX_NET_DISK = 16;    //最大网络硬盘个数

type
  NET_DVR_NET_DISKCFG = record 
    dwSize: DWORD;  
    struNetDiskParam: array[0..MAX_NET_DISK-1] of NET_DVR_SINGLE_NET_DISK_INFO;  
  end;
  LPNET_DVR_NET_DISKCFG = ^NET_DVR_NET_DISKCFG;

type
  NET_DVR_SINGLE_NET_DISK_INFO_V40 = record 
    byNetDiskType: BYTE;  //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    byRes1: array[0..3-1] of BYTE;  //保留
    sDirectory: array[0..PATHNAME_LEN-1] of BYTE;  // PATHNAME_LEN = 128
    byDevAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //域名 64
    wPort: WORD;  //iscsi有端口，现在为默认
    byRes2: array[0..2-1] of BYTE;  
    uMountMethodParam: NET_DVR_MOUNTMETHOD_PARAM_UNION;  
    byRes4: array[0..80-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_NET_DISK_INFO_V40 = ^NET_DVR_SINGLE_NET_DISK_INFO_V40;

type
  NET_DVR_NET_DISKCFG_V40 = record 
    dwSize: DWORD;  
    struNetDiskParam: array[0..MAX_NET_DISK-1] of NET_DVR_SINGLE_NET_DISK_INFO_V40;  
  end;
  LPNET_DVR_NET_DISKCFG_V40 = ^NET_DVR_NET_DISKCFG_V40;
//事件类型
//主类型
type
  MAIN_EVENT_TYPE =  
  (  
    EVENT_MOT_DET = 0,  //移动侦测
    EVENT_ALARM_IN = 1,  //报警输入
    EVENT_VCA_BEHAVIOR = 2,  // 异常行为检测
    EVENT_INQUEST = 3,  //审讯事件
    EVENT_VCA_DETECTION = 4,  //智能侦测
    EVENT_POS = 5,  
    EVENT_TRIAL_CASE = 6,  //庭审案件信息
    EVENT_ACS_CASE = 7,  //门禁事件
    EVENT_IOT_CASE = 8,  //非视频联动事件―本类事件均为非视频设备联动视频设备产生的事件，不包含非视频设备本身的事件
    EVENT_STREAM_INFO = 100  //流ID信息
  );

const
  INQUEST_START_INFO = $1001;    //讯问开始信息
  INQUEST_STOP_INFO = $1002;    //讯问停止信息
  INQUEST_TAG_INFO = $1003;    //重点标记信息
  INQUEST_SEGMENT_INFO = $1004;    //审讯片断状态信息
  INQUEST_CASE_INFO = $1005;    // 案件信息类型

{$WARN BOUNDS_ERROR OFF}
type
  VCA_DETECTION_MINOR_TYPE =  
  (  
    EVENT_VCA_TRAVERSE_PLANE = 1,  //越警侦测
    EVENT_FIELD_DETECTION,  //区域入侵侦测
    EVENT_AUDIO_INPUT_ALARM,  //音频输入异常
    EVENT_SOUND_INTENSITY_ALARM,  //声强突变侦测
    EVENT_FACE_DETECTION,  //人脸侦测
    EVENT_VIRTUAL_FOCUS_ALARM,  //虚焦侦测
    EVENT_SCENE_CHANGE_ALARM,  //场景变更侦测
    EVENT_PIR_ALARM,  //PIR报警
    EVENT_ENTER_REGION,  //进入区域
    EVENT_EXIT_REGION,  //目标离开区域
    EVENT_LOITERING,  //徘徊
    EVENT_GROUPDETECTION,  //区域内人员聚集,支持区域规则
    EVENT_RAPIDMOVE,  //快速移动
    EVENT_PARK,  //停车
    EVENT_UNATTENDED_BAGGAGE,  //物品遗留
    EVENT_ATTENDEDBAGGAGE,  //物品拿取
    EVENT_VEHICLE_DETECTION,  //车辆检测
    EVENT_ALL = $ffffffff  //表示全部
  );
{$WARN BOUNDS_ERROR ON}



//异常行为检测主类型对应的次类型， 0xffff表示全部
type
  BEHAVIOR_MINOR_TYPE =  
  (  
    EVENT_TRAVERSE_PLANE = 0,  // 穿越警戒面
    EVENT_ENTER_AREA,  //目标进入区域,支持区域规则
    EVENT_EXIT_AREA,  //目标离开区域,支持区域规则
    EVENT_INTRUSION,  // 周界入侵,支持区域规则
    EVENT_LOITER,  //徘徊,支持区域规则
    EVENT_LEFT_TAKE,  //物品遗留拿取,支持区域规则
    EVENT_PARKING,  //停车,支持区域规则
    EVENT_RUN,  //快速移动,支持区域规则
    EVENT_HIGH_DENSITY,  //区域内人员聚集,支持区域规则
    EVENT_STICK_UP,  //贴纸条,支持区域规则
    EVENT_INSTALL_SCANNER,  //安装读卡器,支持区域规则
    EVENT_OPERATE_OVER_TIME,  // 操作超时
    EVENT_FACE_DETECT,  // 异常人脸
    EVENT_LEFT,  // 物品遗留
    EVENT_TAKE,  // 物品拿取
    EVENT_LEAVE_POSITION,  //离岗事件
    EVENT_TRAIL_INFO = 16,  //尾随
    EVENT_HUMAN_ENTER = 18,  //人员进入
    EVENT_FALL_DOWN_INFO = 19,  //倒地
    EVENT_OBJECT_PASTE = 20,  // 异物粘贴区域
    EVENT_FACE_CAPTURE_INFO = 21,  //正常人脸
    EVENT_MULTI_FACES_INFO = 22,  //多张人脸
    EVENT_AUDIO_ABNORMAL_INFO = 23,  //声强突变
    EVENT_SUNGLASSES_FACE_INFO = 25,  //戴墨镜人脸
    EVENT_CALLING_FACE_INFO = 26,  //打电话人脸
    EVENT_VIOLENT_MOTION = 27,  //剧烈运动
    EVENT_SAFETY_HELMET = 28,  //安全帽检测
    EVENT_PEOPLE_NUM_CHANGE = 29,  //人数变化
    EVENT_GET_UP = 30,  //起身
    EVENT_ADV_REACH_HEIGHT = 31,  //折线攀高
    EVENT_STOOD_UP = 32,  //起立
    EVENT_PERSON_DENSITY = 33,  //人员密度（人数预警）
    EVENT_MANUAL_ALARM = 34,  //手动报警
    EVENT_VIOLATION_HIGH_SPEED = 35,  //超速
    EVENT_GSENSOR = 36,  // G-Sensor事件（急加速、急减速、急左转弯、急右转弯、车辆翻车、车辆碰撞）
    EVENT_SENSOR_IN = 37,  // Sensor-In行为（刹车、左转、右转、倒车）
    EVENT_VCA_DBD = 38,  //司机驾驶行为
    EVENT_VCA_ABS = 39,  //高级辅助驾驶
    EVENT_TOILET_TARRY = 40  //如厕超时
  );

//主类型6对应的次类型
type
  TRIAL_CASE_MINOR_TYPE =  
  (  
    TRIAL_START_INFO = $1001,  // 庭审开始事件
    TRIAL_STOP_INFO = $1002,  //庭审结束事件
    TRIAL_TAG_INFO = $1003,  //庭审重点标注事件
    TRIAL_SEGMENT_INFO = $1004,  // 庭审片段状态信息
    TRIAL_JUDGE_CASE_INFO = $1005  //庭审案件信息
  );

// 主类型100，对应的小类型
type
  STREAM_INFO_MINOR_TYPE =  
  (  
    EVENT_STREAM_ID = 0,  // 流ID
    EVENT_TIMING = 1,  // 定时录像
    EVENT_MOTION_DETECT = 2,  // 移动侦测
    EVENT_ALARM = 3,  // 报警录像
    EVENT_ALARM_OR_MOTION_DETECT = 4,  // 报警或移动侦测
    EVENT_ALARM_AND_MOTION_DETECT = 5,  // 报警和移动侦测
    EVENT_COMMAND_TRIGGER = 6,  // 命令触发
    EVENT_MANNUAL = 7,  // 手动录像
    EVENT_BACKUP_VOLUME = 8,  // 存档卷录像
    STREAM_EVENT_SEMAPHORE,  //信号量
    STREAM_EVENT_HIDE,  //遮挡
    STREAM_EVENT_INVERSE,  //逆行
    STREAM_EVENT_VIDEO_LOST,  //视频丢失
    STREAM_EVENT_WIRELESS_ALARM,  //无线报警
    STREAM_EVENT_PIR_ALARM,  //PIR报警
    STREAM_EVENT_CALLHELP_ALARM,  //呼救报警

    STREAM_EVENT_FACESNAP,  //人脸抓拍
    STREAM_EVENT_FACE_DETECTION,  //人脸侦测
    STREAM_EVENT_ITS_PLATE,  //车辆检测
    STREAM_EVENT_PDC,  //客流量统计
    STREAM_EVENT_SCENECHANGE_DETECTION,  //场景变更
    STREAM_EVENT_DEFOCUS_DETECTION,  //虚焦侦测
    STREAM_EVENT_AUDIOEXCEPTION,  //音频异常

        //以下为异常行为检测（COMM_ALARM_RULE）的子类型，具体见VCA_EVENT_TYPE
    VCA_EVENT_TRAVERSE_PLANE,  //穿越警戒面
    VCA_EVENT_INTRUSION,  //周界入侵
    VCA_EVENT_ENTER_AREA,  //进入区域
    VCA_EVENT_EXIT_AREA,  //离开区域
    VCA_EVENT_LOITER,  //徘徊侦测
    VCA_EVENT_HIGH_DENSITY,  //人员聚集
    VCA_EVENT_RUN,  //快速移动
    VCA_EVENT_PARKING,  //非法停车
    VCA_EVENT_LEFT,  //物品遗留
    VCA_EVENT_TAKE  //物品拿取
  );

// typedef enum tagITS_MINOR_TYPE
// <
//     ITS_EVENT_CONGESTION    = 0,    // 拥堵
//     ITS_EVENT_PARKING,              // 停车
//     ITS_EVENT_INVERSE,              // 逆行
//     ITS_EVENT_PEDESTRIAN,           // 行人
//     ITS_EVENT_DEBRIS                // 遗留物，抛洒物碎片
// >ITS_MINOR_TYPE;


const
  SEARCH_EVENT_INFO_LEN = 300;    //事件信息长度
  CASE_NO_LEN = 64;    
  CASE_NAME_LEN = 128;    
  LITIGANT_LEN = 32;    
  CHIEF_JUDGE_LEN = 32;    
  SEARCH_CASE_NO_LEN = 56;    
  SEARCH_CASE_NAME_LEN = 100;    
  SEARCH_LITIGANT_LEN = 32;    
  SEARCH_CHIEF_JUDGE_LEN = 32;    
  CASE_NO_RET_LEN = 52;    
  CASE_NAME_RET_LEN = 64;    
  LITIGANT_RET_LEN = 24;    
  CHIEF_JUDGE_RET_LEN = 24;    
  NET_SDK_CASETYPE_LEN = 32;    
//事件搜索条件
type
  NET_DVR_SEARCH_EVENT_PARAM = record 
    wMajorType: WORD;  //0-移动侦测，1-报警输入, 2-智能事件
    wMinorType: WORD;  //搜索次类型- 根据主类型变化，0xffff表示全部
    struStartTime: NET_DVR_TIME;  //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    struEndTime: NET_DVR_TIME;  //
    byLockType: BYTE;  // 0xff-全部，0-未锁，1-锁定
    byValue: BYTE;  //0-按位表示，1-按值表示
    byRes: array[0..130-1] of BYTE;  // 保留
    uSeniorParam: record 
      case Byte of
      0: (byLen: array[0..SEARCH_EVENT_INFO_LEN-1] of BYTE);  
      1: (struAlarmParam: record
        byAlarmInNo: array[0..MAX_ALARMIN_V30-1] of BYTE;  //报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
        byRes: array[0..SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30-1] of BYTE;  
      end);  

      2: (struAlarmParamByValue: record
        wAlarmInNo: array[0..128-1] of WORD;  //报警输入号，按值表示,采用紧凑型排列
        byRes: array[0..44-1] of BYTE;  //保留
      end);  

      3: (struMotionParam: record
        byMotDetChanNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  //移动侦测通道，byMotDetChanNo[0]若置1则表示查找由通道1发生移动侦测触发的事件
        byRes: array[0..SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30-1] of BYTE;  
      end);  

      4: (struMotionParamByValue: record
        wMotDetChanNo: array[0..64-1] of WORD;  // 移动侦测通道，按值表示 ,采用紧凑型排列
        byRes: array[0..172-1] of BYTE;  //保留
      end);  

      5: (struVcaParam: record
        byChanNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  //触发事件的通道
        byRuleID: BYTE;  //规则ID，0xff表示全部
        byRes1: array[0..43-1] of BYTE;  //保留
      end);  

      6: (struVcaParamByValue: record
        wChanNo: array[0..64-1] of WORD;  //异常行为检测对应的通道，按值表示,采用紧凑型排列
        byRuleID: BYTE;  //异常行为检测类型，规则0xff表示全部，从0开始
        byRes: array[0..171-1] of BYTE;  //保留
      end);  

      7: (struInquestParam: record
        byRoomIndex: BYTE;  //审讯室编号,按值表示，从1开始
        byRes1: array[0..3-1] of BYTE;  
        sInquestInfo: array[0..INQUEST_CASE_LEN-1] of BYTE;  
        byRes2: array[0..232-1] of BYTE;  //保留
      end);  
      8: (struVCADetectByBit: record
        byChan: array[0..256-1] of BYTE;  //触发智能侦测的通道号，按数组下标表示，byChan[0]若置1则表示查找由通道1发生移动侦测触发的事件
      end);  

      9: (struVCADetectByValue: record
        dwChanNo: array[0..MAX_CHANNUM_V30-1-1] of DWORD;  // 触发通道号,按值表示，0xffffffff无效，且后续数据也表示无效值
        byAll: BYTE;  //0-表示不是全部，1-表示全部。
        byres: array[0..3-1] of BYTE;  
      end);  
      10: (struStreamIDParam: record
        struIDInfo: NET_DVR_STREAM_INFO;  // 流id信息，72字节长
        dwCmdType: DWORD;  // 外部触发类型，NVR接入云存储使用
        byBackupVolumeNum: BYTE;  //存档卷号，CVR使用
        byRes: array[0..223-1] of BYTE;  
      end);  
      11: (struTrialParam: record
        byCaseNo: array[0..SEARCH_CASE_NO_LEN-1] of BYTE;  //案件编号
        byCaseName: array[0..SEARCH_CASE_NAME_LEN-1] of BYTE;  //案件名称；
        byLitigant1: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  //当事人1；
        byLitigant2: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  //当事人2；
        byChiefJudge: array[0..SEARCH_CHIEF_JUDGE_LEN-1] of BYTE;  //审判长
        byCaseType: BYTE;  //案件类型；0-全部、1-刑事案件、2-民事案件
        byRes: array[0..47-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_PARAM = ^NET_DVR_SEARCH_EVENT_PARAM;

const
  MAX_POS_KEYWORDS_NUM = 3;    //支持关键字查找条数
  MAX_POS_KEYWORD_LEN = 128;    //每条关键字长度
  SEARCH_EVENT_INFO_LEN_V40 = 800;    

//事件搜索条件
type
  NET_DVR_SEARCH_EVENT_PARAM_V40 = record 
    wMajorType: WORD;  //0-移动侦测，1-报警输入, 2-智能事件 5-pos录像 7-门禁事件
    wMinorType: WORD;  //搜索次类型- 根据主类型变化，0xffff表示全部
    struStartTime: NET_DVR_TIME;  //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    struEndTime: NET_DVR_TIME;  //
    byLockType: BYTE;  // 0xff-全部，0-未锁，1-锁定
    byQuickSearch: BYTE;  // 是否启用快速查询，0-不启用，1-启用（快速查询不会返回文件大小，仅对设备数据库进行查询，避免频繁唤醒硬盘）
    byRes: array[0..130-1] of BYTE;  // 保留
    uSeniorParam: record 
      case Byte of
      0: (byLen: array[0..SEARCH_EVENT_INFO_LEN_V40{800}-1] of BYTE);  
      1: (struAlarmParam: record

            //报警输入号，按值表示,采用紧凑型排列，0xffff表示后续无效
        wAlarmInNo: array[0..128-1] of WORD;  
        byRes: array[0..544-1] of BYTE;  //保留
      end);  

      2: (struMotionParam: record

            // 移动侦测通道，按值表示 ,采用紧凑型排列，0xffff表示后续无效
        wMotDetChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  
        byRes: array[0..672-1] of BYTE;  //保留
      end);  

      3: (struVcaParam: record

            //异常行为检测对应的通道，按值表示,采用紧凑型排列，0xffff表示后续无效
        wChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  
        byRuleID: BYTE;  //异常行为检测类型，规则0xff表示全部，从0开始
        byDriverBehaviortType: BYTE;  //司机驾驶行为类型：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜
        byADASType: BYTE;  //高级辅助驾驶类型：0-保留、1-前向碰撞、2-车道偏离、3-盲区检测、4-车距检测、5-行人防撞、6-急加速、7-急减速、8-急左转弯、9-急右转弯、10-车辆翻车、11-未礼让行人
        byGSensorType: BYTE;  // G-Sensor事件：0-保留、1-急加速、2-急减速、3-急左转弯、4-急右转弯、5-车辆翻车、6-车辆碰撞
        bySensorInType: BYTE;  // Sensor-In行为：0-保留、1-刹车、2-左转、3-右转、4-倒车
        byRes: array[0..667-1] of BYTE;  //保留
      end);  

      4: (struInquestParam: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byRes: array[0..799-1] of BYTE;  //保留
      end);  

      5: (struVCADetect: record
        byAll: BYTE;  //查找全部通道，0-否，此时dwChanNo参数有效，
            //1-查找全部通道，此时dwChanNo参数无效。
        byRes1: array[0..3-1] of BYTE;  
        wChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  // 触发通道号,按值表示，0xffff无效，且后续数据也表示无效值
        byRes: array[0..668-1] of BYTE;  
      end);  

      6: (struStreamIDParam: record
        struIDInfo: NET_DVR_STREAM_INFO;  // 流id信息，72字节长
        dwCmdType: DWORD;  // 外部触发类型，NVR接入云存储使用
        byBackupVolumeNum: BYTE;  //存档卷号，CVR使用
        byRes1: array[0..3-1] of BYTE;  
        byArchiveLabel: array[0..64-1] of BYTE;  //存档标签，CVR使用
        byRes: array[0..656-1] of BYTE;  
      end);  

      7: (struPosAlarm: record
        wChannel: array[0..MAX_CHANNUM_V30-1] of WORD;  //通道，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
        byAllChan: BYTE;  //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
        byCaseSensitive: BYTE;  //0-不区分大小写， 1-区分大小写
        byCombinateMode: BYTE;  //关键字组合方式，0-或，1-与
        byRes1: BYTE;  //保留
        sKeyWord: array[0..MAX_POS_KEYWORDS_NUM-1, 0..MAX_POS_KEYWORD_LEN-1] of AnsiChar;  
                                             //关键字查找时的条件
        byRes: array[0..284-1] of BYTE;  //保留
      end);  

      8: (struTrialParam: record
        byCaseNo: array[0..SEARCH_CASE_NO_LEN-1] of BYTE;  //案件编号
        byCaseName: array[0..SEARCH_CASE_NAME_LEN-1] of BYTE;  //案件名称
        byLitigant1: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  //当事人1
        byLitigant2: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  //当事人2
        byChiefJudge: array[0..SEARCH_CHIEF_JUDGE_LEN-1] of BYTE;  //审判长
        byCaseType: BYTE;  
        byRes: array[0..47-1] of BYTE;  
      end);  

      9: (struACSAlarm: record
        dwMajor: DWORD;  //报警主类型（与事件上传主类型一致，0代表全部）
        dwMinor: DWORD;  //报警次类型（与事件上传主类型一致，0代表全部）
        byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
        byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
        byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理MAC地址
        byRes: array[0..722-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_PARAM_V40 = ^NET_DVR_SEARCH_EVENT_PARAM_V40;

//事件搜索条件
type
  NET_DVR_SEARCH_EVENT_PARAM_V50 = record 
    wMajorType: WORD;  //0-移动侦测，1-报警输入, 2-智能事件 5-pos录像 7-门禁事件, 8-非视频联动事件
    wMinorType: WORD;  //搜索次类型- 根据主类型变化，0xffff表示全部
    struStartTime: NET_DVR_TIME_SEARCH_COND;  //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    struEndTime: NET_DVR_TIME_SEARCH_COND;  //搜索的结束时间
    byLockType: BYTE;  // 0xff-全部，0-未锁，1-锁定
    byQuickSearch: BYTE;  // 是否启用快速查询，0-不启用，1-启用（快速查询不会返回文件大小，仅对设备数据库进行查询，避免频繁唤醒硬盘）
    byRes: array[0..254-1] of BYTE;  // 保留
    uSeniorParam: record 
      case Byte of
      0: (byLen: array[0..SEARCH_EVENT_INFO_LEN_V40{800}-1] of BYTE);  
      1: (struAlarmParam: record

            //报警输入号，按值表示,采用紧凑型排列，0xffff表示后续无效
        wAlarmInNo: array[0..128-1] of WORD;  
        byRes: array[0..544-1] of BYTE;  //保留
      end);  

      2: (struMotionParam: record

            // 移动侦测通道，按值表示 ,采用紧凑型排列，0xffff表示后续无效
        wMotDetChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  
        byRes: array[0..672-1] of BYTE;  //保留
      end);  

      3: (struVcaParam: record

            //异常行为检测对应的通道，按值表示,采用紧凑型排列，0xffff表示后续无效
        wChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  
        byRuleID: BYTE;  //异常行为检测类型，规则0xff表示全部，从0开始
        byDriverBehaviortType: BYTE;  //司机驾驶行为类型：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜
        byADASType: BYTE;  //高级辅助驾驶类型：0-保留、1-前向碰撞、2-车道偏离、3-盲区检测、4-车距检测、5-行人防撞、6-急加速、7-急减速、8-急左转弯、9-急右转弯、10-车辆翻车、11-未礼让行人
        byGSensorType: BYTE;  // G-Sensor事件：0-保留、1-急加速、2-急减速、3-急左转弯、4-急右转弯、5-车辆翻车、6-车辆碰撞
        bySensorInType: BYTE;  // Sensor-In行为：0-保留、1-刹车、2-左转、3-右转、4-倒车
        byRes: array[0..667-1] of BYTE;  //保留
      end);  

      4: (struInquestParam: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byRes: array[0..799-1] of BYTE;  //保留
      end);  

      5: (struVCADetect: record
        byAll: BYTE;  //查找全部通道，0-否，此时dwChanNo参数有效，
            //1-查找全部通道，此时dwChanNo参数无效。
        byRes1: array[0..3-1] of BYTE;  
        wChanNo: array[0..MAX_CHANNUM_V30-1] of WORD;  // 触发通道号,按值表示，0xffff无效，且后续数据也表示无效值
        byRes: array[0..668-1] of BYTE;  
      end);  

      6: (struStreamIDParam: record
        struIDInfo: NET_DVR_STREAM_INFO;  // 流id信息，72字节长
        dwCmdType: DWORD;  // 外部触发类型，NVR接入云存储使用
        byBackupVolumeNum: BYTE;  //存档卷号，CVR使用
        byRes1: array[0..3-1] of BYTE;  
        byArchiveLabel: array[0..64-1] of BYTE;  //存档标签，CVR使用
        byRes: array[0..656-1] of BYTE;  
      end);  

      7: (struPosAlarm: record
        wChannel: array[0..MAX_CHANNUM_V30-1] of WORD;  //通道，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
        byAllChan: BYTE;  //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
        byCaseSensitive: BYTE;  //0-不区分大小写， 1-区分大小写
        byCombinateMode: BYTE;  //关键字组合方式，0-或，1-与
        byRes1: BYTE;  //保留
        sKeyWord: array[0..MAX_POS_KEYWORDS_NUM-1, 0..MAX_POS_KEYWORD_LEN-1] of AnsiChar;  
            //关键字查找时的条件
        byRes: array[0..284-1] of BYTE;  //保留
      end);  

      8: (struTrialParam: record
        byCaseNo: array[0..SEARCH_CASE_NO_LEN-1] of BYTE;  
        byCaseName: array[0..SEARCH_CASE_NAME_LEN-1] of BYTE;  
        byLitigant1: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  
        byLitigant2: array[0..SEARCH_LITIGANT_LEN-1] of BYTE;  
        byChiefJudge: array[0..SEARCH_CHIEF_JUDGE_LEN-1] of BYTE;  
        byCaseType: BYTE;  
        byRes: array[0..547-1] of BYTE;  
      end);  

      9: (struACSAlarm: record
        dwMajor: DWORD;  //报警主类型（与事件上传主类型一致，0代表全部）
        dwMinor: DWORD;  //报警次类型（与事件上传主类型一致，0代表全部）
        byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
        byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
        byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理MAC地址
        byRes: array[0..722-1] of BYTE;  
      end);  
      10: (struIOTAlarm: record
        wDeviceType: WORD;  //设备类型,0-私有门禁主机，1-私有可视对讲设备, 2-私有报警主机（预留） 3-GJD报警主机 4-Luminite报警主机, 5-OPTEX报警主机,6-cameraDetector模拟相机传感器设备
        wEventType: WORD;  //搜索次类型- 根据主类型变化，0xffff表示全部
        wChannel: array[0..MAX_CHANNUM_V30{64}-1] of WORD;  //通道号，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
        byAllChan: BYTE;  //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
        byCaseSensitive: BYTE;  //0-不区分大小写， 1-区分大小写
        byCombinateMode: BYTE;  //关键字组合方式，0-或，1-与
        bySearchType: BYTE;  //搜索方式：0-按视频源搜索（此时通道号为视频通道号）
        sKeyWord: array[0..MAX_POS_KEYWORDS_NUM{3}-1, 0..MAX_POS_KEYWORD_LEN{128}-1] of AnsiChar;  //关键字查找时的条件
        wZoneNo: WORD;  //防区号，仅当设备类型为私有报警主机，次类型为防区（wEventType为1）时有效
        byRes: array[0..278-1] of BYTE;  //保留
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_PARAM_V50 = ^NET_DVR_SEARCH_EVENT_PARAM_V50;


//查找返回结果
type
  NET_DVR_SEARCH_EVENT_RET = record 
    wMajorType: WORD;  //主类型
    wMinorType: WORD;  //次类型
    struStartTime: NET_DVR_TIME;  //事件开始的时间
    struEndTime: NET_DVR_TIME;  //事件停止的时间，脉冲事件时和开始时间一样
    byChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byChanEx: array[0..32-1] of BYTE;  //关联通道，按位表示，使用该字段后byChan可以不使用
    byRes: array[0..4-1] of BYTE;  
    uSeniorRet: record 
      case Byte of
      0: (struAlarmRet: record
        dwAlarmInNo: DWORD;  //报警输入号
        byRes: array[0..SEARCH_EVENT_INFO_LEN-1] of BYTE;  
      end);  
      1: (struMotionRet: record
        dwMotDetNo: DWORD;  //移动侦测通道
        byRes: array[0..SEARCH_EVENT_INFO_LEN-1] of BYTE;  
      end);  
      2: (struVcaRet: record
        dwChanNo: DWORD;  //触发事件的通道号
        byRuleID: BYTE;  //规则ID
        byRes1: array[0..3-1] of BYTE;  //保留
        byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
        uEvent: NET_VCA_EVENT_UNION;  //行为事件参数
      end);  
      3: (struInquestRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        byRes1: array[0..6-1] of BYTE;  //保留
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        wSegmentState: WORD;  //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
        byRes2: array[0..288-1] of BYTE;  //保留
      end);  
      4: (struStreamIDRet: record
        dwRecordType: DWORD;  {录像类型 0-定时录像,1-移动侦测,2-报警触发,3-报警|移动侦测, 4-报警&移动侦测,5-命令触发,6-手动录像,7-震动报警,8-环境触发报警,
                                   9-智能报警,10-PIR报警,11-无线报警,12-呼救报警,13- PIR|无线报警|呼救报, 14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
                                   18-场景变更侦测, 19-全部简单智能（越界侦测|区域入侵|进入区域|离开区域|人脸识别）, 20-信号量,21-回传、22-回迁录像,23-遮挡 24-录像拼接存档}
        dwRecordLength: DWORD;  //录像大小
        byLockFlag: BYTE;  // 锁定标志 0：没锁定 1：锁定
        byDrawFrameType: BYTE;  // 0：非抽帧录像 1：抽帧录像
        byRes1: array[0..2-1] of BYTE;  
        byFileName: array[0..NAME_LEN-1] of BYTE;  //文件名
        dwFileIndex: DWORD;  // 存档卷上的文件索引
        byRes: array[0..256-1] of BYTE;  
      end);  
      5: (struTrialRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        bySegmentState: BYTE;  //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
        byCaseType: BYTE;  //案件类型；0-全部、1-刑事案件、2-民事案件
        byRes: array[0..2-1] of BYTE;  
        byCaseNo: array[0..CASE_NO_RET_LEN-1] of BYTE;  //案件编号
        byCaseName: array[0..CASE_NAME_RET_LEN-1] of BYTE;  //案件名称；
        byLitigant1: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人1；
        byLitigant2: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人2；
        byChiefJudge: array[0..CHIEF_JUDGE_RET_LEN-1] of BYTE;  //审判长
        byRes1: array[0..104-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_RET = ^NET_DVR_SEARCH_EVENT_RET;

const
  NET_SDK_MAX_TAPE_INDEX_LEN = 32;    //磁带编号最大长度
  NET_SDK_MAX_FILE_LEN = 256;    //文件名最大长度

//查找返回结果
type
  NET_DVR_SEARCH_EVENT_RET_V40 = record 
    wMajorType: WORD;  //主类型
    wMinorType: WORD;  //次类型
    struStartTime: NET_DVR_TIME;  //事件开始的时间
    struEndTime: NET_DVR_TIME;  //事件停止的时间，脉冲事件时和开始时间一样
    wChan: array[0..MAX_CHANNUM_V40{512}-1] of WORD;  //触发的通道号，0xffff表示后续无效
    byRes: array[0..36-1] of BYTE;  
    uSeniorRet: record 
      case Byte of
      0: (byLen: array[0..800-1] of BYTE);  //联合体长度
      1: (struAlarmRet: record
        dwAlarmInNo: DWORD;  //报警输入号
        byRes: array[0..796-1] of BYTE;  
      end);  
      2: (struMotionRet: record
        dwMotDetNo: DWORD;  //移动侦测通道
        byRes: array[0..796-1] of BYTE;  
      end);  
      3: (struVcaRet: record
        dwChanNo: DWORD;  //触发事件的通道号
        byRuleID: BYTE;  //规则ID
        byRes1: array[0..3-1] of BYTE;  //保留
        byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
        uEvent: NET_VCA_EVENT_UNION;  //行为事件参数
        byRes: array[0..668-1] of BYTE;  //保留
      end);  

      4: (struInquestRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        byRes1: array[0..6-1] of BYTE;  //保留
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        wSegmentState: WORD;  //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
        byRes2: array[0..784-1] of BYTE;  //保留
      end);  

      5: (struStreamIDRet: record
        dwRecordType: DWORD;  //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
        dwRecordLength: DWORD;  //录像大小
        byLockFlag: BYTE;  // 锁定标志 0：没锁定 1：锁定
        byDrawFrameType: BYTE;  // 0：非抽帧录像 1：抽帧录像
        byPosition: BYTE;  // 文件所在存储位置：0-阵列上，1-带库机位上，可以直接下载，2-磁带库内，需要把磁盘切换到机位上，3-不在磁带库中，需要把磁盘插到磁带库中
        byRes1: BYTE;  
        byFileName: array[0..NAME_LEN-1] of BYTE;  //文件名
        dwFileIndex: DWORD;  // 存档卷上的文件索引
        byTapeIndex: array[0..NET_SDK_MAX_TAPE_INDEX_LEN-1] of BYTE;  //文件所在磁带编号
        byFileNameEx: array[0..NET_SDK_MAX_FILE_LEN{256}-1] of BYTE;  //文件名扩展
        byRes: array[0..464-1] of BYTE;  
      end);  

      6: (struPosRet: record
        dwChanNo: DWORD;  //触发产生pos事件的通道
        byRes: array[0..796-1] of BYTE;  
      end);  

      7: (struTrialRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        bySegmentState: BYTE;  //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
        byCaseType: BYTE;  //案件类型；0-全部、1-刑事案件、2-民事案件
        byRes: array[0..2-1] of BYTE;  
        byCaseNo: array[0..CASE_NO_RET_LEN-1] of BYTE;  //案件编号
        byCaseName: array[0..CASE_NAME_RET_LEN-1] of BYTE;  //案件名称；
        byLitigant1: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人1；
        byLitigant2: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人2；
        byChiefJudge: array[0..CHIEF_JUDGE_RET_LEN-1] of BYTE;  //审判长
        byRes1: array[0..600-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_RET_V40 = ^NET_DVR_SEARCH_EVENT_RET_V40;

//查找返回结果
type
  NET_DVR_SEARCH_EVENT_RET_V50 = record 
    wMajorType: WORD;  //主类型
    wMinorType: WORD;  //次类型
    struStartTime: NET_DVR_TIME_SEARCH;  //事件开始的时间
    struEndTime: NET_DVR_TIME_SEARCH;  //事件停止的时间，脉冲事件时和开始时间一样
    struAddr: NET_DVR_ADDRESS;  //片段所在的地址信息，集群回放时用到
    wChan: array[0..MAX_CHANNUM_V40{512}-1] of WORD;  //触发的通道号，0xffff表示后续无效
    byRes: array[0..256-1] of BYTE;  
    uSeniorRet: record 
      case Byte of
      0: (byLen: array[0..800-1] of BYTE);  //联合体长度
      1: (struAlarmRet: record
        dwAlarmInNo: DWORD;  //报警输入号
        byRes: array[0..796-1] of BYTE;  
      end);  
      2: (struMotionRet: record
        dwMotDetNo: DWORD;  //移动侦测通道
        byRes: array[0..796-1] of BYTE;  
      end);  
      3: (struVcaRet: record
        dwChanNo: DWORD;  //触发事件的通道号
        byRuleID: BYTE;  //规则ID
        byRes1: array[0..3-1] of BYTE;  //保留
        byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
        uEvent: NET_VCA_EVENT_UNION;  //行为事件参数
        byRes: array[0..668-1] of BYTE;  //保留
      end);  

      4: (struInquestRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        byRes1: array[0..6-1] of BYTE;  //保留
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        wSegmentState: WORD;  //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
        byRes2: array[0..784-1] of BYTE;  //保留
      end);  

      5: (struStreamIDRet: record
        dwRecordType: DWORD;  //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
        dwRecordLength: DWORD;  //录像大小
        byLockFlag: BYTE;  // 锁定标志 0：没锁定 1：锁定
        byDrawFrameType: BYTE;  // 0：非抽帧录像 1：抽帧录像
        byPosition: BYTE;  // 文件所在存储位置：0-阵列上，1-带库机位上，可以直接下载，2-磁带库内，需要把磁盘切换到机位上，3-不在磁带库中，需要把磁盘插到磁带库中
        byRes1: BYTE;  
        byFileName: array[0..NAME_LEN-1] of BYTE;  //文件名
        dwFileIndex: DWORD;  // 存档卷上的文件索引
        byTapeIndex: array[0..NET_SDK_MAX_TAPE_INDEX_LEN-1] of BYTE;  //文件所在磁带编号
        byFileNameEx: array[0..NET_SDK_MAX_FILE_LEN{256}-1] of BYTE;  //文件名扩展
        byRes: array[0..464-1] of BYTE;  
      end);  

      6: (struPosRet: record
        dwChanNo: DWORD;  //触发产生pos事件的通道
        byRes: array[0..796-1] of BYTE;  
      end);  

      7: (struTrialRet: record
        byRoomIndex: BYTE;  //审讯室编号,从1开始
        byDriveIndex: BYTE;  //刻录机编号,从1开始
        wSegmetSize: WORD;  //本片断的大小, 单位M
        dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
        bySegmentState: BYTE;  //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
        byCaseType: BYTE;  //案件类型；0-全部、1-刑事案件、2-民事案件
        byRes: array[0..2-1] of BYTE;  
        byCaseNo: array[0..CASE_NO_RET_LEN-1] of BYTE;  //案件编号
        byCaseName: array[0..CASE_NAME_RET_LEN-1] of BYTE;  //案件名称；
        byLitigant1: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人1；
        byLitigant2: array[0..LITIGANT_RET_LEN-1] of BYTE;  //当事人2；
        byChiefJudge: array[0..CHIEF_JUDGE_RET_LEN-1] of BYTE;  //审判长
        byRes1: array[0..600-1] of BYTE;  
      end);  
      8: (struIOTRet: record
        dwChanNo: DWORD;  //触发产生事件的通道号（事件源通道）
        byRes: array[0..796-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SEARCH_EVENT_RET_V50 = ^NET_DVR_SEARCH_EVENT_RET_V50;

//SDK_V35  2009-10-26

// 标定配置类型
type
  CALIBRATE_TYPE =  
  (  
    PDC_CALIBRATE = $01,  // PDC 标定
    BEHAVIOR_OUT_CALIBRATE = $02,  //行为室外场景标定
    BEHAVIOR_IN_CALIBRATE = $03,  // 行为室内场景标定
    ITS_CALBIRETE = $04,  //  交通事件标定
    BV_DIRECT_CALIBRATE = $05,  //双目直接标定
    PDC_LINE_CALIBRATE = $06  //PDC 线 标定
  );

const
  MAX_RECT_NUM = 6;    
type
  NET_DVR_RECT_LIST = record 
    byRectNum: BYTE;  // 矩形框的个数
    byRes1: array[0..11-1] of BYTE;  //保留字节
    struVcaRect: array[0..MAX_RECT_NUM-1] of NET_VCA_RECT;  // 最大为6个Rect
  end;
  LPNET_DVR_RECT_LIST = ^NET_DVR_RECT_LIST;

// PDC 标定参数
type
  NET_DVR_PDC_CALIBRATION = record 
    struRectList: NET_DVR_RECT_LIST;  // 标定矩形框列表
    byRes: array[0..120-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_CALIBRATION = ^NET_DVR_PDC_CALIBRATION;


// 标定线的属性类别，用来表示当前标定线在实际表示的是高度线还是长度线。
type
  LINE_MODE =  
  (  
    HEIGHT_LINE,  //高度样本线
    LENGTH_LINE  //长度样本线
  );
{
在设置标定信息的时候，如果相应位设置了使能，并设置相关参数，
若没有设置使能，则标定后可以获取相关的摄像机参数
}
type
  NET_DVR_CAMERA_PARAM = record 
    byEnableHeight: BYTE;  // 是否使能设置摄像机高度线
    byEnableAngle: BYTE;  // 是否使能设置摄像机俯仰角度
    byEnableHorizon: BYTE;  // 是否使能设置摄像机地平线
    byRes: array[0..5-1] of BYTE;  // 保留字节
    fCameraHeight: FLOAT;  // 摄像机高度
    fCameraAngle: FLOAT;  // 摄像机俯仰角度
    fHorizon: FLOAT;  // 场景中的地平线
  end;
  LPNET_DVR_CAMERA_PARAM = ^NET_DVR_CAMERA_PARAM;
{
当fValue表示目标高度的时候，struStartPoint和struEndPoint分别表示目标头部点和脚部点。
当fValue表示线段长度的时候，struStartPoint和struEndPoint分别表示线段起始点和终点，
mode表示当前样本线表示高度线还是长度线。
}
type
  NET_DVR_LINE_SEGMENT = record 
    byLineMode: BYTE;  // 参照 LINE_MODE
    byRes: array[0..3-1] of BYTE;  // 保留字节
    struStartPoint: NET_VCA_POINT;  
    struEndPoint: NET_VCA_POINT;  
    fValue: FLOAT;  
  end;
  LPNET_DVR_LINE_SEGMENT = ^NET_DVR_LINE_SEGMENT;

const
  MAX_LINE_SEG_NUM = 8;    

{
标定样本线目前需要4-8调样本线，以获取摄像机相关参数
}
type
  NET_DVR_BEHAVIOR_OUT_CALIBRATION = record 
    dwLineSegNum: DWORD;  // 样本线个数
    struLineSegment: array[0..MAX_LINE_SEG_NUM-1] of NET_DVR_LINE_SEGMENT;  // 样本线最大个数
    struCameraParam: NET_DVR_CAMERA_PARAM;  // 摄像机参数
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_BEHAVIOR_OUT_CALIBRATION = ^NET_DVR_BEHAVIOR_OUT_CALIBRATION;

{
该结构体表示IAS智能库标定样本，
其中包括一个目标框和一条对应的高度标定线；
目标框为站立的人体外接矩形框；高度线样本标识从人头顶点到脚点的标定线；
用归一化坐标表示；
}
type
  NET_DVR_IN_CAL_SAMPLE = record 
    struVcaRect: NET_VCA_RECT;  // 目标框
    struLineSegment: NET_DVR_LINE_SEGMENT;  // 高度标定线
  end;
  LPNET_DVR_IN_CAL_SAMPLE = ^NET_DVR_IN_CAL_SAMPLE;

const
  MAX_SAMPLE_NUM = 5;    //直接标定点最大个数
  MAX_SAMPLE_NUM_EX = 7;    //样本标定点个数扩展

type
  NET_DVR_BEHAVIOR_IN_CALIBRATION = record 
    dwCalSampleNum: DWORD;  //  标定样本个数
    struCalSample: array[0..MAX_SAMPLE_NUM-1] of NET_DVR_IN_CAL_SAMPLE;  // 标定样本最大个数
    struCameraParam: NET_DVR_CAMERA_PARAM;  // 摄像机参数
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_BEHAVIOR_IN_CALIBRATION = ^NET_DVR_BEHAVIOR_IN_CALIBRATION;

const
  CALIB_PT_NUM = 4;    
type
  NET_DVR_ITS_CALIBRATION = record 
    dwPointNum: DWORD;  //标定点数
    struPoint: array[0..CALIB_PT_NUM-1] of NET_VCA_POINT;  //图像坐标
    fWidth: FLOAT;  
    fHeight: FLOAT;  
    byRes1: array[0..100-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ITS_CALIBRATION = ^NET_DVR_ITS_CALIBRATION;

type
  NET_DVR_BV_DIRECT_CALIBRATION = record 
    dwCameraHeight: DWORD;  //摄像机高度，单位cm
    fPitchAngle: FLOAT;  //摄像机俯视角度[0°, 60°],
    fInclineAngle: FLOAT;  //摄像机倾斜角度[-20°,20°]
    byRes1: array[0..228-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_DIRECT_CALIBRATION = ^NET_DVR_BV_DIRECT_CALIBRATION;

// PDC 标定参数
type
  NET_DVR_PDC_LINE_CALIBRATION = record 
    struCalibrationLine: NET_VCA_LINE;  
    byRes: array[0..224-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_LINE_CALIBRATION = ^NET_DVR_PDC_LINE_CALIBRATION;

// 标定参数联合体
// 后续的相关标定参数可以放在该结构里面
type
  NET_DVR_CALIBRATION_PRARM_UNION = record 
    case Byte of
    0: (byRes: array[0..240-1] of BYTE);  //联合体结构大小
    1: (struPDCCalibration: NET_DVR_PDC_CALIBRATION);  //PDC 标定参数
    2: (struBehaviorOutCalibration: NET_DVR_BEHAVIOR_OUT_CALIBRATION);  //  行为室外场景标定  主要应用于IVS等
    3: (struBehaviorInCalibration: NET_DVR_BEHAVIOR_IN_CALIBRATION);  // 行为室内场景标定，主要应用IAS等
    4: (struITSCalibration: NET_DVR_ITS_CALIBRATION);  
    5: (struBvDirectCalibration: NET_DVR_BV_DIRECT_CALIBRATION);  //双目直接标定
    6: (struPDCLineCalibration: NET_DVR_PDC_LINE_CALIBRATION);  //PDC 线标定参数
  end;
  LPNET_DVR_CALIBRATION_PRARM_UNION = ^NET_DVR_CALIBRATION_PRARM_UNION;


// 标定配置结构
type
  NET_DVR_CALIBRATION_CFG = record 
    dwSize: DWORD;  //标定结构大小
    byEnable: BYTE;  // 是否启用标定
    byCalibrationType: BYTE;  // 标定类型 根据不同类型在联合体类选择不同的标定 参考CALIBRATE_TYPE
    byRes1: array[0..2-1] of BYTE;  
    uCalibrateParam: NET_DVR_CALIBRATION_PRARM_UNION;  // 标定参数联合体
    byRes2: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_CALIBRATION_CFG = ^NET_DVR_CALIBRATION_CFG;

//流量统计方向结构体
type
  NET_DVR_PDC_ENTER_DIRECTION = record 
    struStartPoint: NET_VCA_POINT;  //流量统计方向起始点
    struEndPoint: NET_VCA_POINT;  // 流量统计方向结束点
  end;
  LPNET_DVR_PDC_ENTER_DIRECTION = ^NET_DVR_PDC_ENTER_DIRECTION;

type
  NET_DVR_PDC_RULE_CFG = record 
    dwSize: DWORD;  //结构大小
    byEnable: BYTE;  // 是否激活规则;
    byRes1: array[0..23-1] of BYTE;  // 保留字节
    struPolygon: NET_VCA_POLYGON;  // 多边形
    struEnterDirection: NET_DVR_PDC_ENTER_DIRECTION;  // 流量进入方向
  end;
  LPNET_DVR_PDC_RULE_CFG = ^NET_DVR_PDC_RULE_CFG;

type
  NET_DVR_PDC_RULE_CFG_V41 = record 
    dwSize: DWORD;  //结构大小
    byEnable: BYTE;  // 是否激活规则;
    byRes1: array[0..23-1] of BYTE;  // 保留字节
    struPolygon: NET_VCA_POLYGON;  // 多边形
    struEnterDirection: NET_DVR_PDC_ENTER_DIRECTION;  // 流量进入方向
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struDayStartTime: NET_DVR_TIME_EX;  //白天开始时间，时分秒有效
    struNightStartTime: NET_DVR_TIME_EX;  //夜晚开始时间，时分秒有效
    byRes: array[0..100-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_RULE_CFG_V41 = ^NET_DVR_PDC_RULE_CFG_V41;

//******** IPC5.1.7 人流量统计规则 Begin 2014-03-21**********
//条件结构
type
  NET_DVR_PDC_RULE_COND = record 
    dwSize: DWORD;  //结构大小
    dwChannel: DWORD;  //通道号
    dwID: DWORD;  //场景ID，兼容球机多场景概念，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为场景1
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_PDC_RULE_COND = ^NET_DVR_PDC_RULE_COND;

//折线结构体
type
  NET_VCA_POLYLINE = record 
    struPoint: array[0..4-1] of NET_VCA_POINT;  //折线点
  end;
  LPNET_VCA_POLYLINE = ^NET_VCA_POLYLINE;

//配置结构
type
  NET_DVR_PDC_RULE_CFG_V42 = record 
    dwSize: DWORD;  //结构大小
    byEnable: BYTE;  //是否激活规则;
    byOSDEnable: BYTE;  //客流统计OSD显示是否启用,  0-否（0-无），1-是（0-进入和离开）， 2-进入， 3-离开   对于老设备的不启用OSD叠加对应（无），启用对应（进入/离开），4-经过人数，5-进入和经过。
    byCurDetectType: BYTE;  //当前检测区域类型，0-多边形，1-检测线, 2-折线检测
    byInterferenceSuppression: BYTE;  //干扰抑制，按位表示,0-未勾选,1-勾选，bit0-阴影，bit1-徘徊，bit2-推车
    struOSDPoint: NET_VCA_POINT;  //客流统计显示OSD显示左上角坐标
    //客流量检测数据上传周期（0-15、1-1、2-5、3-10、4-20、5-30、6-60）单位：分钟
    byDataUploadCycle: BYTE;  
    //每秒上传机制使能（0-关闭，1-开启）
    bySECUploadEnable: BYTE;  
    byEmailDayReport: BYTE;  //客流日报表使能 0-关闭，1-开启
    byEmailWeekReport: BYTE;  //客流周报表使能 0-关闭，1-开启
    byEmailMonthReport: BYTE;  //客流月报表使能0-关闭，1-开启
    byEmailYearReport: BYTE;  //客流年报表使能0-关闭，1-开启
    byRes2: array[0..6-1] of BYTE;  // 保留字节
    struPolygon: NET_VCA_POLYGON;  // 多边形
    struEnterDirection: NET_DVR_PDC_ENTER_DIRECTION;  // 流量进入方向
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struDayStartTime: NET_DVR_TIME_EX;  //白天开始时间，时分秒有效
    struNightStartTime: NET_DVR_TIME_EX;  //夜晚开始时间，时分秒有效
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V40;  //处理方式 仅支持上传中心
    byDetecteSensitivity: BYTE;  //目标检测灵敏度：范围1-100，默认50
    byGenerateSpeedSpace: BYTE;  //目标生成速度（空域）：范围1-100，默认50
    byGenerateSpeedTime: BYTE;  // 目标生成速度（时域）：范围1-100，默认50
    byCountSpeed: BYTE;  // 计数速度：范围1-100，默认50
    byDetecteType: BYTE;  // 目标检测类型：0-自动，1-人头，2-头肩，默认0-自动，自动模式下DSP调整算法的参数配置给算法库
    byTargetSizeCorrect: BYTE;  //目标尺寸修正：范围1-100，默认50
    byStreamOverlayRuleInfos: BYTE;  //码流智能信息叠加 0-否，1-是
    byRes3: BYTE;  // 保留字节
    struLine: NET_VCA_LINE;  //检测线
    byHeightFilterEnable: BYTE;  //高度过滤是否开启，0-保留，1-关闭，2-开启
    byDetectThreshold: BYTE;  //检测阈值,范围[0,100],默认 90(内部使用，暂不开放)用于设定算法库中被检测目标的置信度阈值，置信度低于该阈值的目标，不用于计数；
    byAidedTrackEnabled: BYTE;  //辅助开关，0~开启、1~关闭，默认开启(内部使用) 用于开启和关闭算法模块中的光流辅助，客流人员，增加精准度。
    byRes4: BYTE;  
    fHeightFilter: FLOAT;  //过滤高度，单位：厘米，默认值：120厘米，范围：40-200厘米。byHeightFilterEnable为2是才有效
    byCalibrateType: BYTE;  //标定类型，0-未进行标定，1-自动标定，2-手动标定
    byCountingType: BYTE;  //计数触发方式 0-无,1-报警输入触发,2-视频分析触发
    bySignalType: BYTE;  //信号类型 0-电平，1-脉冲
    byRS485TransmissionEnabled: BYTE;  //启用485传输 0-关闭，1-开启
    fTiltAngle: FLOAT;  //俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,只读
    fHeelAngle: FLOAT;  //倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,只读
    fHeight: FLOAT;  //高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时设置有效，其余时只读
    struCountPolygon: NET_VCA_POLYGON;  //计数区域：该参数默认为只读属性，若智能通道分析能力中返回了<CountingPolygon>能力节点，则代表该参数支持配置。
    struAutoCalibPolygon: NET_VCA_POLYGON;  //标定区域，当byCalibrateType为1时有效
    struDailyResetTime: NET_DVR_TIME_EX;  //定时清零
    struPolyLine: NET_VCA_POLYLINE;  //折线检测区域（配置折线后，struLine不做显示）
    byRes: array[0..4-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PDC_RULE_CFG_V42 = ^NET_DVR_PDC_RULE_CFG_V42;
//******** IPC5.1.7 人流量统计规则 End 2014-03-21**********

//试用版信息结构体
type
  NET_DVR_TRIAL_VERSION_CFG = record 
    dwSize: DWORD;  
    wReserveTime: WORD;  //试用期剩余时间，0xffff表示无效，单位：天
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_TRIAL_VERSION_CFG = ^NET_DVR_TRIAL_VERSION_CFG;

type
  NET_DVR_SYN_CHANNEL_NAME_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SYN_CHANNEL_NAME_PARAM = ^NET_DVR_SYN_CHANNEL_NAME_PARAM;

type
  NET_DVR_RESET_COUNTER_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byMode: BYTE;  //生效模式，0-定时，1-手动
    byRes1: array[0..2-1] of BYTE;  
    struTime: array[0..MAX_DAYS-1] of NET_DVR_TIME_EX;  //数据清零时间，时分秒有效
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_RESET_COUNTER_CFG = ^NET_DVR_RESET_COUNTER_CFG;

type
  NET_DVR_VCA_CTRLINFO_COND = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VCA_CTRLINFO_COND = ^NET_DVR_VCA_CTRLINFO_COND;

const
  NET_SDK_MAX_RELATED_CHAN_NUM = 4;    //最大关联通道数

type
  NET_DVR_VCA_CTRLINFO_CFG = record 
    dwSize: DWORD;  
    byVCAEnable: BYTE;  //是否开启智能
    byVCAType: BYTE;  //智能能力类型，VCA_CHAN_ABILITY_TYPE
    byStreamWithVCA: BYTE;  //码流中是否带智能信息
    byMode: BYTE;  //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE ,TFS 能力时参照 TFS_CHAN_MODE_TYPE，异常行为检测完整版时参照BEHAVIOR_SCENE_MODE_TYPE
    byControlType: BYTE;  //控制类型，按位表示，0-否，1-是
    //byControlType &1 是否启用抓拍功能
    //byControlType &2 是否启用联动前端设备
    byRes1: array[0..3-1] of BYTE;  
    wRelatedChannel: array[0..NET_SDK_MAX_RELATED_CHAN_NUM{4}-1] of WORD;  //关联通道号，0-不关联（当前仅ATM设备使用，当设置通道模式为ATM面板时，可以关联一路ATM人脸通道）
    byRes: array[0..72-1] of BYTE;  //保留，设置为0
  end;
  LPNET_DVR_VCA_CTRLINFO_CFG = ^NET_DVR_VCA_CTRLINFO_CFG;

//设置人流量统计参数  复用行为内部关键字参数
// HUMAN_GENERATE_RATE
// 目标生成速度参数，控制PDC库生成目标的速度。速度越快，目标越容易生成。当输入视频光照条件较差，对比度较低时，或者设置的规则区域较小时，应加快目标生成速度， 避免目标的漏检；当输入视频中对比度较高时，或者规则区域较大时，应该降低目标生成速度，以减少误检。目标生成速度参数共有5级，1级速度最慢，5级最快，默认参数为3。
//
// DETECT_SENSITIVE
// 目标检测灵敏度控制参数，控制PDC库中一个矩形区域被检测为目标的灵敏度。灵敏度越高，矩形区域越容易被检测为目标，灵敏度越低则越难检测为目标。当输入视频光照条件较差，对比度较低时，应提高检测灵敏度， 避免目标的漏检；当输入视频中对比度较高时，应该降低检测灵敏度，以减少误检。对应参数共有5级，级别1灵敏度最低，5级最高，默认级别为3。
// TRAJECTORY_LEN
// 生成长度控制参数，表示生成时要求目标的最大位移像素。对应参数共有5级，级别1，生成长度最长，生成最慢，5级生成长度最短，生成最快，默认级别为3。
// TRAJECT_CNT_LEN
// 计数长度控制参数，表示计数时要求目标的最大位移像素。对应参数共有5级，级别1，计数要求长度最长，计数最慢，5级计数要求长度最短，计数最快，默认级别为3。
// PREPROCESS
// 图像预处理控制参数，0 - 不处理；1 - 处理。默认为0；
// CAMERA_ANGLE
// 摄像机角度输入参数， 0 - 倾斜； 1 - 垂直。默认为0；
type
  PDC_PARAM_KEY =  
  (  
    HUMAN_GENERATE_RATE = 50,  // 目标生成速度 从50开始
    DETECT_SENSITIVE = 51  // 检测灵敏度
  );

type
  NET_DVR_PDC_TARGET_INFO = record 
    dwTargetID: DWORD;  // 目标id
    struTargetRect: NET_VCA_RECT;  // 目标框
    byRes1: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_TARGET_INFO = ^NET_DVR_PDC_TARGET_INFO;

type
  NET_DVR_PDC_TARGET_IN_FRAME = record 
    byTargetNum: BYTE;  //目标个数
    byRes1: array[0..3-1] of BYTE;  
    struTargetInfo: array[0..MAX_TARGET_NUM-1] of NET_DVR_PDC_TARGET_INFO;  //目标信息数组
    byRes2: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_TARGET_IN_FRAME = ^NET_DVR_PDC_TARGET_IN_FRAME;

type
  NET_DVR_PDC_ALRAM_INFO = record 
    dwSize: DWORD;  // PDC人流量报警上传结构体大小
    byMode: BYTE;  // 0 单帧统计结果 1最小时间段统计结果 2 信号量触发（结果存在“统计起始时间”&&“统计结束时间”）
    byChannel: BYTE;  // 报警上传通道号
    //******** IPC5.1.7 新增参数 Begin 2014-03-21**********
    bySmart: BYTE;  //专业智能返回0，Smart 返回 1
    byRes1: BYTE;  // 保留字节
    //******** IPC5.1.7 新增参数 End 2014-03-21**********
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    uStatModeParam: record 
      case Byte of
      0: (struStatFrame: record
        dwRelativeTime: DWORD;  // 相对时标
        dwAbsTime: DWORD;  // 绝对时标
        byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
        cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
        cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
        byRes: array[0..89-1] of BYTE;  
      end);  
      1: (struStatTime: record
        tmStart: NET_DVR_TIME;  // 统计起始时间
        tmEnd: NET_DVR_TIME;  //  统计结束时间
        byTimeDifferenceFlag: BYTE;  //0-默认行为，cStartTimeDifferenceH,等时差信息无效，1-时差信息有效
        cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14，+表示东区
        cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区
        cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，+表示东区
        cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区
        byRes: array[0..87-1] of BYTE;  
      end);  
    end;  // 作为一个联合体 单帧的时候才有帧内目标信息 最小时间段统计结果需要统计时间 参数
    dwLeaveNum: DWORD;  // 离开人数
    dwEnterNum: DWORD;  // 进入人数
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不是重传数据，1-重传数据
    byRes3: BYTE;  
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx
    dwPassingNum: DWORD;  // 经过人数（进入区域后徘徊没有触发进入、离开的人数）
    dwChildLeaveNum: DWORD;  // 小孩离开人数
    dwChildEnterNum: DWORD;  // 小孩进入人数
    dwDuplicatePeople: DWORD;  // 重复人数
    dwXmlLen: DWORD;  //XML透传数据长度, 即EventNotificationAlert XML Block的数据长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
{$ELSE}
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    byRes4: array[0..4-1] of BYTE;  
{$ENDIF}
    byRes2: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PDC_ALRAM_INFO = ^NET_DVR_PDC_ALRAM_INFO;


//  人流量信息查询
type
  NET_DVR_PDC_QUERY = record 
    tmStart: NET_DVR_TIME;  
    tmEnd: NET_DVR_TIME;  
    dwLeaveNum: DWORD;  
    dwEnterNum: DWORD;  
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_PDC_QUERY = ^NET_DVR_PDC_QUERY;

type
  NET_DVR_POSITION_RULE_CFG = record 
    dwSize: DWORD;  // 结构大小
    struPtzPosition: NET_DVR_PTZ_POSITION;  // 场景位置信息
    struVcaRuleCfg: NET_VCA_RULECFG;  //行为规则配置
    byRes2: array[0..80-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_POSITION_RULE_CFG = ^NET_DVR_POSITION_RULE_CFG;

type
  NET_DVR_POSITION_RULE_CFG_V41 = record 
    dwSize: DWORD;  // 结构大小
    struPtzPosition: NET_DVR_PTZ_POSITION;  // 场景位置信息
    struVcaRuleCfg: NET_VCA_RULECFG_V41;  //行为规则配置
    byTrackEnable: BYTE;  //是否启用
    byRes1: BYTE;  
    wTrackDuration: WORD;  //持续时间，单位s
    byRes2: array[0..76-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_POSITION_RULE_CFG_V41 = ^NET_DVR_POSITION_RULE_CFG_V41;


type
  NET_DVR_LIMIT_ANGLE = record 
    byEnable: BYTE;  // 是否启用场景限位功能
    byRes1: array[0..3-1] of BYTE;  
    struUp: NET_DVR_PTZPOS;  // 上限位
    struDown: NET_DVR_PTZPOS;  // 下限位
    struLeft: NET_DVR_PTZPOS;  // 左限位
    struRight: NET_DVR_PTZPOS;  // 右限位
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_LIMIT_ANGLE = ^NET_DVR_LIMIT_ANGLE;

type
  NET_DVR_POSITION_INDEX = record 
    byIndex: BYTE;  // 场景索引
    byRes1: BYTE;  
    wDwell: WORD;  // 停留时间
    byRes2: array[0..4-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_POSITION_INDEX = ^NET_DVR_POSITION_INDEX;

const
  MAX_POSITION_NUM = 10;    
type
  NET_DVR_POSITION_TRACK_CFG = record 
    dwSize: DWORD;  
    byNum: BYTE;  // 场景个数
    byRes1: array[0..3-1] of BYTE;  
    struPositionIndex: array[0..MAX_POSITION_NUM-1] of NET_DVR_POSITION_INDEX;  
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_POSITION_TRACK_CFG = ^NET_DVR_POSITION_TRACK_CFG;

//巡航路径场景信息
type
  NET_DVR_PATROL_SCENE_INFO = record 
    wDwell: WORD;  // 停留时间 30-300
    byPositionID: BYTE;  // 场景号1-10，默认0表示该巡航点不添加场景
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_PATROL_SCENE_INFO = ^NET_DVR_PATROL_SCENE_INFO;

// 场景巡航配置信息
type
  NET_DVR_PATROL_TRACKCFG = record 
    dwSize: DWORD;  // 结构大小
    struPatrolSceneInfo: array[0..10-1] of NET_DVR_PATROL_SCENE_INFO;  // 巡航路径
    byRes: array[0..16-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PATROL_TRACKCFG = ^NET_DVR_PATROL_TRACKCFG;

//球机本地规则菜单配置结构体
type
  NET_DVR_TRACK_PARAMCFG = record 
    dwSize: DWORD;  // 结构大小
    wAlarmDelayTime: WORD;  // 报警延时时间，目前球机只支持全局入侵 范围1-120秒
    wTrackHoldTime: WORD;  // 报警持续时间  范围0-300秒
    byTrackMode: BYTE;  //  参照 IPDOME_TRACK_MODE
    byPreDirection: BYTE;  // 方向预判 0-不启用 1-启用
    byTrackSmooth: BYTE;  // 连续  0-不启用 1-启用
    byZoomAdjust: BYTE;  // 倍率系数调整 参见下表
    byMaxTrackZoom: BYTE;  //最大倍率系数,0-表示默认倍率系数,等级6-标定值*1.0(默认),1-5为缩小标定值，值越小，缩小的比例越大,7-15为放大，值越大，放大的比例越大
    byStopTrackWhenFindFace: BYTE;  //人脸检测到后是否停止 0-否 1-是
    byStopTrackThreshold: BYTE;  //终止评分阈值
    byRes: array[0..9-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_TRACK_PARAMCFG = ^NET_DVR_TRACK_PARAMCFG;

// 球机机芯参数
type
  NET_DVR_DOME_MOVEMENT_PARAM = record 
    wMaxZoom: WORD;  // 球机最大倍率系数
    byRes: array[0..42-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DOME_MOVEMENT_PARAM = ^NET_DVR_DOME_MOVEMENT_PARAM;

//*******************************智能交通事件 begin***************************************
const
  MAX_REGION_NUM = 8;    // 区域列表最大数目
  MAX_TPS_RULE = 8;    // 最大参数规则数目
  MAX_AID_RULE = 8;    // 最大事件规则数目
  MAX_LANE_NUM = 8;    // 最大车道数目

//交通事件类型，
type
  TRAFFIC_AID_TYPE =  
  (  
    CONGESTION = $01,  //拥堵
    PARKING = $02,  //停车
    INVERSE = $04,  //逆行
    PEDESTRIAN = $08,  //行人
    DEBRIS = $10,  //遗留物 抛洒物碎片
    SMOKE = $20,  //烟雾
    OVERLINE = $40,  //压线
    VEHICLE_CONTROL_LIST = $80,  //禁止名单数据
    SPEED = $100,  //超速
    LANECHANGE = $200,  //变道
    TURNAROUND = $400,  //掉头
    VEHICLE_OCCUPANCY_NONVEHICLE = $800,  //机动车占用非机动车位
    GASSER = $1000,  //加塞
    ROADBLOCK = $2000,  //路障
    CONSTRUCTION = $4000,  //施工
    TRAFFIC_ACCIDENT = $8000,  //交通事故检测（交通事故目前先做车车事故，追尾、剐蹭等算法判断车与车之间有交叉，其他车辆绕行则报警）
    PARALLEL_PARKING = $10000,  //侧方位停车检测
    FOG_DETECTION = $20000,  //浓雾检测
    OCCUPY_EMERGENCY_LANE = $40000,  //占用紧急车道
    CONFLAGRATION = $80000,  //火灾
    TFS_MANUAL_TRIGGER = $100000,  //手动违章取证事件
    LOADING_DOCK_TRIGGER_UPLOAD = $200000,  //月台触发上传
    OCCUPY_OVERTAKING_LANE = $400000,  //占用超车道
    PROHIBITION_MARK_VIOLATION = $800000,  //违反禁令标志
    CHECK_POINT = $1000000,  //卡口
    SUDDEN_SPEED_DROP = $2000000,  //速度骤降
    SLOW_MOVING = $4000000  //车辆缓行
  );

type
  TRAFFIC_SCENE_MODE =  
  (  
    FREEWAY = 0,  //  高速户外场景
    TUNNEL,  //  高速隧道场景
    BRIDGE  //  高速桥梁场景
  );

type
  ITS_ABILITY_TYPE =  
  (  
    ITS_CONGESTION_ABILITY = $01,  //拥堵
    ITS_PARKING_ABILITY = $02,  //停车
    ITS_INVERSE_ABILITY = $04,  //逆行
    ITS_PEDESTRIAN_ABILITY = $08,  //行人
    ITS_DEBRIS_ABILITY = $10,  //遗留物 抛洒物碎片
    ITS_SMOKE_ABILITY = $20,  //烟雾-隧道
    ITS_OVERLINE_ABILITY = $40,  //压线
    ITS_VEHICLE_CONTROL_LIST_ABILITY = $80,  //禁止名单数据
    ITS_SPEED_ABILITY = $100,  //超速
    ITS_LANECHANGE_ABILITY = $200,  //变道
    ITS_TURNAROUND_ABILITY = $400,  //掉头
    ITS_LANE_VOLUME_ABILITY = $010000,  //车道流量
    ITS_LANE_VELOCITY_ABILITY = $020000,  //车道平均速度
    ITS_TIME_HEADWAY_ABILITY = $040000,  //车头时距
    ITS_SPACE_HEADWAY_ABILITY = $080000,  //车头间距
    ITS_TIME_OCCUPANCY_RATIO_ABILITY = $100000,  //车道占有率，（时间上)
    ITS_SPACE_OCCUPANCY_RATIO_ABILITY = $200000,  //车道占有率，百分比计算（空间上)
    ITS_LANE_QUEUE_ABILITY = $400000,  //排队长度
    ITS_VEHICLE_TYPE_ABILITY = $800000,  //车辆类型
    ITS_TRAFFIC_STATE_ABILITY = $1000000  //交通状态
  );

// 交通统计参数
type
  ITS_TPS_TYPE =  
  (  
    LANE_VOLUME = $01,  //车道流量
    LANE_VELOCITY = $02,  //车道速度
    TIME_HEADWAY = $04,  //车头时距
    SPACE_HEADWAY = $08,  //车头间距
    TIME_OCCUPANCY_RATIO = $10,  //车道占有率 (时间上)
    SPACE_OCCUPANCY_RATIO = $20,  //车道占有率，百分比计算(空间上)
    QUEUE = $40,  //排队长度
    VEHICLE_TYPE = $80,  //车辆类型
    TRAFFIC_STATE = $100  //交通状态
  );

type
  NET_DVR_REGION_LIST = record 
    dwSize: DWORD;  // 结构体大小
    byNum: BYTE;  // 区域个数
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struPolygon: array[0..MAX_REGION_NUM-1] of NET_VCA_POLYGON;  // 区域
    byRes2: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_REGION_LIST = ^NET_DVR_REGION_LIST;


// 方向结构体
type
  NET_DVR_DIRECTION = record 
    struStartPoint: NET_VCA_POINT;  // 方向起始点
    struEndPoint: NET_VCA_POINT;  // 方向结束点
  end;
  LPNET_DVR_DIRECTION = ^NET_DVR_DIRECTION;

// 单个车道
type
  NET_DVR_ONE_LANE = record 
    byEnable: BYTE;  // 车道是否启用
    byRes1: array[0..11-1] of BYTE;  // 保留字节
    byLaneName: array[0..NAME_LEN-1] of BYTE;  // 车道规则名称
    struFlowDirection: NET_DVR_DIRECTION;  // 车道内车流方向
    struPolygon: NET_VCA_POLYGON;  // 车道区域
  end;
  LPNET_DVR_ONE_LANE = ^NET_DVR_ONE_LANE;

// 车道配置
type
  NET_DVR_LANE_CFG = record 
    dwSize: DWORD;  // 结构体大小
    struLane: array[0..MAX_LANE_NUM-1] of NET_DVR_ONE_LANE;  // 车道参数 数组下标作为车道ID，
    byRes1: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_LANE_CFG = ^NET_DVR_LANE_CFG;

// 交通事件参数
type
  NET_DVR_AID_PARAM = record 
    wParkingDuration: WORD;  // 违停检测灵敏度  10-120s
    wPedestrianDuration: WORD;  // 行人持续时间    1-120s
    wDebrisDuration: WORD;  // 抛洒物持续时间  10-120s
    wCongestionLength: WORD;  // 拥堵长度阈值    5-200（米）
    wCongestionDuration: WORD;  // 拥堵持续参数    10-120s
    wInverseDuration: WORD;  // 逆行持续时间    1-10s
    wInverseDistance: WORD;  // 逆行距离阈值 单位m 范围[2-100] 默认 10米
    wInverseAngleTolerance: WORD;  // 允许角度偏差 90-180度,车流与逆行允许的夹角
    wIllegalParkingTime: WORD;  // 违停时间[4,60]，单位：分钟 ,TFS(交通违章取证) 城市模式下
    wIllegalParkingPicNum: WORD;  // 违停图片数量[1,6], TFS(交通违章取证) 城市模式下
    byMergePic: BYTE;  // 图片拼接,TFS 城市模式下 0- 不拼接 1- 拼接
    byRes1: array[0..23-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AID_PARAM = ^NET_DVR_AID_PARAM;

// 单条交通事件规则结构体
type
  NET_DVR_ONE_AID_RULE = record 
    byEnable: BYTE;  // 是否启用事件规则
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    byRuleName: array[0..NAME_LEN-1] of BYTE;  // 规则名称
    dwEventType: DWORD;  // 交通事件检测类型 TRAFFIC_AID_TYPE
    struSizeFilter: NET_VCA_SIZE_FILTER;  // 尺寸过滤器
    struPolygon: NET_VCA_POLYGON;  // 规则区域
    struAIDParam: NET_DVR_AID_PARAM;  //  事件参数
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_2-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_ONE_AID_RULE = ^NET_DVR_ONE_AID_RULE;

// 交通事件规则
type
  NET_DVR_AID_RULECFG = record 
    dwSize: DWORD;  // 结构体大小
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struOneAIDRule: array[0..MAX_AID_RULE-1] of NET_DVR_ONE_AID_RULE;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_AID_RULECFG = ^NET_DVR_AID_RULECFG;

// 单条交通事件规则结构体(扩展)
type
  NET_DVR_ONE_AID_RULE_V41 = record 
    byEnable: BYTE;  // 是否启用事件规则
    byLaneNo: BYTE;  // 关联车道号
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    byRuleName: array[0..NAME_LEN-1] of BYTE;  // 规则名称
    dwEventType: DWORD;  // 交通事件检测类型 TRAFFIC_AID_TYPE
    struSizeFilter: NET_VCA_SIZE_FILTER;  // 尺寸过滤器
    struPolygon: NET_VCA_POLYGON;  // 规则区域
    struAIDParam: NET_DVR_AID_PARAM;  // 事件参数
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  // 布防时间段
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_IVMS_IP_CHANNEL-1] of BYTE;  //报警触发的录象通道：1表示触发该通道；0表示不触发
    byRes2: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONE_AID_RULE_V41 = ^NET_DVR_ONE_AID_RULE_V41;

// 交通事件规则(扩展)
type
  NET_DVR_AID_RULECFG_V41 = record 
    dwSize: DWORD;  // 结构体大小
    byPicProType: BYTE;  // 报警时图片处理方式 0-不处理 非0-上传
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struPictureParam: NET_DVR_JPEGPARA;  // 图片规格结构
    struAIDRule: array[0..MAX_AID_RULE-1] of NET_DVR_ONE_AID_RULE_V41;  //规则数组
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_AID_RULECFG_V41 = ^NET_DVR_AID_RULECFG_V41;

// 交通统计参数结构体
type
  NET_DVR_ONE_TPS_RULE = record 
    byEnable: BYTE;  //是否使能车道交通规则参数
    byLaneID: BYTE;  //车道ID
    byRes1: array[0..2-1] of BYTE;  
    dwCalcType: DWORD;  //统计参数类型ITS_TPS_TYPE
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struVitrualLoop: NET_VCA_POLYGON;  //虚拟线圈
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_2-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式,一般为处理是否上传中心，其他功能不需要
    byRes2: array[0..20-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ONE_TPS_RULE = ^NET_DVR_ONE_TPS_RULE;

// 交通参数统计规则配置结构体
type
  NET_DVR_TPS_RULECFG = record 
    dwSize: DWORD;  // 结构大小
    struOneTpsRule: array[0..MAX_TPS_RULE-1] of NET_DVR_ONE_TPS_RULE;  // 下标对应交通参数ID
    byRes2: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_TPS_RULECFG = ^NET_DVR_TPS_RULECFG;

// 交通统计参数结构体(扩展)
type
  NET_DVR_ONE_TPS_RULE_V41 = record 
    byEnable: BYTE;  //是否使能车道交通规则参数
    byLaneID: BYTE;  //车道ID
    byRes1: array[0..2-1] of BYTE;  //保留
    dwCalcType: DWORD;  // 统计参数类型ITS_TPS_TYPE
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struVitrualLoop: NET_VCA_POLYGON;  //虚拟线圈
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRes2: array[0..60-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ONE_TPS_RULE_V41 = ^NET_DVR_ONE_TPS_RULE_V41;


// 交通参数统计规则配置结构体(扩展)
type
  NET_DVR_TPS_RULECFG_V41 = record 
    dwSize: DWORD;  // 结构大小
    struOneTpsRule: array[0..MAX_TPS_RULE-1] of NET_DVR_ONE_TPS_RULE_V41;  // 下标对应交通参数ID
    byRes: array[0..128-1] of BYTE;  // 保留
  end;
  LPNET_DVR_TPS_RULECFG_V41 = ^NET_DVR_TPS_RULECFG_V41;

//交通事件类型扩展
type
  TRAFFIC_AID_TYPE_EX =  
  (  
    ENUM_AID_TYPE_CONGESTION = 1,  //拥堵
    ENUM_AID_TYPE_PARKING = 2,  //停车
    ENUM_AID_TYPE_INVERSE = 3,  //逆行
    ENUM_AID_TYPE_PEDESTRIAN = 4,  //行人
    ENUM_AID_TYPE_DEBRIS = 5,  //遗留物 抛洒物碎片
    ENUM_AID_TYPE_SMOKE = 6,  //烟雾
    ENUM_AID_TYPE_OVERLINE = 7,  //压线
    ENUM_AID_TYPE_VEHICLE_CONTROL_LIST = 8,  //禁止名单数据
    ENUM_AID_TYPE_SPEED = 9,  //超速
    ENUM_AID_TYPE_LANECHANGE = 10,  //变道
    ENUM_AID_TYPE_TURNAROUND = 11,  //掉头
    ENUM_AID_TYPE_VEHICLE_OCCUPANCY_NONVEHICLE = 12,  //机动车占用非机动车位
    ENUM_AID_TYPE_GASSER = 13,  //加塞
    ENUM_AID_TYPE_ROADBLOCK = 14,  //路障
    ENUM_AID_TYPE_CONSTRUCTION = 15,  //施工
    ENUM_AID_TYPE_TRAFFIC_ACCIDENT = 16,  //交通事故检测（交通事故目前先做车车事故，追尾、剐蹭等算法判断车与车之间有交叉，其他车辆绕行则报警）
    ENUM_AID_TYPE_PARALLEL_PARKING = 17,  //侧方位停车检测
    ENUM_AID_TYPE_FOG_DETECTION = 18,  //浓雾检测
    ENUM_AID_TYPE_OCCUPY_EMERGENCY_LANE = 19,  //占用紧急车道
    ENUM_AID_TYPE_CONFLAGRATION = 20,  //火灾
    ENUM_AID_TYPE_TFS_MANUAL_TRIGGER = 21,  //手动违章取证事件
    ENUM_AID_TYPE_LOADING_DOCK_TRIGGER_UPLOAD = 22,  //月台触发上传
    ENUM_AID_TYPE_OCCUPY_OVERTAKING_LANE = 23,  //占用超车道
    ENUM_AID_TYPE_PROHIBITION_MARK_VIOLATION = 24,  //违反禁令标志
    ENUM_AID_TYPE_CHECK_POINT = 25,  //卡口
    ENUM_AID_TYPE_SUDDEN_SPEED_DROP = 26,  //速度骤降
    ENUM_AID_TYPE_SLOW_MOVING = 27,  //车辆缓行
    ENUM_AID_TYPE_NOT_KEEP_DISTANCE = 28,  //未保持车距
    ENUM_AID_TYPE_NOT_SLOW_ZEBRA_CROSSING = 29,  //斑马线未减速
    ENUM_AID_TYPE_OVER_TAKE_RIGHT_SIDE = 30,  //右侧超车
    ENUM_AID_TYPE_LOW_SPEED = 31,  //机动车低速行驶
    ENUM_AID_TYPE_DRAG_RACING = 32,  //飙车
    ENUM_AID_TYPE_CHANGE_LANE_CONTINUOUSLY = 33,  //连续变道
    ENUM_AID_TYPE_S_SHARP_DRIVING = 34,  //蛇形行驶
    ENUM_AID_TYPE_LARGE_VEHICLE_OCCUPY_LINE = 35,  //大车占道
    ENUM_AID_TYPE_ROAD_GROUP = 36,  //道路人员聚集，与异常行为检测的人员聚集算法不同，应用场景不同, 交通事件应用在高速、隧道等交通场景，异常行为检测人员聚集应用场景是街面。
    ENUM_AID_TYPE_SINGLE_VEHICLE_BREAKDOWN = 37,  //单车抛锚
    ENUM_AID_TYPE_BLACK_SMOKE_VEHICLE = 38,  //黑烟车
    ENUM_AID_TYPE_VEHNOYIELDPEDEST = 39,  //机动车不礼让行人
    ENUM_AID_TYPE_ILLEGALMANNEDVEH = 40,  //机动车违法载人
    ENUM_AID_TYPE_ILLEGALMANNEDNONMOTORVEH = 41,  //非机动车违法载人
    ENUM_AID_TYPE_UMBRELLATENTINSTALL = 42,  //非机动车违规加装雨棚
    ENUM_AID_TYPE_NONMOTORVEHONVEHLANE = 43,  //非机动车占用机动车道
    ENUM_AID_TYPE_WEARINGNOHELMET = 44,  //非机动车未佩戴头盔事
    ENUM_AID_TYPE_PEDESTREDLIGHTRUNNING = 45,  //行人闯红灯
    ENUM_AID_TYPE_PEDESTONNONMOTORVEHLANE = 46,  //行人非机动车道行走
    ENUM_AID_TYPE_PEDESTONVEHLANE = 47,  //行人机动车道行走
    ENUM_AID_TYPE_OCCUPYDEDICATEDLANE = 48,  //占用专用车道
    ENUM_AID_TYPE_NOTDRIVEINDEDICATEDLANE = 49  //未按专用车道行驶
  );

// 交通事件信息
type
  NET_DVR_AID_INFO = record 
    byRuleID: BYTE;  // 规则序号，为规则配置结构下标，0-16
    byVisibilityLevel: BYTE;  // 能见度等级：0-保留；1-无雾~薄雾；2-薄雾~中雾；3-大雾~浓雾；4-浓雾及以上
    byRes1: array[0..2-1] of BYTE;  
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //  规则名称
    dwAIDType: DWORD;  // 报警事件类型
    struDirect: NET_DVR_DIRECTION;  // 报警指向区域
    bySpeedLimit: BYTE;  //限速值，单位km/h[0,255]
    byCurrentSpeed: BYTE;  //当前速度值，单位km/h[0,255]
    byVehicleEnterState: BYTE;  //车辆出入状态 0-无效 1-驶入 2-驶出
    byState: BYTE;  //0-变化上传，1-轮巡上传，2-当前设备定时抓拍的数据上传，实际作用于平台形成图片序列，用于反查算法没有检测到的停车车辆（索引值2在“dwAIDType;//报警事件类型”为 “停车事件”的时候生效）
    byParkingID: array[0..16-1] of BYTE;  //停车位编号
    dwAIDTypeEx: DWORD;  // 报警事件类型扩展,参考TRAFFIC_AID_TYPE_EX
    byRes2: array[0..16-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AID_INFO = ^NET_DVR_AID_INFO;

// 交通事件报警
type
  NET_DVR_AID_ALARM = record 
    dwSize: DWORD;  // 结构长度
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  // 前端设备信息
    struAIDInfo: NET_DVR_AID_INFO;  // 交通事件信息
    dwPicDataLen: DWORD;  // 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
    pImage: PBYTE;  // 指向图片的指针
    byRes: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AID_ALARM = ^NET_DVR_AID_ALARM;

// 车道队列结构体
type
  NET_DVR_LANE_QUEUE = record 
    struHead: NET_VCA_POINT;  //队列头
    struTail: NET_VCA_POINT;  //队列尾
    dwLength: DWORD;  //实际队列长度 单位为米 [0-500]
  end;
  LPNET_DVR_LANE_QUEUE = ^NET_DVR_LANE_QUEUE;

type
  TRAFFIC_DATA_VARY_TYPE =  
  (  
    NO_VARY,  //无变化
    VEHICLE_ENTER,  //车辆进入虚拟线圈
    VEHICLE_LEAVE,  //车辆离开虚拟线圈
    UEUE_VARY  //队列变化
  );

type
  NET_DVR_LANE_PARAM = record 
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //车道规则名称
    byRuleID: BYTE;  //规则序号，为规则配置结构下标，0-7
    byVaryType: BYTE;  //车道交通参数变化类型 参照 TRAFFIC_DATA_VARY_TYPE
    byLaneType: BYTE;  //车道上行或下行
    byRes1: BYTE;  
    dwLaneVolume: DWORD;  //车道流量 ，统计有多少车子通过
    dwLaneVelocity: DWORD;  //车道速度，公里计算
    dwTimeHeadway: DWORD;  //车头时距，以秒计算
    dwSpaceHeadway: DWORD;  //车头间距，以米来计算
    fSpaceOccupyRation: FLOAT;  //车道占有率，百分比计算（空间上)
    struLaneQueue: NET_DVR_LANE_QUEUE;  //车道队列长度
    struRuleLocation: NET_VCA_POINT;  //线圈规则的中心点位置
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LANE_PARAM = ^NET_DVR_LANE_PARAM;


type
  NET_DVR_TPS_INFO = record 
    dwLanNum: DWORD;  // 交通参数的车道数目
    struLaneParam: array[0..MAX_TPS_RULE-1] of NET_DVR_LANE_PARAM;  
  end;
  LPNET_DVR_TPS_INFO = ^NET_DVR_TPS_INFO;

type
  NET_DVR_TPS_ALARM = record 
    dwSize: DWORD;  //结构体大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    struTPSInfo: NET_DVR_TPS_INFO;  //交通事件信息
    byRes1: array[0..32-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_TPS_ALARM = ^NET_DVR_TPS_ALARM;

type
  TRAFFIC_DATA_VARY_TYPE_EX_ENUM =  
  (  
    ENUM_TRAFFIC_VARY_NO = $00,  //无变化
    ENUM_TRAFFIC_VARY_VEHICLE_ENTER = $01,  //车辆进入虚拟线圈
    ENUM_TRAFFIC_VARY_VEHICLE_LEAVE = $02,  //车辆离开虚拟线圈
    ENUM_TRAFFIC_VARY_QUEUE = $04,  //队列变化
    ENUM_TRAFFIC_VARY_STATISTIC = $08  //统计数据变化（每分钟变化一次包括平均速度，车道空间/时间占有率，交通状态）
  );

type
  NET_DVR_LANE_PARAM_V41 = record 
    byRuleName: array[0..NAME_LEN-1] of BYTE;  // 车道规则名称
    byRuleID: BYTE;  // 规则序号，为规则配置结构下标，0-7
    byLaneType: BYTE;  // 车道上行或下行
    byTrafficState: BYTE;  // 车道的交通状态，0-无效，1-畅通，2-拥挤，3-堵塞
    byLaneNo: BYTE;  //车道号
    dwVaryType: DWORD;  // 车道交通参数变化类型参照  TRAFFIC_DATA_VARY_TYPE_EX_ENUM，按位区分
    dwTpsType: DWORD;  // 数据变化类型标志，表示当前上传的统计参数中，哪些数据有效，参照ITS_TPS_TYPE,按位区分
    dwLaneVolume: DWORD;  // 车道流量，统计有多少车子通过
    dwLaneVelocity: DWORD;  // 车道速度，公里计算
    dwTimeHeadway: DWORD;  // 车头时距，以秒计算
    dwSpaceHeadway: DWORD;  // 车头间距，以米来计算
    fSpaceOccupyRation: FLOAT;  // 车道占有率，百分比计算（空间上)
    fTimeOccupyRation: FLOAT;  // 时间占有率，百分比计算
    dwLightVehicle: DWORD;  // 小型车数量
    dwMidVehicle: DWORD;  // 中型车数量
    dwHeavyVehicle: DWORD;  // 重型车数量
    struLaneQueue: NET_DVR_LANE_QUEUE;  // 车道队列长度
    struRuleLocation: NET_VCA_POINT;  // 规则位置虚拟线圈的中心
    dwOversizeVehicle: DWORD;  // 大型车数量
    byRes2: array[0..60-1] of BYTE;  // 保留
  end;
  LPNET_DVR_LANE_PARAM_V41 = ^NET_DVR_LANE_PARAM_V41;


type
  NET_DVR_TPS_INFO_V41 = record 
    dwLanNum: DWORD;  // 交通参数的车道数目
    struLaneParam: array[0..MAX_TPS_RULE-1] of NET_DVR_LANE_PARAM_V41;  
    dwSceneID: DWORD;  //场景ID
    byRes: array[0..28-1] of BYTE;  //保留
  end;
  LPNET_DVR_TPS_INFO_V41 = ^NET_DVR_TPS_INFO_V41;

// 人脸规则配置
type
  NET_DVR_FACEDETECT_RULECFG = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  // 是否启用
    byEventType: BYTE;  //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;4-多张人脸&异常人脸;5-多张人脸&正常人脸; 6-多张人脸&异常人脸&正常人脸; 7-多张人脸
    byUpLastAlarm: BYTE;  //2011-04-06 是否先上传最近一次的报警
    byUpFacePic: BYTE;  //是否上传人脸子图，0-否，1-是
    byRuleName: array[0..NAME_LEN-1] of BYTE;  
    struVcaPolygon: NET_VCA_POLYGON;  // 人脸检测规则区域
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    bySensitivity: BYTE;  // 规则灵敏度
    wDuration: WORD;  // 触发人脸报警时间阈值
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_2-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byPicRecordEnable: BYTE;  //2012-3-1是否启用图片存储, 0-不启用, 1-启用
    byRes1: array[0..3-1] of BYTE;  //保留字节
    {
    警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
    0x00: 无效
    0x01: 异常人脸
    0x02: 正常人脸
    0x04: 多张人脸
    0x08: 戴墨镜人脸
    0x10: 打电话人脸
    }
    dwEventTypeEx: DWORD;  //dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
    byRes2: array[0..32-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_FACEDETECT_RULECFG = ^NET_DVR_FACEDETECT_RULECFG;

type
  NET_DVR_FACE_PIPCFG = record 
    byEnable: BYTE;  //是否开启画中画
    byBackChannel: BYTE;  //背景通道号（面板通道）
    byPosition: BYTE;  //叠加位置，0-左上,1-左下,2-右上,3-右下
    byPIPDiv: BYTE;  //分屏系数(人脸画面:面板画面)，0-1:4,1-1:9,2-1:16
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_FACE_PIPCFG = ^NET_DVR_FACE_PIPCFG;

type
  NET_DVR_FACEDETECT_RULECFG_V41 = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  // 是否启用
    byEventType: BYTE;  //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;4-多张人脸&异常人脸;5-多张人脸&正常人脸; 6-多张人脸&异常人脸&正常人脸; 7-多张人脸
    byUpLastAlarm: BYTE;  //2011-04-06 是否先上传最近一次的报警
    byUpFacePic: BYTE;  //是否上传人脸子图，0-否，1-是
    byRuleName: array[0..NAME_LEN-1] of BYTE;  
    struVcaPolygon: NET_VCA_POLYGON;  // 人脸检测规则区域
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    bySensitivity: BYTE;  // 规则灵敏度
    wDuration: WORD;  // 触发人脸报警时间阈值
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byPicRecordEnable: BYTE;  //2012-10-22是否启用图片存储, 0-不启用, 1-启用
    byRes1: BYTE;  
    wAlarmDelay: WORD;  //2012-10-22智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    struFacePIP: NET_DVR_FACE_PIPCFG;  //2012-11-7画中画参数
    wRelSnapChan: array[0..MAX_REL_SNAPCHAN_NUM-1] of WORD;  //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    byRes2: array[0..2-1] of BYTE;  //保留字节
    {
    警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
    0x00: 无效
    0x01: 异常人脸
    0x02: 正常人脸
    0x04: 多张人脸
    0x08: 戴墨镜人脸
    0x10: 打电话人脸
    }
    dwEventTypeEx: DWORD;  //dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
    byRes: array[0..16-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_FACEDETECT_RULECFG_V41 = ^NET_DVR_FACEDETECT_RULECFG_V41;

type
  NET_DVR_FACEDETECT_ALARM = record 
    dwSize: DWORD;  //结构大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    struTargetInfo: NET_VCA_TARGET_INFO;  //报警目标信息
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwPicDataLen: DWORD;  //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据}
    byAlarmPicType: BYTE;  // 0-异常人脸报警图片 1- 人脸图片,2-多张人脸, 3-戴墨镜人脸, 4-打电话人脸
    byPanelChan: BYTE;  //2012-3-1人脸通道关联的面板通道
    byRelAlarmPicNum: BYTE;  //关联通道报警图片数量
    byRes1: BYTE;  
    dwFacePicDataLen: DWORD;  //人脸图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据}
    dwAlarmID: DWORD;  //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRes2: array[0..42-1] of BYTE;  // 保留字节
    pFaceImage: PBYTE;  //指向人脸图指针
    pImage: PBYTE;  //指向图片的指针
  end;
  LPNET_DVR_FACEDETECT_ALARM = ^NET_DVR_FACEDETECT_ALARM;

type
  NET_DVR_EVENT_PARAM_UNION = record 
    uLen: array[0..3-1] of DWORD;  // 联合体大小为12字节
    dwHumanIn: DWORD;  //有无人接近 0 - 无人 1- 有人
    fCrowdDensity: FLOAT;  // 人员聚集值
  end;
  LPNET_DVR_EVENT_PARAM_UNION = ^NET_DVR_EVENT_PARAM_UNION;

// 目前只有有人无人事件和人员聚集事件实时报警上传
type
  NET_DVR_EVENT_INFO = record 
    byRuleID: BYTE;  // Rule ID
    byRes: array[0..3-1] of BYTE;  // 保留字节
    byRuleName: array[0..NAME_LEN-1] of BYTE;  // 规则名称
    dwEventType: DWORD;  // 参照VCA_EVENT_TYPE
    uEventParam: NET_DVR_EVENT_PARAM_UNION;  //
  end;
  LPNET_DVR_EVENT_INFO = ^NET_DVR_EVENT_INFO;

type
  NET_DVR_EVENT_INFO_LIST = record 
    byNum: BYTE;  // 事件实时信息个数
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struEventInfo: array[0..MAX_RULE_NUM-1] of NET_DVR_EVENT_INFO;  // 事际实时信息
  end;
  LPNET_DVR_EVENT_INFO_LIST = ^NET_DVR_EVENT_INFO_LIST;

type
  NET_DVR_RULE_INFO_ALARM = record 
    dwSize: DWORD;  // 结构体大小
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  // 前端设备信息
    struEventInfoList: NET_DVR_EVENT_INFO_LIST;  //事件信息列表
    byRes2: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_RULE_INFO_ALARM = ^NET_DVR_RULE_INFO_ALARM;

//单条场景时间段
type
  NET_DVR_ONE_SCENE_TIME = record 
    byActive: BYTE;  //0 -无效,1C有效
    byRes1: array[0..3-1] of BYTE;  //保留
    dwSceneID: DWORD;  //场景ID
    struEffectiveTime: NET_DVR_SCHEDTIME;  //场景起效时间
    byRes2: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONE_SCENE_TIME = ^NET_DVR_ONE_SCENE_TIME;

//场景起效时间段配置
type
  NET_DVR_SCENE_TIME_CFG = record 
    dwSize: DWORD;  //结构大小
    struSceneTime: array[0..MAX_SCENE_TIMESEG_NUM-1] of NET_DVR_ONE_SCENE_TIME;  //场景时间段数组
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCENE_TIME_CFG = ^NET_DVR_SCENE_TIME_CFG;


//单条场景配置信息
type
  NET_DVR_ONE_SCENE_CFG = record 
    byEnable: BYTE;  //是否启用该场景,0-不启用 1- 启用
    byDirection: BYTE;  //显示方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    byRes1: array[0..2-1] of BYTE;  //保留
    dwSceneID: DWORD;  //场景ID(只读), 0 - 表示该场景无效
    bySceneName: array[0..NAME_LEN-1] of BYTE;  //场景名称
    struPtzPos: NET_DVR_PTZPOS;  //ptz 坐标
    dwTrackTime: DWORD;  //球机时间[5,300] 秒，TFS(交通取证)模式下有效
    byRes2: array[0..24-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONE_SCENE_CFG = ^NET_DVR_ONE_SCENE_CFG;

//场景配置结构体
type
  NET_DVR_SCENE_CFG = record 
    dwSize: DWORD;  //结构大小
    struSceneCfg: array[0..MAX_ITS_SCENE_NUM-1] of NET_DVR_ONE_SCENE_CFG;  //场景配置信息
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCENE_CFG = ^NET_DVR_SCENE_CFG;

//多场景操作条件
type
  NET_DVR_SCENE_COND = record 
    dwSize: DWORD;  //结构大小
    lChannel: LONG;  //通道号
    dwSceneID: DWORD;  //场景ID, 0-表示该场景无效
    byRes: array[0..48-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCENE_COND = ^NET_DVR_SCENE_COND;

//取证方式
type
  NET_DVR_FORENSICS_MODE = record 
    dwSize: DWORD;  //结构大小
    byMode: BYTE;  // 0-手动取证 ,1-自动取证，2-半自动和静态取证
    byRes: array[0..23-1] of BYTE;  //保留
  end;
  LPNET_DVR_FORENSICS_MODE = ^NET_DVR_FORENSICS_MODE;

//报警场景信息
type
  NET_DVR_SCENE_INFO = record 
    dwSceneID: DWORD;  //场景ID, 0 - 表示该场景无效
    bySceneName: array[0..NAME_LEN-1] of BYTE;  //场景名称
    byDirection: BYTE;  //显示方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    byRes1: array[0..3-1] of BYTE;  //保留
    struPtzPos: NET_DVR_PTZPOS;  //Ptz 坐标
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCENE_INFO = ^NET_DVR_SCENE_INFO;

//交通事件报警(扩展)
type
  NET_DVR_AID_ALARM_V41 = record 
    dwSize: DWORD;  //结构长度
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    struAIDInfo: NET_DVR_AID_INFO;  //交通事件信息
    struSceneInfo: NET_DVR_SCENE_INFO;  //场景信息
    dwPicDataLen: DWORD;  //图片长度
    pImage: PBYTE;  //指向图片的指针
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    byDataType: BYTE;  
    byLaneNo: BYTE;  //关联车道号
    wMilliSecond: WORD;  //时标毫秒
    //显示点编号（路口编号、内部编号）
    byMonitoringSiteID: array[0..MONITORSITE_ID_LEN{48}-1] of BYTE;  
    byDeviceID: array[0..DEVICE_ID_LEN{48}-1] of BYTE;  //设备编号
    dwXmlLen: DWORD;  //XML报警信息长度
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    byTargetType: BYTE;  // 检测的目标类型，0~未知，1~行人、2~二轮车、3~三轮车(行人检测中返回)
    byRuleID: BYTE;  //规则ID,1-4,当congestion事件配置了规则区域时返回
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byBrokenNetHttp: BYTE;  // 断网续传标志位，0-不重传数据，1-重传数据
    byRes: array[0..3-1] of BYTE;  // 保留字节
    dwPlateSmallPicDataLen: DWORD;  //车牌小图图片长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pPlateSmallImage: PAnsiChar;  // //指向车牌小图的指针
{$ELSE}
    pPlateSmallImage: PAnsiChar;  //指向车牌小图的指针
    byRes1: array[0..4-1] of BYTE;  
{$ENDIF}
  end;
  LPNET_DVR_AID_ALARM_V41 = ^NET_DVR_AID_ALARM_V41;

//交通统计信息报警(扩展)
type
  NET_DVR_TPS_ALARM_V41 = record 
    dwSize: DWORD;  // 结构体大小
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  // 前端设备信息
    struTPSInfo: NET_DVR_TPS_INFO_V41;  // 交通参数统计信息
    //显示点编号（路口编号、内部编号）
    byMonitoringSiteID: array[0..MONITORSITE_ID_LEN{48}-1] of BYTE;  
    byDeviceID: array[0..DEVICE_ID_LEN{48}-1] of BYTE;  //设备编号
    dwStartTime: DWORD;  // 开始统计时间
    dwStopTime: DWORD;  // 结束统计时间
    byRes: array[0..24-1] of BYTE;  // 保留
  end;
  LPNET_DVR_TPS_ALARM_V41 = ^NET_DVR_TPS_ALARM_V41;

//******************************智能交通事件 end****************************************

const
  XXX_MAJOR_VERSION = 2;    

// 子版本号，性能优化、局部结构调整、模块内集成其他库的主版本提升时递增，最大31 

const
  XXX_SUB_VERSION = 3;    

// 修正版本号，修正bug后递增，最大31 

const
  XXX_REVISION_VERSION = 4;    

type
  NET_DVR_VCA_VERSION = record 
    wMajorVersion: WORD;  // 主版本号
    wMinorVersion: WORD;  // 次版本号
    wRevisionNumber: WORD;  // 修正号
    wBuildNumber: WORD;  // 编译号
    wVersionYear: WORD;  //    版本日期-年
    byVersionMonth: BYTE;  //    版本日期-月
    byVersionDay: BYTE;  //    版本日期-日
    byType: BYTE;  {算法库类型名称，0-保留，1-人脸属性,2-异常行为检测,3-人体属性,4-人脸抓拍,5人脸识别 6-人脸对比,7-学生站立检测,
                   8-区域人数统计,9-人脸评分库,10-安全帽检测,11-电梯检测算法库,12-客流量统计,13-(私有目标结构化算法)HMS,
                   14-教师行为检测, 15-人员密度，16-人数异常，17-离岗检测，18-人员滞留，19-人脸建模抓拍，20-HMS建模,21-态势分析,
                   22-城管算法,23-排队检测}
    byRes: array[0..7-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VCA_VERSION = ^NET_DVR_VCA_VERSION;


//*****************************智能 end**********************************

//*****************************车牌识别 begin*****************************************
type
  NET_DVR_PALTE_PARAM = record 
    byPlateRecoMode: BYTE;  //车牌识别的模式,默认为1(视频触发模式)
    byBelive: BYTE;  //整牌置信度阈值, 只用于视频识别方式, 根据背景复杂程度设置, 误触发率高就设高, 漏车率高就设低, 建议在80-90范围内
    byRes: array[0..22-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PALTE_PARAM = ^NET_DVR_PALTE_PARAM;

type
  NET_DVR_PLATECFG = record 
    dwSize: DWORD;  
    dwEnable: DWORD;  // 是否启用视频车牌识别 0－否 1－是 
    byPicProType: BYTE;  //报警时图片处理方式 0-不处理 非0-上传
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struPlateParam: NET_DVR_PALTE_PARAM;  // 车牌识别参数配置
    struHandleType: NET_DVR_HANDLEEXCEPTION;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRelRecordChan: array[0..MAX_CHANNUM-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PLATECFG = ^NET_DVR_PLATECFG;

// 车牌识别结果子结构
type
  NET_DVR_PLATE_INFO = record 
    byPlateType: BYTE;  //车牌类型
    byColor: BYTE;  //车牌颜色
    byBright: BYTE;  //车牌亮度
    byLicenseLen: BYTE;  //车牌字符个数
    byEntireBelieve: BYTE;  //整个车牌的置信度，-100
    byRegion: BYTE;  // 区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,4-中东(ME),5-亚太(APAC),6-非美(非洲和美洲,AfandAM),0xff-所有
    byCountry: BYTE;  // 国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, //ALL  全部"）
    byArea: BYTE;  //区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
    byPlateSize: BYTE;  //车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
    //附加信息标识（即是否有NET_DVR_VEHICLE_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
    byAddInfoFlag: BYTE;  
    //该字段是在byCountry索引基础上，扩展了区域索引，之后使用该字段代替byCountry，优先使用wCRIndex字段
    //为了兼容老用户，如果该字段值大于256（即新增区域），则byCountry赋值为0xfd（国家字段无效）。
    wCRIndex: WORD;  //国家/地区索引，索引值参考_CR_ INDEX_
    byRes: array[0..4-1] of BYTE;  //保留
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pAddInfoBuffer: PBYTE;  
{$ELSE}
    //附加信息指针,指向NET_DVR_VEHICLE_ADDINFO结构体
    pAddInfoBuffer: PBYTE;  
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    sPlateCategory: array[0..MAX_CATEGORY_LEN{8}-1] of AnsiChar;  //车牌附加信息, 即中东车牌中车牌号码旁边的小字信息，(目前只有中东地区支持)
    dwXmlLen: DWORD;  //XML报警信息长度
    pXmlBuf: PAnsiChar;  // XML报警信息指针,报警类型为 COMM_ITS_PLATE_RESUL、COMM_PLATE_RESULT_V50时有效，其XML对应到EventNotificationAlert XML Block
    struPlateRect: NET_VCA_RECT;  //车牌位置
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
    byBelieve: array[0..MAX_LICENSE_LEN-1] of BYTE;  //各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
  end;
  LPNET_DVR_PLATE_INFO = ^NET_DVR_PLATE_INFO;

type
  NET_DVR_PLATERECO_RESULE = record 
    dwSize: DWORD;  
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  // 前段设备信息
    struPlateInfo: NET_DVR_PLATE_INFO;  
    dwPicDataLen: DWORD;  //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据}
    dwRes: array[0..4-1] of DWORD;  //保留，设置为0
    pImage: PBYTE;  //指向图片的指针
  end;
  LPNET_DVR_PLATERECO_RESULE = ^NET_DVR_PLATERECO_RESULE;

//*****************************车牌识别 end*****************************************

//******************************视频综合平台**********************************
type
  NET_DVR_LOG_MATRIX = record 
    strLogTime: NET_DVR_TIME;  
    dwMajorType: DWORD;  //Main type 1-alarm; 2-abnormal; 3-operation; 0xff-all
    dwMinorType: DWORD;  //Hypo-Type 0-all;
    sPanelUser: array[0..MAX_NAMELEN-1] of BYTE;  //user ID for local panel operation
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //user ID for network operation
    struRemoteHostAddr: NET_DVR_IPADDR;  //remote host IP
    dwParaType: DWORD;  //parameter type
    dwChannel: DWORD;  //channel number
    dwDiskNumber: DWORD;  //HD number
    dwAlarmInPort: DWORD;  //alarm input port
    dwAlarmOutPort: DWORD;  //alarm output port
    dwInfoLen: DWORD;  
    byDevSequence: BYTE;  //槽位号
    byMacAddr: array[0..MACADDR_LEN-1] of BYTE;  //MAC地址,6
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号，48
    sInfo: array[0..LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1 -1] of AnsiChar;  
  end;
  LPNET_DVR_LOG_MATRIX = ^NET_DVR_LOG_MATRIX;

//2009-11-21 视频综合平台
type
  NET_DVR_VEDIOPLATLOG = record 
    bySearchCondition: BYTE;  //搜索条件，0-按槽位号搜索，1-按序列号搜索，2-按MAC地址进行搜索
    //槽位号，0-79：对应子系统的槽位号；
    //0xff：表示搜索所有的日志，包括78K和所有6467；
    //0xfe：表示搜索78K上的日志；0xfd：子域日志；0xfc：域日志。。
    byDevSequence: BYTE;  
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号，48
    byMacAddr: array[0..MACADDR_LEN-1] of BYTE;  //MAC地址,6
  end;
  LPNET_DVR_VEDIOPLATLOG = ^NET_DVR_VEDIOPLATLOG;

type
  NET_DVR_CODESYSTEMABILITY = record 
    dwSize: DWORD;  
    dwAbilityVersion: DWORD;  //能力集版本号，高16位表示主版本，低16位表示次版本
    dwSupportMaxVideoFrameRate: DWORD;  //单位(K)
                                     {按位:
                                     0:定时录像；
                                     1:定时|事件触发录像
                                     2:移动侦测录像；
                                     3:网络开关量报警录像；
                                     4:移动侦测|网络开关量报警录像；
                                     5:移动侦测&网络开关量报警录像；
                                     6:周界防范触发录像；
                                     7:人脸检测触发录像；
                                     8:车牌识别触发录像；
    9:手动录像}
    dwSupportRecordType: DWORD;  
    bySupportLinkMode: BYTE;  //按位:第0位:表示主码流，第1位:表示子码流
    bySupportStringRow: BYTE;  //支持字符叠加行数
    bySupportHideNum: BYTE;  //支持视频遮挡数量
    byRes1: BYTE;  
    //0-DCIF，1-CIF，2-QCIF，3-4CIF，4-2CIF，6-QVGA(320*240), 16-VGA，17-UXGA，18-SVGA，19-HD720p，20-XVGA，21-HD900p，22-SXGAp，27-HD1080i，28-2560*1920，29-1600*304，30-2048*1536，31-2448*2048，32-2448*1200，33-2448*800 ，34-XGA（1024x768），35-SXGA（1280x1024）
    byMainStreamSupportResolution: array[0..8-1] of BYTE;  //主码流支持的分辨率，按位
    bySubStreamSupportResolution: array[0..8-1] of BYTE;  //子码流支持的分辨率，按位
    byEventStreamSupportResolution: array[0..8-1] of BYTE;  //事件触发码流支持的分辨率，按位
    byNotSupportPreview: BYTE;  //是否支持预览,1-不支持，0-支持
    byNotSupportStorage: BYTE;  //是否支持存储,1-不支持，0-支持
    byRes2: array[0..98-1] of BYTE;  //保留
  end;
  LPNET_DVR_CODESYSTEMABILITY = ^NET_DVR_CODESYSTEMABILITY;

//*******************************end******************************************

//*****************************抓拍机******************************************
//IO输入配置
type
  NET_DVR_IO_INCFG = record 
    dwSize: DWORD;  
    byIoInStatus: BYTE;  //输入的IO口状态，0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    byRes: array[0..3-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_IO_INCFG = ^NET_DVR_IO_INCFG;

//IO输出配置
type
  NET_DVR_IO_OUTCFG = record 
    dwSize: DWORD;  
    byDefaultStatus: BYTE;  //IO默认状态：0-低电平，1-高电平
    byIoOutStatus: BYTE;  //IO起效时状态：0-低电平，1-高电平，2-脉冲
    wAheadTime: WORD;  //输出IO提前时间，单位us
    dwTimePluse: DWORD;  //脉冲间隔时间，单位us
    dwTimeDelay: DWORD;  //IO有效持续时间，单位us
    byFreqMulti: BYTE;  //倍频，数值范围[1,15]
    byDutyRate: BYTE;  //占空比，[0,40%]
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_IO_OUTCFG = ^NET_DVR_IO_OUTCFG;

//闪光灯配置
type
  NET_DVR_FLASH_OUTCFG = record 
    dwSize: DWORD;  
    byMode: BYTE;  //闪光灯闪烁模式，0-不闪，1-闪，2-关联闪，3-轮闪
    byRelatedIoIn: BYTE;  //闪光灯关联的输入IO号（关联闪时此参数有效）
    byRecognizedLane: BYTE;  //关联的IO号，按位表示，bit0表示IO1是否关联，0-不关联，1-关联
    byDetectBrightness: BYTE;  //自动检测亮度使能闪光灯0-不检测；1-检测
    byBrightnessThreld: BYTE;  //使能闪光灯亮度阈值，范围[0,100],高于阈值闪
    byStartHour: BYTE;  //开始时间-小时,取值范围0-23
    byStartMinute: BYTE;  //开始时间-分,取值范围0-59
    byEndHour: BYTE;  //结束时间-小时,取值范围0-23
    byEndMinute: BYTE;  //结束时间-分,取值范围0-59
    byFlashLightEnable: BYTE;  //设置闪光灯时间使能:0-关;1-开
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_FLASH_OUTCFG = ^NET_DVR_FLASH_OUTCFG;

//红绿灯功能（2个IO输入一组）
type
  NET_DVR_LIGHTSNAPCFG = record 
    dwSize: DWORD;  
    byLightIoIn: BYTE;  //红绿灯的IO 号
    byTrigIoIn: BYTE;  //触发的IO号
    byRelatedDriveWay: BYTE;  //触发IO关联的车道号
    byTrafficLight: BYTE;  //0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    bySnapTimes1: BYTE;  //红灯抓拍次数1，0-不抓拍，非0-连拍次数，最大5次
    bySnapTimes2: BYTE;  //绿灯抓拍次数2，0-不抓拍，非0-连拍次数，最大5次
    byRes1: array[0..2-1] of BYTE;  
    wIntervalTime1: array[0..MAX_INTERVAL_NUM-1] of WORD;  //红灯连拍间隔时间，ms
    wIntervalTime2: array[0..MAX_INTERVAL_NUM-1] of WORD;  //绿灯连拍间隔时间，ms
    byRecord: BYTE;  //闯红灯周期录像标志，0-不录像，1-录像
    bySessionTimeout: BYTE;  //闯红灯周期录像超时时间（秒）
    byPreRecordTime: BYTE;  //闯红灯录像片段预录时间(秒)
    byVideoDelay: BYTE;  //闯红灯录像片段延时时间（秒）
    byRes2: array[0..32-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_LIGHTSNAPCFG = ^NET_DVR_LIGHTSNAPCFG;

//测速功能(2个IO输入一组）
type
  NET_DVR_MEASURESPEEDCFG = record 
    dwSize: DWORD;  
    byTrigIo1: BYTE;  //测速第1线圈
    byTrigIo2: BYTE;  //测速第2线圈
    byRelatedDriveWay: BYTE;  //触发IO关联的车道号
    byTestSpeedTimeOut: BYTE;  //测速模式超时时间，单位s
    dwDistance: DWORD;  //线圈距离,cm
    byCapSpeed: BYTE;  //测速模式起拍速度，单位km/h
    bySpeedLimit: BYTE;  //限速值，单位km/h
    bySnapTimes1: BYTE;  //线圈1抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    bySnapTimes2: BYTE;  //线圈2抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    wIntervalTime1: array[0..MAX_INTERVAL_NUM-1] of WORD;  //线圈1连拍间隔时间，ms
    wIntervalTime2: array[0..MAX_INTERVAL_NUM-1] of WORD;  //线圈2连拍间隔时间，ms
    byRes: array[0..32-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_MEASURESPEEDCFG = ^NET_DVR_MEASURESPEEDCFG;


//配置条件
type
  NET_DVR_CLOUDSTORAGE_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CLOUDSTORAGE_COND = ^NET_DVR_CLOUDSTORAGE_COND;

//配置结构
type
  NET_DVR_POOLPARAM = record 
    dwPoolID: DWORD;  // 云存储分配节点号
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_POOLPARAM = ^NET_DVR_POOLPARAM;

type
  NET_DVR_CLOUDSTORAGE_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //0-不开启，1-开启
    byRes: array[0..3-1] of BYTE;  
    struIP: NET_DVR_IPADDR;  
    wPort: WORD;  //数据端口
    byRes1: array[0..2-1] of BYTE;  
    szUser: array[0..CLOUD_NAME_LEN{48}-1] of AnsiChar;  //用户名
    szPassword: array[0..CLOUD_PASSWD_LEN{48}-1] of AnsiChar;  // 密码
    struPoolInfo: array[0..16-1] of NET_DVR_POOLPARAM;  //数组0表示卡口录像池，数组1表示违章录像池，数组2表示车辆侦测数据池（IPC/D）
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CLOUDSTORAGE_CFG = ^NET_DVR_CLOUDSTORAGE_CFG;

type
  NET_DVR_PARKLAMP_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byParkingIndex: BYTE;  //相对车位号（1～4）
    byRes: array[0..15-1] of BYTE;  //保留
  end;
  LPNET_DVR_PARKLAMP_COND = ^NET_DVR_PARKLAMP_COND;

type
  NET_DVR_PARKLAMP_INFOCFG = record 
    dwSize: DWORD;  
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    sParkingNo: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车位编号(实际的车位编号)
    byLampFlicker: BYTE;  //0~不闪烁 1 ～闪烁 (车位指示灯闪烁)
    byLampColor: BYTE;  //0- 灭 1-红 2-绿  3-黄  4-蓝 5-品红 6-青 7-白色  (车位指示灯颜色)
    byStatus: BYTE;  //车位状态 0-无车，1-有车
    byColorDepth: BYTE;  //车身颜色深浅，0-深色，1-浅色,0xff-未知
    byColor: BYTE;  //车身颜色，0-其他色，1-白色，2-银色，3-灰色，4-黑色，5-红色，6-深蓝，7-蓝色，8-黄色，9-绿色，10-棕色，11-粉色，12-紫色，0xff-未进行车身颜色识别
    //车辆品牌类型识别； 参考枚举类型 VLR_VEHICLE_CLASS
    byVehicleLogoRecog: BYTE;  
    byRes: array[0..250-1] of BYTE;  //保留
  end;
  LPNET_DVR_PARKLAMP_INFOCFG = ^NET_DVR_PARKLAMP_INFOCFG;

//视频参数配置
type
  NET_DVR_VIDEOEFFECT = record 
    byBrightnessLevel: BYTE;  //0-100
    byContrastLevel: BYTE;  //0-100
    bySharpnessLevel: BYTE;  //0-100
    bySaturationLevel: BYTE;  //0-100
    byHueLevel: BYTE;  //0-100,（保留）
    byEnableFunc: BYTE;  //使能，按位表示，bit0-SMART IR(防过曝)，bit1-低照度,bit2-强光抑制使能，0-否，1-是
    byLightInhibitLevel: BYTE;  //强光抑制等级，[1-3]表示等级
    byGrayLevel: BYTE;  //灰度值域，0-[0-255]，1-[16-235]
  end;
  LPNET_DVR_VIDEOEFFECT = ^NET_DVR_VIDEOEFFECT;

//增益配置
type
  NET_DVR_GAIN = record 
    byGainLevel: BYTE;  //增益：0-100
    byGainUserSet: BYTE;  //用户自定义增益；0-100，对于抓拍机，是CCD模式下的抓拍增益
    byRes: array[0..2-1] of BYTE;  
    dwMaxGainValue: DWORD;  //最大增益值，单位dB
  end;
  LPNET_DVR_GAIN = ^NET_DVR_GAIN;

//白平衡配置
type
  NET_DVR_WHITEBALANCE = record 
    byWhiteBalanceMode: BYTE;  {0-手动白平衡（MWB）,1-自动白平衡1（AWB1）,2-自动白平衡2 (AWB2),3-自动控制改名为锁定白平衡(Locked WB)，
                         4-室外(Indoor)，5-室内(Outdoor)6-日光灯(Fluorescent Lamp)，7-钠灯(Sodium Lamp)，
                         8-自动(Auto-Track)9-一次白平衡(One Push)，10-室外自动(Auto-Outdoor)，
                         11-钠灯自动 (Auto-Sodiumlight)，12-水银灯(Mercury Lamp)，13-自动白平衡(Auto)，
14-白炽灯 (IncandescentLamp)，15-暖光灯(Warm Light Lamp)，16-自然光(Natural Light) }
    byWhiteBalanceModeRGain: BYTE;  //手动白平衡时有效，手动白平衡 R增益
    byWhiteBalanceModeBGain: BYTE;  //手动白平衡时有效，手动白平衡 B增益
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_WHITEBALANCE = ^NET_DVR_WHITEBALANCE;

//曝光控制
type
  NET_DVR_EXPOSURE = record 
    byExposureMode: BYTE;  //0 手动曝光 1自动曝光
    byAutoApertureLevel: BYTE;  // 自动光圈灵敏度, 0-10 
    byRes: array[0..2-1] of BYTE;  
    dwVideoExposureSet: DWORD;  { 自定义视频曝光时间（单位us）}//注:自动曝光时该值为曝光最慢值 新增20-1s(1000000us)
    dwExposureUserSet: DWORD;  // 自定义曝光时间,在抓拍机上应用时，CCD模式时是抓拍快门速度
    dwRes: DWORD;  
  end;
  LPNET_DVR_EXPOSURE = ^NET_DVR_EXPOSURE;

//宽动态配置
type
  NET_DVR_WDR = record 
    byWDREnabled: BYTE;  //宽动态：0 dsibale  1 enable 2 auto
    byWDRLevel1: BYTE;  //0-F
    byWDRLevel2: BYTE;  //0-F
    byWDRContrastLevel: BYTE;  //0-100
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_WDR = ^NET_DVR_WDR;

type
  NET_DVR_WDR_CFG = record 
    dwSize: DWORD;  //结构体大小
    struWDR: NET_DVR_WDR;  //配置信息
  end;
  LPNET_DVR_WDR_CFG = ^NET_DVR_WDR_CFG;


//日夜转换功能配置
type
  NET_DVR_DAYNIGHT = record 
    byDayNightFilterType: BYTE;  //日夜切换：0-白天，1-夜晚，2-自动，3-定时，4-报警输入触发, 5-自动模式2（无光敏）,6-黑光，7-黑光自动，8-黑光定时
    bySwitchScheduleEnabled: BYTE;  //0 dsibale  1 enable,(保留)
    //定时模式参数
    byBeginTime: BYTE;  //开始时间（小时），0-23
    byEndTime: BYTE;  //结束时间（小时），0-23
    //模式2
    byDayToNightFilterLevel: BYTE;  //0-7
    byNightToDayFilterLevel: BYTE;  //0-7
    byDayNightFilterTime: BYTE;  //(60秒)
    //定时模式参数
    byBeginTimeMin: BYTE;  //开始时间（分），0-59
    byBeginTimeSec: BYTE;  //开始时间（秒），0-59
    byEndTimeMin: BYTE;  //结束时间（分），0-59
    byEndTimeSec: BYTE;  //结束时间（秒），0-59
    //报警输入触发模式参数
    byAlarmTrigState: BYTE;  //报警输入触发状态，0-白天，1-夜晚
  end;
  LPNET_DVR_DAYNIGHT = ^NET_DVR_DAYNIGHT;

//Gamma校正
type
  NET_DVR_GAMMACORRECT = record 
    byGammaCorrectionEnabled: BYTE;  //0 dsibale  1 enable
    byGammaCorrectionLevel: BYTE;  //0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_GAMMACORRECT = ^NET_DVR_GAMMACORRECT;

//背光补偿配置
type
  NET_DVR_BACKLIGHT = record 
    byBacklightMode: BYTE;  //背光补偿:0 off 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE、6自定义，10-开，11-自动，12-多区域背光补偿
    byBacklightLevel: BYTE;  //0x0-0xF
    byRes1: array[0..2-1] of BYTE;  
    dwPositionX1: DWORD;  //（X坐标1）
    dwPositionY1: DWORD;  //（Y坐标1）
    dwPositionX2: DWORD;  //（X坐标2）
    dwPositionY2: DWORD;  //（Y坐标2）
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_BACKLIGHT = ^NET_DVR_BACKLIGHT;

//数字降噪功能
type
  NET_DVR_NOISEREMOVE = record 
    byDigitalNoiseRemoveEnable: BYTE;  //0-不启用，1-普通模式数字降噪，2-专家模式数字降噪
    byDigitalNoiseRemoveLevel: BYTE;  //普通模式数字降噪级别：0x0-0xF
    bySpectralLevel: BYTE;  //专家模式下空域强度：0-100
    byTemporalLevel: BYTE;  //专家模式下时域强度：0-100
    byDigitalNoiseRemove2DEnable: BYTE;  // 抓拍帧2D降噪，0-不启用，1-启用 
    byDigitalNoiseRemove2DLevel: BYTE;  // 抓拍帧2D降噪级别，0-100 
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_NOISEREMOVE = ^NET_DVR_NOISEREMOVE;

//CMOS模式下前端镜头配置
type
  NET_DVR_CMOSMODECFG = record 
    byCaptureMod: BYTE;  //抓拍模式：0-抓拍模式1；1-抓拍模式2
    byBrightnessGate: BYTE;  //亮度阈值
    byCaptureGain1: BYTE;  //抓拍增益1,0-100
    byCaptureGain2: BYTE;  //抓拍增益2,0-100
    dwCaptureShutterSpeed1: DWORD;  //抓拍快门速度1
    dwCaptureShutterSpeed2: DWORD;  //抓拍快门速度2
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_CMOSMODECFG = ^NET_DVR_CMOSMODECFG;

//前端参数配置
type
  NET_DVR_CAMERAPARAMCFG = record 
    dwSize: DWORD;  
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //亮度、对比度、饱和度、锐度、色调配置
    struGain: NET_DVR_GAIN;  //自动增益
    struWhiteBalance: NET_DVR_WHITEBALANCE;  //白平衡
    struExposure: NET_DVR_EXPOSURE;  //曝光控制
    struGammaCorrect: NET_DVR_GAMMACORRECT;  //Gamma校正
    struWdr: NET_DVR_WDR;  //宽动态
    struDayNight: NET_DVR_DAYNIGHT;  //日夜转换
    struBackLight: NET_DVR_BACKLIGHT;  //背光补偿
    struNoiseRemove: NET_DVR_NOISEREMOVE;  //数字降噪
    byPowerLineFrequencyMode: BYTE;  //0-50HZ; 1-60HZ
    {
        0-自动光圈,
        1-手动光圈,
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-private 3.8-16mm F1.5（HV3816P-8MPIR)
        6-private 11-40mm F1.7 (HV1140P-8MPIR)
        7-private 2.7-12mm F1.2（TV2712P-MPIR）
        8- MZ5721D-12MPIR
        9- MZ1555D-12MPIR
        10- MZ5721D-12MPIR(RS485)
        11- MZ1555D-12MPIR(RS485)
    }
    byIrisMode: BYTE;  
    byMirror: BYTE;  // 镜像：0 off，1- leftright，2- updown，3-center 
    byDigitalZoom: BYTE;  //数字缩放:0 dsibale  1 enable
    byDeadPixelDetect: BYTE;  //坏点检测,0 dsibale  1 enable
    byBlackPwl: BYTE;  //黑电平补偿 ,  0-255
    byEptzGate: BYTE;  // EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    byLocalOutputGate: BYTE;  //本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  11-缩放输出，12-裁剪输出，13-裁剪缩放输出
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60,
    //49-SDI_720P25
    //50-SDI_720P30
    //51-SDI_1080I25
    //52-SDI_1080I30
    //60- YPBPR_720P50
    //61-YPBPR_720P60
    //62-YPBPR_1080I50
    //63-YPBPR_1080I60
    //64-YPBPR_1080P24
    //65-YPBPR_1080P25
    //66-YPBPR_1080P30
    //67-YPBPR_1080P50
    //68-YPBPR_1080P60
    //69-YPBPR_720P25
    //70-YPBPR_720P30
    //71- HDMI_1080P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    //72- HDMI_720P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    //73- HDMI_2160P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    byCoderOutputMode: BYTE;  //编码器fpga输出模式0直通3像素搬家
    byLineCoding: BYTE;  //是否开启行编码：0-否，1-是
    byDimmerMode: BYTE;  //调光模式：0-半自动，1-自动
    byPaletteMode: BYTE;  //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
    byEnhancedMode: BYTE;  //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    byDynamicContrastEN: BYTE;  //动态对比度增强 0-1
    byDynamicContrast: BYTE;  //动态对比度 0-100
    byJPEGQuality: BYTE;  //JPEG图像质量 0-100
    struCmosModeCfg: NET_DVR_CMOSMODECFG;  //CMOS模式下前端参数配置，镜头模式从能力集获取
    byFilterSwitch: BYTE;  //滤波开关：0-不启用，1-启用
    byFocusSpeed: BYTE;  //镜头调焦速度：0-10
    byAutoCompensationInterval: BYTE;  //定时自动快门补偿：1-120，单位：分钟
    bySceneMode: BYTE;  //场景模式：0-室外，1-室内，2-默认，3-弱光
  end;
  LPNET_DVR_CAMERAPARAMCFG = ^NET_DVR_CAMERAPARAMCFG;

//透雾
type
  NET_DVR_DEFOGCFG = record 
    byMode: BYTE;  //模式，0-不启用，1-自动模式，2-常开模式
    byLevel: BYTE;  //等级，0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_DEFOGCFG = ^NET_DVR_DEFOGCFG;

//电子防抖
type
  NET_DVR_ELECTRONICSTABILIZATION = record 
    byEnable: BYTE;  //使能 0- 不启用，1- 启用
    byLevel: BYTE;  //等级，0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_ELECTRONICSTABILIZATION = ^NET_DVR_ELECTRONICSTABILIZATION;

//走廊模式
type
  NET_DVR_CORRIDOR_MODE_CCD = record 
    byEnableCorridorMode: BYTE;  //是否启用走廊模式 0～不启用， 1～启用
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_CORRIDOR_MODE_CCD = ^NET_DVR_CORRIDOR_MODE_CCD;

// SMART IR(防过曝)配置参数
type
  NET_DVR_SMARTIR_PARAM = record 
    byMode: BYTE;  //0～手动，1～自动
    byIRDistance: BYTE;  //红外距离等级(等级，距离正比例)level:1~100 默认:50（手动模式下增加）
    byShortIRDistance: BYTE;  // 近光灯距离等级(1~100)
    byLongIRDistance: BYTE;  // 远光灯距离等级(1~100)
  end;
  LPNET_DVR_SMARTIR_PARAM = ^NET_DVR_SMARTIR_PARAM;

//在byIrisMode 为P-Iris1时生效，配置红外光圈大小等级，配置模式
type
  NET_DVR_PIRIS_PARAM = record 
    byMode: BYTE;  //0-自动，1-手动
    byPIrisAperture: BYTE;  //红外光圈大小等级(等级,光圈大小正比例)level:1~100 默认:50（手动模式下增加）
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_PIRIS_PARAM = ^NET_DVR_PIRIS_PARAM;


//激光参数配置 2014-02-25
type
  NET_DVR_LASER_PARAM_CFG = record 

    //Length = 16
    byControlMode: BYTE;  //控制模式            0-无效，1-自动，2-手动 默认自动
    bySensitivity: BYTE;  //激光灯灵敏度        0-100 默认50
    byTriggerMode: BYTE;  //激光灯触发模式    0-无效，1-机芯触发，2-光敏触发 默认机芯触发
    byBrightness: BYTE;  //控制模式为手动模式下有效；激光灯亮度        0-255 默认100
    byAngle: BYTE;  //激光灯角度        0-无效，范围1-36  默认12，激光灯照射范围为一个圆圈，调节激光角度是调节这个圆的半径的大小
    byLimitBrightness: BYTE;  //控制模式为自动模式下有效；激光灯亮度限制 0~100 （新增）2014-01-26
    byEnabled: BYTE;  //手动控制激光灯使能 0-关闭，1-启动
    byIllumination: BYTE;  //激光灯强度配置0~100
    byLightAngle: BYTE;  //补光角度 0~100
    byRes: array[0..7-1] of BYTE;  //保留
  end;
  LPNET_DVR_LASER_PARAM_CFG = ^NET_DVR_LASER_PARAM_CFG;

type
  NET_DVR_FFC_PARAM = record 

    //1-Schedule Mode,2-Temperature Mode, 3-Off
    byMode: BYTE;  
    //（时间:按能力显示，单位分钟，选项有10,20,30,40,50,60,120,180,240）
    byRes1: BYTE;  
    wCompensateTime: WORD;  //定时模式下生效
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_FFC_PARAM = ^NET_DVR_FFC_PARAM;

type
  NET_DVR_DDE_PARAM = record //在sensor中完成
    byMode: BYTE;  //1-Off,2-Normal Mode,3-Expert Mode
    byNormalLevel: BYTE;  //普通模式等级范围[1,100]，普通模式下生效
    byExpertLevel: BYTE;  //专家模式等级范围[1,100]，专家模式下生效
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_DDE_PARAM = ^NET_DVR_DDE_PARAM;

type
  NET_DVR_AGC_PARAM = record 
    bySceneType: BYTE;  //1-Normal Sence,2-Highlight Sence,3-Manual Sence
    byLightLevel: BYTE;  //亮度等级[1,100]；手动模式下生效
    byGainLevel: BYTE;  //增益等级[1,100]；手动模式下生效
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_AGC_PARAM = ^NET_DVR_AGC_PARAM;

//抓拍机CCD参数 共64字节
type
  NET_DVR_SNAP_CAMERAPARAMCFG = record 
    byWDRMode: BYTE;  // 宽动态模式;0~关闭，1~数字宽动态 2~宽动态
    byWDRType: BYTE;  // 宽动态切换模式; 0~强制启用，1~按时间启用，2~按亮度启用
    byWDRLevel: BYTE;  // 宽动态等级，0~6索引对应1-7，默认索引2（即3级）；
    byRes1: BYTE;  
    struStartTime: NET_DVR_TIME_EX;  //开始宽动态时间
    struEndTime: NET_DVR_TIME_EX;  //结束宽动态时间
    byDayNightBrightness: BYTE;  //日夜转换亮度阈值，0-100，默认50；
    //记忆色增强
    byMCEEnabled: BYTE;  //记忆色增强使能，true：开启，false：关闭
    byMCELevel: BYTE;  //记忆色增强强度，0~100，默认值50
    //自动对比度
    byAutoContrastEnabled: BYTE;  //自动对比度使能，true：开启，false：关闭
    byAutoContrastLevel: BYTE;  //自动对比等级（0-100）,默认50
    //细节增强
    byLSEDetailEnabled: BYTE;  //细节增强使能，true：开启，false：关闭
    byLSEDetailLevel: BYTE;  //细节增强等级（0-100）,默认50
    // License Plate Definition Enhancement车牌增强
    byLPDEEnabled: BYTE;  //车牌增强使能，true：开启，false：关闭
    byLPDELevel: BYTE;  //车牌增强等级（0-100）,默认50
    //对比度增强
    byLseEnabled: BYTE;  //对比度增强使能，true：开启，false：关闭
    byLseLevel: BYTE;  //对比度增强等级（0-100）,默认0
    byLSEHaloLevel: BYTE;  //光晕抑制等级。范围 0-100,默认0
    byLseType: BYTE;  //对比度增强切换模式; 0~强制启用，1~按时间启用，2~按亮度启用（该字段可同时控制byLseLevel、byLSEHaloLevel两个参数）
    byRes2: array[0..3-1] of BYTE;  
    struLSEStartTime: NET_DVR_TIME_EX;  //开始对比度增强时间（当byLseType为1时生效）
    struLSEEndTime: NET_DVR_TIME_EX;  //结束对比度增强时间（当byLseType为1时生效）
    byLightLevel: BYTE;  //为亮度等级参数（0-100）,默认0，（当byLseType为2时生效）
    //车牌对比度
    byPlateContrastLevel: BYTE;  //车牌对比度等级，0~100，默认0
    //车牌饱和度
    byPlateSaturationLevel: BYTE;  //车牌饱和度等级，0~100，默认0
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_SNAP_CAMERAPARAMCFG = ^NET_DVR_SNAP_CAMERAPARAMCFG;

//光学透雾参数
type
  NET_DVR_OPTICAL_DEHAZE = record 
    byEnable: BYTE;  //0~不启用光学透雾，1~启用光学透雾
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_DEHAZE = ^NET_DVR_OPTICAL_DEHAZE;

//测温AGC设置，当测温AGC模式为无效时，以NET_DVR_AGC_PARAM配置参数为准，当测温AGC模式为自动或者手动时，NET_DVR_AGC_PARAM配置参数无效
type
  NET_DVR_THERMOMETRY_AGC = record 
    byMode: BYTE;  //AGC模式，0~无效，1~自动，2~手动
    byRes1: array[0..3-1] of BYTE;  
    iHighTemperature: INT;  //最高温度，范围为：-273~9999摄氏度（1~手动模式下生效）
    iLowTemperature: INT;  //最低温度，范围为：-273~9999摄氏度（1~手动模式下生效）
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_AGC = ^NET_DVR_THERMOMETRY_AGC;

//前端参数配置
type
  NET_DVR_CAMERAPARAMCFG_EX = record 
    dwSize: DWORD;  
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //亮度、对比度、饱和度、锐度、色调配置
    struGain: NET_DVR_GAIN;  //自动增益
    struWhiteBalance: NET_DVR_WHITEBALANCE;  //白平衡
    struExposure: NET_DVR_EXPOSURE;  //曝光控制
    struGammaCorrect: NET_DVR_GAMMACORRECT;  //Gamma校正
    struWdr: NET_DVR_WDR;  //宽动态
    struDayNight: NET_DVR_DAYNIGHT;  //日夜转换
    struBackLight: NET_DVR_BACKLIGHT;  //背光补偿
    struNoiseRemove: NET_DVR_NOISEREMOVE;  //数字降噪
    byPowerLineFrequencyMode: BYTE;  //0-50HZ; 1-60HZ
    {
    0-自动光圈,
    1-手动光圈,
    2-P-Iris1,
    3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
    4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
    5-private 3.8-16mm F1.5（HV3816P-8MPIR)
    6-private 11-40mm F1.7 (HV1140P-8MPIR)
    7-private 2.7-12mm F1.2（TV2712P-MPIR）
    8- MZ5721D-12MPIR
    9- MZ1555D-12MPIR
    10- MZ5721D-12MPIR(RS485)
    11- MZ1555D-12MPIR(RS485)
    }
    byIrisMode: BYTE;  
    byMirror: BYTE;  // 镜像：0 off，1- leftright，2- updown，3-center 4-Auto
    byDigitalZoom: BYTE;  //数字缩放:0 dsibale  1 enable
    byDeadPixelDetect: BYTE;  //坏点检测,0 dsibale  1 enable
    byBlackPwl: BYTE;  //黑电平补偿 ,  0-255
    byEptzGate: BYTE;  // EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    byLocalOutputGate: BYTE;  //本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    byCoderOutputMode: BYTE;  //编码器fpga输出模式0直通3像素搬家
    byLineCoding: BYTE;  //是否开启行编码：0-否，1-是
    byDimmerMode: BYTE;  //调光模式：0-半自动，1-自动
    byPaletteMode: BYTE;  //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8, 9-融合1,10-彩虹,11-融合2,12-铁红1,13-铁红2,14-深褐色,15-色彩1,16-色彩2,17-冰火,18-雨,19-红热,20-绿热,21-深蓝，22-色彩3
    byEnhancedMode: BYTE;  //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    byDynamicContrastEN: BYTE;  //动态对比度增强 0-1
    byDynamicContrast: BYTE;  //动态对比度 0-100
    byJPEGQuality: BYTE;  //JPEG图像质量 0-100
    struCmosModeCfg: NET_DVR_CMOSMODECFG;  //CMOS模式下前端参数配置，镜头模式从能力集获取
    byFilterSwitch: BYTE;  //滤波开关：0-不启用，1-启用
    byFocusSpeed: BYTE;  //镜头调焦速度：0-10
    byAutoCompensationInterval: BYTE;  //定时自动快门补偿：1-120，单位：分钟
    bySceneMode: BYTE;  //场景模式：0-室外，1-室内，2-默认，3-弱光
    struDefogCfg: NET_DVR_DEFOGCFG;  //透雾参数
    struElectronicStabilization: NET_DVR_ELECTRONICSTABILIZATION;  //电子防抖
    struCorridorMode: NET_DVR_CORRIDOR_MODE_CCD;  //走廊模式
    byExposureSegmentEnable: BYTE;  //0~不启用,1~启用  曝光时间和增益呈阶梯状调整，比如曝光往上调整时，先提高曝光时间到中间值，然后提高增益到中间值，再提高曝光到最大值，最后提高增益到最大值
    byBrightCompensate: BYTE;  //亮度增强 [0~100]
    {
    0-关闭、1-640*480@25fps、2-640*480@30ps、3-704*576@25fps、4-704*480@30fps、5-1280*720@25fps、6-1280*720@30fps、
    7-1280*720@50fps、8-1280*720@60fps、9-1280*960@15fps、10-1280*960@25fps、11-1280*960@30fps、
    12-1280*1024@25fps、13--1280*1024@30fps、14-1600*900@15fps、15-1600*1200@15fps、16-1920*1080@15fps、
    17-1920*1080@25fps、18-1920*1080@30fps、19-1920*1080@50fps、20-1920*1080@60fps、21-2048*1536@15fps、22-2048*1536@20fps、
    23-2048*1536@24fps、24-2048*1536@25fps、25-2048*1536@30fps、26-2560*2048@25fps、27-2560*2048@30fps、
    28-2560*1920@7.5fps、29-3072*2048@25fps、30-3072*2048@30fps、31-2048*1536@12.5、32-2560*1920@6.25、
    33-1600*1200@25、34-1600*1200@30、35-1600*1200@12.5、36-1600*900@12.5、37-1280*960@12.5fps、38-800*600@25fps、39-800*600@30fps40、
    4000*3000@12.5fps、41-4000*3000@15fps、42-4096*2160@20fps、43-3840*2160@20fps 、44-960*576@25fps、45-960*480@30fps、46-752*582@25fps、
    47-768*494@30fps、48-2560*1440@25fps、49-2560*1440@30fps 、50-720P@100fps、51-720P@120fps、52-2048*1536@50fps、53-2048*1536@60fps、
    54-3840*2160@25fps、55-3840*2160@30fps、56-4096*2160@25fps、57-4096*2160@30fps 、58-1280*1024@50fps、59-1280*1024@60fps、
    60-3072*2048@50fps、61-3072*2048@60fps、62-3072*1728@25fps、63-3072*1728@30fps、64-3072*1728@50fps、65-3072*1728@60fps、66-336*256@50fps、67-336*256@60fps、
    68-384*288@50fps、69-384*288@60fps 、70- 640 * 512@50fps 、71- 640 * 512@60fps、72-2592*1944@25fps、73-2592*1944@30fps、74-2688*1536@25fps、75-2688*1536@30fps
    76-2592*1944@20fps、77-2592*1944@15fps、78-2688*1520@20fps、79-2688*1520@15fps、80-2688*1520@25fps、81-2688*1520@30fps、82- 2720*2048@25fps、 83- 2720*2048@30fps、
    84-336*256@25fps、85- 384*288@25fps、86-640*512@25fps、87-1280*960@50fps、88-1280*960@60fps、89-1280*960@100fps、90-1280*960@120fps、91-4000*3000@20fps、
    92-1920*1200@25fps、93-1920*1200@30fps、94-2560*1920@25fps、95-2560*1920@20fps、96-2560*1920@30fps、97-1280*1920@25fps、98-1280*1920@30fps
    99-4000*3000@24fps、100-4000*3000@25fps、101-4000*3000@10fps、102- 384*288@30fps、103-2560*1920@15fps、104-2400*3840@25fps、105-1200*1920@25fps
    106-4096*1800@30fps、107-3840*1680@30fps、108-2560*1120@30fps、109-704*320@30fps、110-1280*560@30fps、111-4096*1800@25fps、112-3840*1680@25fps
    113-2560*1120@25fps、114-704*320@25fps、115-1280*560@25fps、116-2400*3840@24fps、117-3840*2400@24fps、118-3840*2400@25fps、119-2560*1920@12.5fps
    120-2560*2048@12fps、121-2560*2048@15fps、122-2560*1536@25fps、123-2560*1536@30fps、124-2256*2048@25fps、125-2256*2048@30fps、126-2592*2592@12.5fps、127-2592*2592@15fps、
    128 - 640*512@30fps、129-2048*1520@30fps、130-2048*1520@25fps、131-3840*2160@24fps、132-2592*1520@25fps、133-2592*1520@30fps、134-2592*1536@25fps、135-2592*1536@30fps
    136-640*960@25fps、137-640*960@24fps、139-3840*1080@25fps、140-3840*1080@30fps、142-2992*2192@25fps、143-2992*2192@30fps、144-3008*2160@25fps、145-3008*2160@30fps、
    146-3072*1728@20fps、147-2560*1440@20fps、148-2160*3840@25fps、149-2160*3840@30fps、150-7008*1080@25fps、151-7008*1080@30fps、152-3072*2048@20fps、153-1536*864@25fps、
    154-2560*1920@24fps、155-2400*3840@30fps、156-3840*2400@30fps、157-3840*2160@15fps、
    158-384*288@8.3fps、159-640*512@8.3fps、160-160*120@8.3fps、161-1024*768@8.3fps、162-640*480@8.3fps、163-3840*2160@12.5fps、164-2304*1296@30fps、165-2304*1296@25fps、
    166-2560*1440@24fps、167-2688*1512@25fps、168-2688*1512@30fps、169-2688*1512@50fps、170-2688*1512@60fps、171-1536*864@30fps、172-2560*1440@50fps、173-2560*1440@60fps、
    174-2048*2048@25fps、175-2048*2048@30fps、176-4000*3060@20fps、177-3060*3060@25fps、178-3060*3060@30fps、179-3000*3000@25fps、180-3000*3000@30fps、181-8160*3616@30fps、
    182-8160*3616@25fps、183-3000*3000@20fps、184-3000*3000@15fps、185-3000*3000@12.5fps、186-5472*3648@25fps、187-5472*3648@30fps、188-7680*4320@25fps、189-7680*4320@30fps、
    190-8160*2400@25fps、191-8160*2400@30fps、192-5520*2400@25fps、193-5520*2400@30fps、194-2560*1440@15fps、195-1944*1212@24fps、196-1944*1212@25fps、197-3456*1920@30fps、
    198-4800*2688@25fps、199-4800*2688@30fps、200-6480*1080@25fps、201-6480*1080@30fps、202-8640*1440@25fps、203-8640*1440@30fps、204-3456*1920@25fps、205-2688*1520@50fps、
    206-2688*1520@60fps、207-4976*1452@25fps、208-4976*1452@30fps、 209-3200*1800@25fps、210-3200*1800@30fps、211-5472*3648@24fps、212-1920*1080@12.5fps、213-2944*1656@20fps、
    214-1920*1080@24fps、215-4800*1600@25fps、216-4800*1600@30fps、217-2560*1440@12.5fps、218-6560*3690@1fps、219-5120*1400@20fps、220-7680*4320@1fps、221-1920*1080@20fps
    222-5120*1440@20fps、223-4080*1808@25fps、224-4080*1808@30fps、225-4080*1152@25fps、226-4080*1152@30fps、227-2688*1944@20fps、228-2592*1944@24fps、229-3200*1800@15fps、
    230-4416*1696@20fps、231-3456*1080@25fps、232-3200*1800@12.5fps、233-2688*1532@25fps、234-2688*1532@30fps、235-4416*1696@12.5fps、236-3840*2048P12.5fps、237-3840*4096P12.5fps、
    238-5120*1440@12.5fps、239-3840*1080@24fps、240-320*256@30fps、241-3264*2448@25fps、242-3264*2448@30fps、243-5430*3054@1fps、244-2688*1520@24@24fps、245-4000*3000@30fps、
    246-1632*1224@25fps、247-1632*1224@30fps、248-160*120@25fps、249-1920*1440@25fps、250-1920*1440@30fps、-3632*1632@20fps、252-3040*1368@25fps、253-3040*1368@24fps、
    254-5120*1440@25fps、255-超出字段表示范围
    设备输入模式索引超过255时：
    1）获取时，该字段值为255（无具体含义，用于表示实际输入模式索引值超过255），实际由wCaptureModeN、wCaptureModeP表示；
    2）设置时，该值仍需要设置为255，实际由wCaptureModeN、wCaptureModeP表示。
    设备输入模式索引小于255时：
    1）获取时，该字段值为实际输入模式值，wCaptureModeN、wCaptureModeP值无需处理；
    2）设置时该字段为实际输入模式值，wCaptureModeN、wCaptureModeP值保持不变
    }
    byCaptureModeN: BYTE;  //视频输入模式（N制）
    byCaptureModeP: BYTE;  //视频输入模式（P制）
    struSmartIRParam: NET_DVR_SMARTIR_PARAM;  //红外放过爆配置信息
    struPIrisParam: NET_DVR_PIRIS_PARAM;  //PIris配置信息对应byIrisMode字段从2-PIris1开始生效
    //2014-02-25 新增参数
    struLaserParam: NET_DVR_LASER_PARAM_CFG;  //激光参数
    struFFCParam: NET_DVR_FFC_PARAM;  
    struDDEParam: NET_DVR_DDE_PARAM;  
    struAGCParam: NET_DVR_AGC_PARAM;  
    byLensDistortionCorrection: BYTE;  //镜头畸变校正 0-关闭,1-开启
    byDistortionCorrectionLevel: BYTE;  //畸变校正等级：0-保留；1-等级一；2-等级二；3-等级三;255-自定义
    byCalibrationAccurateLevel: BYTE;  // 畸变校正强度[0-100]
    byZoomedInDistantViewLevel: BYTE;  //远端放大等级[0-100]
    struSnapCCD: NET_DVR_SNAP_CAMERAPARAMCFG;  //抓拍机CCD参数，只用于抓拍机
    struOpticalDehaze: NET_DVR_OPTICAL_DEHAZE;  //光学透雾参数
    struThermAGC: NET_DVR_THERMOMETRY_AGC;  //测温AGC配置
    byFusionMode: BYTE;  //双光谱视频融合模式，0~热成像模式，1~融合模式，2~画中画模式,3~可见光模式, 4~融合黑白模式, 5~融合彩色模式-草地，6~融合彩色模式-荒地，7~融合彩色模式-雪地，8~融合彩色模式-海洋，9~融合彩色模式-城市
    byHorizontalFOV: BYTE;  //水平视场角[0-100]
    byVerticalFOV: BYTE;  //垂直视场角[0-100]
    byBrightnessSuddenChangeSuppression: BYTE;  //亮度突变抑制0-关闭,1-开启
    byGPSEnabled: BYTE;  //GPS开关使能，0-关，1-开
    byRes: BYTE;  
    {
    256-160*120@50fps、257-3200*1800@20fps、258-800*480@25fps、259-2688*1944@25fps、260-640*384@50fps、261-8000*6000@1fps、262-1440*1080@50fps、263-1440*1080@60fps、
    264-8160*3616@24fps、265-3632*1632@25fps、266-3632*1632@30fps、267-3632*1632@20fps、268-1760*1320@25fps、269-4000*3000@4fps、270-192*256@25fps、271-720*576@25fps、
    272-720x576@30fps、273-960*432@25fps、274-960*432@30fps、275-1200*536@25fps、276-1200*536@30fps、277-1760*1320@12.5fps、278-2560*480@25fps、279-2048*384@25fps、
    280-96*96@25fps、281-320*256@25fps、282-6128*1800@25fps、283-6128*1800@30fps、284-2304*1296@24fps、285-2048*1152@25fps、286-2048*1152@30fps、287-3840*2100@20fps、
    288-96*72@25fps、289-2048*1152@24fps、290-720*576@50fps、291-2368*1776@25fps、292-2368*1776@30fps、293-1776*1776@25fps、294-3776*2832@25fps、295-3776*2832@30fps、
    296-2832*2832@25ps、297-2832*2832@30、298-1776*1776@30fps
    }
    wCaptureModeN: WORD;  //视频输入模式（N制），当模式索引小于255时，与byCaptureModeN保持一致，大于255时以该字段返回索引值判断。
    wCaptureModeP: WORD;  //视频输入模式（P制），当模式索引小于255时，与byCaptureModeN保持一致，大于255时以该字段返回索引值判断
    byRes2: array[0..150-1] of BYTE;  
  end;
  LPNET_DVR_CAMERAPARAMCFG_EX = ^NET_DVR_CAMERAPARAMCFG_EX;

type
  NET_DVR_FOCUSING_POSITION_STATE = record 
    dwSize: DWORD;  
    byState: BYTE;  //聚焦到位状态参数 0-不到位，1-到位
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_FOCUSING_POSITION_STATE = ^NET_DVR_FOCUSING_POSITION_STATE;

type
  VCA_PLATE_COLOR =  
  (  
    VCA_BLUE_PLATE = 0,  //蓝色车牌
    VCA_YELLOW_PLATE,  //黄色车牌
    VCA_WHITE_PLATE,  //白色车牌
    VCA_BLACK_PLATE,  //黑色车牌
    VCA_GREEN_PLATE,  //绿色车牌
    VCA_BKAIR_PLATE,  //民航黑色车牌
    VCA_RED_PLATE,  //红色车牌
    VCA_ORANGE_PLATE,  //橙色车牌
    VCA_BROWN_PLATE = 8,  //棕色车牌
    VCA_OTHER = $ff  //其他
  );

//车牌类型
type
  VCA_PLATE_TYPE =  
  (  
    VCA_STANDARD92_PLATE = 0,  //标准民用车与特种车
    VCA_STANDARD02_PLATE,  //02式民用车牌
    VCA_WJPOLICE_PLATE,  //武警车
    VCA_JINGCHE_PLATE,  //警车
    STANDARD92_BACK_PLATE,  //民用车双行尾牌
    VCA_SHIGUAN_PLATE,  //使馆车牌
    VCA_NONGYONG_PLATE,  //农用车
    VCA_MOTO_PLATE,  //摩托车
    NEW_ENERGY_PLATE,  //新能源车牌
    VCA_CONSULATE_PLATE = 9,  //领事馆车牌
    VCA_EMERGENCY_PLATE = 10,  //应急车牌
    //2017-05-18 增加 中东地区车牌类型
    TRANSPORT_PLATE = $20,  //运输车
    COMMERCIAL_PLATE,  //商用车
    PRIVATE_PLATE,  //私家车
    LEARNING_PLATE,  //教练车
    CD_PLATE,  //使馆车
    CC_PLATE,  //使馆车
    SPECIAL_PLATE,  //特种车
    PROTOCOL_PLATE,  //PROTOCOL
    GOVERNMENT_PLATE,  //政府车
    EXPORT_PLATE,  //EXPORT
    TAXI_PLATE,  //出租车
    TESTING_PLATE,  //TESTING
    TRANSFER_PLATE,  //TRANSFER
    TRUCK_PLATE,  //货车
    BUS_PLATE,  //公交车
    PUBLIC_PLATE,  //PUBLIC
    PUB_TRANS_PLATE,  //PUBLIC TRANSFER
    PRI_TRANS_PLATE,  //PRIVATE TRANSPORT
    TUMBREL_PLATE,  //二轮车
    HONG_KONG_MACAO_PLATE,  //港澳入出车
    UNKNOWN_PLATE = $ff  //未知（未识别）
  );

//车型识别结果
type
  VTR_RESULT =  
  (  
    VTR_RESULT_OTHER = 0,  //未知
    VTR_RESULT_BUS = 1,  //客车
    VTR_RESULT_TRUCK = 2,  //货车
    VTR_RESULT_CAR = 3,  //轿车
    VTR_RESULT_MINIBUS = 4,  //面包车
    VTR_RESULT_SMALLTRUCK = 5,  //小货车
    VTR_RESULT_HUMAN = 6,  //行人
    VTR_RESULT_TUMBREL = 7,  //二轮车
    VTR_RESULT_TRIKE = 8,  //三轮车
    VTR_RESULT_SUV_MPV = 9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS = 10,  //中型客车
    VTR_RESULT_MOTOR_VEHICLE = 11,  //机动车
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //非机动车
    VTR_RESULT_SMALLCAR = 13,  //小型轿车
    VTR_RESULT_MICROCAR = 14,  //微型轿车
    VTR_RESULT_PICKUP = 15,  //皮卡车
    VTR_RESULT_CONTAINER_TRUCK = 16,  // 集装箱卡车
    VTR_RESULT_MINI_TRUCK = 17,  // 微卡，栏板卡
    VTR_RESULT_SLAG_CAR = 18,  // 渣土车
    VTR_RESULT_CRANE = 19,  // 吊车，工程车
    VTR_RESULT_OIL_TANK_TRUCK = 20,  // 油罐车
    VTR_RESULT_CONCRETE_MIXER = 21,  // 混凝土搅拌车
    VTR_RESULT_PLATFORM_TRAILER = 22,  // 平板拖车
    VTR_RESULT_HATCHBACK = 23,  // 两厢轿车
    VTR_RESULT_SALOON = 24,  // 三厢轿车
    VTR_RESULT_SPORT_SEDAN = 25,  // 轿跑
    VTR_RESULT_SMALL_BUS = 26  //小型客车
  );


//车身颜色
type
  VCR_CLR_CLASS =  
  (  
    VCR_CLR_UNSUPPORT = 0,  //不支持
    VCR_CLR_WHITE = 1,  //白
    VCR_CLR_SILVER = 2,  //银
    VCR_CLR_GRAY = 3,  //灰
    VCR_CLR_BLACK = 4,  //黑
    VCR_CLR_RED = 5,  //红
    VCR_CLR_DARKBLUE = 6,  //深蓝
    VCR_CLR_BLUE = 7,  //蓝
    VCR_CLR_YELLOW = 8,  //黄
    VCR_CLR_GREEN = 9,  //绿
    VCR_CLR_BROWN = 10,  //棕
    VCR_CLR_PINK = 11,  //粉
    VCR_CLR_PURPLE = 12,  //紫
    VCR_CLR_DARKGRAY = 13,  //深灰
    VCR_CLR_CYAN = 14  //青色
  );

//车辆操作类型 2013-11-04
type
  VCA_OPERATE_TYPE =  
  (  
    VCA_LICENSE_TYPE = $1,  //车牌号码
    VCA_PLATECOLOR_TYPE = $2,  //车牌颜色
    VCA_CARDNO_TYPE = $4,  //卡号
    VCA_PLATETYPE_TYPE = $8,  //车牌类型
    VCA_LISTTYPE_TYPE = $10,  //车辆名单类型
    VCA_INDEX_TYPE = $20,  //数据流水号 2014-02-25
    VCA_OPERATE_INDEX_TYPE = $40  //操作数 2014-03-03
  );

type
  VCA_ILLEGAL_TYPE =  
  (  
    VCA_POSTPIC_TYPE = $1,  //卡口图片
    VCA_LOWSPEED_TYPE = $2,  //低速
    VCA_HIGHSPEED_TYPE = $4,  //高速
    VCA_RETROGRADE_TYPE = $8,  //逆行
    VCA_RUSH_REDLIGHT_TYPE = $10,  //闯红灯
    VCA_PRESS_LANE_TYPE = $20,  //压车道线
    VCA_VIOLATE_GUIDE_TYPE = $40,  //不按导向
    VCA_ROAD_STRAND_TYPE = $80,  //路口滞留(设备不支持)
    VCA_VEHICLE_ILLEGAL_LANE_TYPE = $100,  //机占非
    VCA_ILLEGAL_LANE_CHANGE_TYPE = $200,  //违法变道
    VCA_ILLEGAL_LANE_DRIVE_TYPE = $400,  //不按车道
    VCA_VIOLATE_BAN_TYPE = $800,  //违法禁令
    VCA_CROSS_PARKING_TYPE = $1000,  //路口停车
    VCA_GREEN_PARKING_TYPE = $2000  //绿灯停车
  );

type
  VCA_VEHICLE_TYPE =  
  (  
    VCA_OTHER_TYPE = $1,  //其它车型
    VCA_SMALLCAR_TYPE = $2,  //小型车
    VCA_BIGCAR_TYPE = $4,  //大型车
    VCA_BUS_TYPE = $8,  //客车
    VCA_TRUCK_TYPE = $10,  //货车
    VCA_CAR_TYPE = $20,  //轿车
    VCA_MINIBUS_TYPE = $40,  //面包车
    VCA_SMALL_TRUCK_TYPE = $80  //小货车
  );

//车辆品牌主类型
type
  VLR_VEHICLE_CLASS =  
  (  
    VLR_OTHER = 0,  //其它
    VLR_VOLKSWAGEN = 1,  //大众
    VLR_BUICK = 2,  //别克
    VLR_BMW = 3,  //宝马
    VLR_HONDA = 4,  //本田
    VLR_PEUGEOT = 5,  //标致
    VLR_TOYOTA = 6,  //丰田
    VLR_FORD = 7,  //福特
    VLR_NISSAN = 8,  //日产
    VLR_AUDI = 9,  //奥迪
    VLR_MAZDA = 10,  //马自达
    VLR_CHEVROLET = 11,  //雪佛兰
    VLR_CITROEN = 12,  //雪铁龙
    VLR_HYUNDAI = 13,  //现代
    VLR_CHERY = 14,  //奇瑞
    VLR_KIA = 15,  //起亚
    VLR_ROEWE = 16,  //荣威
    VLR_MITSUBISHI = 17,  //三菱
    VLR_SKODA = 18,  //斯柯达
    VLR_GEELY = 19,  //吉利
    VLR_ZHONGHUA = 20,  //中华
    VLR_VOLVO = 21,  //沃尔沃
    VLR_LEXUS = 22,  //雷克萨斯
    VLR_FIAT = 23,  //菲亚特
    VLR_EMGRAND = 24,  //帝豪(吉利)
    VLR_DONGFENG = 25,  //东风
    VLR_BYD = 26,  //比亚迪
    VLR_SUZUKI = 27,  //铃木
    VLR_JINBEI = 28,  //金杯
    VLR_HAIMA = 29,  //海马
    VLR_SGMW = 30,  //五菱
    VLR_JAC = 31,  //江淮
    VLR_SUBARU = 32,  //斯巴鲁
    VLR_ENGLON = 33,  //英伦(吉利)
    VLR_GREATWALL = 34,  //长城
    VLR_HAFEI = 35,  //哈飞
    VLR_ISUZU = 36,  //五十铃(庆铃)
    VLR_SOUEAST = 37,  //东南
    VLR_CHANA = 38,  //长安
    VLR_FOTON = 39,  //福田
    VLR_XIALI = 40,  //夏利(一汽)
    VLR_BENZ = 41,  //奔驰
    VLR_FAW = 42,  //一汽
    VLR_NAVECO = 43,  //依维柯
    VLR_LIFAN = 44,  //力帆
    VLR_BESTURN = 45,  //一汽奔腾(一汽)
    VLR_CROWN = 46,  //皇冠(丰田)
    VLR_RENAULT = 47,  //雷诺
    VLR_JMC = 48,  //JMC(江铃)
    VLR_MG = 49,  //MG名爵
    VLR_KAMA = 50,  //凯马
    VLR_ZOTYE = 51,  //众泰
    VLR_CHANGHE = 52,  //昌河
    VLR_XMKINGLONG = 53,  //厦门金龙(金旅)
    VLR_HUIZHONG = 54,  //上海汇众(上汽集团)
    VLR_SZKINGLONG = 55,  //苏州金龙
    VLR_HIGER = 56,  //海格
    VLR_YUTONG = 57,  //宇通
    VLR_CNHTC = 58,  //中国重汽
    VLR_BEIBEN = 59,  //北奔重卡
    VLR_XINGMA = 60,  //华菱星马
    VLR_YUEJIN = 61,  //跃进
    VLR_HUANGHAI = 62,  //黄海
    VLR_OLDWALL = 63,  //老款长城
    VLR_CHANACOMMERCIAL = 64,  //长安商用
    VLR_PORSCHE = 65,  // 保时捷
    VLR_CADILLAC = 66,  // 凯迪拉克
    VLR_INFINITI = 67,  // 英菲尼迪
    VLR_GLEAGLE = 68,  // 吉利全球鹰(吉利)
    VLR_JEEP = 69,  // JEEP(吉普)
    VLR_LANDROVER = 70,  // 路虎
    VLR_CHANGFENG = 71,  // 长丰
    VLR_BENNI = 72,  // 长安奔奔(长安)
    VLR_ERA = 73,  // 福田时代(时代)
    VLR_TAURUS = 74,  // 长安金牛星(长安商用)
    VLR_EADO = 75,  // 长安逸动
    VLR_SHANQI = 76,  // 陕汽
    VLR_HONGYAN = 77,  // 红岩汽车(上汽依维柯红岩)
    VLR_DRAGON = 78,  // 霸龙汽车(东风柳汽)
    VLR_JACTEXT = 79,  // 江淮JAC (江淮)
    VLR_JACBUS = 80,  // 江淮现代客车 (江淮)
    VLR_ANKAI = 81,  // 安凯客车
    VLR_SHENLONG = 82,  // 申龙客车
    VLR_DAEWOO = 83,  // 大宇客车
    VLR_WUZHENG = 84,  // 五征汽车
    VLR_MAN = 85,  // MAN汽车
    VLR_ZHONGTONG = 86,  // 中通客车
    VLR_BAOJUN = 87,  // 宝骏
    VLR_BQWEIWANG = 88,  // 北汽威旺
    VLR_TRUMPCHE = 89,  // 传祺
    VLR_LUFENG = 90,  // 陆风
    VLR_HMZHENGZHOU = 91,  // 海马郑州
    VLR_BEIJING = 92,  // 北京汽车
    VLR_ZHONGSHUN = 93,  // 中顺
    VLR_WEILIN = 94,  // 威麟汽车
    VLR_OPEL = 95,  // 欧宝
    VLR_KARRY = 96,  // 开瑞
    VLR_SMA = 97,  // 华普汽车
    VLR_SMATEXT = 98,  // 华普汽车文字SMA
    VLR_YUWIN = 99,  // 江铃驭胜
    VLR_MINI = 100,  // 宝马MINI
    VLR_MARK = 101,  // 丰田MARKX
    VLR_HAVAL = 102,  // 哈弗HAVAL
    VLR_OGA = 103,  // 讴歌
    VLR_VENUCIA = 104,  // 启辰
    VLR_BYD2 = 105,  // 比亚迪样式2 (比亚迪)
    VLR_SMART = 106,  // 奔驰SMART
    VLR_BAW = 107,  // 北京汽车制造厂BAW
    VLR_LUXGEN = 108,  // 纳智捷
    VLR_YEMA = 109,  // 野马
    VLR_ZTE = 110,  // 中兴
    VLR_EVERUS = 111,  // 理念
    VLR_CHRYSLER = 112,  // 克莱斯勒
    VLR_GONOW = 113,  // 吉奥汽车
    VLR_SHJIANG = 114,  // 松花江
    VLR_RUILIN = 115,  // 瑞麟
    VLR_FORTA = 116,  // 福达
    VLR_GAGUAR = 117,  // 捷豹
    VLR_HEIBAO = 118,  // 黑豹
    VLR_TKING = 119,  // 唐骏
    VLR_TKINGTEXT = 120,  // 唐骏文字
    VLR_FODAY = 121,  // 福迪
    VLR_LOTUS = 122,  // 莲花汽车
    VLR_NANJUN = 123,  // 南骏
    VLR_SHUANGHUAN = 124,  // 双环汽车
    VLR_SAIBAO = 125,  // 哈飞赛豹
    VLR_HAWTAI = 126,  // 华泰
    VLR_LIFO = 127,  // 永源飞碟
    VLR_JONWAY = 128,  // 永源汽车
    VLR_FULONGMA = 129,  // 福龙马
    VLR_WEILI = 130,  // 潍力
    VLR_ANCHI = 131,  // 江淮安驰
    VLR_PAIXI = 132,  // 派喜
    VLR_HIGERTEXT = 133,  // 海格HIGER文字
    VLR_RIYECAR = 134,  // 广汽日野轻卡
    VLR_RIYETRUCK = 135,  // 广汽日野重卡
    VLR_JIANGNAN = 136,  // 江南
    VLR_OLDZOTYE = 137,  // 老款众泰
    VLR_OLDXIALI = 138,  // 老款夏利
    VLR_NEWAOCHI = 139,  // 新奥驰
    VLR_CDW = 140,  // 王牌重汽
    VLR_CDWTEXT = 141,  // 王牌重汽文字
    VLR_CIIMO = 142,  // 本田思铭
    VLR_CHANADS = 143,  // 长安谛艾仕
    VLR_DS = 144,  // 道奇
    VLR_ROHENS = 145,  // 现代劳恩斯酷派
    VLR_YANTAI = 146,  // 燕台
    VLR_SHUANGLONG = 147,  // 双龙
    VLR_FENGLING = 148,  // 时代风菱
    VLR_XINKAI = 149,  // 新凯
    VLR_GMC = 150,  // GMC
    VLR_DATONG = 151,  // 上汽大通
    VLR_BQYINXIANG = 152,  // 北汽银翔
    VLR_NEWCHERY = 153,  // 新奇瑞
    VLR_MUDAN = 154,  // 牡丹
    VLR_DAYUN = 155,  // 大运汽车
    VLR_DONGWO = 156,  // 东沃汽车
    VLR_UNION = 157,  // 联合汽车
    VLR_CHUNZHOU = 158,  // 春洲客车
    VLR_SANY = 159,  // 三一重工
    VLR_YAXING = 160,  // 亚星客车
    VLR_HENGTONG = 161,  // 恒通客车
    VLR_SHAOLIN = 162,  // 少林客车
    VLR_YOUNG = 163,  // 青年客车
    VLR_STOM = 164,  // 十通
    VLR_SANHUAN = 165,  // 三环
    VLR_XUGONG = 166,  // 徐工
    VLR_BEIFANG = 167,  // 北方汽车
    VLR_JIANGHUAN = 168,  // 江环货车
    VLR_BJFARM = 169,  // 北京农用
    VLR_NEWDADI = 170,  // 新大地汽车
    VLR_SUNWIN = 171,  // 申沃客车
    VLR_YINGTIAN = 172,  // 英田
    VLR_QINGQI = 173,  // 轻骑
    VLR_CHUFENG = 174,  // 楚风汽车
    VLR_SCANIA = 175,  // 斯堪尼亚
    VLR_JIULONG = 176,  // 九龙客车
    VLR_YOUYI = 177,  // 友谊客车
    VLR_SHANGRAO = 178,  // 上饶客车
    VLR_JIJIANG = 179,  // 吉江
    VLR_YANGZI = 180,  // 扬子客车
    VLR_XIWO = 181,  // 西沃客车
    VLR_CHANGJIANG = 182,  // 长江客车
    VLR_WUYI = 183,  // 武夷
    VLR_CHENGDU = 184,  // 成都客车
    VLR_TIANMA = 185,  // 天马
    VLR_BAOLONG = 186,  // 宝龙
    VLR_NEWYATU = 187,  // 新雅途
    VLR_BARUI = 188,  // 起亚霸锐
    VLR_GUANZHI = 189,  // 观致
    VLR_XIYATE = 190,  // 西雅特
    VLR_BINLI = 191,  // 宾利
    VLR_DADI = 192,  // 大迪
    VLR_FUQI = 193,  // 富奇
    VLR_HANGTIAN = 194,  // HT汽车
    VLR_HENGTIAN = 195,  // 恒天汽车
    VLR_JMCCAR = 196,  // 江铃轻汽
    VLR_KAERSEN = 197,  // 卡尔森汽车
    VLR_KAWEI = 198,  // 卡威汽车
    VLR_LANBOJINI = 199,  // 兰博基尼
    VLR_MASHALADI = 200,  // 玛莎拉蒂
    VLR_SHUCHI = 201,  // 舒驰客车
    VLR_SHILI = 202,  // 实力客车
    VLR_HUABEI = 203,  // 中客华北
    VLR_YIZHENG = 204,  // 上汽仪征
    VLR_CHUNLAN = 205,  // 春兰汽车
    VLR_DAFA = 206,  // 大发汽车
    VLR_SHENYE = 207,  // 神野汽车
    VLR_FALALI = 208,  // 法拉利汽车
    VLR_FUXING = 209,  // 福星汽车
    VLR_ANYUAN = 210,  // 安源客车
    VLR_JINGHUA = 211,  // 京华客车
    VLR_TAIHU = 212,  // 太湖客车
    VLR_WUZHOULONG = 213,  // 五洲龙
    VLR_CHANGLONG = 214,  // 常隆客车
    VLR_YUEXI = 215,  // 悦西客车
    VLR_SHENMA = 216,  // 神马客车
    VLR_LUSHAN = 217,  // 庐山牌
    VLR_WANFENG = 218,  // 万丰牌
    VLR_GZYUNBAO = 219,  // 广州云豹
    VLR_ZHONGDA = 220,  // 中大汽车
    VLR_THREEWHEEL = 221,  // 三轮车
    VLR_TWOWHEEL = 222,  // 二轮车
    VLR_JBC = 223,  // 金杯JBC
    VLR_YZJIANG = 224,  // 扬子江客车
    VLR_CNJ = 225,  // 南骏CNJ
    VLR_FORLAND = 226,  // 福田时代文字
    VLR_FARMCAR = 227,  // 农用车
    VLR_DONGFANGHONG = 228,  // 东方红
    VLR_STEYR = 229,  // 斯太尔汽车
    VLR_HONGQI = 230,  // 红旗
    VLR_USER1 = 231,  //用户1
    VLR_USER2 = 232,  //用户2
    VLR_USER3 = 233,  //用户3
    VLR_USER4 = 234,  //用户4
    VLR_USER5 = 235,  //用户5
    VLR_USER6 = 236,  //用户6
    VLR_USER7 = 237,  //用户7
    VLR_USER8 = 238  //用户8
  );

//*******************车辆品牌子类型Begin************************
//大众子品牌类型
type
  VSB_VOLKSWAGEN_CLASS =  
  (  
    VSB_VOLKSWAGEN_OTHER = 0,  // 其他（保留）
    VSB_VOLKSWAGEN_LAVIDA = 1,  // 朗逸
    VSB_VOLKSWAGEN_CROSSLAVIDA = 2,  // 朗境
    VSB_VOLKSWAGEN_TIGUAN = 3,  // 途观
    VSB_VOLKSWAGEN_TOURAN = 4,  // 途安
    VSB_VOLKSWAGEN_SANTANA = 5,  // 桑塔纳
    VSB_VOLKSWAGEN_SANTANA2000 = 6,  // 桑塔纳2000
    VSB_VOLKSWAGEN_SANTANA3000 = 7,  // 桑塔纳3000
    VSB_VOLKSWAGEN_VISTA = 8,  // 桑塔纳-志俊
    VSB_VOLKSWAGEN_PASSAT = 9,  // 帕萨特
    VSB_VOLKSWAGEN_PASSATLINGYU = 10,  // 帕萨特-领驭
    VSB_VOLKSWAGEN_POLO = 11,  // 波罗
    VSB_VOLKSWAGEN_POLOCROSS = 12,  // 波罗-运动版
    VSB_VOLKSWAGEN_POLOGTI = 13,  // 波罗-GTI
    VSB_VOLKSWAGEN_SAGITAR = 14,  // 速腾
    VSB_VOLKSWAGEN_MAGOTAN = 15,  // 迈腾
    VSB_VOLKSWAGEN_JETTA = 16,  // 捷达
    VSB_VOLKSWAGEN_BORA = 17,  // 宝来
    VSB_VOLKSWAGEN_NEWGOLF = 18,  // 新高尔夫
    VSB_VOLKSWAGEN_GOLFGTI = 19,  // 高尔夫-GTI
    VSB_VOLKSWAGEN_GOL = 20,  // 高尔
    VSB_VOLKSWAGEN_CADDY = 21,  // 开迪
    VSB_VOLKSWAGEN_PHAETON = 22,  // 辉腾
    VSB_VOLKSWAGEN_TOUREG = 23,  // 途锐
    VSB_VOLKSWAGEN_SCIROCCO = 24,  // 尚酷
    VSB_VOLKSWAGEN_BEETLE = 25,  // 甲壳虫
    VSB_VOLKSWAGEN_SHARAN = 26,  // 夏朗
    VSB_VOLKSWAGEN_MULTIVAN = 27,  // 迈特威
    VSB_VOLKSWAGEN_CARBONCOPY = 28,  // 一汽大众-CC
    VSB_VOLKSWAGEN_VISTACHANGDA = 29,  // 桑塔纳志俊-畅达
    VSB_VOLKSWAGEN_BORASPORTLINE = 30,  // 宝来-SPORTLINE
    VSR_VOLKSWAGEN_CC_1 = 31,  //大众-CC-2012,2011,2010
    VSR_VOLKSWAGEN_Cross_POLO_1 = 32,  //大众-Cross-POLO-2010,2007
    VSR_VOLKSWAGEN_Cross_POLO_2 = 33,  //大众-Cross-POLO-2014,2012
    VSR_VOLKSWAGEN_MULTIVAN_1 = 34,  //大众-Multivan-2014,2012,2011
    VSR_VOLKSWAGEN_POLO_1 = 35,  //大众-POLO-2006,2005,2004,2003,2002
    VSR_VOLKSWAGEN_POLO_2 = 36,  //大众-POLO-2013,2012,2011
    VSR_VOLKSWAGEN_POLO_JINQU_1 = 37,  //大众-POLO劲取-2009,2008,2007,2006
    VSR_VOLKSWAGEN_POLO_JINQU_2 = 38,  //大众-POLO劲取-2011
    VSR_VOLKSWAGEN_Tiguan_1 = 39,  //大众-Tiguan-2011,2009
    VSR_VOLKSWAGEN_Tiguan_2 = 40,  //大众-Tiguan-2014,2013,2012
    VSR_VOLKSWAGEN_XIALANG_1 = 41,  //大众-夏朗-2013,2012
    VSR_VOLKSWAGEN_BAOLAI_1 = 42,  //大众-宝来-2005,2004
    VSR_VOLKSWAGEN_BAOLAI_2 = 43,  //大众-宝来-2006
    VSR_VOLKSWAGEN_BAOLAI_3 = 44,  //大众-宝来-2012,2011,2010,2009,2008
    VSR_VOLKSWAGEN_BAOLAI_4 = 45,  //大众-宝来-2014,2013
    VSR_VOLKSWAGEN_SHANGKU_1 = 46,  //大众-尚酷-2014,2013
    VSR_VOLKSWAGEN_PASATE_1 = 47,  //大众-帕萨特-2003进口,2001领驭
    VSR_VOLKSWAGEN_PASATE_2 = 48,  //大众-帕萨特-2007,2006,2005领驭
    VSR_VOLKSWAGEN_PASATE_3 = 49,  //大众-帕萨特-2009,2008,2007,2005,2004,2003,2001,2000
    VSR_VOLKSWAGEN_PASATE_4 = 50,  //大众-帕萨特-2011,2009领驭
    VSR_VOLKSWAGEN_PASATE_5 = 51,  //大众-帕萨特-2014,2013,2012,2011
    VSR_VOLKSWAGEN_JIEDA_1 = 52,  //大众-捷达-2005CIF伙伴,2002
    VSR_VOLKSWAGEN_JIEDA_2 = 53,  //大众-捷达-2009,2008,2006,2005,2004
    VSR_VOLKSWAGEN_JIEDA_3 = 54,  //大众-捷达-2012,2010
    VSR_VOLKSWAGEN_JIEDA_4 = 55,  //大众-捷达-2013
    VSR_VOLKSWAGEN_LANGYI_1 = 56,  //大众-朗逸-2012,2011,2010,2009,2008
    VSR_VOLKSWAGEN_LANGYI_2 = 57,  //大众-朗逸-2013
    VSR_VOLKSWAGEN_SANGTANA_1 = 58,  //大众-桑塔纳-2007,2002,2000,1999,1995
    VSR_VOLKSWAGEN_SANGTANA_2 = 59,  //大众-桑塔纳-2014,2013
    VSR_VOLKSWAGEN_SANGTANA_3 = 60,  //大众-桑塔纳2000-2003,2001,2000,1999,1998,1996
    VSR_VOLKSWAGEN_SANGTANA_4 = 61,  //大众-桑塔纳3000-2007,2006,2005,2004,2003
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,  //大众-桑塔纳志俊(vista)-2011,2010,2009,2008
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,  //大众-桑塔纳志俊(vista)-2006
    VSR_VOLKSWAGEN_JIAKECHONG_1 = 64,  //大众-甲壳虫-2010,2009,2008,2007,2006,2005
    VSR_VOLKSWAGEN_JIAKECHONG_2 = 65,  //大众-甲壳虫-2014,2013
    VSR_VOLKSWAGEN_HUITENG_2 = 66,  //大众-辉腾-2010,2009,2007,2006
    VSR_VOLKSWAGEN_MAITENG_1 = 67,  //大众-迈腾-2011,2010,2009,2008,2007
    VSR_VOLKSWAGEN_MAITENG_2 = 68,  //大众-迈腾-2013,2012
    VSR_VOLKSWAGEN_TUAN_3 = 69,  //大众-途安-2006,2005,2004
    VSR_VOLKSWAGEN_TUAN_1 = 70,  //大众-途安-2010,2009,2008
    VSR_VOLKSWAGEN_TUAN_2 = 71,  //大众-途安-2013,2012,2011
    VSR_VOLKSWAGEN_TUGUAN_1 = 72,  //大众-途观-2012,2011,2010
    VSR_VOLKSWAGEN_TURUI_1 = 73,  //大众-途锐-2006,2005,2003
    VSR_VOLKSWAGEN_TURUI_2 = 74,  //大众-途锐-2014,2013,2012,2011
    VSR_VOLKSWAGEN_SUTENG_1 = 75,  //大众-速腾-2010,2009,2007,2006
    VSR_VOLKSWAGEN_SUTENG_2 = 76,  //大众-速腾-2011
    VSR_VOLKSWAGEN_SUTENG_3 = 77,  //大众-速腾-2014,2013,2012
    VSR_VOLKSWAGEN_GAOERFU_1 = 78,  //大众-高尔夫-2008,2007,2006,2005,2004,2003
    VSR_VOLKSWAGEN_GAOERFU_2 = 79,  //大众-高尔夫-2012,2011进口,2012,2011,2010
    VSR_VOLKSWAGEN_GAOERFU_3 = 80,  //大众-高尔夫GTI-2013,2012,2011,2010
    VSR_VOLKSWAGEN_LANGYI_3 = 81,  //大众-朗逸-2014
    VSR_VOLKSWAGEN_HUITENG_1 = 82  //大众-辉腾-2004
  );

//别克子品牌类型
type
  VBR_BUICK_CLASS =  
  (  
    VBR_BUICK_OTHER = 0,  // 其他（保留）
    VBR_BUICK_ENCORE = 1,  // 昂科拉
    VBR_BUICK_GL8 = 2,  // GL8
    VBR_BUICK_LEGAL = 3,  // 君威
    VBR_BUICK_LACROSS = 4,  // 君越
    VBR_BUICK_EXCELLE = 5,  // 凯越
    VBR_BUICK_EXCELLEGT = 6,  // 英朗GT
    VBR_BUICK_WXCELLEXT = 7,  // 英朗XT
    VBR_BUICK_ENCLAVE = 8,  // 昂科雷
    VBR_BUICK_ROYAUM = 9,  // 荣御
    VBR_BUICK_SAIL = 10,  // 别克赛欧
    VBR_BUICK_EXCELLEHRV = 11,  // 凯越HRV
    VBR_BUICK_PARKAVENUE = 12,  // 林荫大道
    VBR_BUICK_CENTURY = 13,  // 新世纪
    VBR_BUICK_GL8_1 = 14,  // 别克-GL8-2004,2003
    VBR_BUICK_GL8_2 = 15,  // 别克-GL8-2007,2006,2005
    VBR_BUICK_GL8_3 = 16,  // 别克-GL8-2010_2008_2006_2005陆尊
    VBR_BUICK_GL8_4 = 17,  // 别克-GL8-2014,2013,2012,2011
    VBR_BUICK_GL8_5 = 18,  // 别克-GL8-2014_2013_2011豪华版
    VBR_BUICK_ENCORE_1 = 19,  // 别克-昂科拉-2014,2013
    VBR_BUICK_ENCLAVE_1 = 20,  // 别克-昂科雷-2013,2010,2009
    VBR_BUICK_LEGAL_1 = 21,  // 别克-君威-2001,2000,1999
    VBR_BUICK_LEGAL_2 = 22,  // 别克-君威-2008,2006,2005,2004,2002
    VBR_BUICK_LEGAL_3 = 23,  // 别克-君威-2013,2012,2011,2010,2009
    VBR_BUICK_LEGAL_4 = 24,  // 别克-君威-2013_2012_2011运动版
    VBR_BUICK_LEGAL_5 = 25,  // 别克-君威-2014
    VBR_BUICK_LEGAL_6 = 26,  // 别克-君威-2014运动版
    VBR_BUICK_LACROSS_1 = 27,  // 别克-君越-2008,2007,2006
    VBR_BUICK_LACROSS_2 = 28,  // 别克-君越-2012,2011,2010,2009
    VBR_BUICK_LACROSS_3 = 29,  // 别克-君越-2013
    VBR_BUICK_EXCELLE_1 = 30,  // 别克-凯越-2006,2005,2004
    VBR_BUICK_EXCELLE_2 = 31,  // 别克-凯越-2008_2006_2005_2004HRV
    VBR_BUICK_EXCELLE_3 = 32,  // 别克-凯越-2011,2009,2008
    VBR_BUICK_EXCELLE_4 = 33,  // 别克-凯越-2013
    VBR_BUICK_PARKAVENUE_1 = 34,  // 别克-林荫大道-2011,2010,2009,2008,2007
    VBR_BUICK_SAIL_1 = 35,  // 别克-赛欧-2004,2003
    VBR_BUICK_EXCELLEGT_1 = 36,  // 别克-英朗GT-2013,2012,2011,2010
    VBR_BUICK_WXCELLEXT_1 = 37,  // 别克-英朗XT-2014,2013,2012,2010
    VBR_BUICK_CENTURY_1 = 38,  // 别克-新世纪-2000
    VBR_BUICK_RONGYU_1 = 39  // 别克-荣御-2005,2004
  );

//宝马子品牌类型
type
  VSB_BMW_CLASS =  
  (  
    VSB_BMW_OTHER = 0,  // 其他（保留）
    VSB_BMW_3SERIES = 1,  // 宝马3系
    VSB_BMW_5SERIES = 2,  // 宝马5系
    VSB_BMW_X1 = 3,  // 宝马X1
    VSB_BMW_1SERIES = 4,  // 宝马1系
    VSB_BMW_7SERIES = 5,  // 宝马7系
    VSB_BMW_X3 = 6,  // 宝马X3
    VSB_BMW_X5 = 7,  // 宝马X5
    VSB_BMW_X6 = 8,  // 宝马X6
    VSB_BMW_Z4 = 9,  // 宝马Z4
    VSB_BMW_MINI = 10,  // 迷你
    VSB_BMW_6SERIES = 11,  //宝马6系
    VSB_BMW_YIXI_1 = 12,  // 宝马-1系-2011,2010,2008,2007
    VSB_BMW_YIXI_2 = 13,  // 宝马-1系-2013,2012
    VSB_BMW_SANXI_1 = 14,  // 宝马-3系-2004
    VSB_BMW_SANXI_2 = 15,  // 宝马-3系-2007,2005
    VSB_BMW_SANXI_3 = 16,  // 宝马-3系-2012,2011,2010,2009
    VSB_BMW_SANXI_4 = 17,  // 宝马-3系-2014,2013
    VSB_BMW_WUXI_1 = 18,  // 宝马-5系-2010,2009,2008
    VSB_BMW_WUXI_2 = 19,  // 宝马-5系-2013,2012,2011
    VSB_BMW_LIUXI_1 = 20,  // 宝马-6系-未知
    VSB_BMW_QIXI_1 = 21,  // 宝马-7系-2011,2010,2009
    VSB_BMW_QIXI_2 = 22,  // 宝马-7系-2013
    VSB_BMW_X1_1 = 23,  // 宝马-X1-2012,2010
    VSB_BMW_X1_2 = 24,  // 宝马-X1-2014,2013
    VSB_BMW_X3_1 = 25,  // 宝马-X3-2009,2008,2006
    VSB_BMW_X3_2 = 26,  // 宝马-X3-2013,2012,2011
    VSB_BMW_X5_1 = 27,  // 宝马-X5-2010,2009,2008
    VSB_BMW_X5_2 = 28,  // 宝马-X5-2013,2012,2011
    VSB_BMW_X5_3 = 29,  // 宝马-X5-2013运动型
    VSB_BMW_X6_1 = 30,  // 宝马-X6-2013,2012,2011,2009,2008
    VSB_BMW_Z4_1 = 31  // 宝马-Z4-2004
  );

//本田子品牌类型
type
  VSB_HONDA_CLASS =  
  (  
    VSB_HONDA_OTHER = 0,  // 其他（保留）
    VSB_HONDA_CRV = 1,  // 本田CR-V(思威)
    VSB_HONDA_JADE = 2,  // 杰德
    VSB_HONDA_CIVIC = 3,  // 思域
    VSB_HONDA_SPIRIOR = 4,  // 思铂睿
    VSB_HONDA_CIIMO = 5,  // 思铭
    VSB_HONDA_ELYSION = 6,  // 艾力绅
    VSB_HONDA_OBYSSEY = 7,  // 奥赛德
    VSB_HONDA_FIT = 8,  // 飞度
    VSB_HONDA_NEWCITY = 9,  // 锋范
    VSB_HONDA_CROSSTOUR = 10,  // 歌诗图
    VSB_HONDA_CRIDER = 11,  // 凌派
    VSB_HONDA_ACCORD = 12,  // 雅阁
    VSB_HONDA_CITY = 13,  // 思迪
    VSB_HONDA_ANTILOCK = 14,  // 阿柯德
    VSB_HONDA_CRZ = 15,  // 本田CR-Z
    VSB_HONDA_CRV_1 = 16,  // 本田-CR-V-2004
    VSB_HONDA_CRV_2 = 17,  // 本田-CR-V-2005
    VSB_HONDA_CRV_3 = 18,  // 本田-CR-V-2008,2007
    VSB_HONDA_CRV_4 = 19,  // 本田-CR-V-2010
    VSB_HONDA_CRV_5 = 20,  // 本田-CR-V-2013,2012
    VSB_HONDA_CRIDER_1 = 21,  // 本田-凌派-2014,2013
    VSB_HONDA_OBYSSEY_1 = 22,  // 本田-奥德赛-2002
    VSB_HONDA_OBYSSEY_2 = 23,  // 本田-奥德赛-2006,2005,2004
    VSB_HONDA_OBYSSEY_3 = 24,  // 本田-奥德赛-2008,2007
    VSB_HONDA_OBYSSEY_4 = 25,  // 本田-奥德赛-2011豪华版
    VSB_HONDA_CIVIC_1 = 26,  // 本田-思域-2007
    VSB_HONDA_CIVIC_5 = 27,  // 本田-思域-1996
    VSB_HONDA_CIVIC_2 = 28,  // 本田-思域-2008,2006
    VSB_HONDA_CIVIC_3 = 29,  // 本田-思域-2009
    VSB_HONDA_CIVIC_4 = 30,  // 本田-思域-2013,2012,2011
    VSB_HONDA_CITY_1 = 31,  // 本田-思迪-2008,2007,2006
    VSB_HONDA_SPIRIOR_1 = 32,  // 本田-思铂睿-2009
    VSB_HONDA_SIMING_1 = 33,  // 本田-思铭-2012
    VSB_HONDA_JIEDE_1 = 34,  // 本田-杰德-2013
    VSB_HONDA_CROSSTOUR_1 = 35,  // 本田-歌诗图-2013,2012,2010
    VSB_HONDA_AILISHEN_1 = 36,  // 本田-艾力绅-2012
    VSB_HONDA_NEWCITY_1 = 37,  // 本田-锋范-2009
    VSB_HONDA_NEWCITY_2 = 38,  // 本田-锋范-2011
    VSB_HONDA_NEWCITY_3 = 39,  // 本田-锋范-2014,2012
    VSB_HONDA_ACCORD_1 = 40,  // 本田-雅阁-1996
    VSB_HONDA_ACCORD_2 = 41,  // 本田-雅阁-1999
    VSB_HONDA_ACCORD_3 = 42,  // 本田-雅阁-2001
    VSB_HONDA_ACCORD_4 = 43,  // 本田-雅阁-2003
    VSB_HONDA_ACCORD_5 = 44,  // 本田-雅阁-2008
    VSB_HONDA_ACCORD_6 = 45,  // 本田-雅阁-2010
    VSB_HONDA_ACCORD_7 = 46,  // 本田-雅阁-2011
    VSB_HONDA_ACCORD_8 = 47,  // 本田-雅阁-2012
    VSB_HONDA_ACCORD_9 = 48,  // 本田-雅阁-2013
    VSB_HONDA_ACCORD_10 = 49,  // 本田-雅阁-2014
    VSB_HONDA_FIT_1 = 50,  // 本田-飞度-2004
    VSB_HONDA_FIT_2 = 51,  // 本田-飞度-2004三厢
    VSB_HONDA_FIT_3 = 52,  // 本田-飞度-2005
    VSB_HONDA_FIT_4 = 53,  // 本田-飞度-2007
    VSB_HONDA_FIT_5 = 54,  // 本田-飞度-2008
    VSB_HONDA_FIT_6 = 55  // 本田-飞度-2013,2011
  );

//标致子品牌类型
type
  VSB_PEUGEOT_CLASS =  
  (  
    VSB_PEUGEOT_OTHER = 0,  // 其他（保留）
    VSB_PEUGEOT_2008 = 1,  // 标致2008
    VSB_PEUGEOT_207 = 2,  // 标致207
    VSB_PEUGEOT_SENNA = 3,  // 赛纳
    VSB_PEUGEOT_3008 = 4,  // 标致3008
    VSB_PEUGEOT_301 = 5,  // 标致301
    VSB_PEUGEOT_307 = 6,  // 标致307
    VSB_PEUGEOT_308 = 7,  // 标致308
    VSB_PEUGEOT_408 = 8,  // 标致408
    VSB_PEUGEOT_508 = 9,  // 标致508
    VSB_PEUGEOT_206 = 10,  // 标致206
    VSB_PEUGEOT_407 = 11,  // 标致407
    VSB_PEUGEOT_206_1 = 12,  // 标致-206-未知
    VSB_PEUGEOT_207_1 = 13,  // 标致-207两厢-2011,2010,2009
    VSB_PEUGEOT_207_2 = 14,  // 标致-207两厢-2013
    VSB_PEUGEOT_3008_1 = 15,  // 标致-3008-2014,2013
    VSB_PEUGEOT_301_1 = 16,  // 标致-301-未知
    VSB_PEUGEOT_307_1 = 17,  // 标致-307三厢-2007,2006,2005,2004
    VSB_PEUGEOT_307_2 = 18,  // 标致-307三厢-2010,2009,2008
    VSB_PEUGEOT_307_3 = 19,  // 标致-307两厢-2013_2012_2011CROSS
    VSB_PEUGEOT_308_1 = 20,  // 标致-308-2014,2013,2012
    VSB_PEUGEOT_407_1 = 21,  // 标致-407-未知
    VSB_PEUGEOT_408_1 = 22,  // 标致-408-2012,2011,2010
    VSB_PEUGEOT_408_2 = 23,  // 标致-408-2013
    VSB_PEUGEOT_508_1 = 24,  // 标致-508-2014,2013,2012,2011
    VSB_PEUGEOT_207_3 = 25,  // 标致-207三厢-2011,2010,2009
    VSB_PEUGEOT_307_4 = 26  // 标致-307两厢-2013,2012,2010,2009,2008

  );

//丰田子品牌类型
type
  VSB_TOYOTA_CLASS =  
  (  
    VSB_TOYOTA_OTHER = 0,  // 其他（保留）
    VSB_TOYOTA_HIGHLANDER = 1,  // 汉兰达
    VSB_TOYOTA_CAMRY = 2,  // 凯美瑞
    VSB_TOYOTA_YARIS = 3,  // 雅力士
    VSB_TOYOTA_YARISL = 4,  // YARIS L致炫
    VSB_TOYOTA_VERSO = 5,  // 逸致
    VSB_TOYOTA_HUAGUAN = 6,  // 花冠
    VSB_TOYOTA_CROWN = 7,  // 皇冠
    VSB_TOYOTA_COROLLA = 8,  // 卡罗拉
    VSB_TOYOTA_COSTER = 9,  // 柯斯达
    VSB_TOYOTA_PRADO = 10,  // 普拉多
    VSB_TOYOTA_PRIUS = 11,  // 普锐斯
    VSB_TOYOTA_RAV4 = 12,  // 丰田RAV4
    VSB_TOYOTA_REZI = 13,  // 锐志
    VSB_TOYOTA_VIOS = 14,  // 威驰
    VSB_TOYOTA_PREVIA = 15,  // 普瑞维亚
    VSB_TOYOTA_HIACE = 16,  // 海狮
    VSB_TOYOTA_86 = 17,  // 丰田86
    VSB_TOYOTA_SPEQUOIA = 18,  // 红杉
    VSB_TOYOTA_LANDCRUISER = 19,  // 陆地巡洋舰(兰德酷路泽)
    VSB_TOYOTA_SIENNA = 20,  // 赛纳
    VSB_TOYOTA_CAMRYHYBRID = 21,  // 凯美瑞-HYBRID
    VSB_TOYOTA_GRACE = 22,  // 阁瑞斯
    VSB_TOYOTA_ALPHARD = 23,  // 埃尔法
    VSB_TOYOTA_RAV4_1 = 24,  // 丰田-RAV4-2012手动经典版,2011,2010,2009
    VSB_TOYOTA_RAV4_2 = 25,  // 丰田-RAV4-2013
    VSB_TOYOTA_86_1 = 26,  // 丰田-丰田86-未知
    VSB_TOYOTA_JIAMEI_2 = 27,  // 丰田-佳美-2001,2000,1999,1998
    VSB_TOYOTA_JIAMEI_3 = 28,  // 丰田-佳美-2004,2003,2002
    VSB_TOYOTA_LANDEKLZ_1 = 29,  // 丰田-兰德酷路泽-2011中东版,2010,2007
    VSB_TOYOTA_KAIMEIRUI_1 = 30,  // 丰田-凯美瑞-2008,2007,2006
    VSB_TOYOTA_KAIMEIRUI_2 = 31,  // 丰田-凯美瑞-2012尊瑞
    VSB_TOYOTA_KAIMEIRUI_3 = 32,  // 丰田-凯美瑞-2012经典版,2011,2010,2009
    VSB_TOYOTA_KAIMEIRUI_4 = 33,  // 丰田-凯美瑞-2013,2012
    VSB_TOYOTA_KAIMEIRUI_5 = 34,  // 丰田-凯美瑞-2013经典版
    VSB_TOYOTA_KAIMEIRUI_6 = 35,  // 丰田-凯美瑞-2014,2012骏瑞
    VSB_TOYOTA_KALUOLA_1 = 36,  // 丰田-卡罗拉-2010,2009,2008,2007,2006
    VSB_TOYOTA_KALUOLA_2 = 37,  // 丰田-卡罗拉-2013,2012,2011
    VSB_TOYOTA_AIERFA_1 = 38,  // 丰田-埃尔法-2011,2010
    VSB_TOYOTA_AIERFA_2 = 39,  // 丰田-埃尔法-2013,2012
    VSB_TOYOTA_WEICHI_1 = 40,  // 丰田-威驰-2004,2003
    VSB_TOYOTA_WEICHI_2 = 41,  // 丰田-威驰-2007,2006,2005
    VSB_TOYOTA_WEICHI_3 = 42,  // 丰田-威驰-2009,2008
    VSB_TOYOTA_WEICHI_4 = 43,  // 丰田-威驰-2013,2012,2011,2010
    VSB_TOYOTA_WEICHI_5 = 44,  // 丰田-威驰-2014
    VSB_TOYOTA_PULADUO_1 = 45,  // 丰田-普拉多-2007,2006,2005,2004
    VSB_TOYOTA_PULADUO_2 = 46,  // 丰田-普拉多-2010
    VSB_TOYOTA_PULADUO_3 = 47,  // 丰田-普拉多-2014
    VSB_TOYOTA_PURUIWEIYA_1 = 48,  // 丰田-普瑞维亚-2004
    VSB_TOYOTA_PURUIWEIYA_4 = 49,  // 丰田-普瑞维亚-2005
    VSB_TOYOTA_PURUIWEIYA_2 = 50,  // 丰田-普瑞维亚-2006
    VSB_TOYOTA_PURUIWEIYA_3 = 51,  // 丰田-普瑞维亚-2012,2010,2008,2007
    VSB_TOYOTA_KESIDA_1 = 52,  // 丰田-柯斯达-2007
    VSB_TOYOTA_KESIDA_2 = 53,  // 丰田-柯斯达-2011
    VSB_TOYOTA_HANLANDA_1 = 54,  // 丰田-汉兰达-2011,2009
    VSB_TOYOTA_HANLANDA_2 = 55,  // 丰田-汉兰达-2012
    VSB_TOYOTA_HANLANDA_3 = 56,  // 丰田-汉兰达-2013
    VSB_TOYOTA_HAISHI_1 = 57,  // 丰田-海狮-2001
    VSB_TOYOTA_HUANGGUAN_1 = 58,  // 丰田-皇冠-1999
    VSB_TOYOTA_HUANGGUAN_2 = 59,  // 丰田-皇冠-2009,2008,2007,2006,2005
    VSB_TOYOTA_HUANGGUAN_3 = 60,  // 丰田-皇冠-2010
    VSB_TOYOTA_HUANGGUAN_4 = 61,  // 丰田-皇冠-2012,2011
    VSB_TOYOTA_HONGSHAN_1 = 62,  // 丰田-红杉-未知
    VSB_TOYOTA_HUAGUAN_1 = 63,  // 丰田-花冠-2006,2005,2004
    VSB_TOYOTA_HUAGUAN_2 = 64,  // 丰田-花冠-2009,2008,2007
    VSB_TOYOTA_HUAGUAN_3 = 65,  // 丰田-花冠-2011,2010
    VSB_TOYOTA_YIZHI_1 = 66,  // 丰田-逸致-2014,2012,2011
    VSB_TOYOTA_RUIZHI_1 = 67,  // 丰田-锐志-2006,2005
    VSB_TOYOTA_RUIZHI_2 = 68,  // 丰田-锐志-2009,2008,2007
    VSB_TOYOTA_RUIZHI_3 = 69,  // 丰田-锐志-2010风度版
    VSB_TOYOTA_RUIZHI_4 = 70,  // 丰田-锐志-2012,2010
    VSB_TOYOTA_LUDIXUNYANG_1 = 71,  // 丰田-陆地巡洋舰-未知
    VSB_TOYOTA_YALISHI_1 = 72,  // 丰田-雅力士-2009,2008,2007
    VSB_TOYOTA_YALISHI_2 = 73,  // 丰田-雅力士-2012,2011,2010
    VSB_TOYOTA_RAV4_3 = 74,  // 丰田-RAV4-2013经典,精英,尊崇,2012
    VSB_TOYOTA_YARiSL_1 = 75,  // 丰田-YARiS-L
    VSB_TOYOTA_JIAMEI_1 = 76,  // 丰田-佳美-1996
    VSB_TOYOTA_PLATZ_1 = 77,  // 丰田-PLATZ-1999
    VSB_TOYOTA_LANDEKLZ_2 = 78  // 丰田-兰德酷路泽-2014,2012中东版,2012
  );

//福特子品牌类型
type
  VSB_FORD_CLASS =  
  (  
    VSB_FORD_OTHER = 0,  // 其他（保留）
    VSB_FORD_FOCUS = 1,  // 福克斯
    VSB_FORD_FIESTA = 2,  // 嘉年华
    VSB_FORD_SMAX = 3,  // 麦柯斯
    VSB_FORD_MONDEO = 4,  // 蒙迪欧
    VSB_FORD_ECOSPORT = 5,  // 翼博
    VSB_FORD_ESCAPE = 6,  // 翼虎
    VSB_FORD_ZHISHENG = 7,  // 致胜
    VSB_FORD_ESCORT = 8,  // 福睿斯
    VSB_FORD_EXPLORER = 9,  // 福特探险者
    VSB_FORD_EDGE = 10,  // 锐界
    VSB_FORD_TRANSIT = 11,  // 全顺
    VSB_FORD_QUANSHUN_1 = 12,  // 福特-全顺-未知
    VSB_FORD_JIANIANHUA_1 = 13,  // 福特-嘉年华三厢-2006,2005,2004
    VSB_FORD_JIANIANHUA_2 = 14,  // 福特-嘉年华三厢-2011,2010,2009
    VSB_FORD_JIANIANHUA_3 = 15,  // 福特-嘉年华三厢-2013
    VSB_FORD_JIANIANHUA_4 = 16,  // 福特-嘉年华两厢-2012
    VSB_FORD_TANXIANZHE_1 = 17,  // 福特-探险者-2013,2011
    VSB_FORD_FOCUS_1 = 18,  // 福特-福克斯三厢-2005
    VSB_FORD_FOCUS_2 = 19,  // 福特-福克斯三厢-2005经典型
    VSB_FORD_FOCUS_3 = 20,  // 福特-福克斯三厢-2008,2007,2006
    VSB_FORD_FOCUS_4 = 21,  // 福特-福克斯三厢-2013,2012经典,2011,2009
    VSB_FORD_FOCUS_5 = 22,  // 福特-福克斯两厢-2012
    VSB_FORD_FOCUS_6 = 23,  // 福特-福克斯两厢-2012基本,时尚,2011,2010,2009,2008
    VSB_FORD_YIBO_1 = 24,  // 福特-翼博-2013
    VSB_FORD_YIHU_1 = 25,  // 福特-翼虎-2013
    VSB_FORD_MENGDIOU_1 = 26,  // 福特-蒙迪欧-2003
    VSB_FORD_MENGDIOU_2 = 27,  // 福特-蒙迪欧-2005,2004
    VSB_FORD_MENGDIOU_3 = 28,  // 福特-蒙迪欧-2006
    VSB_FORD_MENGDIOU_4 = 29,  // 福特-蒙迪欧-2013
    VSB_FORD_MENGDIOU_5 = 30,  // 福特-蒙迪欧-致胜-2010,2008,2007
    VSB_FORD_MENGDIOU_6 = 31,  // 福特-蒙迪欧-致胜-2011
    VSB_FORD_RUIJIE_1 = 32,  // 福特-锐界-2012,2011
    VSB_FORD_MAIKESI_1 = 33  // 福特-麦柯斯-2008,2007
  );

//日产子品牌类型
type
  VSB_NISSAN_CLASS =  
  (  
    VSB_NISSAN_OTHER = 0,  // 其他（保留）
    VSB_NISSAN_XTRAIL = 1,  // 奇骏
    VSB_NISSAN_MURANO = 2,  // 楼兰
    VSB_NISSAN_LIVINA = 3,  // 骊威
    VSB_NISSAN_MARCH = 4,  // 玛驰
    VSB_NISSAN_TIIDA = 5,  // 骐达
    VSB_NISSAN_TEANA = 6,  // 天籁
    VSB_NISSAN_QASHQAI = 7,  // 逍客
    VSB_NISSAN_SYLPHY = 8,  // 轩逸
    VSB_NISSAN_SUNNY = 9,  // 阳光
    VSB_NISSAN_D22PICKUP = 10,  // D22皮卡
    VSB_NISSAN_D22VAN = 11,  // D22厢式车
    VSB_NISSAN_CABSTAR = 12,  // 凯普斯达
    VSB_NISSAN_HV200 = 13,  // NV200
    VSB_NISSAN_PALADIN = 14,  // 帕拉丁
    VSB_NISSAN_YIDA = 15,  // 颐达
    VSB_NISSAN_DUCK = 16,  // 公爵
    VSB_NISSAN_CEFIRO = 17,  // 风度
    VSB_NISSAN_FENGSHENBLUEBIRD = 18,  // 风神蓝鸟
    VSB_NISSAN_FENGSHENSUNNY = 19,  // 风神阳光
    VSB_NISSAN_SUCCE = 20,  // 帅客
    VSB_NISSAN_FUGA = 21,  // 风雅
    VSB_NISSAN_BLUEBIRD4 = 22,  // 蓝鸟4代
    VSB_NISSAN_VENUCIA = 23,  // 启辰
    VSB_NISSAN_QUEST = 24,  // 贵士
    VSB_NISSAN_GENISS = 25,  // 俊逸
    VSB_NISSAN_NV200_1 = 26,  // 日产-NV200-2013,2012,2011,2010
    VSB_NISSAN_TIANLAI_1 = 27,  // 日产-天籁-2005,2004
    VSB_NISSAN_TIANLAI_2 = 28,  // 日产-天籁-2007,2006
    VSB_NISSAN_TIANLAI_3 = 29,  // 日产-天籁-2010,2008
    VSB_NISSAN_TIANLAI_4 = 30,  // 日产-天籁-2012,2011
    VSB_NISSAN_TIANLAI_5 = 31,  // 日产-天籁-2012云安全版,2011公爵
    VSB_NISSAN_TIANLAI_6 = 32,  // 日产-天籁-2014,2013
    VSB_NISSAN_QIJUN_1 = 33,  // 日产-奇骏-2010,2008
    VSB_NISSAN_QIJUN_2 = 34,  // 日产-奇骏-2012,2011进口
    VSB_NISSAN_PALADING_1 = 35,  // 日产-帕拉丁-2013,2011,2006,2004
    VSB_NISSAN_LOULAN_1 = 36,  // 日产-楼兰-2013,2011
    VSB_NISSAN_LOULAN_2 = 37,  // 日产-玛驰-2010
    VSB_NISSAN_LANNIAO_1 = 38,  // 日产-蓝鸟-2002
    VSB_NISSAN_LANNIAO_2 = 39,  // 日产-蓝鸟-2003
    VSB_NISSAN_LANNIAO_3 = 40,  // 日产-蓝鸟-2004
    VSB_NISSAN_GUISHI_1 = 41,  // 日产-贵士-2005
    VSB_NISSAN_XUANYI_1 = 42,  // 日产-轩逸-2006
    VSB_NISSAN_XUANYI_2 = 43,  // 日产-轩逸-2012经典,2009,2007
    VSB_NISSAN_XUANYI_3 = 44,  // 日产-轩逸-2014,2012
    VSB_NISSAN_XIAOKE_1 = 45,  // 日产-逍客-2009,2008
    VSB_NISSAN_XIAOKE_2 = 46,  // 日产-逍客-2013,2012,2011
    VSB_NISSAN_SUNNY_3 = 47,  // 日产-阳光-2004
    VSB_NISSAN_SUNNY_1 = 48,  // 日产-阳光-2006,2005
    VSB_NISSAN_SUNNY_2 = 49,  // 日产-阳光-2012,2011
    VSB_NISSAN_YIDA_1 = 50,  // 日产-颐达-2008,2006,2005
    VSB_NISSAN_YIDA_2 = 51,  // 日产-颐达-未知
    VSB_NISSAN_FENGDU_1 = 52,  // 日产-风度-未知
    VSB_NISSAN_FENGYA_1 = 53,  // 日产-风雅-未知
    VSB_NISSAN_LIWEI_1 = 54,  // 日产-骊威-2008,2007
    VSB_NISSAN_LIWEI_2 = 55,  // 日产-骊威-2009
    VSB_NISSAN_LIWEI_3 = 56,  // 日产-骊威-2010
    VSB_NISSAN_LIWEI_4 = 57,  // 日产-骊威-2011,2010劲锐,2008炫能型
    VSB_NISSAN_JUNYI_1 = 58,  // 日产-骏逸-2006
    VSB_NISSAN_QIDA_1 = 59,  // 日产-骐达-2006,2005
    VSB_NISSAN_QIDA_2 = 60,  // 日产-骐达-2009,2008
    VSB_NISSAN_QIDA_3 = 61,  // 日产-骐达-2013,2012,2011
    VSB_NISSAN_RUIQI_1 = 62  // 日产-锐骐皮卡-2009豪华型
  );

//奥迪子品牌类型
type
  VSB_AUDI_CLASS =  
  (  
    VSB_AUDI_OTHER = 0,  // 其他（保留）
    VSB_AUDI_A3 = 1,  // 奥迪A3
    VSB_AUDI_A4L = 2,  // 奥迪A4L
    VSB_AUDI_A6L = 3,  // 奥迪A6L
    VSB_AUDI_Q3 = 4,  // 奥迪Q3
    VSB_AUDI_Q5 = 5,  // 奥迪Q5
    VSB_AUDI_A1 = 6,  // 奥迪A1
    VSB_AUDI_A4 = 7,  // 奥迪A4
    VSB_AUDI_A5 = 8,  // 奥迪A5
    VSB_AUDI_A6 = 9,  // 奥迪A6
    VSB_AUDI_A7 = 10,  // 奥迪A7
    VSB_AUDI_A8L = 11,  // 奥迪A8L
    VSB_AUDI_Q7 = 12,  // 奥迪Q7
    VSB_AUDI_S5 = 13,  // 奥迪S5
    VSB_AUDI_TT = 14,  // 奥迪TT
    VSB_AUDI_100 = 15,  // 奥迪100
    VSB_AUDI_200 = 16,  // 奥迪200
    VSB_AUDI_S7 = 17,  // 奥迪S7
    VSB_AUDI_S8 = 18,  // 奥迪S8
    VSB_AUDI_100_1 = 19,  // 奥迪-100-未知
    VSB_AUDI_200_1 = 20,  // 奥迪-200-未知
    VSB_AUDI_A1_1 = 21,  // 奥迪-A1-2014,2013,2012
    VSB_AUDI_A3_1 = 22,  // 奥迪-A3-2013,2010舒适版
    VSB_AUDI_A3_2 = 23,  // 奥迪-A3-2013技术型,2011,2010
    VSB_AUDI_A4_1 = 24,  // 奥迪-A4-2005国产,2000进口版
    VSB_AUDI_A4_2 = 25,  // 奥迪-A4-2007,2006国产,2004进口
    VSB_AUDI_A4L_1 = 26,  // 奥迪-A4L-2013
    VSB_AUDI_A5_1 = 27,  // 奥迪-A5-2011,2010
    VSB_AUDI_A6_1 = 28,  // 奥迪-A6-1996,1995,1991
    VSB_AUDI_A6L_1 = 29,  // 奥迪-A6L-2008,2007,2006,2005
    VSB_AUDI_A6L_2 = 30,  // 奥迪-A6L-2011,2010,2009
    VSB_AUDI_A6L_3 = 31,  // 奥迪-A6L-2014,2013,2012
    VSB_AUDI_A7_1 = 32,  // 奥迪-A7-2014,2013进取型,2012,2011
    VSB_AUDI_A8L_1 = 33,  // 奥迪-A8L-2006
    VSB_AUDI_A8L_2 = 34,  // 奥迪-A8L-2009,2008
    VSB_AUDI_A8L_3 = 35,  // 奥迪-A8L-2011
    VSB_AUDI_A8L_4 = 36,  // 奥迪-A8L-2013,2012
    VSB_AUDI_Q3_1 = 37,  // 奥迪-Q3-2014,2013,2012
    VSB_AUDI_Q5_1 = 38,  // 奥迪-Q5-2012,2010运动
    VSB_AUDI_Q5_2 = 39,  // 奥迪-Q5-2012豪华型,2010越野版
    VSB_AUDI_Q5_3 = 40,  // 奥迪-Q5-2012进取型,2011,2010,2009
    VSB_AUDI_Q5_4 = 41,  // 奥迪-Q5-2013
    VSB_AUDI_Q7_1 = 42,  // 奥迪-Q7-2007
    VSB_AUDI_Q7_2 = 43,  // 奥迪-Q7-2014,2013
    VSB_AUDI_S7_1 = 44,  // 奥迪-S7-2013
    VSB_AUDI_S8_1 = 45,  // 奥迪-S8-2013
    VSB_AUDI_TT_2 = 46,  // 奥迪-TT-2010,2008,2007
    VSB_AUDI_TT_3 = 47,  // 奥迪-TT-2012,2011
    VSB_AUDI_TT_4 = 48,  // 奥迪-TT-2013,2013,2011TTS
    VSB_AUDI_TT_1 = 49  // 奥迪-TT-2008TTS
  );

//马自达子品牌类型
type
  VSB_MAZDA_CLASS =  
  (  
    VSB_MAZDA_OTHER = 0,  // 其他（保留）
    VSB_MAZDA_CX5 = 1,  // 马自达CX5
    VSB_MAZDA_2 = 2,  // 马自达2
    VSB_MAZDA_3 = 3,  // 马自达3
    VSB_MAZDA_6 = 4,  // 马自达6
    VSB_MAZDA_8 = 5,  // 马自达8
    VSB_MAZDA_COREWING = 6,  // 睿翼
    VSB_MAZDA_CX7 = 7,  // 马自达CX7
    VSB_MAZDA_X5 = 8,  // 马自达X5
    VSB_MAZDA_5 = 9,  // 马自达5
    VSB_MAZDA_PREMACY = 10,  // 老款普力马
    VSB_MAZDA_MPV = 11,  // 马自达MPV
    VSB_MAZDA_CX5_1 = 12,  // 马自达-CX-5-2014,2013,2012进口
    VSB_MAZDA_CX7_1 = 13,  // 马自达-CX-7-2014,2013,2011,2010
    VSB_MAZDA_2_1 = 14,  // 马自达-Mazda2两厢-2011,2009,2008,2007A
    VSB_MAZDA_3_1 = 15,  // 马自达-Mazda3三厢-2004,2002
    VSB_MAZDA_3_2 = 16,  // 马自达-Mazda3三厢-2009,2007
    VSB_MAZDA_3_3 = 17,  // 马自达-Mazda3三厢-2012,2010
    VSB_MAZDA_3_4 = 18,  // 马自达-Mazda3星骋两厢-2013,2012
    VSB_MAZDA_5_1 = 19,  // 马自达-Mazda5-2010,2008,2007
    VSB_MAZDA_5_2 = 20,  // 马自达-Mazda5-2013,2012,2011
    VSB_MAZDA_6_2 = 21,  // 马自达-Mazda6-2006
    VSB_MAZDA_6_3 = 22,  // 马自达-Mazda6-2007
    VSB_MAZDA_8_1 = 23,  // 马自达-Mazda8-2013,2011,2010
    VSB_MAZDA_PREMACY_1 = 24,  // 马自达-普力马-2003
    VSB_MAZDA_PREMACY_2 = 25,  // 马自达-普力马-2006,2005,2004
    VSB_MAZDA_COREWING_1 = 26,  // 马自达-睿翼-2012,2011,2010,2009
    VSB_MAZDA_COREWING_2 = 27,  // 马自达-睿翼轿跑-2011,2010
    VSB_MAZDA_COREWING_3 = 28,  // 马自达-睿翼轿跑-2012
    VSB_MAZDA_2_2 = 29,  // 马自达-Mazda2劲翔(三厢)-2011,2010,2008
    VSB_MAZDA_6_1 = 30,  // 马自达-Mazda6-2004
    VSB_MAZDA_6_4 = 31  // 马自达-Mazda6-2014,2013,2012,2011,2010
  );

//雪佛兰子品牌类型
type
  VSB_CHEVROLET_CLASS =  
  (  
    VSB_CHEVROLET_OTHER = 0,  // 其他（保留）
    VSB_CHEVROLET_NEWAVEO = 1,  // 爱唯欧
    VSB_CHEVROLET_EPICA = 2,  // 景程
    VSB_CHEVROLET_CRUZE = 3,  // 科鲁兹
    VSB_CHEVROLET_CAPTIVA = 4,  // 科帕奇
    VSB_CHEVROLET_MALIBU = 5,  // 迈锐宝
    VSB_CHEVROLET_SAIL = 6,  // 赛欧
    VSB_CHEVROLET_CAMARO = 7,  // 科迈罗
    VSB_CHEVROLET_LECHENG = 8,  // 乐成
    VSB_CHEVROLET_LOVA = 9,  // 乐风
    VSB_CHEVROLET_OLDAVEO = 10,  // 乐骋-老款爱唯欧
    VSB_CHEVROLET_SPARK = 11,  // 乐驰
    VSB_CHEVROLET_SAILSRV = 12,  // 赛欧SRV
    VSB_CHEVROLET_LOVA_1 = 13,  // 雪佛兰-乐风-2009,2008,2007,2006
    VSB_CHEVROLET_LOVA_2 = 14,  // 雪佛兰-乐风-2010
    VSB_CHEVROLET_SPARK_1 = 15,  // 雪佛兰-乐驰-2010,2009,2006,2005,2004
    VSB_CHEVROLET_SPARK_2 = 16,  // 雪佛兰-乐驰-2010运动款
    VSB_CHEVROLET_OLDAVEO_1 = 17,  // 雪佛兰-乐骋-2005
    VSB_CHEVROLET_OLDAVEO_2 = 18,  // 雪佛兰-乐骋-2010,2009,2008
    VSB_CHEVROLET_EPICA_1 = 19,  // 雪佛兰-景程-2005
    VSB_CHEVROLET_EPICA_3 = 20,  // 雪佛兰-景程-2012,2011,2010
    VSB_CHEVROLET_EPICA_4 = 21,  // 雪佛兰-景程-2012,2011,2010致真版
    VSB_CHEVROLET_EPICA_5 = 22,  // 雪佛兰-景程-2013
    VSB_CHEVROLET_NEWAVEO_1 = 23,  // 雪佛兰-爱唯欧三厢-2013,2012,2011
    VSB_CHEVROLET_CAPTIVA_1 = 24,  // 雪佛兰-科帕奇-2010,2008
    VSB_CHEVROLET_CAPTIVA_2 = 25,  // 雪佛兰-科帕奇-2014,2013,2012,2011
    VSB_CHEVROLET_KEMAILUO_1 = 26,  // 雪佛兰-科迈罗-2012,2011
    VSB_CHEVROLET_CRUZE_1 = 27,  // 雪佛兰-科鲁兹-2014,2013,2012,2011,2010,2009
    VSB_CHEVROLET_SAIL_1 = 28,  // 雪佛兰-赛欧三厢-2005
    VSB_CHEVROLET_SAIL_2 = 29,  // 雪佛兰-赛欧三厢-2013,2011,2010
    VSB_CHEVROLET_MALIBU_1 = 30,  // 雪佛兰-迈锐宝-2014,2013,2012
    VSB_CHEVROLET_EPICA_2 = 31  // 雪佛兰-景程-2009,2008,2007
  );

//雪铁龙子品牌类型
type
  VSB_CITROEN_CLASS =  
  (  
    VSB_CITROEN_OTHER = 0,  // 其他（保留）
    VSB_CITROEN_C2 = 1,  // 雪铁龙C2
    VSB_CITROEN_C4L = 2,  // 雪铁龙C4L
    VSB_CITROEN_C5 = 3,  // 雪铁龙C5
    VSB_CITROEN_ELYSEE = 4,  // 爱丽舍三厢
    VSB_CITROEN_CQUATRELIANGXIANG = 5,  // 世嘉两厢
    VSB_CITROEN_CQUATRESANXIANG = 6,  // 世嘉三厢
    VSB_CITROEN_SAEAPICASSO = 7,  // 萨拉-毕加索
    VSB_CITROEN_PICASSO = 8,  // 毕加索
    VSB_CITROEN_CTRIOMPHE = 9,  // 凯旋
    VSB_CITROEN_XSARA = 10,  // 塞纳
    VSB_CITROEN_SHENLONGFUKANG = 11,  // 神龙富康
    VSB_CITROEN_CHANGANDS = 12,  // 长安DS
    VSB_CITROEN_C2_1 = 13,  // 雪铁龙-C2-2012,2010,2008,2007,2006
    VSB_CITROEN_C4L_1 = 14,  // 雪铁龙-C4L-2014,2013
    VSB_CITROEN_C4PICASSO_1 = 15,  // 雪铁龙-C4毕加索-2009舒适版
    VSB_CITROEN_C5_1 = 16,  // 雪铁龙-C5-2012,2011,2010
    VSB_CITROEN_CQUATRESANXIANG_1 = 17,  // 雪铁龙-世嘉三厢-2013,2012
    VSB_CITROEN_CQUATRELIANGXIANG_1 = 18,  // 雪铁龙-世嘉两厢-2011,2010,2009,2008
    VSB_CITROEN_CTRIOMPHE_1 = 19,  // 雪铁龙-凯旋-2010,2009,2008,2006
    VSB_CITROEN_FUKANG_1 = 20,  // 雪铁龙-富康-2006,2005,2004,2003,2002
    VSB_CITROEN_ELYSEE_1 = 21,  // 雪铁龙-爱丽舍三厢-2006,2005,2004,2003,2002
    VSB_CITROEN_ELYSEE_2 = 22,  // 雪铁龙-爱丽舍三厢-2013,2012,2011,2010,2009,2008,2007
    VSB_CITROEN_SAEAPICASSO_1 = 23  // 雪铁龙-萨拉-毕加索-2014
  );

//现代子品牌类型
type
  VSB_HYUNDAI_CLASS =  
  (  
    VSB_HYUNDAI_OTHER = 0,  // 其他（保留）
    VSB_HYUNDAI_IX35 = 1,  // 现代IX35
    VSB_HYUNDAI_LANGDONG = 2,  // 朗动
    VSB_HYUNDAI_MOINCA = 3,  // 名驭
    VSB_HYUNDAI_SHENGDA = 4,  // 胜达
    VSB_HYUNDAI_VERNA = 5,  // 瑞纳
    VSB_HYUNDAI_RUIYI = 6,  // 瑞奕
    VSB_HYUNDAI_SONATAEIGHT = 7,  // 索纳塔八
    VSB_HYUNDAI_TUCSON = 8,  // 途胜
    VSB_HYUNDAI_YUEDONG = 9,  // 悦动
    VSB_HYUNDAI_ELANTRA = 10,  // 伊兰特
    VSB_HYUNDAI_GRANDSANTAFE = 11,  // 格锐
    VSB_HYUNDAI_COUPE = 12,  // 酷派
    VSB_HYUNDAI_MATRIX = 13,  // 美佳
    VSB_HYUNDAI_ACCENT = 14,  // 雅绅特
    VSB_HYUNDAI_IX30 = 15,  // 现代IX30
    VSB_HYUNDAI_SONATA = 16,  // 索纳塔
    VSB_HYUNDAI_REFINE = 17,  // 现代瑞风商务车
    VSB_HYUNDAI_MISTRA = 18,  // 名图
    VSB_HYUNDAI_SONATAYUFENG = 19,  // 索纳塔-御翔
    VSB_HYUNDAI_SANTAFE = 20,  // 现代圣达菲
    VSB_HYUNDAI_HUIYI = 21,  // 进口辉翼
    VSB_HYUNDAI_I30_1 = 22,  // 现代-i30-2010,2009
    VSB_HYUNDAI_IX35_1 = 23,  // 现代-ix35-2012,2011,2010
    VSB_HYUNDAI_YILANTE_1 = 24,  // 现代-伊兰特-2006,2005,2004
    VSB_HYUNDAI_YILANTE_2 = 25,  // 现代-伊兰特-2007三厢
    VSB_HYUNDAI_YILANTE_3 = 26,  // 现代-伊兰特-2011
    VSB_HYUNDAI_SHENGDA_1 = 27,  // 现代-全新胜达-2013,2012
    VSB_HYUNDAI_MINGTU_1 = 28,  // 现代-名图-2014,2013
    VSB_HYUNDAI_MINGYU_1 = 29,  // 现代-名驭-2013,2011,2009
    VSB_HYUNDAI_SHENGDAFEI_1 = 30,  // 现代-圣达菲-未知
    VSB_HYUNDAI_YUXIANG_1 = 31,  // 现代-御翔-2005舒适版
    VSB_HYUNDAI_YUXIANG_2 = 32,  // 现代-御翔-2006,2005
    VSB_HYUNDAI_YUEDONG_1 = 33,  // 现代-悦动-2010,2009,2008
    VSB_HYUNDAI_YUEDONG_2 = 34,  // 现代-悦动-2012,2011
    VSB_HYUNDAI_SHENGDA_2 = 35,  // 现代-新胜达-2009,2006
    VSB_HYUNDAI_SHENGDA_3 = 36,  // 现代-新胜达-2012,2011,2010
    VSB_HYUNDAI_LANGDONG_1 = 37,  // 现代-朗动-2013,2012
    VSB_HYUNDAI_GERUI_1 = 38,  // 现代-格锐-未知
    VSB_HYUNDAI_RUIYI_1 = 39,  // 现代-瑞奕-2014
    VSB_HYUNDAI_RUINA_1 = 40,  // 现代-瑞纳三厢-2013,2010
    VSB_HYUNDAI_RUINA_2 = 41,  // 现代-瑞纳两厢-2014,2013,2011
    VSB_HYUNDAI_RUIFENG_1 = 42,  // 现代-瑞风-未知
    VSB_HYUNDAI_SUONATA_1 = 43,  // 现代-索纳塔-2008,2007,2006,2004,2003标准型
    VSB_HYUNDAI_SUONATA_2 = 44,  // 现代-索纳塔-2010,2009,2008,2006,2004
    VSB_HYUNDAI_SOUNATA_3 = 45,  // 现代-索纳塔八-2011,2010
    VSB_HYUNDAI_WEILAKESI_1 = 46,  // 现代-维拉克斯-2012,2010,2008,2007
    VSB_HYUNDAI_MEIJIA_1 = 47,  // 现代-美佳-未知
    VSB_HYUNDAI_JINKOUHUIYI_1 = 48,  // 现代-进口辉翼-未知
    VSB_HYUNDAI_TUSHENG_1 = 49,  // 现代-途胜-2005
    VSB_HYUNDAI_TUSHENG_2 = 50,  // 现代-途胜-2011,2009,2008,2006
    VSB_HYUNDAI_TUSHENG_3 = 51,  // 现代-途胜-2013
    VSB_HYUNDAI_KUPAI_1 = 52,  // 现代-酷派-未知
    VSB_HYUNDAI_YASHENTE_1 = 53,  // 现代-雅绅特-2008,2006
    VSB_HYUNDAI_YASHENTE_2 = 54,  // 现代-雅绅特-2011
    VSB_HYUNDAI_LINGXIANG_1 = 55,  // 现代-领翔-2009,2008
    VSB_HYUNDAI_FEISI_1 = 56  // 现代-飞思-2011
  );

//奇瑞子品牌类型
type
  VSB_CHERY_CLASS =  
  (  
    VSB_CHERY_OTHER = 0,  // 其他（保留）
    VSB_CHERY_A1 = 1,  // 奇瑞A1
    VSB_CHERY_A3 = 2,  // 奇瑞A3
    VSB_CHERY_EASTAR = 3,  // 东方之子
    VSB_CHERY_FULWIN = 4,  // 风云
    VSB_CHERY_QQ = 5,  // 奇瑞QQ
    VSB_CHERY_E5 = 6,  // 奇瑞E5
    VSB_CHERY_COWIN = 7,  // 旗云
    VSB_CHERY_TIGGO = 8,  // 瑞虎
    VSB_CHERY_A5 = 9,  // 奇瑞A5
    VSB_CHERY_S16 = 10,  // 奇瑞S16
    VSB_CHERY_YOUYA = 11,  // 优雅
    VSB_CHERY_V5 = 12,  // 奇瑞V5
    VSB_CHERY_E3 = 13,  // 奇瑞E3
    VSB_CHERY_A1_1 = 14,  // 奇瑞-A1-2011,2008,2007
    VSB_CHERY_A3LIANGXIANG_1 = 15,  // 奇瑞-A3两厢-2012,2010,2009
    VSB_CHERY_A5_1 = 16,  // 奇瑞-A5-2009,2007,2006
    VSB_CHERY_QQ_1 = 17,  // 奇瑞-QQ-2006,2005,2004
    VSB_CHERY_QQ_2 = 18,  // 奇瑞-QQ-2010,2007,2006
    VSB_CHERY_QQ_3 = 19,  // 奇瑞-QQ-2012,2011,2010,2009,2007
    VSB_CHERY_QQ_4 = 20,  // 奇瑞-QQ-2012运动版
    VSB_CHERY_QQ_5 = 21,  // 奇瑞-QQ-2013
    VSB_CHERY_DONGFANGZHIZI_1 = 22,  // 奇瑞-东方之子-2005,2004,2003
    VSB_CHERY_DONGFANGZHIZI_2 = 23,  // 奇瑞-东方之子-2007,2006
    VSB_CHERY_DONGFANGZHIZI_3 = 24,  // 奇瑞-东方之子CROSS-2009,2008,2007
    VSB_CHERY_YOUYA_1 = 25,  // 奇瑞-优雅-未知
    VSB_CHERY_E3_1 = 26,  // 奇瑞-奇瑞E3-2013
    VSB_CHERY_E5_1 = 27,  // 奇瑞-奇瑞E5-2014,2012,2011
    VSB_CHERY_QIYUN1_1 = 28,  // 奇瑞-旗云1-2010
    VSB_CHERY_QIYUN1_2 = 29,  // 奇瑞-旗云1-2012
    VSB_CHERY_QIYUN_1 = 30,  // 奇瑞-旗云-2004
    VSB_CHERY_QIYUN_2 = 31,  // 奇瑞-旗云-2009,2008,2007,2006
    VSB_CHERY_QIYUN2_1 = 32,  // 奇瑞-旗云2-2012
    VSB_CHERY_QIYUN2_2 = 33,  // 奇瑞-旗云2-2012豪华型,2010
    VSB_CHERY_QIYUN3_1 = 34,  // 奇瑞-旗云3-2010
    VSB_CHERY_RUIHU_1 = 35,  // 奇瑞-瑞虎-2007,2006,2005
    VSB_CHERY_RUIHU_2 = 36,  // 奇瑞-瑞虎-2009,2007
    VSB_CHERY_RUIHU_3 = 37,  // 奇瑞-瑞虎-2012,2011
    VSB_CHERY_RUIHU_4 = 38,  // 奇瑞-瑞虎-2013,2012自动DVVT豪华型
    VSB_CHERY_RUIHU_5 = 39,  // 奇瑞-瑞虎-2013精英版豪华型,2012精英版舒适型
    VSB_CHERY_FENGYUN2SANXIANG_1 = 40,  // 奇瑞-风云2三厢-2010
    VSB_CHERY_AIRUIZE7_1 = 41  // 奇瑞-艾瑞泽7-2014,2013
  );

//起亚子品牌类型
type
  VSB_KIA_CLASS =  
  (  
    VSB_KIA_OTHER = 0,  // 其他（保留）
    VSB_KIA_K2 = 1,  // 起亚K2
    VSB_KIA_K3 = 2,  // 起亚K3
    VSB_KIA_K5 = 3,  // 起亚K5
    VSB_KIA_RIO = 4,  // 锐欧
    VSB_KIA_CERATO = 5,  // 赛拉图
    VSB_KIA_SPORTAGER = 6,  // 狮跑
    VSB_KIA_SOUL = 7,  // 秀尔
    VSB_KIA_ZHIPAO = 8,  // 智跑
    VSB_KIA_CARENS = 9,  // 佳乐
    VSB_KIA_CARNIVAL = 10,  // 嘉华
    VSB_KIA_OPTIMA = 11,  // 远舰
    VSB_KIA_OPIRUS = 12,  // 欧菲莱斯
    VSB_KIA_MAXIMA = 13,  // 千里马
    VSB_KIA_FORTE = 14,  // 福瑞迪
    VSB_KIA_SORENTO = 15,  // 索兰托
    VSB_KIA_K2_1 = 16,  // 起亚-K2-2013,2012,2011
    VSB_KIA_K3_1 = 17,  // 起亚-K3-2012
    VSB_KIA_K5_1 = 18,  // 起亚-K5-2012,2011
    VSB_KIA_RUIOU_1 = 19,  // 起亚-RIO锐欧-2009,2007
    VSB_KIA_QIANLIMA_1 = 20,  // 起亚-千里马-2004
    VSB_KIA_QIANLIMA_2 = 21,  // 起亚-千里马-2006,2005
    VSB_KIA_JIAHUA_1 = 22,  // 起亚-嘉华-未知
    VSB_KIA_XINJIALE_1 = 23,  // 起亚-新佳乐-2011
    VSB_KIA_ZHIPAO_1 = 24,  // 起亚-智跑-2014,2012,2011,2010
    VSB_KIA_SHIPAO_1 = 25,  // 起亚-狮跑-2008,2007,2005
    VSB_KIA_SHIPAO_2 = 26,  // 起亚-狮跑-2011,2009
    VSB_KIA_SHIPAO_3 = 27,  // 起亚-狮跑-2012
    VSB_KIA_SHIPAO_4 = 28,  // 起亚-狮跑-2013
    VSB_KIA_FURUIDI_1 = 29,  // 起亚-福瑞迪-2012,2011,2009
    VSB_KIA_FURUIDI_2 = 30,  // 起亚-福瑞迪-2014
    VSB_KIA_XIUER_1 = 31,  // 起亚-秀尔-2012,2010
    VSB_KIA_SUOLANTUO_1 = 32,  // 起亚-索兰托-2006
    VSB_KIA_SUOLANTUO_2 = 33,  // 起亚-索兰托-2012,2010,2009
    VSB_KIA_SAILATU_1 = 34,  // 起亚-赛拉图-2006,2005
    VSB_KIA_SAILATU_2 = 35,  // 起亚-赛拉图-2007
    VSB_KIA_SAILATU_3 = 36,  // 起亚-赛拉图-2012,2010GLS
    VSB_KIA_YUANJIAN_1 = 37  // 起亚-远舰-未知
  );

//奔驰子品牌类型
type
  VSB_BENZ_CLASS =  
  (  
    VSB_BENZ_OTHER = 0,  // 其他（保留）
    VSB_BENZ_C = 1,  // 奔驰C级
    VSB_BENZ_E = 2,  // 奔驰E级
    VSB_BENZ_GLK = 3,  // 奔驰GLK级
    VSB_BENZ_WEITING = 4,  // 威霆-PINYIN
    VSB_BENZ_SPRINTER = 5,  // 凌特
    VSB_BENZ_VIANO = 6,  // 唯雅诺
    VSB_BENZ_M = 7,  // 奔驰M系
    VSB_BENZ_CLK = 8,  // 奔驰CLK系
    VSB_BENZ_G = 9,  // 奔驰G系
    VSB_BENZ_GL = 10,  // 奔驰GL系
    VSB_BENZ_R = 11,  // 奔驰R系
    VSB_BENZ_S = 12,  // 奔驰S系
    VSB_BENZ_A = 13,  // 奔驰A系
    VSB_BENZ_SMART = 14,  // 斯玛特(精灵)
    VSB_BENZ_B = 15,  // 奔驰B系
    VSB_BENZ_SLK = 16,  // 奔驰SLK系
    VSB_BENZ_MB100 = 17,  // 奔驰MB100
    VSB_BENZ_VITO = 18,  // 威特
    VSB_BENZ_CLS = 19,  // 奔驰CLS系
    VSB_BENZ_SL = 20,  // 奔驰SL系
    VSB_BENZ_AJI_1 = 21,  // 奔驰-A级-2011,2009
    VSB_BENZ_AJI_2 = 22,  // 奔驰-A级-2013
    VSB_BENZ_BJI_1 = 23,  // 奔驰-B级-2010,2009
    VSB_BENZ_CJI_1 = 24,  // 奔驰-C级-2010,2008,2007时尚型
    VSB_BENZ_CJI_2 = 25,  // 奔驰-C级-2013,2011,CGI
    VSB_BENZ_CJI_3 = 26,  // 奔驰-C级-2013,2011时尚型
    VSB_BENZ_EJI_1 = 27,  // 奔驰-E级-2002
    VSB_BENZ_EJI_2 = 28,  // 奔驰-E级-2007,2006
    VSB_BENZ_EJI_3 = 29,  // 奔驰-E级-2013,2012,2011,2010,2009
    VSB_BENZ_EJI_4 = 30,  // 奔驰-E级-2013,2012,2011,2010,2009时尚型
    VSB_BENZ_GLKJI_1 = 31,  // 奔驰-GLK级-2012,2011
    VSB_BENZ_GLKJI_2 = 32,  // 奔驰-GLK级-2012,2011豪华型,2008
    VSB_BENZ_GLKJI_3 = 33,  // 奔驰-GLK级-2014,2013
    VSB_BENZ_GLJI_1 = 34,  // 奔驰-GL级-2011
    VSB_BENZ_GLJI_2 = 35,  // 奔驰-GL级-2011尊贵型,2010
    VSB_BENZ_GLJI_3 = 36,  // 奔驰-GL级-2012,2010北美版
    VSB_BENZ_GJI_1 = 37,  // 奔驰-G级-2013,2010,2009
    VSB_BENZ_MB100_1 = 38,  // 奔驰-MB100-2000
    VSB_BENZ_MLJI_1 = 39,  // 奔驰-ML级-2006,2005
    VSB_BENZ_MLJI_2 = 40,  // 奔驰-ML级-2010,2008
    VSB_BENZ_MLJI_3 = 41,  // 奔驰-ML级-2014,2012
    VSB_BENZ_RJI_1 = 42,  // 奔驰-R级-2006
    VSB_BENZ_RJI_2 = 43,  // 奔驰-R级-2007
    VSB_BENZ_RJI_3 = 44,  // 奔驰-R级-2014,2011,2010,2009
    VSB_BENZ_SLKJI_2 = 45,  // 奔驰-SLK级-2006,2004
    VSB_BENZ_SLKJI_3 = 46,  // 奔驰-SLK级-2010,2009
    VSB_BENZ_SLKJI_1 = 47,  // 奔驰-SLK级-2011
    VSB_BENZ_SJI_1 = 48,  // 奔驰-S级-2004
    VSB_BENZ_SJI_2 = 49,  // 奔驰-S级-2009_Hybrid,2008,2006
    VSB_BENZ_SJI_3 = 50,  // 奔驰-S级-2009,2008商务型
    VSB_BENZ_SJI_4 = 51,  // 奔驰-S级-2012,2011,2010
    VSB_BENZ_LINGTE_1 = 52,  // 奔驰-凌特-2013,2012,2011
    VSB_BENZ_WEIYANUO_1 = 53,  // 奔驰-唯雅诺-2010,2006,2004
    VSB_BENZ_WEIYANUO_2 = 54,  // 奔驰-唯雅诺-2014,2013,2012,2011
    VSB_BENZ_WEITING_1 = 55,  // 奔驰-威霆-2013,2011,2010
    VSB_BENZ_KECHE_1 = 56  // 奔驰-客车车型1-A款
  );

//斯柯达子品牌类型
type
  VSB_SKODA_CLASS =  
  (  
    VSB_SKODA_OTHER = 0,  // 其他（保留）
    VSB_SKODA_HAORUI = 1,  // 昊锐
    VSB_SKODA_FABIA = 2,  // 晶锐
    VSB_SKODA_OCTAVIA = 3,  // 明锐
    VSB_SKODA_SUPERB = 4,  // 速派
    VSB_SKODA_SPACEBACK = 5,  // 昕动
    VSB_SKODA_RAPID = 6,  // 昕锐
    VSB_SKODA_YETI = 7,  // 野帝
    VSB_SKODA_HAORUI_1 = 8,  // 斯柯达-昊锐-2013,2012,2010,2009
    VSB_SKODA_MINGRUI_1 = 9,  // 斯柯达-明锐-2009,2008,2007
    VSB_SKODA_MINGRUI_2 = 10,  // 斯柯达-明锐-2014,2013,2012,2011,2010
    VSB_SKODA_MINGRUI_3 = 11,  // 斯柯达-明锐RS-2010
    VSB_SKODA_XINRUI_1 = 12,  // 斯柯达-昕锐-2013乐选型
    VSB_SKODA_JINGRUI_1 = 13,  // 斯柯达-晶锐-2011,2009,2008
    VSB_SKODA_JINGRUI_2 = 14,  // 斯柯达-晶锐-2014,2013,2012
    VSB_SKODA_JINGRUI_3 = 15,  // 斯柯达-晶锐-2014,2013,2012Sport版
    VSB_SKODA_SUPAI_1 = 16,  // 斯柯达-速派-2013
    VSB_SKODA_YEDI_1 = 17  // 斯柯达-野帝-2014,2013
  );

//东风子品牌类型
type
  VSB_DONGFENG_CLASS =  
  (  
    VSB_DONGFENG_OTHER = 0,  // 其他（保留）
    VSB_DONGFENG_JOYEARX5 = 1,  // 景逸X5
    VSB_DONGFENG_LINGZHI = 2,  // 菱智
    VSB_DONGFENG_JOYEARX3 = 3,  // 景逸X3
    VSB_DONGFENG_JOYEAR = 4,  // 景逸
    VSB_DONGFENG_FENGXINGCM7 = 5,  // 风行CM7
    VSB_DONGFENG_YUFENG = 6,  // 御风
    VSB_DONGFENG_FENGSHENA60 = 7,  // 风神A60
    VSB_DONGFENG_FENGSHENS30 = 8,  // 风神S30
    VSB_DONGFENG_FENGSHENH30CROSS = 9,  // 风神H30-CROSS
    VSB_DONGFENG_PICKUP = 10,  // 东风皮卡
    VSB_DONGFENG_ZHONGXINGMIANBAOCHE = 11,  // 东风中型面包车
    VSB_DONGFENG_XIAOXINGMIANBAOCHE = 12,  // 东风小型面包车
    VSB_DONGFENG_ZHONGXINGVAN = 13,  // 东风重型货车
    VSB_DONGFENG_QINGXINGXIANGSHIVAN = 14,  // 东风轻型厢式货车
    VSB_DONGFENG_QINGZHONGXINGVAN = 15,  // 东风轻中型普通货车
    VSB_DONGFENG_FENGSHENMERCURY = 16,  // 风神水星
    VSB_DONGFENG_SUCCE = 17,  // 帅客
    VSB_DONGFENG_ODIN = 18,  // 奥丁
    VSB_DONGFENG_YUMSUN = 19,  // 御轩
    VSB_DONGFENG_RUIQI = 20,  // 锐骐
    VSB_DONGFENG_FENGGUANG = 21,  // 风光
    VBR_DONGFENG_C35_1 = 22,  // 东风-C35-2013
    VBR_DONGFENG_K07_1 = 23,  // 东风-K07-2008
    VBR_DONGFENG_K07_2 = 24,  // 东风-K07-2010,2006
    VBR_DONGFENG_V21_1 = 25,  // 东风-V21-2011
    VBR_DONGFENG_JIALONG_1 = 26,  // 东风-东风嘉龙-载货车
    VBR_DONGFENG_XKFG_1 = 27,  // 东风-东风小康风光-2013
    VBR_DONGFENG_CV03_1 = 28,  // 东风-俊风CV03-2012
    VBR_DONGFENG_KAIPUTE_1 = 29,  // 东风-凯普特-C390
    VBR_DONGFENG_DUOLIKA_1 = 30,  // 东风-多利卡-S2800
    VBR_DONGFENG_DUOLIKA_2 = 31,  // 东风-多利卡-XL中卡
    VBR_DONGFENG_DUOLIKA_3 = 32,  // 东风-多利卡-中卡
    VBR_DONGFENG_TIANJIN_1 = 33,  // 东风-天锦-4X2载货车
    VBR_DONGFENG_TIANJIN_2 = 34,  // 东风-天锦-A款
    VBR_DONGFENG_XBW_1 = 35,  // 东风-小霸王-轻卡1
    VBR_DONGFENG_XBW_2 = 36,  // 东风-小霸王-轻卡2
    VBR_DONGFENG_MENGKA_1 = 37,  // 东风-梦卡-轻卡
    VBR_DONGFENG_FURUIKA_1 = 38,  // 东风-福瑞卡-轻卡1
    VBR_DONGFENG_RUIQI_1 = 39,  // 东风-锐骐皮卡-2013,2010,2009
    VBR_DONGFENG_A60_1 = 40,  // 东风风神-A60-2014,2012
    VBR_DONGFENG_H30_1 = 41,  // 东风风神-H30-Cross-2012,2011
    VBR_DONGFENG_H30_2 = 42,  // 东风风神-H30-Cross-2014,2013
    VBR_DONGFENG_H30_3 = 43,  // 东风风神-H30-2012
    VBR_DONGFENG_JINGYI_1 = 44,  // 东风风行-景逸-2014_2012LV,2011豪华型
    VBR_DONGFENG_JINGYI_2 = 45,  // 东风风行-景逸-2014_2012XL,2011,2010,2009,2008,2007
    VBR_DONGFENG_JINGYI_3 = 46,  // 东风风行-景逸X5-2014,2013
    VBR_DONGFENG_LINGZHI_1 = 47,  // 东风风行-菱智-2004
    VBR_DONGFENG_LINGZHI_2 = 48,  // 东风风行-菱智-2011,2008,2007
    VBR_DONGFENG_LINGZHI_3 = 49,  // 东风风行-菱智-2011Q3标准型,2010Q7
    VBR_DONGFENG_LINGZHI_4 = 50,  // 东风风行-菱智-2014_2013M3
    VBR_DONGFENG_LINGZHI_5 = 51  // 东风风行-菱智-2014_2013V3,2011M3_商用版_舒适型
  );

//比亚迪子品牌类型
type
  VSB_BYD_CLASS =  
  (  
    VSB_BYD_OTHER = 0,  // 其他（保留）
    VSB_BYD_F0 = 1,  // 比亚迪F0
    VSB_BYD_F3 = 2,  // 比亚迪F3
    VSB_BYD_F3R = 3,  // 比亚迪F3R
    VSB_BYD_F6 = 4,  // 比亚迪F6
    VSB_BYD_G3 = 5,  // 比亚迪G3
    VSB_BYD_G3R = 6,  // 比亚迪G3R
    VSB_BYD_G6 = 7,  // 比亚迪G6
    VSB_BYD_L3 = 8,  // 比亚迪L3
    VSB_BYD_M6 = 9,  // 比亚迪M6
    VSB_BYD_S6 = 10,  // 比亚迪S6
    VSB_BYD_SURUI = 11,  // 速锐
    VSB_BYD_FOLEL = 12,  // 秦川福莱尔
    VSB_BYD_SIRUI = 13,  // 思锐
    VSB_BYD_MT5 = 14,  // 比亚迪MT5(精灵)
    VSB_BYD_F0_1 = 15,  // 比亚迪-F0-2013,2012,2011,2010,2009,2008
    VSB_BYD_F3R_1 = 16,  // 比亚迪-F3R-2011,2009,2008,2007
    VSB_BYD_F6_1 = 17,  // 比亚迪-F6-2011,2009,2008
    VSB_BYD_G3R_1 = 18,  // 比亚迪-G3R-2011
    VSB_BYD_G6_1 = 19,  // 比亚迪-G6-2013,2012,2011
    VSB_BYD_L3_1 = 20,  // 比亚迪-L3-2013,2012,2011,2010
    VSB_BYD_M6_1 = 21,  // 比亚迪-M6-2013,2011,2010
    VSB_BYD_S6_1 = 22,  // 比亚迪-S6-2014,2013,2012,2011
    VSB_BYD_FULAIER_1 = 23,  // 比亚迪-福莱尔-2005豪华型
    VSB_BYD_SURUI_1 = 24  // 比亚迪-速锐-2014,2013,2012
  );

//铃木子品牌类型
type
  VSB_SUZUKI_CLASS =  
  (  
    VSB_SUZUKI_OTHER = 0,  // 其他（保留）
    VSB_SUZUKI_ALTO = 1,  // 长安奥拓
    VSB_SUZUKI_SCROSS = 2,  // 锋驭
    VSB_SUZUKI_SWIFT = 3,  // 雨燕
    VSB_SUZUKI_SX4 = 4,  // 天语
    VSB_SUZUKI_LINGYANG = 5,  // 羚羊
    VSB_SUZUKI_BEIDOUXING = 6,  // 北斗星
    VSB_SUZUKI_LIANAA6 = 7,  // 利亚纳-A6
    VSB_SUZUKI_LANDY = 8,  // 浪迪
    VSB_SUZUKI_SPLASH = 9,  // 派喜
    VSB_SUZUKI_GRANDVITARA = 10,  // 超级维特拉
    VSB_SUZUKI_JIMNY = 11,  // 吉姆尼
    VSB_SUZUKI_KAZASHI = 12,  // 凯泽西
    VSB_SUZUKI_LIANA = 13,  // 利亚纳
    VSB_SUZUKI_LIANA_1 = 14,  // 铃木-利亚纳三厢-2012,2011,2010,2008,2007,2005
    VSB_SUZUKI_LIANA_2 = 15,  // 铃木-利亚纳两厢-2013,2012,2011
    VSB_SUZUKI_BEIDOUXING_1 = 16,  // 铃木-北斗星-2012,2011,2010,2009,2008,2007,2005,2004标准型
    VSB_SUZUKI_BEIDOUXING_2 = 17,  // 铃木-北斗星-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003
    VSB_SUZUKI_BEIDOUXING_3 = 18,  // 铃木-北斗星-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003适用型
    VSB_SUZUKI_BEIDOUXING_4 = 19,  // 铃木-北斗星-2013X5
    VSB_SUZUKI_JIMUNI_1 = 20,  // 铃木-吉姆尼-2011,2010,2009,2007
    VSB_SUZUKI_JIMUNI_2 = 21,  // 铃木-吉姆尼-2012
    VSB_SUZUKI_SX4_1 = 22,  // 铃木-天语SX4三厢-2008,2006
    VSB_SUZUKI_SX4_2 = 23,  // 铃木-天语SX4三厢-2010,2009
    VSB_SUZUKI_SX4_3 = 24,  // 铃木-天语SX4两厢-2011A,2009,2008,2007
    VSB_SUZUKI_SX4_4 = 25,  // 铃木-天语SX4两厢-2011B
    VSB_SUZUKI_SX4_5 = 26,  // 铃木-天语SX4尚悦-2013,2012,2011
    VSB_SUZUKI_ALTO_1 = 27,  // 铃木-奥拓-2006,2001,2000,1999,1993标准型
    VSB_SUZUKI_ALTO_2 = 28,  // 铃木-奥拓-2006,2004,2001,2000,1999,1993
    VSB_SUZUKI_ALTO_3 = 29,  // 铃木-奥拓-2013
    VSB_SUZUKI_ALTO_4 = 30,  // 铃木-奥拓-2014,2012,2011,2010,2009
    VSB_SUZUKI_SPLASH_1 = 31,  // 铃木-派喜-2013,2012,2011
    VSB_SUZUKI_LANDY_1 = 32,  // 铃木-浪迪-2011,2010,2007
    VSB_SUZUKI_LINGYANG_2 = 33,  // 铃木-羚羊-2006,2004,2003
    VSB_SUZUKI_LINGYANG_3 = 34,  // 铃木-羚羊-2009,2008,2007
    VSB_SUZUKI_LINGYANG_4 = 35,  // 铃木-羚羊-2011
    VSB_SUZUKI_LINGYANG_5 = 36,  // 铃木-羚羊-2012
    VSB_SUZUKI_GRANDVITARA_1 = 37,  // 铃木-超级维特拉-2011,2008,2007,2006
    VSB_SUZUKI_FENGYU_1 = 38,  // 铃木-锋驭-2014
    VSB_SUZUKI_SWIFT_1 = 39,  // 铃木-雨燕-2011_1.3L,2009,2008,2007,2005
    VSB_SUZUKI_SWIFT_2 = 40,  // 铃木-雨燕-2012,2011
    VSB_SUZUKI_KINGCHANG_1 = 41,  // 铃木-昌铃王-2004
    VSB_SUZUKI_LINGYANG_1 = 42  // 铃木-羚羊-2002
  );

//五菱子品牌类型
type
  VSB_SGMW_CLASS =  
  (  
    VSB_SGMW_OTHER = 0,  // 其他（保留）
    VSB_SGMW_HONGGUANG = 1,  // 五菱宏光
    VSB_SGMW_HONGGUANGS = 2,  // 五菱宏光S
    VSB_SGMW_ZHIGUANG = 3,  // 五菱之光
    VSB_SGMW_RONGGUANGS = 4,  // 五菱荣光S
    VSB_SGMW_RONGGUANG = 5,  // 五菱荣光
    VSB_SGMW_HONGTU = 6,  // 五菱鸿途
    VSB_SGMW_XINGWANG = 7,  // 五菱兴旺
    VSB_SGMW_YANGGUANG = 8,  // 五菱扬光
    VSB_SGMW_XIAOXUANFENG = 9,  // 五菱小旋风
    VSB_SGMW_WULINGZHIGUANG_1 = 10,  // 五菱-五菱之光-2010,2009立业
    VSB_SGMW_WULINGZHIGUANG_2 = 11,  // 五菱-五菱之光-2010短车身,基本型
    VSB_SGMW_WULINGZHIGUANG_3 = 12,  // 五菱-五菱之光-2010长车身,2008厢式,2007
    VSB_SGMW_XINGWANG_1 = 13,  // 五菱-兴旺面包车-2003
    VSB_SGMW_XINGWANG_2 = 14,  // 五菱-兴旺面包车-2009标准
    VSB_SGMW_XINGWANG_3 = 15,  // 五菱-兴旺面包车-2010,2009,2007,2006,2005,2004
    VSB_SGMW_HONNGUANG_1 = 16,  // 五菱-宏光-2013,2010
    VSB_SGMW_HONNGUANG_2 = 17,  // 五菱-宏光-2014,2013S
    VSB_SGMW_XIAOXUANFENG_1 = 18,  // 五菱-小旋风-2006
    VSB_SGMW_YANGGUANG_1 = 19,  // 五菱-扬光-2006,2005,2004
    VSB_SGMW_YANGGUANG_2 = 20,  // 五菱-扬光-2008,2007
    VSB_SGMW_YANGGUANG_3 = 21,  // 五菱-扬光-2009,2006,2005手动标准型
    VSB_SGMW_RONGGUANG_1 = 22,  // 五菱-荣光面包车-2012,2011,2008基本
    VSB_SGMW_RONGGUANG_2 = 23,  // 五菱-荣光面包车-2012,2011,2008标准
    VSB_SGMW_HONGTU_1 = 24  // 五菱-鸿途-2010,2009,2008,2007
  );

//长安子品牌类型
type
  VSB_CHANA_CLASS =  
  (  
    VSB_CHANA_OTHER = 0,  // 其他（保留）
    VSB_CHANA_HONOR = 1,  // 欧诺
    VSB_CHANA_XINGKA = 2,  // 长安星卡
    VSB_CHANA_ZHIXING = 3,  // 长安之星
    VSB_CHANA_PICKUP = 4,  // 长安神骐小卡(长安皮卡)
    VSB_CHANA_ZHIXING2 = 5,  // 长安之星2代
    VSB_CHANA_TAURUS = 6,  // 金牛星
    VSB_CHANA_XINGGUANG = 7,  // 长安星光
    VSB_CHANA_BENNI = 8,  // 奔奔
    VSB_CHANA_ALSVIN = 9,  // 悦翔
    VSB_CHANA_CX20 = 10,  // 长安CX20
    VSB_CHANA_CX30 = 11,  // 长安CX30
    VSB_CHANA_EADO = 12,  // 逸动
    VSB_CHANA_ZHIXINGS460 = 13,  // 长安之星S460
    VSB_CHANA_CM8 = 14,  // 长安CM8
    VSB_CHANA_XINBAO = 15,  // 新豹
    VSB_CHANA_XUNLONG = 16,  // 勋龙
    VSB_CHANA_YUNTONG = 17,  // 运通
    VSB_CHANA_LEIMENG = 18,  // 镭蒙
    VSB_CHANA_XINGYUN = 19,  // 长安星韵
    VSB_CHANA_OULIWEI = 20,  // 欧力威
    VSB_CHANA_EADOXT = 21,  // 致尚XT
    VSB_CHANA_XINGYUN_1 = 22,  // 长安商用-星韵-2004,2003,2000
    VSB_CHANA_OULIWEI_1 = 23,  // 长安商用-欧力威-2013
    VSB_CHANA_YUNTONG_1 = 24,  // 长安商用-运通-2004
    VSB_CHANA_TAURUS_1 = 25,  // 长安商用-金牛星-2013,2012,2011,2010
    VSB_CHANA_LEIMENG_1 = 26,  // 长安商用-镭蒙-2005,2003
    VSB_CHANA_ZHIXING_1 = 27,  // 长安商用-长安之星-2010,2009
    VSB_CHANA_ZHIXING_2 = 28,  // 长安商用-长安之星-2013
    VSB_CHANA_ZHIXING_3 = 29,  // 长安商用-长安之星2-2009,2008
    VSB_CHANA_ZHIXING_4 = 30,  // 长安商用-长安之星2-2012
    VSB_CHANA_ZHIXING_5 = 31,  // 长安商用-长安之星S460-2010,2009
    VSB_CHANA_ZHIXING_6 = 32,  // 长安商用-长安之星SC6350-2003
    VSB_CHANA_PICKUP_1 = 33,  // 长安商用-长安微货神骐-2013,2012
    VSB_CHANA_XINGGUANG_1 = 34,  // 长安商用-长安星光4500-2009,2007
    VSB_CHANA_XINGGUANG_2 = 35,  // 长安商用-长安星光4500-2012
    VSB_CHANA_HONOR_1 = 36  // 长安商用-长安欧诺-2014,2012
  );

//长安轿车子品牌类型
type
  VSB_EADO_CLASS =  
  (  
    VSB_EADO_OTHER = 0,  // 其他（保留）
    VSB_EADO_CS_1 = 1,  // 长安轿车-CS35-2014,2013,2012
    VSB_EADO_CX_1 = 2,  // 长安轿车-CX20-2011
    VSB_EADO_CX_2 = 3,  // 长安轿车-CX30两厢-2010
    VSB_EADO_BENBEN_1 = 4,  // 长安轿车-奔奔-2008,2007,2006
    VSB_EADO_BENBEN_2 = 5,  // 长安轿车-奔奔-2008经典型,2007运动型
    VSB_EADO_BENBEN_3 = 6,  // 长安轿车-奔奔-2010
    VSB_EADO_BENBEN_4 = 7,  // 长安轿车-奔奔MINI-2011,2010
    VSB_EADO_BENBEN_5 = 8,  // 长安轿车-奔奔MINI-2012
    VSB_EADO_YUEXIANG_1 = 9,  // 长安轿车-悦翔-2011,2010,2009
    VSB_EADO_YUEXIANG_2 = 10,  // 长安轿车-悦翔-2012
    VSB_EADO_YUEXIANG_3 = 11,  // 长安轿车-悦翔V3-2013,2012
    VSB_EADO_YUEXIANG_4 = 12,  // 长安轿车-悦翔V5-2012
    VSB_EADO_YIDONG_1 = 13  // 长安轿车-逸动-2014,2013,2012
  );

//金杯子品牌类型
type
  VSB_JINBEI_CLASS =  
  (  
    VSB_JINBEI_OTHER = 0,  // 其他（保留）
    VSB_JINBEI_GRACE = 1,  // 金杯阁瑞斯
    VSB_JINBEI_HIACE = 2,  // 金杯海狮
    VSB_JINBEI_HAIXING = 3,  // 海星
    VSB_JINBEI_BADAO = 4,  // 金杯霸道
    VSB_JINBEI_LINGQI = 5,  // 领骐
    VSB_JINBEI_JINQI = 6,  // 金骐
    VSB_JINBEI_LINGCHI = 7,  // 领驰
    VSB_JINBEI_QIYUN = 8,  // 骐运
    VSB_JINBEI_ZHISHANG_1 = 9,  // 金杯-智尚S30-2014,2013,2012
    VSB_JINBEI_HAIXING_1 = 10,  // 金杯-海星-2012
    VSB_JINBEI_HAIXING_2 = 11,  // 金杯-海星-2012A7特惠型,2011
    VSB_JINBEI_HIACE_1 = 12,  // 金杯-海狮-2008
    VSB_JINBEI_HIACE_2 = 13,  // 金杯-海狮-2013,2011,2010
    VSB_JINBEI_HIACE_3 = 14,  // 金杯-海狮-2013豪华型,2011汽油,2008标准型
    VSB_JINBEI_JINDIAN_1 = 15,  // 金杯-金典-2009
    VSB_JINBEI_GRACE_1 = 16,  // 金杯-阁瑞斯MPV-2011,2008,2007
    VSB_JINBEI_GRACE_2 = 17,  // 金杯-阁瑞斯MPV-2011御领豪华型,2010,2009,2007标准9座
    VSB_JINBEI_BADAO_1 = 18  // 金杯-霸道SUV-2011,2008

  );

//吉利子品牌类型
type
  VSB_GEELY_CLASS =  
  (  
    VSB_GEELY_OTHER = 0,  // 其他（保留）
    VSB_GEELY_EC7 = 1,  // 吉利帝豪EC7
    VSB_GEELY_EC8 = 2,  // 吉利帝豪EC8
    VSB_GEELY_SC3 = 3,  // 吉利SC3
    VSB_GEELY_SC5RV = 4,  // 吉利SC5-RV
    VSB_GEELY_SC6 = 5,  // 吉利SC6
    VSB_GEELY_JINGYING = 6,  // 金鹰
    VSB_GEELY_JINGGANG = 7,  // 金刚
    VSB_GEELY_SX7 = 8,  // 吉利SX7
    VSB_GEELY_HAOQING = 9,  // 豪情
    VSB_GEELY_MEIRI = 10,  // 美日
    VSB_GEELY_YINGLUNSC7 = 11,  // 英伦SC7
    VSB_GEELY_PANDA = 12,  // 熊猫
    VSB_GEELY_YUANJING = 13,  // 远景
    VSB_GEELY_ZIYOUJIAN = 14  // 自由舰
  );

//三菱子品牌类型
type
  VSB_MITSUBISHI_CLASS =  
  (  
    VSB_MITSUBISHI_OTHER = 0,  // 其他（保留）
    VSB_MITSUBISHI_GALANT = 1,  // 戈蓝
    VSB_MITSUBISHI_ZINGER = 2,  // 君阁
    VSB_MITSUBISHI_LANCER = 3,  // 蓝瑟
    VSB_MITSUBISHI_LANCEREX = 4,  // 翼神
    VSB_MITSUBISHI_PAJERO = 5,  // 帕杰罗
    VSB_MITSUBISHI_PAJEROSPORT = 6,  // 帕杰罗-劲畅
    VSB_MITSUBISHI_JINGXUANASX = 7,  // 劲炫ASX
    VSB_MITSUBISHI_GRANDIS = 8,  // 三菱格蓝迪
    VSB_MITSUBISHI_OUTLANDER = 9,  // 欧蓝德
    VSB_MITSUBISHI_QINXINGYUEYE = 10,  // 三菱轻型越野
    VSB_MITSUBISHI_GTO = 11,  // 三菱GTO
    VSB_MITSUBISHI_SOVERAN = 12,  // 三菱菱绅
    VSB_MITSUBISHI_LIONVEL = 13,  // 三菱菱悦
    VSB_MITSUBISHI_HAFEISIMBO = 14,  // 哈飞赛马
    VSB_MITSUBISHI_LANCEREX_1 = 15,  // 三菱-三菱翼神-2012,2011,2010
    VSB_MITSUBISHI_JINGXUAN_1 = 16,  // 三菱-劲炫-2012,2011
    VSB_MITSUBISHI_ZINGER_1 = 17,  // 三菱-君阁-2011,2009
    VSB_MITSUBISHI_PAJERO_1 = 18,  // 三菱-帕杰罗-2004国产
    VSB_MITSUBISHI_PAJERO_2 = 19,  // 三菱-帕杰罗-2004进口
    VSB_MITSUBISHI_PAJERO_3 = 20,  // 三菱-帕杰罗-2010进口
    VSB_MITSUBISHI_PAJEROSPORT_1 = 21,  // 三菱-帕杰罗劲畅-2011
    VSB_MITSUBISHI_GALANT_1 = 22,  // 三菱-戈蓝-2009
    VSB_MITSUBISHI_GALANDI_1 = 23,  // 三菱-格蓝迪-2007
    VSB_MITSUBISHI_GALANDI_2 = 24,  // 三菱-格蓝迪-2010
    VSB_MITSUBISHI_OUTLANDER_1 = 25,  // 三菱-欧蓝德-2012,2011,2010
    VSB_MITSUBISHI_OUTLANDER_2 = 26,  // 三菱-欧蓝德-2013
    VSB_MITSUBISHI_LINGYUE_1 = 27,  // 三菱-菱悦-未知
    VSB_MITSUBISHI_LANCER_1 = 28  // 三菱-蓝瑟-2010
  );

//雷克萨斯子品牌类型
type
  VSB_LEXUS_CLASS =  
  (  
    VSB_LEXUS_OTHER = 0,  // 其他（保留）
    VSB_LEXUS_ES = 1,  // 雷克萨斯ES
    VSB_LEXUS_CT = 2,  // 雷克萨斯CT
    VSB_LEXUS_RX = 3,  // 雷克萨斯RX
    VSB_LEXUS_IS = 4,  // 雷克萨斯IS
    VSB_LEXUS_LX = 5,  // 雷克萨斯LX
    VSB_LEXUS_GS = 6,  // 雷克萨斯GS
    VSB_LEXUS_GX = 7,  // 雷克萨斯GX
    VSB_LEXUS_LS = 8,  // 雷克萨斯LS
    VSB_LEXUS_CT_1 = 9,  // 雷克萨斯-CT-2013,2012,2011
    VSB_LEXUS_ES_1 = 10,  // 雷克萨斯-ES-1994
    VSB_LEXUS_ES_2 = 11,  // 雷克萨斯-ES-2010,2009,2006
    VSB_LEXUS_ES_3 = 12,  // 雷克萨斯-ES-2013,2012
    VSB_LEXUS_GS_1 = 13,  // 雷克萨斯-GS-2011,2010,2009,2008,2005
    VSB_LEXUS_GX_1 = 14,  // 雷克萨斯-GX-2012,2010
    VSB_LEXUS_IS_1 = 15,  // 雷克萨斯-IS-2011
    VSB_LEXUS_LS_1 = 16,  // 雷克萨斯-LS-1994
    VSB_LEXUS_LS_2 = 17,  // 雷克萨斯-LS-2005,2004
    VSB_LEXUS_LS_3 = 18,  // 雷克萨斯-LS-2009,2007,2006
    VSB_LEXUS_LX_1 = 19,  // 雷克萨斯-LX-2013,2012
    VSB_LEXUS_RX_1 = 20,  // 雷克萨斯-RX-2011,2010,2009
    VSB_LEXUS_RX_2 = 21,  // 雷克萨斯-RX-2013,2012
    VSB_LEXUS_RX_3 = 22  // 雷克萨斯-RX-2007
  );

//荣威子品牌类型
type
  VSB_ROEWE_CLASS =  
  (  
    VSB_ROEWE_OTHER = 0,  // 其他（保留）
    VSB_ROEWE_350 = 1,  // 荣威350
    VSB_ROEWE_550 = 2,  // 荣威550
    VSB_ROEWE_W5 = 3,  // 荣威W5
    VSB_ROEWE_950 = 4,  // 荣威950
    VSB_ROEWE_750 = 5,  // 荣威750
    VSB_ROEWE_350_1 = 6,  // 荣威-350-2011迅智版,2010
    VSB_ROEWE_350_2 = 7,  // 荣威-350-2014,2013,2012,2011
    VSB_ROEWE_550_1 = 8,  // 荣威-550-2012,2010,2009,2008
    VSB_ROEWE_750_1 = 9,  // 荣威-750-2009,2008,2007,2006
    VSB_ROEWE_750_2 = 10,  // 荣威-750-2012,2011
    VSB_ROEWE_950_1 = 11  // 荣威-950-2012
  );


//海马子品牌类型
type
  VSB_HAIMA_CLASS =  
  (  
    VSB_HAIMA_OTHER = 0,  // 其他（保留）
    VSB_HAIMA_PREMARIN = 1,  // 普力马
    VSB_HAIMA_S7 = 2,  // 海马S7
    VSB_HAIMA_PRINCE = 3,  // 海马王子
    VSB_HAIMA_CUPID = 4,  // 海马2-丘比特
    VSB_HAIMA_HATCHBACK = 5,  // 海马3-欢动
    VSB_HAIMA_KNIGHT = 6,  // 骑士
    VSB_HAIMA_HAPPIN = 7,  // 海福星
    VSB_HAIMA_FAMILY = 8,  // 福美来
    VSB_HAIMA_M3 = 9,  // 海马M3
    VSB_HAIMA_CUPID_1 = 10,  // 海马-丘比特-2012,2011,2010
    VSB_HAIMA_PREMARIN_1 = 11,  // 海马-普力马-2007
    VSB_HAIMA_PREMARIN_2 = 12,  // 海马-普力马-2012,2010
    VSB_HAIMA_HATCHBACK_1 = 13,  // 海马-欢动-2010,2009
    VSB_HAIMA_HAPPIN_1 = 14,  // 海马-海福星-2010,2009,2008,2007,2004
    VSB_HAIMA_HAPPIN_2 = 15,  // 海马-海福星-2012,2011
    VSB_HAIMA_M3_1 = 16,  // 海马-海马3-2010,2008,2007
    VSB_HAIMA_FAMILY_1 = 17,  // 海马-福美来-2007,2006
    VSB_HAIMA_FAMILY_2 = 18,  // 海马-福美来-2010,2009,2008
    VSB_HAIMA_FAMILY_3 = 19,  // 海马-福美来-2011
    VSB_HAIMA_FAMILY_4 = 20,  // 海马-福美来-2014,2013,2012
    VSB_HAIMA_KNIGHT_1 = 21,  // 海马-骑士-2013_2012A,2011,2010
    VSB_HAIMA_KNIGHT_2 = 22,  // 海马-骑士-2013_2012B
    VSB_HAIMA_NEWHONGDA_1 = 23,  // 海马商用车-新鸿达-2009
    VSB_HAIMA_NEWHONDGA_2 = 24,  // 海马商用车-新鸿达-2012
    VSB_HAIMA_PRINCE_1 = 25,  // 海马商用车-海马王子-2010
    VSB_HAIMA_RONGDA_1 = 26  // 海马商用车-荣达-2012

  );

//长城子品牌类型
type
  VSB_GREATWALL_CLASS =  
  (  
    VSB_GREATWALL_OTHER = 0,  // 其他（保留）
    VSB_GREATWALL_SING = 1,  // 赛影
    VSB_GREATWALL_SAIJUN = 2,  // 赛骏
    VSB_GREATWALL_HAVAL = 3,  // 哈弗
    VSB_GREATWALL_SAFE = 4,  // 赛弗
    VSB_GREATWALL_SAIKU = 5,  // 赛酷
    VSB_GREATWALL_SAILING = 6,  // 赛铃
    VSB_GREATWALL_KINGDEER = 7,  // 金迪尔
    VSB_GREATWALL_DEER = 8,  // 迪尔
    VSB_GREATWALL_WINGLE = 9,  // 风骏
    VSB_GREATWALL_COOLBEAR = 10,  // 酷熊
    VSB_GREATWALL_LINGAO = 11,  // 凌傲
    VSB_GREATWALL_CROSS = 12,  // 炫丽
    VSB_GREATWALL_GWPERI = 13,  // 精灵
    VSB_GREATWALL_COWRY = 14,  // 腾翼
    VSB_GREATWALL_M4 = 15,  // 长城M4
    VSB_GREATWALL_LINGAO_1 = 16,  // 长城-凌傲-2010
    VSB_GREATWALL_HAVAL_1 = 17,  // 长城-哈弗H3-2010,2009
    VSB_GREATWALL_HAVAL_2 = 18,  // 长城-哈弗H3-2012,2010,2009锐意版
    VSB_GREATWALL_HAVAL_3 = 19,  // 长城-哈弗H5-2012,2011,2010
    VSB_GREATWALL_HAVAL_4 = 20,  // 长城-哈弗H5-2012,2011,2010绿静豪华型
    VSB_GREATWALL_HAVAL_5 = 21,  // 长城-哈弗H5-2012舒适型
    VSB_GREATWALL_HAVAL_6 = 22,  // 长城-哈弗H5-2014,2013
    VSB_GREATWALL_HAVAL_8 = 23,  // 长城-哈弗H6-2014,2013升级版
    VSB_GREATWALL_HAVAL_9 = 24,  // 长城-哈弗M2-2010
    VSB_GREATWALL_HAVAL_10 = 25,  // 长城-哈弗M2-2013,2012
    VSB_GREATWALL_HAVAL_11 = 26,  // 长城-哈弗M4-2012
    VSB_GREATWALL_HAVAL_12 = 27,  // 长城-哈弗派-2011
    VSB_GREATWALL_CROSS_1 = 28,  // 长城-炫丽-2009,2008
    VSB_GREATWALL_CROSS_2 = 29,  // 长城-炫丽CROSS-2011,2009
    VSB_GREATWALL_JINGLING_1 = 30,  // 长城-精灵-未知
    VSB_GREATWALL_SING_1 = 31,  // 长城-赛影-2003
    VSB_GREATWALL_SAIKU_1 = 32,  // 长城-赛酷-2004
    VSB_GREATWALL_SAILING_1 = 33,  // 长城-赛铃-未知
    VSB_GREATWALL_DIER_1 = 34,  // 长城-迪尔-未知
    VSB_GREATWALL_COOLBEAR_1 = 35,  // 长城-酷熊-2010,2009
    VSB_GREATWALL_KINGDEER_1 = 36,  // 长城-金迪尔-2008,2007,2004,2003
    VSB_GREATWALL_GREATWALL_1 = 37,  // 长城-长城C20R-2013,2011
    VSB_GREATWALL_GREATWALL_2 = 38,  // 长城-长城C30-2010
    VSB_GREATWALL_GREATWALL_3 = 39,  // 长城-长城C30-2012
    VSB_GREATWALL_GREATWALL_4 = 40,  // 长城-长城C30-2013
    VSB_GREATWALL_GREATWALL_5 = 41,  // 长城-长城C50-2013,2012
    VSB_GREATWALL_GREATWALL_6 = 42,  // 长城-长城V80-2013,2012,2010,2009,2008
    VSB_GREATWALL_WINGLE_1 = 43,  // 长城-风骏3-2011,2010,2007,2006
    VSB_GREATWALL_WINGLE_2 = 44,  // 长城-风骏5-2014,2012,2011,2009
    VSB_GREATWALL_HAVAL_7 = 45  // 长城-哈弗H6-2013,2012,2011
  );

//道奇子品牌类型
type
  VSB_DS_CLASS =  
  (  
    VSB_DS_OTHER = 0,  // 其他（保留）
    VSB_DS_KUBO_1 = 1,  // 道奇-酷搏-2011,2010,2009,2008
    VSB_DS_KUWEI_1 = 2,  // 道奇-酷威-2011,2010,2009
    VSB_DS_KUWEI_2 = 3  // 道奇-酷威-2013
  );

//路虎子品牌类型
type
  VSB_LANDROVER_CLASS =  
  (  
    VSB_LANDROVER_OTHER = 0,  // 其他（保留）
    VSB_LANDROVER_FAXIAN_1 = 1,  // 路虎-发现-2005,2004
    VSB_LANDROVER_FAXIAN_2 = 2,  // 路虎-发现-2013,2011,2010
    VSB_LANDROVER_LANSHENG_1 = 3,  // 路虎-揽胜-2012,2011,2010
    VSB_LANDROVER_LANSHENG_2 = 4,  // 路虎-揽胜极光-2014,2013,2012,2011
    VSB_LANDROVER_LANSHENG_3 = 5,  // 路虎-揽胜运动版-2013,2012,2011,2010
    VSB_LANDROVER_LANSHENG_4 = 6,  // 路虎-揽胜运动版-2013驭红限量版
    VSB_LANDROVER_SXZ_1 = 7  // 路虎-神行者2代-2014,2013,2011
  );

//名爵子品牌类型
type
  VSB_MG_CLASS =  
  (  
    VSB_MG_OTHER = 0,  // 其他（保留）
    VSB_MG_3SW_1 = 1,  // MG-MG-3SW-2009,2008
    VSB_MG_MG3_1 = 2,  // MG-MG3-2013,2012,2011
    VSB_MG_MG5_1 = 3,  // MG-MG5-2014,2013,2012
    VSB_MG_MG6_1 = 4,  // MG-MG6三厢-2012,2011
    VSB_MG_MG7_1 = 5  // MG-MG7-2010,2009,2008,2007
  );

//一汽子品牌类型
type
  VSB_FAW_CLASS =  
  (  
    VSB_FAW_OTHER = 0,  // 其他（保留）
    VSB_FAW_501_1 = 1,  //一汽-501-轻卡
    VSB_FAW_N3_1 = 2,  //一汽-N3+两厢-2006
    VSB_FAW_N3_2 = 3,  //一汽-N3+两厢-2008
    VSB_FAW_JIABAO_1 = 4,  //一汽-佳宝货车-2011T50,T57
    VSB_FAW_JIABAO_2 = 5,  //一汽-佳宝面包车-2000
    VSB_FAW_JIABAO_3 = 6,  //一汽-佳宝面包车-2006
    VSB_FAW_JIABAO_4 = 7,  //一汽-佳宝面包车-2012,2011V50舒适版
    VSB_FAW_JIABAO_5 = 8,  //一汽-佳宝面包车-2012,2011V70
    VSB_FAW_JIABAO_6 = 9,  //一汽-佳宝面包车-2013,2012,2011V52实用型
    VSB_FAW_JIABAO_7 = 10,  //一汽-佳宝面包车-2014,2013V80
    VSB_FAW_XIALI_1 = 11,  //一汽-夏利-1999,1997
    VSB_FAW_XIALI_2 = 12,  //一汽-夏利2000-2003,2002
    VSB_FAW_XIALI_3 = 13,  //一汽-夏利A+-2011,2010,2006,2005
    VSB_FAW_XIALI_4 = 14,  //一汽-夏利N3-2012
    VSB_FAW_XIALI_5 = 15,  //一汽-夏利N5-2014,2013,2011,2010,2009
    VSB_FAW_XIALI_6 = 16,  //一汽-夏利N7-2013
    VSB_FAW_AOWEI_1 = 17,  //一汽-奥威J5P-2005,2004,2003
    VSB_FAW_AOWEI_2 = 18,  //一汽-奥威J5P-4X2复合型牵引车,自卸车
    VSB_FAW_AOWEI_3 = 19,  //一汽-奥威J5P-4X2牵引车,卸货车
    VSB_FAW_AOWEI_4 = 20,  //一汽-奥威J5P-6X6越野自卸车
    VSB_FAW_AOXING_1 = 21,  //一汽-奥星-2004
    VSB_FAW_WEILE_1 = 22,  //一汽-威乐-2004
    VSB_FAW_WEILE_2 = 23,  //一汽-威乐-2008,2007
    VSB_FAW_WEIZI_1 = 24,  //一汽-威姿-2004
    VSB_FAW_WEIZHI_1 = 25,  //一汽-威志V2-2012手动CROSS
    VSB_FAW_WEIZHI_2 = 26,  //一汽-威志V2-2012自动CROSS,2010
    VSB_FAW_WEIZHI_3 = 27,  //一汽-威志V5-2013,2012
    VSB_FAW_WEIZHI_4 = 28,  //一汽-威志三厢-2009,2008,2007
    VSB_FAW_WEIZHI_5 = 29,  //一汽-威志三厢-2011
    VSB_FAW_XIAOJIEFANG_1 = 30,  //一汽-小解放-90,109马力轻卡
    VSB_FAW_HANWEI_1 = 31,  //一汽-悍威J5M-4X4载货车
    VSB_FAW_HANWEI_2 = 32,  //一汽-悍威J5M-6X6牵引车,6X4自卸车
    VSB_FAW_HANWEI_3 = 33,  //一汽-悍威J5M-8X8自卸车
    VSB_FAW_XINDAWEI_1 = 34,  //一汽-新大威-2010
    VSB_FAW_XINHANWEI_1 = 35,  //一汽-新悍威-2011
    VSB_FAW_SENYA_1 = 36,  //一汽-森雅M80-2012,2011,2009
    VSB_FAW_TENGWEI_1 = 37,  //一汽-腾威L5M-重卡
    VSB_FAW_JIEFANG_1 = 38,  //一汽-解放J4R-A款
    VSB_FAW_JIEFANG_2 = 39,  //一汽-解放J4R-自卸车,牵引车
    VSB_FAW_JIEFANG_3 = 40,  //一汽-解放J6-2004
    VSB_FAW_JIEFANG_4 = 41,  //一汽-解放J6-重卡
    VSB_FAW_JIEFANG_5 = 42,  //一汽-解放J6L-中卡
    VSB_FAW_JIEFANG_6 = 43,  //一汽-解放L5-A款
    VSB_FAW_SAILONG_1 = 44,  //一汽-赛龙-中卡
    VSB_FAW_JUNWEI_1 = 45,  //一汽-骏威J5K-中卡
    VSB_FAW_B50_1 = 46,  //一汽-奔腾B50-2012,2011,2009
    VSB_FAW_B50_2 = 47  //一汽-奔腾B50-2013
  );


//上汽子品牌类型
type
  VSB_SAICMOTOR_CLASS =  
  (  
    VSB_SAICMOTOR_OTHER = 0,  // 其他（保留）
    VSB_HONGYAN_JIESHI_1 = 1,  // 上汽依维柯红岩-杰狮-2012
    VSB_DATONG_V80_1 = 2  // 上汽大通-V80-2014,2013,2012,2011
  );

//东南汽车子品牌类型
type
  VSB_SOUEAST_CLASS =  
  (  
    VSB_SOUEAST_OTHER = 0,  // 其他（保留）
    VSB_SOUEAST_V3_1 = 1,  // 东南-V3菱悦-2011超值幸福版,2010,2009,2008
    VSB_SOUEAST_V3_2 = 2,  // 东南-V3菱悦-2012
    VSB_SOUEAST_V3_3 = 3,  // 东南-V3菱悦-2012旗舰版,2011,2010新风采版
    VSB_SOUEAST_V3_4 = 4,  // 东南-V3菱悦-2012风采版
    VSB_SOUEAST_V5_1 = 5,  // 东南-V5菱致-2014,2013,2012
    VSB_SOUEAST_XIWANG_1 = 6,  // 东南-希旺-2011,2010
    VSB_SOUEAST_DELIKA_1 = 7,  // 东南-得利卡-2003,2002
    VSB_SOUEAST_DELIKA_2 = 8,  // 东南-得利卡-2005
    VSB_SOUEAST_DELIKA_3 = 9,  // 东南-得利卡-2008
    VSB_SOUEAST_DELIKA_4 = 10,  // 东南-得利卡-2009
    VSB_SOUEAST_LINGSHUAI_1 = 11,  // 东南-菱帅-2005,2004GLXi
    VSB_SOUEAST_FULIKA_1 = 12,  // 东南-富利卡-2005
    VSB_SOUEAST_FULIKA_2 = 13  // 东南-富利卡-2007
  );


//中兴汽车子品牌类型
type
  VSB_ZTE_CLASS =  
  (  
    VSB_ZTE_OTHER = 0,  // 其他（保留）
    VSB_ZTE_WEIHU_1 = 1,  // 中兴-威虎-2012,2010
    VSB_ZTE_WEIHU_2 = 2,  // 中兴-威虎TUV-2010,2006
    VSB_ZTE_WUXIAN_1 = 3,  // 中兴-无限-2008
    VSB_ZTE_WUXIAN_2 = 4  // 中兴-无限-2012,2011,2010,2009
  );


//中华汽车子品牌类型
type
  VSB_ZHONGHUA_CLASS =  
  (  
    VSB_ZHONGHUA_OTHER = 0,  // 其他（保留）
    VSB_ZHONGHUA_H230_1 = 1,  // 中华-H230-2012
    VSB_ZHONGHUA_H320_1 = 2,  // 中华-H320-2012
    VSB_ZHONGHUA_H330_1 = 3,  // 中华-H330-2013
    VSB_ZHONGHUA_H530_1 = 4,  // 中华-H530-2012,2011
    VSB_ZHONGHUA_V5_1 = 5,  // 中华-V5-2012,2011
    VSB_ZHONGHUA_ZUNCHI_1 = 6,  // 中华-尊驰-2004
    VSB_ZHONGHUA_ZUNCHI_2 = 7,  // 中华-尊驰-2005,2003
    VSB_ZHONGHUA_KUBAO_1 = 8,  // 中华-酷宝-2007
    VSB_ZHONGHUA_JUNJIE_1 = 9,  // 中华-骏捷-2010,2009,2008,2007,2006
    VSB_ZHONGHUA_JUNJIE_2 = 10,  // 中华-骏捷-2012,2011
    VSB_ZHONGHUA_JUNJIECROSS_1 = 11,  // 中华-骏捷cross-2010,2009
    VSB_ZHONGHUA_JUNJIEFRV_1 = 12,  // 中华-骏捷FRV-2009,2008
    VSB_ZHONGHUA_JUNJIEFRV_2 = 13,  // 中华-骏捷FRV-2010
    VSB_ZHONGHUA_JUNJIEFSV_1 = 14,  // 中华-骏捷FSV-2009
    VSB_ZHONGHUA_JUNJIEFSV_2 = 15,  // 中华-骏捷FSV-2010
    VSB_ZHONGHUA_JUNJIEFSV_3 = 16  // 中华-骏捷FSV-2011
  );


//中国重汽子品牌类型
type
  VSB_CNHTC_CLASS =  
  (  
    VSB_CNHTC_OTHER = 0,  // 其他（保留）
    VSB_CNHTC_HOKA_2 = 1,  // 中国重汽-HOKA-牵引车,自卸车
    VSB_CNHTC_HOWO_1 = 2,  // 中国重汽-HOWO-A7
    VSB_CNHTC_HOWO_2 = 3,  // 中国重汽-HOWO-T7H
    VSB_CNHTC_HOWO_3 = 4,  // 中国重汽-HOWO-轻卡
    VSB_CNHTC_HOWO_4 = 5,  // 中国重汽-HOWO重卡-牵引车
    VSB_CNHTC_HOWO_5 = 6,  // 中国重汽-HOWO重卡-自卸车A
    VSB_CNHTC_HOWO_6 = 7,  // 中国重汽-HOWO重卡-自卸车B
    VSB_CNHTC_HOWO_7 = 8,  // 中国重汽-HOWO重卡-载货车A
    VSB_CNHTC_HOWO_8 = 9,  // 中国重汽-HOWO重卡-载货车C
    VSB_CNHTC_SITAIERWANG_1 = 10,  // 中国重汽-斯太尔王-牵引车A,载货车,搅拌车
    VSB_CNHTC_HAOHAN_1 = 11,  // 中国重汽-豪瀚-A款
    VSB_CNHTC_HAOYUN_1 = 12,  // 中国重汽-豪运-牵引车B,载货车,自卸车
    VSB_CNHTC_JINWANGZI_1 = 13,  // 中国重汽-金王子重卡-牵引车B
    VSB_CNHTC_HOKA_1 = 14  // 中国重汽-HOKA-H7
  );

//中通子品牌类型
type
  VSB_ZHONGTONG_CLASS =  
  (  
    VSB_ZHONGTONG_OTHER = 0,  // 其他（保留）
    VSB_ZHONGTONG_KAICHI_1 = 1,  // 中通客车-凯驰A-A款
    VSB_ZHONGTONG_LINGYU_1 = 2,  // 中通客车-领御-A款
    VSB_ZHONGTONG_LINGXIU_1 = 3,  // 中通客车-领秀-A款
    VSB_ZHONGTONG_LINGHANG_1 = 4,  // 中通客车-领航-A款
    VSB_ZHONGTONG_SHIJI_1 = 5,  // 中通客车-世纪-A款
    VSB_ZHONGTONG_KAIXUAN_1 = 6,  // 中通客车-凯旋-A款
    VSB_ZHONGTONG_LINGYUN_1 = 7,  // 中通客车-领韵A-A款
    VSB_ZHONGTONG_YANGGUANG_1 = 8  // 中通客车-阳光-A款
  );


//九龙子品牌类型
type
  VSB_JIULONG_CLASS =  
  (  
    VSB_JIULONG_OTHER = 0,  // 其他（保留）
    VSB_JIULONG_JIULONGA5_1 = 1  // 九龙-九龙A5-2011
  );

//众泰子品牌类型
type
  VSB_ZOTYE_CLASS =  
  (  
    VSB_ZOTYE_OTHER = 0,  // 其他（保留）
    VSB_ZOTYE_2008_2 = 1,  // 众泰-2008-2011,2010,2008
    VSB_ZOTYE_5008_1 = 2,  // 众泰-5008-2013,2011,2010,2008
    VSB_ZOTYE_Z300_1 = 3,  // 众泰-Z300-2013,2012
    VSB_ZOTYE_2008_1 = 4  // 众泰-2008-2007
  );

//依维柯子品牌类型
type
  VSB_NAVECO_CLASS =  
  (  
    VSB_NAVECO_OTHER = 0,  // 其他（保留）
    VSB_NAVECO_Daily_1 = 1,  // 依维柯-Daily-2006,2004,2003
    VSB_NAVECO_Power_1 = 2,  // 依维柯-Power-Daily
    VSB_NAVECO_Turbo_1 = 3,  // 依维柯-Turbo-Daily-2014,2012,2011
    VSB_NAVECO_Venice_1 = 4,  // 依维柯-Venice-2011,2008
    VSB_NAVECO_BAODI_1 = 5,  // 依维柯-宝迪-2012,2009
    VSB_NAVECO_DEYIHUOCHE_1 = 6,  // 依维柯-得意货车-2011
    VSB_NAVECO_DULING_1 = 7  // 依维柯-都灵-2010,2009,2007
  );

//保时捷子品牌类型
type
  VSB_PORSCHE_CLASS =  
  (  
    VSB_PORSCHE_OTHER = 0,  // 其他（保留）
    VBR_PORSCHE_PANAMERA_1 = 1,  // 保时捷-panamera-2013,2012,2010
    VBR_PORSCHE_CAYENNE_1 = 2  // 保时捷-卡宴Cayenne-2014,2013,2011,2010
  );


//克莱斯勒子品牌类型
type
  VSB_CHRYSLER_CLASS =  
  (  
    VSB_CHRYSLER_OTHER = 0,  // 其他（保留）
    VSB_CHRYSLER_300C_1 = 1,  // 克莱斯勒-300C-2007,2006,2004
    VSB_CHRYSLER_PTMANBUZHE_1 = 2  // 克莱斯勒-PT漫步者-2007
  );

//凯迪拉克子品牌类型
type
  VSB_CADILLAC_CLASS =  
  (  
    VSB_CADILLAC_OTHER = 0,  // 其他（保留）
    VSB_CADILLAC_ATS_1 = 1,  // 凯迪拉克-ATS-2014
    VSB_CADILLAC_CTS_1 = 2,  // 凯迪拉克-CTS-2012
    VSB_CADILLAC_CTS_3 = 3,  // 凯迪拉克-CTS-2012精英运动型,2011,2010,2009,2008
    VSB_CADILLAC_SLS_1 = 4,  // 凯迪拉克-SLS赛威-2007,2006
    VSB_CADILLAC_SLS_2 = 5,  // 凯迪拉克-SLS赛威-2012,2011,2010
    VSB_CADILLAC_SRX_1 = 6,  // 凯迪拉克-SRX-2012,2011,2010,2009
    VSB_CADILLAC_CTS_2 = 7,  // 凯迪拉克-CTS-2012,2009CTS
    VSB_CADILLAC_KAILEIDE_1 = 8  // 凯迪拉克-凯雷德-2011,2010,2008,2007,2006
  );


//凯马KAMA子品牌类型
type
  VSB_KAMA_CLASS =  
  (  
    VSB_KAMA_OTHER = 0,  // 其他（保留）
    VSB_KAMA_QINGKA_2 = 1,  // 凯马KAMA-凯马-轻卡D
    VSB_KAMA_FULAIKA_1 = 2,  // 凯马KAMA-福来卡-轻卡A
    VSB_KAMA_JINYUNKA_1 = 3,  // 凯马KAMA-金运卡-轻卡
    VSB_KAMA_JUNWEIKA_1 = 4,  // 凯马KAMA-骏威卡车-2014,2011
    VSB_KAMA_QINGKA_1 = 5  // 凯马KAMA-凯马-轻卡C
  );

//力帆子品牌类型
type
  VSB_LIFAN_CLASS =  
  (  
    VSB_LIFAN_OTHER = 0,  // 其他（保留）
    VSB_LIFAN_320_1 = 1,  // 力帆-320-2012,2011,2009
    VSB_LIFAN_520_1 = 2,  // 力帆-520-2007,2006
    VSB_LIFAN_520_2 = 3,  // 力帆-520-2013,2011,2010,2008
    VSB_LIFAN_620_1 = 4,  // 力帆-620-2012,2010,2009,2008
    VSB_LIFAN_X60_1 = 5,  // 力帆-X60-2013,2012,2011
    VSB_LIFAN_FENGSHUN_1 = 6  // 力帆-丰顺-2011
  );


//北京子品牌类型
type
  VSB_BEIJING_CLASS =  
  (  
    VSB_BEIJING_OTHER = 0,  // 其他（保留）
    VSB_BEIJING_E_1 = 1  // 北京汽车-E系列两厢-2014,2013,2012
  );

//北奔重汽子品牌类型
type
  VSB_BEIBEN_CLASS =  
  (  
    VSB_BEIBEN_OTHER = 0,  // 其他（保留）
    VSB_BEIBEN_NG80_1 = 1,  // 北奔重汽-NG80-重卡A
    VSB_BEIBEN_NG80_2 = 2,  // 北奔重汽-NG80-重卡B
    VSB_BEIBEN_NG80_3 = 3,  // 北奔重汽-NG80-重卡C
    VSB_BEIBEN_V3_1 = 4,  // 北奔重汽-北奔V3-V3H1
    VSB_BEIBEN_V3_2 = 5  // 北奔重汽-北奔V3-重卡A
  );

//北方客车子品牌类型
type
  VSB_BEIFANG_CLASS =  
  (  
    VSB_BEIFANG_OTHER = 0,  // 其他（保留）
    VSB_BEIFANG_A_1 = 1  // 北方客车-客车车型1-A款
  );


//北汽制造子品牌类型
type
  VSB_BAW_CLASS =  
  (  
    VSB_BAW_OTHER = 0,  // 其他（保留）
    VSB_BAW_YUSHENG007_1 = 1,  // 北汽制造-域胜007-2013,2011
    VSB_BAW_QILING_1 = 2,  // 北汽制造-旗铃-A款
    VSB_BAW_LUBA_1 = 3,  // 北汽制造-陆霸-2004
    VSB_BAW_QISHI_1 = 4  // 北汽制造-骑士-2009,2007
  );

//北汽威旺子品牌类型
type
  VSB_BQWEIWANG_CLASS =  
  (  
    VSB_BQWEIWANG_OTHER = 0,  // 其他（保留）
    VSB_BQWEIWANG_205_1 = 1,  // 北汽威旺-205-2013
    VSB_BQWEIWANG_306_1 = 2  // 北汽威旺-306-2014,2013,2011
  );


//华普子品牌类型
type
  VSB_SMA_CLASS =  
  (  
    VSB_SMA_OTHER = 0,  // 其他（保留）
    VSB_SMA_HAIYU_1 = 1,  // 华普-海域-2007,2005,2004
    VSB_SMA_HAIYU_2 = 2,  // 华普-海域-2007海域MB
    VSB_SMA_HAISHANG_1 = 3,  // 华普-海尚-2008,2005
    VSB_SMA_HAIJING_1 = 5,  // 华普-海景-2010,2009
    VSB_SMA_HAIXUN_1 = 4,  // 华普-海迅-2005,2004飙风
    VSB_SMA_HAIXUN_2 = 6  // 华普-海迅-2007,2006
  );

//华菱星马子品牌类型
type
  VSB_XINGMA_CLASS =  
  (  
    VSB_XINGMA_OTHER = 0,  // 其他（保留）
    VSB_XINGMA_XINGKAIMA_1 = 1  // 华菱星马-星凯马-牵引车型1,载货车型1
  );

//双环子品牌类型
type
  VSB_SHUANGHUAN_CLASS =  
  (  
    VSB_SHUANGHUAN_OTHER = 0,  // 其他（保留）
    VSB_SHUANGHUAN_SCEO_1 = 1  // 双环-SCEO-2011,2009,2006,2005
  );

//吉普子品牌类型
type
  VSB_JEEP_CLASS =  
  (  
    VSB_JEEP_OTHER = 0,  // 其他（保留）
    VSB_JEEP_DAQIENUOJI_1 = 1,  // 吉普-大切诺基(进口)-2014,2013,2012,2011
    VSB_JEEP_DAQIENUOJI_2 = 2,  // 吉普-大切诺基(进口)-2014舒享导航版
    VSB_JEEP_ZHINANZHE_1 = 3,  // 吉普-指南者-2010,2007
    VSB_JEEP_ZHINANZHE_2 = 4,  // 吉普-指南者-2014,2013,2012,2011
    VSB_JEEP_MUMAREN_1 = 5,  // 吉普-牧马人-2012使命召唤限量版,2011
    VSB_JEEP_MUMAREN_2 = 6,  // 吉普-牧马人-2014,2013,2012,2011,2010,2009,2008
    VSB_JEEP_ZIYOUKE = 7  // 吉普-自由客-2014,2013,2012,2011
  );

//启辰子品牌类型
type
  VSB_VENUCIA_CLASS =  
  (  
    VSB_VENUCIA_OTHER = 0,  // 其他（保留）
    VSB_VENUCIA_D50_1 = 1  // 启辰-D50-2014,2013,2012
  );

//哈飞子品牌类型
type
  VSB_HAFEI_CLASS =  
  (  
    VSB_HAFEI_OTHER = 0,  // 其他（保留）
    VSB_HAFEI_XINMINYI_1 = 1,  // 哈飞-新民意货车-2010
    VSB_HAFEI_XINMINYI_2 = 2,  // 哈飞-新民意面包车-2012
    VSB_HAFEI_MINYI_1 = 3,  // 哈飞-民意货车-2006
    VSB_HAFEI_MINYI_2 = 4,  // 哈飞-民意面包车-2008
    VSB_HAFEI_SAIBAO_1 = 5,  // 哈飞-赛豹Ⅲ-2012
    VSB_HAFEI_SAIMA_1 = 6,  // 哈飞-赛马-2002
    VSB_HAFEI_SAIMA_2 = 7,  // 哈飞-赛马-2004,2003
    VSB_HAFEI_SAIMA_3 = 8,  // 哈飞-赛马-2009
    VSB_HAFEI_LUBAO_1 = 9,  // 哈飞-路宝-2004
    VSB_HAFEI_LUBAO_2 = 10,  // 哈飞-路宝-2008,2007
    VSB_HAFEI_LUBAO_3 = 11,  // 哈飞-路宝-2012
    VSB_HAFEI_LUZUNXIAOBAWANG_1 = 12,  // 哈飞-路尊小霸王-2011,2010
    VSB_HAFEI_RUIYI_1 = 13,  // 哈飞-锐意-2009
    VSB_HAFEI_JUNYI_1 = 14  // 哈飞-骏意-2012,2010
  );

//唐骏欧铃子品牌类型
type
  VSB_TKING_CLASS =  
  (  
    VSB_TKING_OTHER = 0,  // 其他（保留）
    VSB_TKING_OUGUAN_1 = 1,  // 唐骏欧铃-欧冠-2011
    VSB_TKING_OUGUAN_2 = 2,  // 唐骏欧铃-欧冠-轻卡B
    VSB_TKING_OUTENG_1 = 3,  // 唐骏欧铃-欧腾-轻卡A
    VSB_TKING_FUXING_1 = 4,  // 唐骏欧铃-福星-2006
    VSB_TKING_QINGKAWANG_1 = 5,  // 唐骏欧铃-轻卡王-轻卡
    VSB_TKING_AFANDA_1 = 6,  // 唐骏欧铃-阿凡达-中重卡
    VSB_TKING_JUNQI_1 = 7  // 唐骏欧铃-骏麒-中重卡A
  );

//大宇子品牌类型
type
  VSB_DAEWOO_CLASS =  
  (  
    VSB_DAEWOO_OTHER = 0,  // 其他（保留）
    VBR_DAEWOO_6960H3_1 = 1  // 大宇-6960H3-A款
  );

//大运汽车子品牌类型
type
  VSB_DAYUN_CLASS =  
  (  
    VSB_DAYUN_OTHER = 0,  // 其他（保留）
    VBR_DAYUN_ZHONGKA_1 = 1  // 大运汽车-重卡-A款
  );

//奔腾子品牌类型
type
  VSB_BESTURN_CLASS =  
  (  
    VSB_BESTURN_OTHER = 0,  // 其他（保留）
    VSB_BESTURN_B70_1 = 1,  // 奔腾-B70-2009,2007,2006
    VSB_BESTURN_B70_2 = 2,  // 奔腾-B70-2011
    VSB_BESTURN_B70_3 = 3,  // 奔腾-B70-2011精英型,2010
    VSB_BESTURN_B70_4 = 4,  // 奔腾-B70-2012
    VSB_BESTURN_B90_1 = 5,  // 奔腾-B90-2012
    VSB_BESTURN_AOXING_1 = 6  // 一汽-奥星-2004
  );

//威麟子品牌类型
type
  VSB_WEILIN_CLASS =  
  (  
    VSB_WEILIN_OTHER = 0,  // 其他（保留）
    VSB_WEILIN_H3_1 = 1,  // 威麟-H3-2011
    VSB_WEILIN_V5_1 = 2,  // 威麟-V5-2012,2009
    VSB_WEILIN_X5_1 = 3  // 威麟-X5-2012,2011,2010
  );

//宇通子品牌类型
type
  VSB_YUTONG_CLASS =  
  (  
    VSB_YUTONG_OTHER = 0,  // 其他（保留）
    VSB_YUTONG_8XI_1 = 1,  // 宇通-8系-2012,2005
    VSB_YUTONG_KECHE_1 = 2,  // 宇通-客车车型10-2013,2010
    VSB_YUTONG_KECHE_3 = 3,  // 宇通-客车车型2-A款
    VSB_YUTONG_KECHE_4 = 4,  // 宇通-客车车型8-2004
    VSB_YUTONG_KECHE_5 = 5,  // 宇通-客车车型9-2014
    VSB_YUTONG_KECHE_2 = 6  // 宇通-客车车型12-A款
  );

//安凯子品牌类型
type
  VSB_ANKAI_CLASS =  
  (  
    VSB_ANKAI_OTHER = 0,  // 其他（保留）
    VSB_ANKAI_KECHE_1 = 1,  // 安凯-客车车型1-A款
    VSB_ANKAI_KECHE_2 = 2  // 安凯-客车车型3-A款
  );

//宝骏子品牌类型
type
  VSB_BAOJUN_CLASS =  
  (  
    VSB_BAOJUN_OTHER = 0,  // 其他（保留）
    VSB_BAOJUN_630_1 = 1  // 宝骏-宝骏630-2014,2013,2012,2011
  );

//宾利子品牌类型
type
  VSB_BINLI_CLASS =  
  (  
    VSB_BINLI_OTHER = 0,  // 其他（保留）
    VSB_BINLI_OULU_1 = 1  // 宾利-欧陆-2009,2008
  );

//广汽传祺子品牌类型
type
  VSB_TRUMPCHE_CLASS =  
  (  
    VSB_TRUMPCHE_OTHER = 0,  // 其他（保留）
    VSB_TRUMPCHE_GA5_1 = 1,  // 广汽传祺-GA5-2012,2011
    VSB_TRUMPCHE_GA5_2 = 3,  // 广汽传祺-GA5-2013,2012自动精英版
    VSB_TRUMPCHE_GS5_1 = 2  // 广汽传祺-GS5-2014,2013,2012
  );

//广汽吉奥 子品牌类型
type
  VSB_GONOW_CLASS =  
  (  
    VSB_GONOW_OTHER = 0,  // 其他（保留）
    VSB_GONOW_G3_1 = 1,  // 广汽吉奥-G3-2011
    VSB_GONOW_G5_1 = 2,  // 广汽吉奥-G5-2012,2011
    VSB_GONOW_SHUAIJIAN_1 = 4,  // 广汽吉奥-帅舰-2012,2009
    VSB_GONOW_XINGWANGM1_1 = 3,  // 广汽吉奥-星旺M1-2012
    VSB_GONOW_CAIYUN500_1 = 5  // 广汽吉奥-财运500-2010
  );

//庆铃子品牌类型
type
  VSB_ISUZU_CLASS =  
  (  
    VSB_ISUZU_OTHER = 0,  // 其他（保留）
    VSB_ISUZU_ZHONGXINGSHANGYONG_1 = 1,  // 庆铃-中型商用车-2011
    VSB_ISUZU_WUSHILINGPIKA_1 = 2,  // 庆铃-五十铃皮卡-2009
    VSB_ISUZU_WUSHILINGPIKA_2 = 3,  // 庆铃-五十铃皮卡-2014,2009
    VSB_ISUZU_JINGJIZHE_1 = 4  // 庆铃-竞技者-2004,2002
  );


//开瑞子品牌类型
type
  VSB_KARRY_CLASS =  
  (  
    VSB_KARRY_OTHER = 0,  // 其他（保留）
    VSB_KARRY_YOU_2 = 1,  // 开瑞-优优-2013,2012
    VSB_KARRY_YOUJIN_1 = 2,  // 开瑞-优劲-2012,2011基本型,2010
    VSB_KARRY_YOUSHENG_1 = 3,  // 开瑞-优胜-2010
    VSB_KARRY_YOUSHENG_2 = 4,  // 开瑞-优胜-2012,2011
    VSB_KARRY_YOUYA = 5,  // 开瑞-优雅-2012,2011,2007
    VSB_KARRY_YOU_1 = 6  // 开瑞-优优-2011,2010,2009
  );

//捷豹子品牌类型
type
  VSB_GAGUAR_CLASS =  
  (  
    VSB_GAGUAR_OTHER = 0,  // 其他（保留）
    VSB_GAGUAR_XF_1 = 1,  // 捷豹-XF-2014,2013
    VSB_GAGUAR_XJ_1 = 2  // 捷豹-XJ-2014,2013,2012,2011,2010
  );

//斯巴鲁子品牌类型
type
  VSB_SUBARU_CLASS =  
  (  
    VSB_SUBARU_OTHER = 0,  // 其他（保留）
    VSB_SUBARU_AOHU_1 = 1,  // 斯巴鲁-傲虎-2012,2011,2010
    VSB_SUBARU_LISHI_1 = 2,  // 斯巴鲁-力狮轿车-2008,2006
    VSB_SUBARU_LISHI_2 = 3,  // 斯巴鲁-力狮轿车-2011,2010
    VSB_SUBARU_XV_1 = 4,  // 斯巴鲁-斯巴鲁XV-2014,2012
    VSB_SUBARU_SENLINREN_1 = 5,  // 斯巴鲁-森林人-2007,2006
    VSB_SUBARU_SENLINREN_2 = 6  // 斯巴鲁-森林人-2012,2011,2010,2009,2008
  );

//时代汽车子品牌类型
type
  VSB_ERA_CLASS =  
  (  
    VSB_ERA_OTHER = 0,  // 其他（保留）
    VSB_ERA_XIAOKA_1 = 1,  // 时代汽车-小卡之星-小卡之星1,2,Q2
    VSB_ERA_XIAOKA_3 = 2,  // 时代汽车-小卡之星-小卡之星5
    VSB_ERA_XIAOKA_4 = 3,  // 时代汽车-小卡之星-福锐
    VSB_ERA_KANGRUI_1 = 4,  // 时代汽车-康瑞-康瑞H1
    VSB_ERA_KANGRUI_2 = 5,  // 时代汽车-康瑞-康瑞H3
    VSB_ERA_KANGRUI_3 = 6,  // 时代汽车-康瑞-康瑞K1,KQ1
    VSB_ERA_RUIWO_1 = 7,  // 时代汽车-瑞沃-RC1
    VSB_ERA_RUIWO_2 = 8,  // 时代汽车-瑞沃-RC2
    VSB_ERA_RUIWO_3 = 9,  // 时代汽车-瑞沃-瑞沃II轻卡A
    VSB_ERA_JINGANG = 10,  // 时代汽车-金刚-金刚568
    VSB_ERA_LINGHANG_1 = 11,  // 时代汽车-领航-领航2
    VSB_ERA_LINGHANG_2 = 12,  // 时代汽车-领航-领航3
    VSB_ERA_YULING_1 = 13,  // 时代汽车-驭菱-驭菱V1
    VSB_ERA_YULING_2 = 14,  // 时代汽车-驭菱-驭菱V5,VQ5
    VSB_ERA_YULING_3 = 15,  // 时代汽车-驭菱-驭菱VQ1,VQ2
    VSB_ERA_YULING_4 = 17,  // 时代汽车-驭菱-鸿运
    VSB_ERA_XIAOKA_2 = 17  // 时代汽车-小卡之星-小卡之星3
  );

//昌河子品牌类型
type
  VSB_CHANGHE_CLASS =  
  (  
    VSB_CHANGHE_OTHER = 0,  // 其他（保留）
    VSB_CHANGHE_CH6321_1 = 1,  // 昌河-CH6321-2000
    VSB_CHANGHE_DANSHUANGPAI_1 = 2,  // 昌河-昌河新单双排-1999
    VSB_CHANGHE_AIDIER_1 = 3,  // 昌河-爱迪尔-2004
    VSB_CHANGHE_AIDIER_2 = 4,  // 昌河-爱迪尔Ⅱ-2007,2006
    VSB_CHANGHE_FURUIDA_1 = 5  // 昌河-福瑞达面包车-2014,2013,2011,2009
  );

//欧宝子品牌类型
type
  VSB_OPEL_CLASS =  
  (  
    VSB_OPEL_OTHER = 0,  // 其他（保留）
    VSB_OPEL_YATE_1 = 1  // 欧宝-雅特-2010GTC全景风挡版,2007,2006
  );

//永源子品牌类型
type
  VSB_JONWAY_CLASS =  
  (  
    VSB_JONWAY_OTHER = 0,  // 其他（保留）
    VSB_JONWAY_A380_1 = 1  // 永源-A380-2010,2009,2008
  );

//江南子品牌类型
type
  VSB_JIANGNAN_CLASS =  
  (  
    VSB_JIANGNAN_OTHER = 0,  // 其他（保留）
    VSB_JIANGNAN_TT_1 = 1  // 江南-江南TT-2011,2010,2004
  );

//吉利全球鹰子品牌类型
type
  VSB_GLEAGLE_CLASS =  
  (  
    VSB_GLEAGLE_OTHER = 0,  // 其他（保留）
    VSB_GLEAGLE_EAGLE_GC7_1 = 1,  // 吉利全球鹰-GC7-2013,2012
    VSB_GLEAGLE_EAGLE_GX2_1 = 2,  // 吉利全球鹰-GX2-2012,2011
    VSB_GLEAGLE_EAGLE_GX7_1 = 3,  // 吉利全球鹰-GX7-2013,2012
    VSB_GLEAGLE_EAGLE_PANDA_1 = 4,  // 吉利全球鹰-熊猫-2013,2011,2010,2009
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1 = 5,  // 吉利全球鹰-自由舰-2009精致标准型,2007
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2 = 6,  // 吉利全球鹰-自由舰-2010,2009,2008,2006,2005
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3 = 7,  // 吉利全球鹰-自由舰-2012,2011
    VSB_GLEAGLE_EAGLE_YUANJING_1 = 8,  // 吉利全球鹰-远景-2011,2010,2009,2008,2006
    VSB_GLEAGLE_EAGLE_YUANJING_2 = 9  // 吉利全球鹰-远景-2013,2012
  );

//吉利帝豪子品牌类型
type
  VSB_EMGRAND_CLASS =  
  (  
    VSB_EMGRAND_OTHER = 0,  // 其他（保留）
    VSB_EMGRAND_EC7_2 = 1,  // 吉利帝豪-EC7-2013
    VSB_EMGRAND_EC7_3 = 2,  // 吉利帝豪-EC7-RV
    VSB_EMGRAND_EC8_1 = 3,  // 吉利帝豪-EC8-2013,2011,2010
    VSB_EMGRAND_EC7_1 = 4  // 吉利帝豪-EC7-2012,2010,2009
  );


//吉利英伦子品牌类型
type
  VSB_ENGLON_CLASS =  
  (  
    VSB_ENGLON_OTHER = 0,  // 其他（保留）
    VSB_ENGLON_SC3_1 = 1,  // 吉利英伦-SC3-2012
    VSB_ENGLON_SC5_1 = 2,  // 吉利英伦-SC5-RV-2012
    VSB_ENGLON_SC6_1 = 3,  // 吉利英伦-SC6-2012
    VSB_ENGLON_SC7_1 = 4,  // 吉利英伦-SC7-2013,2012,2011,2010
    VSB_ENGLON_SX7_1 = 5,  // 吉利英伦-SX7-2014,2013
    VSB_ENGLON_JINGANG_1 = 6,  // 吉利英伦-金刚-2010,2007,2006
    VSB_ENGLON_JINYING_1 = 7  // 吉利英伦-金鹰-2011,2010,2008
  );


//江淮-子品牌类型
type
  VSB_JAC_CLASS =  
  (  
    VSB_JAC_OTHER = 0,  // 其他（保留）
    VSB_JAC_TONGYUE_1 = 1,  // 江淮-同悦-2012,2010,2008
    VSB_JAC_HEYUE_1 = 2,  // 江淮-和悦-2012,2011,2010
    VSB_JAC_HEYUEA30_2 = 3,  // 江淮-和悦A30-2013
    VSB_JAC_HEYUERS_3 = 4,  // 江淮-和悦RS-2012,2011
    VSB_JAC_HAOYUN_1 = 5,  // 江淮-好运-轻卡1
    VSB_JAC_WEILING_2 = 6,  // 江淮-威铃-排半轻卡
    VSB_JAC_WEILING_3 = 7,  // 江淮-威铃-栏板载货车
    VSB_JAC_WEILING_4 = 8,  // 江淮-威铃-轻卡
    VSB_JAC_KECHE_1 = 9,  // 江淮-客车-A款
    VSB_JAC_BINYUE_1 = 10,  // 江淮-宾悦-2010,2008
    VSB_JAC_SHUAILING_2 = 11,  // 江淮-帅铃-轻卡
    VSB_JAC_KANGLING_1 = 12,  // 江淮-康铃-轻卡1
    VSB_JAC_KANGLING_2 = 13,  // 江淮-康铃-轻卡2
    VSB_JAC_YUEYUE_1 = 14,  // 江淮-悦悦-2013,2012,2011,2010
    VSB_JAC_XINGRUI_1 = 15,  // 江淮-星锐-2012,2011
    VSB_JAC_GEERFA_H_1 = 16,  // 江淮-格尔发H-栏板载货车
    VSB_JAC_GEERFA_K_2 = 17,  // 江淮-格尔发K-重卡1
    VSB_JAC_GEERFA_K_3 = 18,  // 江淮-格尔发K-重卡2
    VSB_JAC_GEERFA_M_4 = 19,  // 江淮-格尔发M-栏板载货车
    VSB_JAC_RUIFENG_1 = 20,  // 江淮-瑞风-2011,2009,2007手动
    VSB_JAC_RUIFENG_2 = 21,  // 江淮-瑞风-2013,2012,2011,2010,2007,2005
    VSB_JAC_RUIFENG_3 = 22,  // 江淮-瑞风M5-2012,2011
    VSB_JAC_RUIFENG_4 = 23,  // 江淮-瑞风S5-2013
    VSB_JAC_RUIYING_1 = 24,  // 江淮-瑞鹰-2009,2007
    VSB_JAC_RUIYING_2 = 25,  // 江淮-瑞鹰-2013,2012,2011
    VSB_JAC_JUNLING_2 = 26,  // 江淮-骏铃-窄体版,中体版
    VSB_JAC_WEILING_1 = 27,  // 江淮-威铃-厢式轻卡
    VSB_JAC_SHUAILING_1 = 28,  // 江淮-帅铃-五十铃
    VSB_JAC_RUILING_1 = 29,  // 江淮-瑞铃-2012
    VSB_JAC_JUNLING_1 = 30  // 江淮-骏铃-旗舰版
  );


//江铃子品牌类型
type
  VSB_JMC_CLASS =  
  (  
    VSB_JMC_OTHER = 0,  // 其他（保留）
    VSB_JMC_KAIYUN_1 = 1,  // 江铃-凯运-102,109马力轻卡
    VSB_JMC_KAIYUN_2 = 2,  // 江铃-凯运-95马力轻卡
    VSB_JMC_YUHU_1 = 3,  // 江铃-域虎-2012
    VSB_JMC_BAODIAN_1 = 4,  // 江铃-宝典-2007
    VSB_JMC_BAODIAN_2 = 5,  // 江铃-宝典-2009标准型,2008
    VSB_JMC_BAODIAN_3 = 6,  // 江铃-宝典-2014,2012,2009豪华型
    VSB_JMC_BAOWEI_1 = 7,  // 江铃-宝威-2005
    VSB_JMC_BAOWEI_2 = 8,  // 江铃-宝威-2009
    VSB_JMC_QUANSHUN_1 = 9,  // 江铃-福特新世代全顺-2010,2008
    VSB_JMC_QUANSHUN_2 = 10,  // 江铃-经典全顺-2006
    VSB_JMC_QUANSHUN_3 = 11,  // 江铃-经典全顺-2013,2011,2010
    VSB_JMC_SHUNDA_1 = 12,  // 江铃-顺达-2004,2003
    VSB_JMC_SHUNDA_2 = 13,  // 江铃-顺达-2011,2010,2008
    VSB_JMC_YUSHENG_1 = 14,  // 江铃-驭胜-2013
    VSB_JMC_YUSHENG_2 = 15  // 江铃-驭胜-2013手动特装版,2012,2011
  );

// 沃尔沃子品牌类型
type
  VSB_VOLVO_CLASS =  
  (  
    VSB_VOLVO_OTHER = 0,  // 其他（保留）
    VSB_VOLVO_C30_1 = 1,  // 沃尔沃-C30-2013,2012,2011,2010
    VSB_VOLVO_S40_1 = 2,  // 沃尔沃-S40-2012,2011,2010,2009,2008,2007
    VSB_VOLVO_S60_1 = 3,  // 沃尔沃-S60-2003
    VSB_VOLVO_S60_2 = 4,  // 沃尔沃-S60-2013,2012,2011
    VSB_VOLVO_S80L_1 = 5,  // 沃尔沃-S80L-2012,2011,2010,2009
    VSB_VOLVO_XC60_1 = 6,  // 沃尔沃-XC60-2013,2012,2011,2010,2009
    VSB_VOLVO_XC90_1 = 7  // 沃尔沃-XC90-2013,2012,2011,2008
  );

// 海格子品牌类型
type
  VSB_HIGER_CLASS =  
  (  
    VSB_HIGER_OTHER = 0,  // 其他（保留）
    VSB_HIGER_H8_1 = 1,  // 海格-H8-A款
    VSB_HIGER_H92_1 = 2,  // 海格-H92-A款
    VSB_HIGER_V7_1 = 3,  // 海格-V7,V8-2006
    VSB_HIGER_KECHE_1 = 4,  // 海格-客车车型5-A款
    VSB_HIGER_LONGWEI_1 = 5,  // 海格-龙威-2012,2011
    VSB_HIGER_H7V_1 = 6  // 海格-海格H7V-2010
  );

// 瑞麒子品牌类型
type
  VSB_RUILIN_CLASS =  
  (  
    VSB_RUILIN_OTHER = 0,  // 其他（保留）
    VSB_RUILIN_G3_1 = 1,  // 瑞麒-G3-2012,2010
    VSB_RUILIN_G5_1 = 2,  // 瑞麒-G5-2012,2011,2010
    VSB_RUILIN_M1_1 = 3,  // 瑞麒-M1-2013,2011,2010,2009
    VSB_RUILIN_X1_1 = 4,  // 瑞麒-X1-2012A,2011,2010
    VSB_RUILIN_X1_2 = 5  // 瑞麒-X1-2012B
  );

// 申龙子品牌类型
type
  VSB_SHENLONG_CLASS =  
  (  
    VSB_SHENLON_OTHER = 0,  // 其他（保留）
    VSB_SHENLONG_KECHE_1 = 1  //申龙客车-客车车型4-A款
  );

// 福田子品牌类型
type
  VSB_FOTON_CLASS =  
  (  
    VSB_FOTON_OTHER = 0,  // 其他（保留）
    VSB_FOTON_AOLING_1 = 1,  // 福田-奥铃-中卡
    VSB_FOTON_AOLING_2 = 2,  // 福田-奥铃-厢式货车
    VSB_FOTON_AOLING_3 = 3,  // 福田-奥铃-奥铃TX,CTX
    VSB_FOTON_OUMAN_1 = 4,  // 福田-欧曼-GTL6系B
    VSB_FOTON_OUMAN_2 = 5,  // 福田-欧曼-TX6系,9系
    VSB_FOTON_OUMAN_3 = 6,  // 福田-欧曼-欧曼重卡1
    VSB_FOTON_OUMAN_4 = 7,  // 福田-欧曼-雄狮6系,9系
    VSB_FOTON_OUHUI_1 = 8,  // 福田-欧辉客车-D款
    VSB_FOTON_OUMAKE_1 = 9,  // 福田-欧马可-3系
    VSB_FOTON_OUMAKE_2 = 10,  // 福田-欧马可-5系
    VSB_FOTON_SAPU_1 = 11,  // 福田-萨普-2011
    VSB_FOTON_SAPU_3 = 12,  // 福田-萨普-2011柴油共轨
    VSB_FOTON_MENGPAIKE_1 = 13,  // 福田-蒙派克-2013
    VSB_FOTON_MIDI_1 = 14,  // 福田-迷迪-2011,2009
    VSB_FOTON_FENGJING_1 = 15,  // 福田-风景系列-2012,2011,2009
    VSB_FOTON_SAPU_2 = 16  // 福田-萨普-2011四驱征服者Z7
  );

//福迪子品牌类型
type
  VSB_FODAY_CLASS =  
  (  
    VSB_FODAY_OTHER = 0,  // 其他（保留）
    VSB_FODAY_CHAOREN_1 = 1,  // 福迪-小超人皮卡-2009,2006
    VSB_FODAY_CHAOREN_2 = 2,  // 福迪-小超人皮卡-2011
    VSB_FODAY_TANSUOZHE_1 = 3,  // 福迪-探索者6-2013,2011,2010
    VSB_FODAY_TANSUOZHE_2 = 4,  // 福迪-探索者Ⅱ-2011,2010,2009
    VSB_FODAY_TANSUOZHE_3 = 5,  // 福迪-探索者Ⅲ-2011,2004
    VSB_FODAY_XIONGSHI_1 = 6  // 福迪-雄狮F16皮卡-2012
  );

// 红旗子品牌类型
type
  VSB_HONGQI_CLASS =  
  (  
    VSB_HONGQI_OTHER = 0,  // 其他（保留）
    VSB_HONGQI_MINGSHI_1 = 1  // 红旗-明仕-2007,2003,2001,2000,1999
  );


// 纳智捷 子品牌类型
type
  VSB_LUXGEN_CLASS =  
  (  
    VSB_LUXGEN_OTHER = 0,  // 其他（保留）
    VSB_LUXGEN_DASEVEN_1 = 1  // 纳智捷-大7-SUV
  );

// 夏利子品牌类型
type
  VSB_XIALI_CLASS =  
  (  
    VSB_XIALI_OTHER = 0,  // 其他（保留）
    VSB_XIALI_QIBING_1 = 1  // 美亚(夏利)-奇兵-2010
  );

// 舒驰客车子品牌类型
type
  VSB_SHUCHI_CLASS =  
  (  
    VSB_SHUCHI_OTHER = 0,  // 其他（保留）
    VSB_SHUCHI_A_1 = 1  // 舒驰客车-客车-A款
  );

//英菲尼迪子品牌类型
type
  VSB_INFINITI_CLASS =  
  (  
    VSB_INFINITI_OTHER = 0,  // 其他（保留）
    VSB_INFINITI_EX_1 = 1,  // 英菲尼迪-EX-2013,2011,2010,2009,2008
    VSB_INFINITI_FX_1 = 2,  // 英菲尼迪-FX-2007
    VSB_INFINITI_FX_2 = 3,  // 英菲尼迪-FX-2011,2010,2009
    VSB_INFINITI_FX_3 = 4,  // 英菲尼迪-FX-2013,2012FX35
    VSB_INFINITI_G_1 = 5,  // 英菲尼迪-G-2013,2010
    VSB_INFINITI_JX_1 = 6  // 英菲尼迪-JX-2013,2011
  );


// 莲花子品牌类型
type
  VSB_LOTUS_CLASS =  
  (  
    VSB_LOTUS_OTHER = 0,  // 其他（保留）
    VSB_LOTUS_L3_1 = 1,  // 莲花-L3三厢-2010豪华型,2009
    VSB_LOTUS_L3_2 = 2  // 莲花-L5三厢-2012,2011
  );

//菲亚特子品牌类型
type
  VSB_FIAT_CLASS =  
  (  
    VSB_FIAT_OTHER = 0,  // 其他（保留）
    VSB_FIAT_FEIYUE_1 = 1  // 菲亚特-菲跃-2014,2013,2012
  );

//讴歌子品牌类型
type
  VSB_OGA_CLASS =  
  (  
    VSB_OGA_OTHER = 0,  // 其他（保留）
    VSB_OGA_MDX_1 = 1,  // 讴歌-MDX-2010
    VSB_OGA_MDX_2 = 2  // 讴歌-MDX-2011
  );



// 跃进子品牌类型
type
  VSB_YUEJIN_CLASS =  
  (  
    VSB_YUEJIN_OTHER = 0,  // 其他（保留）
    VSB_YUEJIN_SHUAIHU_1 = 1,  // 跃进-帅虎-H100,H300
    VSB_YUEJIN_CAISHEN_1 = 2,  // 跃进-财神-S100
    VSB_YUEJIN_CAISHEN_2 = 3,  // 跃进-财神-S300
    VSB_YUEJIN_CAISHEN_3 = 4  // 跃进-财神-S500
  );

//野马子品牌类型
type
  VSB_YEMA_CLASS =  
  (  
    VSB_YEMA_OTHER = 0,  // 其他（保留）
    VSB_YEMA_F99_1 = 1  // 野马-F99-2012,2011,2010,2009
  );

//金龙子品牌类型
type
  VSB_SZKINGLONG_CLASS =  
  (  
    VSB_SZKINGLONG_OTHER = 0,  // 其他（保留）
    VSB_SZKINGLONG_BUS11_1 = 1,  // 金龙-客车车型11-A款
    VSB_SZKINGLONG_BUS12_1 = 2,  // 金龙-客车车型12-A款
    VSB_SZKINGLONG_BUS13_1 = 3,  // 金龙-客车车型13-A款
    VSB_SZKINGLONG_BUS14_1 = 4,  // 金龙-客车车型14-A款
    VSB_SZKINGLONG_BUS16_1 = 5,  // 金龙-客车车型16-A款
    VSB_SZKINGLONG_BUS18_1 = 6,  // 金龙-客车车型18-A款
    VSB_SZKINGLONG_BUS1_1 = 7,  // 金龙-客车车型1-A款
    VSB_SZKINGLONG_BUS20_1 = 8,  // 金龙-客车车型20-A款
    VSB_SZKINGLONG_BUS2_1 = 9,  // 金龙-客车车型2-A款
    VSB_SZKINGLONG_BUS5_1 = 10,  // 金龙-客车车型5-A款
    VSB_SZKINGLONG_BUS6_1 = 11,  // 金龙-客车车型6-A款
    VSB_SZKINGLONG_BUS9_1 = 12,  // 金龙-客车车型9-A款
    VSB_SZKINGLONG_BUS10_1 = 13,  // 金龙-客车车型10-A款
    VSB_SZKINGLONG_BUS15_1 = 14  // 金龙-客车车型15-A款
  );

//长丰猎豹子品牌类型
type
  VSB_CHANGFENG_CLASS =  
  (  
    VSB_CHANGFENG_OTHER = 0,  // 其他（保留）
    VSB_CHANGFENG_CS7_1 = 1,  // 长丰猎豹-CS7-2009
    VSB_CHANGFENG_QIBING_1 = 2,  // 长丰猎豹-奇兵-2010,2009
    VSB_CHANGFENG_LIEBAO_1 = 3,  // 长丰猎豹-猎豹CS6-2010,2008
    VSB_CHANGFENG_FULING_1 = 4,  // 长丰猎豹-福铃皮卡-A款
    VSB_CHANGFENG_FEIYANG_1 = 5,  // 长丰猎豹-飞扬皮卡-2010,2009,2005
    VSB_CHANGFENG_FEITENG_1 = 6,  // 长丰猎豹-飞腾-2010,2009,2006
    VSB_CHANGFENG_BLACKJINGANG_1 = 7  // 长丰猎豹-黑金刚-2013,2010,2009,2008,2006
  );

//陆风子品牌类型
type
  VSB_LUFENG_CLASS =  
  (  
    VSB_LUFENG_OTHER = 0,  // 其他（保留）
    VSB_LUFENG_X6_1 = 1,  // 陆风-X6-2005
    VSB_LUFENG_X6_2 = 2,  // 陆风-X6-2006
    VSB_LUFENG_X6_3 = 3,  // 陆风-X6-2011,2010,2008,2007
    VSB_LUFENG_LUFENGX5_1 = 4,  // 陆风-陆风X5-2013
    VSB_LUFENG_LUFENGX8_1 = 5,  // 陆风-陆风X8-2013,2012,2011,2009
    VSB_LUFENG_LUFENGX8_2 = 6,  // 陆风-陆风X8-2014,2012探索版
    VSB_LUFENG_FENGHUA_1 = 7,  // 陆风-风华-2008,2007
    VSB_LUFENG_X6_4 = 8,  // 陆风-X6-2011两驱
    VSB_LUFENG_FENGSHANG_1 = 9  // 陆风-风尚-2011,2006
  );

//陕汽重卡子品牌类型
type
  VSB_SHANQI_CLASS =  
  (  
    VSB_SHANQI_OTHER = 0,  // 其他（保留）
    VSB_SHANQI_AOLONG_1 = 1,  // 陕汽重卡-奥龙-重卡A
    VSB_SHANQI_AOLONG_2 = 2,  // 陕汽重卡-奥龙-重卡B
    VSB_SHANQI_DELONG_1 = 3,  // 陕汽重卡-德龙F2000-4X2牵引车
    VSB_SHANQI_DELONG_2 = 4,  // 陕汽重卡-德龙F3000-B款
    VSB_SHANQI_DELONG_3 = 5  // 陕汽重卡-德龙M3000-重卡
  );


//野马子品牌类型
type
  VSB_RENAULT_CLASS =  
  (  
    VSB_RENAULT_OTHER = 0,  // 其他（保留）
    VSB_RENAULT_MEIGANNA_1 = 1,  // 雷诺-梅甘娜-2006
    VSB_RENAULT_KELEIAO_1 = 2,  // 雷诺-科雷傲-2010,2009
    VSB_RENAULT_KELEIAO_2 = 3,  // 雷诺-科雷傲-2013,2012
    VSB_RENAULT_SCENE_1 = 4,  // 雷诺-风景-2007
    VSB_RENAULT_FENGLANG_1 = 5,  // 雷诺-风朗-2011
    VSB_RENAULT_TAFEIKE_1 = 6  // 雷诺-塔菲克-2004
  );

//黄海子品牌类型
type
  VSB_HUANGHAI_CLASS =  
  (  
    VSB_HUANGHAI_OTHER = 0,  // 其他（保留）
    VSB_HUANGHAI_DACAISHEN_1 = 1,  // 黄海-大柴神-2013,2012
    VSB_HUANGHAI_DACAISHEN_2 = 2,  // 黄海-大柴神-2013,2012,2011,2010,2009柴油版
    VSB_HUANGHAI_BUS4_1 = 3,  // 黄海-客车车型4-2012,2011
    VSB_HUANGHAI_CHALLENGER_1 = 4,  // 黄海-挑战者-2011,2010,2009,2008
    VSB_HUANGHAI_AOLONGCUV_1 = 5,  // 黄海-翱龙CUV-2010,2009
    VSB_HUANGHAI_AOJUN_1 = 6,  // 黄海-傲骏-2009
    VSB_HUANGHAI_AOJUN_2 = 7,  // 黄海-傲骏-2010,2009
    VSB_HUANGHAI_QISHENGV3_1 = 8,  // 黄海-旗胜V3-2011
    VSB_HUANGHAI_LINGHANGZHE_1 = 9,  // 黄海-领航者-2007,2005
    VSB_HUANGHAI_FENGCHI_1 = 10  // 黄海-风驰-A款
  );

//*******************车辆品牌子类型End************************

//车辆信息
type
  NET_DVR_VEHICLE_INFO = record 
    dwIndex: DWORD;  //车辆序号
    byVehicleType: BYTE;  //车辆类型 0 表示其它车型，1 表示小型车，2 表示大型车 ,3表示行人触发 ,4表示二轮车触发 5表示三轮车触发(3.5Ver)  6表示机动车触发
    byColorDepth: BYTE;  //车身颜色深浅
    byColor: BYTE;  //车身颜色,参考VCR_CLR_CLASS
    {雷达异常状态：
    0~雷达正常，
    1~雷达故障
    2~雷达一直发送某一个相同速度值
    3~雷达送出数据为0
    4~雷达送出数据过大或者过小
    }
    byRadarState: BYTE;  
    wSpeed: WORD;  //单位km/h
    wLength: WORD;  //前一辆车的车身长度
                            {违规类型，0-正常，1-低速，2-超速，3-逆行，4-闯红灯,5-压车道线,6-不按导向，7-路口滞留，
                            8-机占非，9-违法变道，10-不按车道 11-违反禁令，12-路口停车，13-绿灯停车, 14-未礼让行人(违法代码1357),
    15-违章停车，16-违章掉头,17-占用应急车道,18-禁右,19-禁左,20-压黄线,21-未系安全带,22-行人闯红灯,23-加塞,24-违法使用远光灯，
    25-驾驶时拨打接听手持电话，26-左转不让直行，27-右转不让左转，28-掉头不让直行，29-大弯小转, 30-闯绿灯，31-未带头盔，
    32-非机动车载人，33-非机动车占用机动车道，34-非机动车打伞棚, 35-黑烟车, 36-鸣笛,37-压线停车,38-跨位停车,39-压线且跨位停车,
    40-不让右方道路来车先行,41-进入环形路口未让已在路口内的机动车先行,42-机动车从匝道进入主路未让行,43-大车占道,44-炸街,45-吸烟
    }
    byIllegalType: BYTE;  
    byVehicleLogoRecog: BYTE;  //参考枚举类型 VLR_VEHICLE_CLASS
    byVehicleSubLogoRecog: BYTE;  //车辆品牌子类型识别；参考VSB_VOLKSWAGEN_CLASS等子类型枚举。
    byVehicleModel: BYTE;  //车辆子品牌年款，0-未知，参考"车辆子品牌年款.xlsx"
    byCustomInfo: array[0..16-1] of BYTE;  //自定义信息
    wVehicleLogoRecog: WORD;  //车辆主品牌，参考"车辆主品牌.xlsx" (该字段兼容byVehicleLogoRecog);
    byIsParking: BYTE;  //是否停车 0-无效，1-停车，2-未停车
    byRes: BYTE;  //保留字节
    dwParkingTime: DWORD;  //停车时间，单位：s
    byBelieve: BYTE;  //byIllegalType置信度，1-100
    byCurrentWorkerNumber: BYTE;  //当前作业人数
    byCurrentGoodsLoadingRate: BYTE;  //当前货物装载率 0-空 1-少 2-中 3-多 4-满
    byDoorsStatus: BYTE;  //车门状态 0-车门关闭 1-车门开启
    byRes3: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_INFO = ^NET_DVR_VEHICLE_INFO;

//车牌检测结果
type
  NET_DVR_PLATE_RESULT = record 
    dwSize: DWORD;  //结构长度
    byResultType: BYTE;  //0-视频识别结果，1图像识别结果 2 大于10M时走下载路线
    byChanIndex: BYTE;  //通道号
    wAlarmRecordID: WORD;  //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    dwRelativeTime: DWORD;  //相对时间点
    byAbsTime: array[0..32-1] of BYTE;  //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999（毫秒）
    dwPicLen: DWORD;  //图片长度(近景图)
    dwPicPlateLen: DWORD;  //车牌小图片长度
    dwVideoLen: DWORD;  //录像内容长度
    byTrafficLight: BYTE;  //0-非红绿灯抓拍，1-绿灯时抓拍；2-红灯时抓拍
    byPicNum: BYTE;  //连拍的图片序号
    byDriveChan: BYTE;  //触发车道号
    byVehicleType: BYTE;  //车辆类型，参考VTR_RESULT
    dwBinPicLen: DWORD;  //车牌二值图长度
    dwCarPicLen: DWORD;  //车辆原图长度
    dwFarCarPicLen: DWORD;  //远景图长度
    pBuffer3: PBYTE;  //车牌二值图
    pBuffer4: PBYTE;  //车辆原图
    pBuffer5: PBYTE;  //远景图
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byCarDirectionType: BYTE;  //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    byRes3: array[0..6-1] of BYTE;  
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    pBuffer1: PBYTE;  // 当上传的是图片(近景图)，指针指向图片信息，当上传的是视频，指针指向视频信息，如果不想获得图片或视频信息，传NULL(DVS车辆近景图)
    pBuffer2: PBYTE;  // 当上传的是图片(车牌图)时，指向车牌图片的指针（DVS车牌彩图）
  end;
  LPNET_DVR_PLATE_RESULT = ^NET_DVR_PLATE_RESULT;
//后面紧跟图片数据和录像数据，只传一种，图片数据为场景图片+车牌小图片

type
  NET_VPD_SHUTTER = record 
    dwCommmand: DWORD;  //命令:0,不控制 1,调亮 2,调暗 3,保持 4,直接输入快门值
    dwCode: DWORD;  //快门值, 当参数dwCommmand为4, 该参数不能为空
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_VPD_SHUTTER = ^NET_VPD_SHUTTER;

//图像叠加信息配置
type
  NET_DVR_IMAGEOVERLAYCFG = record 
    dwSize: DWORD;  
    byOverlayInfo: BYTE;  //叠加使能开关，0-不叠加，1-叠加
    byOverlayMonitorInfo: BYTE;  //是否叠加显示点信息，0-不叠加，1-叠加
    byOverlayTime: BYTE;  //是否叠加时间，0-不叠加，1-叠加
    byOverlaySpeed: BYTE;  //是否叠加速度，0-不叠加，1-叠加
    byOverlaySpeeding: BYTE;  //是否叠加超速比例，0-不叠加，1-叠加
    byOverlayLimitFlag: BYTE;  //是否叠加限速标志，0-不叠加，1-叠加
    byOverlayPlate: BYTE;  //是否叠加车牌号，0-不叠加，1-叠加
    byOverlayColor: BYTE;  //是否叠加车身颜色，0-不叠加，1-叠加
    byOverlayLength: BYTE;  //是否叠加车长，0-不叠加，1-叠加
    byOverlayType: BYTE;  //是否叠加车型，0-不叠加，1-叠加
    byOverlayColorDepth: BYTE;  //是否叠加车身颜色深浅，0-不叠加，1-叠加
    byOverlayDriveChan: BYTE;  //是否叠加车道，0-不叠加，1-叠加
    byOverlayMilliSec: BYTE;  //叠加毫秒信息 0-不叠加，1-叠加
    byOverlayIllegalInfo: BYTE;  //叠加违章信息 0-不叠加，1-叠加
    byOverlayRedOnTime: BYTE;  //叠加红灯已亮时间 0-不叠加，1-叠加
    byFarAddPlateJpeg: BYTE;  //远景图是否叠加车牌截图,0-不叠加,1-叠加
    byNearAddPlateJpeg: BYTE;  //近景图是否叠加车牌截图,0-不叠加,1-叠加
    byRes1: array[0..3-1] of BYTE;  //保留
    byMonitorInfo1: array[0..32-1] of BYTE;  //显示点信息1
    byMonitorInfo2: array[0..44-1] of BYTE;  //检测点信息2
    byRes2: array[0..52-1] of BYTE;  //保留
  end;
  LPNET_DVR_IMAGEOVERLAYCFG = ^NET_DVR_IMAGEOVERLAYCFG;

//单IO触发抓拍功能配置
type
  NET_DVR_SNAPCFG = record 
    dwSize: DWORD;  
    byRelatedDriveWay: BYTE;  //触发IO关联的车道号
    bySnapTimes: BYTE;  //线圈抓拍次数，0-不抓拍，非0-连拍次数，目前最大5次
    wSnapWaitTime: WORD;  //抓拍等待时间，单位ms，取值范围[0,60000]
    wIntervalTime: array[0..MAX_INTERVAL_NUM-1] of WORD;  //连拍间隔时间，ms
    dwSnapVehicleNum: DWORD;  //抓拍车辆序号。
    struJpegPara: NET_DVR_JPEGPARA;  //抓拍图片参数
    byRes2: array[0..16-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_SNAPCFG = ^NET_DVR_SNAPCFG;

type
  ITC_MAINMODE_ABILITY =  
  (  
    ITC_MODE_UNKNOW = $0,  //无
    ITC_POST_MODE = $1,  //卡口模式
    ITC_EPOLICE_MODE = $2,  //电警模式
    ITC_POSTEPOLICE_MODE = $4  //卡式电警模式
  );

type
  ITC_RECOG_REGION_TYPE =  
  (  
    ITC_REGION_RECT = $0,  //矩形
    ITC_REGION_POLYGON = $1  //多边形
  );

type
  NET_DVR_SNAP_ABILITY = record 
    dwSize: DWORD;  
    byIoInNum: BYTE;  //IO输入口数
    byIoOutNum: BYTE;  //IO输出口数
    bySingleSnapNum: BYTE;  //单IO触发组数
    byLightModeArrayNum: BYTE;  //红绿灯模式组数
    byMeasureModeArrayNum: BYTE;  //测速模式组数
    byPlateEnable: BYTE;  //车牌识别能力
    byLensMode: BYTE;  //镜头模式0-CCD,1-CMOS
    byPreTriggerSupport: BYTE;  //是否支持原触发模式，0-支持，1-不支持
    dwAbilityType: DWORD;  //支持的触发模式能力，按位表示，定义见ITC_MAINMODE_ABILITY
    byIoSpeedGroup: BYTE;  //支持的IO测速组数
    byIoLightGroup: BYTE;  //支持的IO红绿灯组数
    byRecogRegionType: BYTE;  //牌识区域支持的类型，详见定义ITC_RECOG_REGION_TYPE
    bySupport: BYTE;  //设备能力，按位表示，0-不支持，1-支持
    // bySupport&0x1，表示是否支持扩展的字符叠加配置
    // bySupport&0x2，表示是否支持扩展的校时配置结构
    // bySupport&0x4, 表示是否支持多网卡(多网隔离)
    // bySupport&0x8, 表示是否支持网卡的bonding功能(网络容错)
    // bySupport&0x10, 表示是否支持语音对讲
    //2013-07-09 能力集返回
    wSupportMultiRadar: WORD;  // 设备能力，按位表示，0-不支持，1-支持
    // wSupportMultiRadar&0x1，表示 卡口RS485雷达 支持车道关联雷达处理
    // wSupportMultiRadar&0x2，表示 卡口虚拟线圈 支持车道关联雷达处理
    // wSupportMultiRadar&0x4，表示 混行卡口 支持车道关联雷达处理
    // wSupportMultiRadar&0x8，表示 视频检测 支持车道关联雷达处理
    byICRPresetNum: BYTE;  
    // 表示支持的ICR预置点（滤光片偏移点）数
    byICRTimeSlot: BYTE;  //表示支持的ICR的时间段数（1～8）
    bySupportRS485Num: BYTE;  //表示支持的RS485口的数量
    byExpandRs485SupportSensor: BYTE;  // 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSensor &0x1，表示电警车检器支持车检器
    // byExpandRs485SupportSensor &0x2，表示卡式电警车检器支持车检器
    byExpandRs485SupportSignalLampDet: BYTE;  // 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSignalLampDet &0x1，表示电警车检器支持外接信号灯检测器
    // byExpandRs485SupportSignalLampDet &0x2，表示卡式电警车检器支持外接信号灯检测器
    byRelayNum: BYTE;  // 表示支持继电器的个数 2013-11-04
    bySupport1: BYTE;  //设备能力，按位表示，0-不支持，1-支持
    // bySupport1&0x1，表示是否支持自定义校时信息配置
    // bySupport1&0x2,  表示是否支持视频触发优化方案
    // bySupport1&0x4,  表示是否支持DDNS配置方案
    // bySupport1&0x8,  表示是否支持获取设备当前触发模式接口命令
    // bySupport1&0x10, 表示是否支持出入口配置 2014-03-03
    // bySupport1&0x20,  表示是否支持GPS模块参数配置
    // bySupport1&0x40,  表示是否支持NTP校时间隔支持分钟设置
    // bySupport1&0x80,  表示是否支持tps报警数据上传
    bySupport2: BYTE;  //设备能力，按位表示，0-不支持，1-支持
    // bySupport2&0x01,  表示是否支持码流附加信息配置
    // bySupport2&0x02,  表示通道图像参数（INTER_PICCFG_V30）中是否支持视频叠加时间毫秒启用参数（byOSDMilliSecondEnable）
    // bySupport2&0x04,   表示道闸控制（NET_DVR_BARRIERGATE_CFG）中byBarrierGateCtrl字段支持索引4~解锁道闸，且支持byUnlock解锁使能。反之则标识不支持
    bySupportWhiteBalance: BYTE;  //白平衡能力，默认都是支持手动白平衡、自动白平衡、自动白平衡2这3种模式。
    // bySupportWhiteBalance &0x01,  表示是否支持日光灯模式
    // bySupportWhiteBalance &0x02,  表示是否支持自然光模式
    // bySupportWhiteBalance &0x04,  表示是否支持暖光灯模式
    // bySupportWhiteBalance &0x08,  表示是否支持白炽灯模式
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_SNAP_ABILITY = ^NET_DVR_SNAP_ABILITY;

type
  NET_DVR_TRANSFER_CAP = record 
    byAbility: BYTE;  
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_TRANSFER_CAP = ^NET_DVR_TRANSFER_CAP;

type
  NET_ITC_ICRTIMECFG = record 
    struTime: NET_DVR_SCHEDTIME;  
    byAssociateRresetNo: BYTE;  //预置点号1～8 , 0代表无
    bySubSwitchMode: BYTE;  //1~白天，2~晚上 (当预置点等于0 的时候生效)
    byRes: array[0..10-1] of BYTE;  
  end;
  LPNET_ITC_ICRTIMECFG = ^NET_ITC_ICRTIMECFG;

type
  NET_ITC_ICR_TIMESWITCH_PARAM = record //156
    struAutoCtrlTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_ITC_ICRTIMECFG;  //自动切换时间段 (自动切换下 时空下生效 现在支持4组，预留4组)
    byICRPreset: array[0..MAX_ICR_NUM-1] of BYTE;  //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_ITC_ICR_TIMESWITCH_PARAM = ^NET_ITC_ICR_TIMESWITCH_PARAM;

type
  NET_ITC_ICR_MANUALSWITCH_PARAM = record 
    byICRPreset: array[0..MAX_ICR_NUM-1] of BYTE;  //实际生效根据能力集动态显示 [0~100]
    bySubSwitchMode: BYTE;  //1~白天，2~晚上
    byRes: array[0..147-1] of BYTE;  
  end;
  LPNET_ITC_ICR_MANUALSWITCH_PARAM = ^NET_ITC_ICR_MANUALSWITCH_PARAM;

type
  NET_ITC_ICR_AOTOSWITCH_PARAM = record 
    byICRPreset: array[0..MAX_ICR_NUM-1] of BYTE;  //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    byICRAutoSwitch: BYTE;  // ICR自动切换加阈值选项, 取值范围[0 100]
    byRes: array[0..147-1] of BYTE;  
  end;
  LPNET_ITC_ICR_AOTOSWITCH_PARAM = ^NET_ITC_ICR_AOTOSWITCH_PARAM;

//算法自动
type
  NET_ITC_ICR_ALGAOTOSWITCH_PARAM = record 
    byDetectThreshold: BYTE;  //检测阈值,范围[0,100],默认 58
    byAbBrightnessThreshold: BYTE;  //异常亮度阈值，范围[0,100]，默认12
    byRes: array[0..154-1] of BYTE;  
  end;
  LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM = ^NET_ITC_ICR_ALGAOTOSWITCH_PARAM;

type
  NET_ITC_ICR_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..156-1] of BYTE);  
    1: (struICRAutoSwitch: NET_ITC_ICR_AOTOSWITCH_PARAM);  
    2: (struICRManualSwitch: NET_ITC_ICR_MANUALSWITCH_PARAM);  
    3: (struICRTimeSwitch: NET_ITC_ICR_TIMESWITCH_PARAM);  
    4: (strICRAlgorithmAutoSwitch: NET_ITC_ICR_ALGAOTOSWITCH_PARAM);  
  end;
  LPNET_ITC_ICR_PARAM_UNION = ^NET_ITC_ICR_PARAM_UNION;

type
  NET_ITC_ICRCFG = record 
    dwSize: DWORD;  
    bySwitchType: BYTE;  //1~自动切换，2~手动切换 ,3~定时切换,4~算法自动
    byRes: array[0..3-1] of BYTE;  
    uICRParam: NET_ITC_ICR_PARAM_UNION;  
  end;
  LPNET_ITC_ICRCFG = ^NET_ITC_ICRCFG;

//2013-07-09 异常处理
type
  NET_ITC_HANDLEEXCEPTION = record 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出（继电器输出）
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    byEnable: BYTE;  //0～不启用，1～启用
    byRes: BYTE;  
    wDuration: WORD;  //持续时间(单位/s)
    byAlarmOutTriggered: array[0..MAX_ITC_EXCEPTIONOUT-1] of BYTE;  //触发输出通道
    byRes1: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_HANDLEEXCEPTION = ^NET_ITC_HANDLEEXCEPTION;

type
  NET_ITC_EXCEPTION = record 
    dwSize: DWORD;  
    struSnapExceptionType: array[0..MAX_EXCEPTIONNUM_V30-1] of NET_ITC_HANDLEEXCEPTION;  //数组的每个元素都表示一种异常，数组0- 硬盘出错,1-网线断,2-IP 地址冲突, 3-车检器异常, 4-信号灯检测器异常
  end;
  LPNET_ITC_EXCEPTION = ^NET_ITC_EXCEPTION;

type
  NET_DVR_TRIGCOORDINATE = record 
    wTopLeftX: WORD;  //线圈左上角横坐标（2个字节）
    wTopLeftY: WORD;  //线圈左上角纵坐标（2个字节）
    wWdith: WORD;  //线圈宽度（2个字节）
    wHeight: WORD;  //线圈高度（2个字节）
  end;
  LPNET_DVR_TRIGCOORDINATE = ^NET_DVR_TRIGCOORDINATE;

type
  PROVINCE_CITY_IDX =  
  (  
    ANHUI_PROVINCE = 0,  //安徽
    AOMEN_PROVINCE = 1,  //澳门
    BEIJING_PROVINCE = 2,  //北京
    CHONGQING_PROVINCE = 3,  //重庆
    FUJIAN_PROVINCE = 4,  //福建
    GANSU_PROVINCE = 5,  //甘肃
    GUANGDONG_PROVINCE = 6,  //广东
    GUANGXI_PROVINCE = 7,  //广西
    GUIZHOU_PROVINCE = 8,  //贵州
    HAINAN_PROVINCE = 9,  //海南
    HEBEI_PROVINCE = 10,  //河北
    HENAN_PROVINCE = 11,  //河南
    HEILONGJIANG_PROVINCE = 12,  //黑龙江
    HUBEI_PROVINCE = 13,  //湖北
    HUNAN_PROVINCE = 14,  //湖南
    JILIN_PROVINCE = 15,  //吉林
    JIANGSU_PROVINCE = 16,  //江苏
    JIANGXI_PROVINCE = 17,  //江西
    LIAONING_PROVINCE = 18,  //辽宁
    NEIMENGGU_PROVINCE = 19,  //内蒙古
    NINGXIA_PROVINCE = 20,  //宁夏
    QINGHAI_PROVINCE = 21,  //青海
    SHANDONG_PROVINCE = 22,  //山东
    SHANXI_JIN_PROVINCE = 23,  //山西
    SHANXI_SHAN_PROVINCE = 24,  //陕西
    SHANGHAI_PROVINCE = 25,  //上海
    SICHUAN_PROVINCE = 26,  //四川
    TAIWAN_PROVINCE = 27,  //台湾
    TIANJIN_PROVINCE = 28,  //天津
    XIZANG_PROVINCE = 29,  //西藏
    XIANGGANG_PROVINCE = 30,  //香港
    XINJIANG_PROVINCE = 31,  //新疆
    YUNNAN_PROVINCE = 32,  //云南
    ZHEJIANG_PROVINCE = 33  //浙江
  );

type
  NET_DVR_GEOGLOCATION = record 
    iRes: array[0..2-1] of INT;  //保留
    dwCity: DWORD;  //城市，详见PROVINCE_CITY_IDX 
  end;
  LPNET_DVR_GEOGLOCATION = ^NET_DVR_GEOGLOCATION;

//场景模式
type
  SCENE_MODE =  
  (  
    UNKOWN_SCENE_MODE = 0,  //未知场景模式
    HIGHWAY_SCENE_MODE = 1,  //高速场景模式
    SUBURBAN_SCENE_MODE = 2,  //郊区场景模式(保留)
    URBAN_SCENE_MODE = 3,  //市区场景模式
    TUNNEL_SCENE_MODE = 4  //隧道场景模式(保留)
  );
// 私有信息模块类型
type
  PRIDATA_RENDER =  
  (  
    RENDER_ANA_INTEL_DATA = $00000001,  //智能分析
    RENDER_MD = $00000002,  //移动侦测
    RENDER_ADD_POS = $00000004,  //POS信息后叠加
    RENDER_ADD_PIC = $00000008,  //图片叠加
    RENDER_FIRE_DETCET = $00000010,  //热成像信息
    RENDER_TEM = $00000020,  //温度信息
    RENDER_TRACK_TEM = $00000040,  //信息
    RENDER_THERMAL = $00000080  //废气检测和烟火屏蔽信息
  );

type
  THERMAL_FLAG =  
  (  
    THERMAL_FIREMASK = $00000001,  //烟火屏蔽
    THERMAL_RULEGAS = $00000002,  //规则废气检测
    THERMAL_TARGETGAS = $00000004  //目标废气检测
  );

type
  FIRE_ALARM =    (  
    FIRE_FRAME_DIS = $00000001,  //火点框显示
    FIRE_MAX_TEMP = $00000002,  //最高温度
    FIRE_MAX_TEMP_POSITION = $00000004,  //最高温度位置显示
    FIRE_DISTANCE = $00000008  //最高温度距离>FIRE_ALARM
  );

type
  TEM_FLAG =    (  
    TEM_REGION_BOX = $00000001,  //框测温
    TEM_REGION_LINE = $00000002,  //线测温
    TEM_REGION_POINT = $00000004  //点测温>TEM_FLAG
  );

type
  TRACK_FLAG =  
  (  
    TRACK_PEOPLE = $00000001,  //人
    TRACK_VEHICLE = $00000002  //车
  );

type
  NET_DVR_VTPARAM = record 
    dwSize: DWORD;  
    byEnable: BYTE;  // 是否使能虚拟线圈，0-不使用，1-使用
    byIsDisplay: BYTE;  // 是否显示虚拟线圈，0-不显示，1-显示
    byLoopPos: BYTE;  //晚间触发线圈的偏向：0-向上，1-向下
    bySnapGain: BYTE;  //抓拍增益
    dwSnapShutter: DWORD;  //抓拍快门速度
    struTrigCoordinate: NET_DVR_TRIGCOORDINATE;  //保留
    struRes: array[0..MAX_VL_NUM-1] of NET_DVR_TRIGCOORDINATE;  
    byTotalLaneNum: BYTE;  //视频触发的车道数1
    byPolarLenType: BYTE;  //偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。
    byDayAuxLightMode: BYTE;  //白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明
    byLoopToCalRoadBright: BYTE;  //用以计算路面亮度的车道(虚拟线圈)
    byRoadGrayLowTh: BYTE;  //路面亮度低阈值初始化值1
    byRoadGrayHighTh: BYTE;  //路面亮度高阈值初始化值140
    wLoopPosBias: WORD;  //晚间触发线圈位移30
    dwHfrShtterInitValue: DWORD;  //连续图像曝光时间的初始值2000
    dwSnapShtterInitValue: DWORD;  //抓拍图像曝光时间的初始值500
    dwHfrShtterMaxValue: DWORD;  //连续图像曝光时间的最大值20000
    dwSnapShtterMaxValue: DWORD;  //抓拍图像曝光时间的最大值1500
    dwHfrShtterNightValue: DWORD;  //晚间连续图像曝光时间的设置值3000
    dwSnapShtterNightMinValue: DWORD;  //晚间抓拍图像曝光时间的最小值3000
    dwSnapShtterNightMaxValue: DWORD;  //晚间抓拍图像曝光时间的最大值5000
    dwInitAfe: DWORD;  //增益的初始值200
    dwMaxAfe: DWORD;  //增益的最大值400
    wResolutionX: WORD;  // 设备当前分辨率宽
    wResolutionY: WORD;  // 设备当前分辨率高
    dwGainNightValue: DWORD;  //晚间增益，默认值70
    dwSceneMode: DWORD;  //场景模式， 详见SCENE_MODE 
    dwRecordMode: DWORD;  //录像标志：0-不录像，1-录像
    struGeogLocation: NET_DVR_GEOGLOCATION;  //地址位置
    byTrigFlag: array[0..MAX_VL_NUM-1] of BYTE;  //触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
    byTrigSensitive: array[0..MAX_VL_NUM-1] of BYTE;  //触发灵敏度，1-100
    byRes2: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_VTPARAM = ^NET_DVR_VTPARAM;

type
  NET_DVR_SNAPENABLECFG = record 
    dwSize: DWORD;  
    byPlateEnable: BYTE;  //是否支持车牌识别，0-不支持，1-支持
    byRes1: array[0..2-1] of BYTE;  //保留
    byFrameFlip: BYTE;  //图像是否翻转 0-不翻转，1-翻转
    wFlipAngle: WORD;  //图像翻转角度 0,90,180,270
    wLightPhase: WORD;  //相位，取值范围[0, 360]
    byLightSyncPower: BYTE;  //是否信号灯电源同步，0-不同步；1-同步
    byFrequency: BYTE;  //信号频率
    byUploadSDEnable: BYTE;  //是否自动上传SD图片，0-否；1-是
    byPlateMode: BYTE;  //识别模式参数:0-视频触发,1-外部触发
    byUploadInfoFTP: BYTE;  //是否上传抓拍附加信息到FTP，0-否，1-是
    byAutoFormatSD: BYTE;  //是否自动格式化SD卡，0-否，1-是
    wJpegPicSize: WORD;  //Jpeg图片大小[64-8196]
    bySnapPicResolution: BYTE;  //抓拍图片分辨率(与NET_DVR_COMPRESSION_INFO_V30中分辨率保持一致)
    byRes: array[0..55-1] of BYTE;  //保留
  end;
  LPNET_DVR_SNAPENABLECFG = ^NET_DVR_SNAPENABLECFG;

//ftp上传参数
type
  NET_DVR_FTPCFG = record 
    dwSize: DWORD;  
    dwEnableFTP: DWORD;  //是否启动ftp上传功能
    sFTPIP: array[0..16-1] of AnsiChar;  //ftp 服务器
    dwFTPPort: DWORD;  //ftp端口
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码
    dwDirLevel: DWORD;  //0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录
    wTopDirMode: WORD;  // 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，0x4=使用显示点,0x5=使用时间(年月),0x=6自定义,0x7=违规类型,0x8=方向,0x9=地点
    wSubDirMode: WORD;  // 二级目录，0x1 = 使用通道名,0x2 = 使用通道号，,0x3=使用时间(年月日),0x4=使用车道号,0x=5自定义,0x6=违规类型,0x7=方向,0x8=地点
    byEnableAnony: BYTE;  //启用匿名，0-否，1-是
    byPicArchivingInterval: BYTE;  //图片归档间隔[1~30],0表示关闭
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_FTPCFG = ^NET_DVR_FTPCFG;

//可用来命名图片的相关元素 
const
  PICNAME_ITEM_DEV_NAME = 1;    //设备名
  PICNAME_ITEM_DEV_NO = 2;    //设备号
  PICNAME_ITEM_DEV_IP = 3;    //设备IP
  PICNAME_ITEM_CHAN_NAME = 4;    //通道名
  PICNAME_ITEM_CHAN_NO = 5;    //通道号
  PICNAME_ITEM_TIME = 6;    //时间
  PICNAME_ITEM_CARDNO = 7;    //卡号
  PICNAME_ITEM_PLATE_NO = 8;    //车牌号码
  PICNAME_ITEM_PLATE_COLOR = 9;    //车牌颜色
  PICNAME_ITEM_CAR_CHAN = 10;    //车道号
  PICNAME_ITEM_CAR_SPEED = 11;    //车辆速度
  PICNAME_ITEM_CARCHAN = 12;    //显示点
  PICNAME_ITEM_PIC_NUMBER = 13;    //图片序号
  PICNAME_ITEM_CAR_NUMBER = 14;    //车辆序号
  PICNAME_MAXITEM = 15;    

const
  PICNAME_ITEM_SPEED_LIMIT_VALUES = 15;    //限速值
  PICNAME_ITEM_ILLEGAL_CODE = 16;    //国标违法代码
  PICNAME_ITEM_CROSS_NUMBER = 17;    //路口编号
  PICNAME_ITEM_DIRECTION_NUMBER = 18;    //方向编号

//(3.7Ver)
const
  PICNAME_ITEM_CAR_COLOR = 19;    //车身颜色
  PICNAME_ITEM_PLATE_COORDINATE = 20;    //车牌坐标
  PICNAME_ITEM_CAR_TYPE = 21;    //车辆类型
  PICNAME_ITEM_VIOLATION_TYPE = 22;    //违规类型
  PICNAME_ITEM_CUSTOM = 255;    //自定义



//图片命名
type
  NET_DVR_PICTURE_NAME = record 
    byItemOrder: array[0..PICNAME_MAXITEM-1] of BYTE;  //    桉数组定义文件命名的规则 
    byDelimiter: BYTE;  //分隔符，一般为'_'
  end;
  LPNET_DVR_PICTURE_NAME = ^NET_DVR_PICTURE_NAME;

//命名规则：2013-09-27
const
  PICNAME_ITEM_PARK_DEV_IP = 1;    //设备IP
  PICNAME_ITEM_PARK_PLATE_NO = 2;    //车牌号码
  PICNAME_ITEM_PARK_TIME = 3;    //时间
  PICNAME_ITEM_PARK_INDEX = 4;    //车位编号
  PICNAME_ITEM_PARK_STATUS = 5;    //车位状态
  PICNAME_ITEM_BUILDING_NUMBER = 6;    //栋号单元号
  PICNAME_ITEM_OUTDOOR_UNIT_ID = 7;    //门口机编号
  PICNAME_ITEM_UNLOCK_TYPE = 8;    //开锁方式
  PICNAME_ITEM_DEVICE_NAME = 9;    //设备名称
  PICNAME_ITEM_PERIOD_NO = 10;    //期号
  PICNAME_ITEM_DEV_INDEX = 11;    //设备编号
  PICNAME_PREFIX = 32;    //图片名自定义前缀长度
//图片命名扩展 2013-09-27
type
  NET_DVR_PICTURE_NAME_EX = record 
    byItemOrder: array[0..PICNAME_MAXITEM-1] of BYTE;  //    桉数组定义文件命名的规则 
    byDelimiter: BYTE;  //分隔符，一般为'_'
    byPicNamePrefix: array[0..PICNAME_PREFIX{32}-1] of BYTE;  //图片名自定义前缀
  end;
  LPNET_DVR_PICTURE_NAME_EX = ^NET_DVR_PICTURE_NAME_EX;

// 串口抓图设置
type
  NET_DVR_SERIAL_CATCHPIC_PARA = record 
    byStrFlag: BYTE;  //串口数据开始符
    byEndFlag: BYTE;  //结束符
    wCardIdx: WORD;  //卡号相对起始位
    dwCardLen: DWORD;  //卡号长度
    dwTriggerPicChans: DWORD;  //所触发的通道号，按位，从第1位开始计，即0x2表示第一通道
  end;
  LPNET_DVR_SERIAL_CATCHPIC_PARA = ^NET_DVR_SERIAL_CATCHPIC_PARA;

//DVR抓图参数配置（基线）
type
  NET_DVR_JPEGCFG_V30 = record 
    dwSize: DWORD;  
    struJpegPara: array[0..MAX_CHANNUM_V30-1] of NET_DVR_JPEGPARA;  //每个通道的图像参数
    wBurstMode: WORD;  //抓图方式,按位设置.0x1=报警输入触发，0x2=移动侦测触发 0x4=232触发，0x8=485触发，0x10=网络触发
    wUploadInterval: WORD;  //图片上传间隔(秒)[0,65535]
    struPicNameRule: NET_DVR_PICTURE_NAME;  // 图片命名规则 
    bySaveToHD: BYTE;  //是否保存到硬盘
    byRes1: BYTE;  
    wCatchInterval: WORD;  //抓图间隔(毫秒)[0,65535]
    byRes2: array[0..12-1] of BYTE;  
    struRs232Cfg: NET_DVR_SERIAL_CATCHPIC_PARA;  
    struRs485Cfg: NET_DVR_SERIAL_CATCHPIC_PARA;  
    dwTriggerPicTimes: array[0..MAX_CHANNUM_V30-1] of DWORD;  // 每个通道一次触发拍照次数 
    dwAlarmInPicChanTriggered: array[0..MAX_ALARMIN_V30-1] of DWORD;  //报警触发抓拍通道,按位设置，从第1位开始
  end;
  LPNET_DVR_JPEGCFG_V30 = ^NET_DVR_JPEGCFG_V30;

//抓拍触发请求结构(保留)
type
  NET_DVR_MANUALSNAP = record 
    byOSDEnable: BYTE;  //0-不关闭(默认)，1-关闭
    byLaneNo: BYTE;  //车道号, 范围为1-6，默认为1(抓拍机内部测试使用)
    byChannel: BYTE;  //通道号
    byRes: array[0..21-1] of BYTE;  //保留
  end;
  LPNET_DVR_MANUALSNAP = ^NET_DVR_MANUALSNAP;

type
  NET_DVR_SPRCFG = record 
    dwSize: DWORD;  
    byDefaultCHN: array[0..MAX_CHJC_NUM-1] of BYTE;  //设备运行省份的汉字简写
    byPlateOSD: BYTE;  //0:不发送车牌彩色图,1:发送车牌彩色图
    bySendJPEG1: BYTE;  //0-不传送近景JPEG图,1-传送近景JPEG图
    bySendJPEG2: BYTE;  //0-不传送远景JPEG图,1-传送远景JPEG图
    wDesignedPlateWidth: WORD;  //车牌设计宽度
    byTotalLaneNum: BYTE;  //识别的车道数
    byRes1: BYTE;  //保留
    wRecognizedLane: WORD;  //识别的车道号，按位表示，bit0表示车道1是否识别，0-不识别，1-识别
    struLaneRect: array[0..MAX_LANERECT_NUM-1] of NET_VCA_RECT;  //车道识别区域
    dwRecogMode: DWORD;  {识别的类型，
                                                                      bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
                                                                      bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
                                                                      bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
                                                                      bit3-农用车识别：0-不采用农用车识别，1-农用车识别；
                                                                      bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
                                                                      bit5-帧定位或场定位：0-帧定位，1-场定位；
                                                                      bit6-帧识别或场识别：0-帧识别，1-场识别；
                                                  bit7-晚上或白天：0-白天，1-晚上 }
    bySendPRRaw: BYTE;  //是否发送原图：0-不发送，1-发送
    bySendBinImage: BYTE;  //是否发送车牌二值图：0-不发送，1-发送
    byDelayCapture: BYTE;  //延时抓拍控制,单位：帧
    byUseLED: BYTE;  //使用LED控制，0-否，1-是
    byRes2: array[0..68-1] of BYTE;  //保留
  end;
  LPNET_DVR_SPRCFG = ^NET_DVR_SPRCFG;

type
  NET_DVR_PLCCFG = record 
    dwSize: DWORD;  
    byPlcEnable: BYTE;  //是否启用车牌亮度补偿（默认启用）：0-关闭，1-启用
    byPlateExpectedBright: BYTE;  //车牌的预期亮度（默认值50）, 范围[0, 100]
    byRes1: array[0..2-1] of BYTE;  //保留
    byTradeoffFlash: BYTE;  //是否考虑闪光灯的影响: 0 - 否;  1 - 是(默认);
    //使用闪光灯补光时, 如果考虑减弱闪光灯的亮度增强效应, 则需要设为1;否则为0
    byCorrectFactor: BYTE;  //纠正系数, 范围[0, 100], 默认值50 (在tradeoff_flash切换时,恢复默认值）
    wLoopStatsEn: WORD;  //是否该线圈的亮度，按位表示，0-不统计，1-统计
    byPlcBrightOffset: BYTE;  // 车牌亮度补偿灵敏度(虚拟线圈模式起效)，取值范围1~100
    byRes: array[0..19-1] of BYTE;  
  end;
  LPNET_DVR_PLCCFG = ^NET_DVR_PLCCFG;

type
  NET_DVR_DEVICESTATECFG = record 
    dwSize: DWORD;  
    wPreviewNum: WORD;  //预览连接个数
    wFortifyLinkNum: WORD;  //布防连接个数
    struPreviewIP: array[0..MAX_LINK-1] of NET_DVR_IPADDR;  //预览的用户IP地址
    struFortifyIP: array[0..MAX_FORTIFY_NUM-1] of NET_DVR_IPADDR;  //布防连接的用户IP地址
    dwVideoFrameRate: DWORD;  //帧率：0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    byResolution: BYTE;  //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    bySnapResolution: BYTE;  //抓拍分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    byStreamType: BYTE;  //传输类型：0-主码流；1-子码流
    byTriggerType: BYTE;  //触发模式：0-视频触发；1-普通触发
    dwSDVolume: DWORD;  //SD卡容量
    dwSDFreeSpace: DWORD;  //SD卡剩余空间
    byDetectorState: array[0..MAX_DRIVECHAN_NUM-1, 0..MAX_COIL_NUM-1] of BYTE;  //车检器状态：0-未使用；1-正常；2-异常
    byDetectorLinkState: BYTE;  //车检器连接状态：0-未连接；1-连接
    bySDStatus: BYTE;  //SD卡状态 0－活动；1－休眠；2－异常，3-无sd卡
    byFortifyLevel: array[0..MAX_FORTIFY_NUM-1] of BYTE;  //布防等级，0-无，1-一等级（高），2-二等级（中），3-三等级（低）
    byRes2: array[0..116-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEVICESTATECFG = ^NET_DVR_DEVICESTATECFG;

type
  NET_DVR_POSTEPOLICECFG = record 
    dwSize: DWORD;  
    dwDistance: DWORD;  //线圈距离,单位cm，取值范围[0,20000]
    dwLightChan: array[0..MAX_SIGNALLIGHT_NUM-1] of DWORD;  //信号灯通道号
    byCapSpeed: BYTE;  //标志限速，单位km/h，取值范围[0,255]
    bySpeedLimit: BYTE;  //限速值，单位km/h，取值范围[0,255]
    byTrafficDirection: BYTE;  //车流方向，0-由东向西，1-由西向东，2-由南向北，3-由北向南
    byRes1: BYTE;  //保留
    wLoopPreDist: WORD;  //触发延迟距离 ，单位：分米
    wTrigDelay: WORD;  //触发硬延时时间 ，单位：毫秒
    byRes: array[0..124-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_POSTEPOLICECFG = ^NET_DVR_POSTEPOLICECFG;


//信号灯异常检测
type
  NET_DVR_SIGNALLAMP_DETCFG = record 
    dwSize: DWORD;  //结构长度
    //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    byAbsTime: array[0..32-1] of BYTE;  
    struAlarmCamIP: NET_DVR_IPADDR;  //报警摄像机IP
    dwPic1Len: DWORD;  //异常图片1长度
    dwPic2Len: DWORD;  //异常图片2长度
    pPic1Buffer: PAnsiChar;  //数据指针  叠加车道线图片
    pPic2Buffer: PAnsiChar;  //数据指针  叠加信号灯状态图片
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SIGNALLAMP_DETCFG = ^NET_DVR_SIGNALLAMP_DETCFG;

type
  NET_DVR_EXDEVDET_COND = record 
    dwSize: DWORD;  // 结构体大小
    dwChannel: DWORD;  //通道号
    byExternalDevType: BYTE;  // 0-无效值（保留）1-信号灯,2-闪光灯
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_EXDEVDET_COND = ^NET_DVR_EXDEVDET_COND;

type
  NET_DVR_EXDEVDET_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byExternalDevStatus: BYTE;  // 0-正常1-异常
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_EXDEVDET_CFG = ^NET_DVR_EXDEVDET_CFG;

//**************************** end ********************************************

//  IPC_PROTOCOL_NUM = 50;    //ipc 协议最大个数

//协议类型
type
  NET_DVR_PROTO_TYPE = record 
    dwType: DWORD;  //ipc协议值
    byDescribe: array[0..DESC_LEN-1] of BYTE;  //协议描述字段
  end;
  LPNET_DVR_PROTO_TYPE = ^NET_DVR_PROTO_TYPE;

//协议列表
type
  NET_DVR_IPC_PROTO_LIST = record 
    dwSize: DWORD;  
    dwProtoNum: DWORD;  //有效的ipc协议数目
    struProto: array[0..IPC_PROTOCOL_NUM-1] of NET_DVR_PROTO_TYPE;  //有效的ipc协议
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_IPC_PROTO_LIST = ^NET_DVR_IPC_PROTO_LIST;

//协议列表V41
type
  NET_DVR_IPC_PROTO_LIST_V41 = record 
    dwSize: DWORD;  
    dwProtoNum: DWORD;  //有效的ipc协议数目
    pBuffer: PBYTE;  //协议列表缓冲区, dwProtoNum 个NET_DVR_PROTO_TYPE结构
    dwBufferLen: DWORD;  //缓冲区长度
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IPC_PROTO_LIST_V41 = ^NET_DVR_IPC_PROTO_LIST_V41;

type
  NET_DVR_PTZPOS_INFO = record 
    dwPanPos: DWORD;  // P参数（水平参数）
    dwTiltPos: DWORD;  // T参数（垂直参数）
    dwZoomPos: DWORD;  // Z参数（变倍参数）
  end;
  LPNET_DVR_PTZPOS_INFO = ^NET_DVR_PTZPOS_INFO;

//人体特征识别结果结构体
type
  NET_VCA_HUMAN_FEATURE = record 
    byGroup: BYTE;  //段
    bySex: BYTE;  //性别, 0-表示“未知”（算法不支持）,1 C 男 , 2 C 女, 0xff-算法支持，但是没有识别出来
    byEyeGlass: BYTE;  //是否戴眼镜 0-表示“未知”（算法不支持）,1 C不戴, 2 C戴眼镜, 3 C戴墨镜,0xff-算法支持，但是没有识别出来
    //抓拍图片人脸的使用方式，如byRes3为15,byDeviation为1,表示，实际人脸图片的为14-16之间
    byRes3: BYTE;  // 0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
    byDeviation: BYTE;  //误差值
    byRes0: BYTE;  
    byMask: BYTE;  //是否戴口罩 0-表示“未知”（算法不支持）,1 C 不戴, 2 C 戴, 0xff-算法支持，但是没有识别出来
    bySmile: BYTE;  //是否微笑 0-表示“未知”（算法不支持）,1 C 不微笑, 2 C 微笑, 0xff-算法支持，但是没有识别出来
    byFaceExpression: BYTE;  // 表情,参见FACE_EXPRESSION_GROUP_ENUM
    byRes1: BYTE;  
    byRes2: BYTE;  
    byHat: BYTE;  // 帽子, 0-不支持,1-不戴帽子,2-戴帽子, 3-头盔 0xff-unknow表示未知,算法支持未检出
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_VCA_HUMAN_FEATURE = ^NET_VCA_HUMAN_FEATURE;

//物体颜色属性
type
  NET_DVR_OBJECT_FEATURE = record 
    byColorRatel: BYTE;  //颜色在移动物体中的占比阈值
    byRed: BYTE;  // RGB颜色三分量中的红色
    byGreen: BYTE;  // RGB颜色三分量中的绿色
    byBlue: BYTE;  // RGB颜色三分量中的兰色
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OBJECT_FEATURE = ^NET_DVR_OBJECT_FEATURE;

//组合搜索条件
type
  NET_DVR_ADVANCE_COND_UNION = record 
    case Byte of
    0: (byLen: array[0..36-1] of BYTE);  //联合体长度
    1: (struHumanFeature: NET_VCA_HUMAN_FEATURE);  //人体属性
    2: (struObjectFeature: NET_DVR_OBJECT_FEATURE);  //物体属性
  end;
  LPNET_DVR_ADVANCE_COND_UNION = ^NET_DVR_ADVANCE_COND_UNION;


const
  MAX_ALERTLINE_NUM = 8;    //最大警戒线条数


type
  NET_DVR_TRAVERSE_PLANE_SEARCHCOND = record 
    struVcaTraversePlane: array[0..MAX_ALERTLINE_NUM{8}-1] of NET_VCA_TRAVERSE_PLANE;  //穿越境界面参数
    dwPreTime: DWORD;  //智能报警提前时间 单位:秒
    dwDelayTime: DWORD;  //智能报警延迟时间 单位:秒
    struPTZPosInfo: NET_DVR_PTZPOS_INFO;  //PTZ坐标信息
    byAdvanceType: BYTE;  //组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    byRes1: array[0..3-1] of BYTE;  //保留
    uAdvanceCond: NET_DVR_ADVANCE_COND_UNION;  //组合属性
    byRes: array[0..5604-1] of BYTE;  //保留
  end;
  LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND = ^NET_DVR_TRAVERSE_PLANE_SEARCHCOND;//越界侦测查询条件

const
  MAX_INTRUSIONREGION_NUM = 8;    //最大区域数数
type
  NET_DVR_INTRUSION_SEARCHCOND = record 
    struVcaIntrusion: array[0..MAX_INTRUSIONREGION_NUM{8}-1] of NET_VCA_INTRUSION;  //入侵区域
    dwPreTime: DWORD;  //智能报警提前时间 单位:秒
    dwDelayTime: DWORD;  //智能报警延迟时间 单位:秒
    struPTZPosInfo: NET_DVR_PTZPOS_INFO;  //PTZ坐标信息
    byAdvanceType: BYTE;  //组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    byRes1: array[0..3-1] of BYTE;  //保留
    uAdvanceCond: NET_DVR_ADVANCE_COND_UNION;  //组合属性
    byRes: array[0..5348-1] of BYTE;  //保留
  end;
  LPNET_DVR_INTRUSION_SEARCHCOND = ^NET_DVR_INTRUSION_SEARCHCOND;//区域入侵


type
  NET_DVR_FACEDETECTION_SEARCHCOND = record 
    struFacePolygon: NET_VCA_POLYGON;  //识别区域
    dwPreTime: DWORD;  //智能录像提前时间 单位:秒
    dwDelayTime: DWORD;  //智能录像延迟时间 单位:秒
    byRes: array[0..5972-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACEDETECTION_SEARCHCOND = ^NET_DVR_FACEDETECTION_SEARCHCOND;//人脸检测


type
  NET_DVR_AREA_SMARTSEARCH_COND_UNION = record 
    case Byte of
    0: (byLen: array[0..6144-1] of BYTE);  //结构体长度
    1: (byMotionScope: array[0..64-1, 0..96-1] of BYTE);  //侦测区域 0-96位表示64行，共有96*64个小宏块，1-是移动侦测区域，0-非移动侦测区域
    2: (struTraversPlaneCond: NET_DVR_TRAVERSE_PLANE_SEARCHCOND);  //越界侦测
    3: (struIntrusionCond: NET_DVR_INTRUSION_SEARCHCOND);  //区域入侵
    4: (struFaceSnapCond: NET_DVR_FACEDETECTION_SEARCHCOND);  //人脸侦测条件
  end;
  LPNET_DVR_AREA_SMARTSEARCH_COND_UNION = ^NET_DVR_AREA_SMARTSEARCH_COND_UNION;


//智能搜索参数
type
  NET_DVR_SMART_SEARCH_PARAM = record 
    byChan: BYTE;  //通道号
    bySearchCondType: BYTE;  //智能查找联合体NET_DVR_AREA_SMARTSEARCH_COND_UNION的索引
    //0-移动侦测区域 ，1-越界侦测， 2-区域入侵, 3-人脸侦测 
    wChan: WORD;  //通道号， 该字段是对byChan的扩展，使用该字段后byChan可以不再使用
    struStartTime: NET_DVR_TIME;  //录像开始的时间
    struEndTime: NET_DVR_TIME;  //录像停止的时间
    uSmartSearchCond: NET_DVR_AREA_SMARTSEARCH_COND_UNION;  //智能查找条件
    bySensitivity: BYTE;  //移动侦测搜索灵敏度,1    >80%  2 40%~80%  3 1%~40%
    byRes2: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_SMART_SEARCH_PARAM = ^NET_DVR_SMART_SEARCH_PARAM;

type
  NET_DVR_SMART_SEARCH_PARAM_V40 = record 
    dwSize: DWORD;  //结构体大小
    struIDInfo: NET_DVR_STREAM_INFO;  //通道信息
    bySearchCondType: BYTE;  //智能查找联合体索引 0-侦测区域, 1-越界侦测, 2-区域入侵,3-人脸侦测, 4-车牌检测
    bySensitivity: BYTE;  //侦测区域动态分析灵敏度,1-100
    byRes1: array[0..2-1] of BYTE;  
    struStartTime: NET_DVR_TIME_EX;  
    struEndTime: NET_DVR_TIME_EX;  
    uSmartSearchCond: NET_DVR_AREA_SMARTSEARCH_COND_UNION;  //智能查找条件
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区，byISO8601为1时有效
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区，byISO8601为1时有效
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
    byRes2: array[0..251-1] of BYTE;  
  end;
  LPNET_DVR_SMART_SEARCH_PARAM_V40 = ^NET_DVR_SMART_SEARCH_PARAM_V40;



type
  NET_DVR_SMART_SEARCH_RET = record 
    struStartTime: NET_DVR_TIME;  //移动侦测报警开始的时间
    struEndTime: NET_DVR_TIME;  //事件停止的时间
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_SMART_SEARCH_RET = ^NET_DVR_SMART_SEARCH_RET;

// IPSAN 文件目录查找
type
  NET_DVR_IPSAN_SERACH_PARAM = record 
    struIP: NET_DVR_IPADDR;  // IPSAN IP地址
    wPort: WORD;  // IPSAN  端口
    byRes: array[0..10-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_IPSAN_SERACH_PARAM = ^NET_DVR_IPSAN_SERACH_PARAM;

type
  NET_DVR_IPSAN_SERACH_RET = record 
    byDirectory: array[0..128-1] of BYTE;  // 返回的文件目录
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_IPSAN_SERACH_RET = ^NET_DVR_IPSAN_SERACH_RET;

//DVR设备参数
type
  NET_DVR_DEVICECFG_V40 = record 
    dwSize: DWORD;  
    sDVRName: array[0..NAME_LEN-1] of BYTE;  //DVR名称
    dwDVRID: DWORD;  //DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
    dwRecycleRecord: DWORD;  //是否循环录像,0:不是; 1:是
    //以下不可更改
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    dwSoftwareVersion: DWORD;  //软件版本号,高16位是主版本,低16位是次版本
    dwSoftwareBuildDate: DWORD;  //软件生成日期,0xYYYYMMDD
    dwDSPSoftwareVersion: DWORD;  //DSP软件版本,高16位是主版本,低16位是次版本
    dwDSPSoftwareBuildDate: DWORD;  // DSP软件生成日期,0xYYYYMMDD
    dwPanelVersion: DWORD;  // 前面板版本,高16位是主版本,低16位是次版本
    dwHardwareVersion: DWORD;  // 硬件版本,高16位是主版本,低16位是次版本
    byAlarmInPortNum: BYTE;  //DVR报警输入个数
    byAlarmOutPortNum: BYTE;  //DVR报警输出个数
    byRS232Num: BYTE;  //DVR 232串口个数
    byRS485Num: BYTE;  //DVR 485串口个数
    byNetworkPortNum: BYTE;  //网络口个数
    byDiskCtrlNum: BYTE;  //DVR 硬盘控制器个数
    byDiskNum: BYTE;  //DVR 硬盘个数
    byDVRType: BYTE;  //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    byChanNum: BYTE;  //DVR 通道个数
    byStartChan: BYTE;  //起始通道号,例如DVS-1,DVR - 1
    byDecordChans: BYTE;  //DVR 解码路数
    byVGANum: BYTE;  //VGA口的个数
    byUSBNum: BYTE;  //USB口的个数
    byAuxoutNum: BYTE;  //辅口的个数
    byAudioNum: BYTE;  //语音口的个数
    byIPChanNum: BYTE;  //最大数字通道数 低8位，高8位见byHighIPChanNum
    byZeroChanNum: BYTE;  //零通道编码个数
    bySupport: BYTE;  //能力，位与结果为0表示不支持，1表示支持，
    //bySupport & 0x1, 表示是否支持智能搜索
    //bySupport & 0x2, 表示是否支持备份
    //bySupport & 0x4, 表示是否支持压缩参数能力获取
    //bySupport & 0x8, 表示是否支持多网卡
    //bySupport & 0x10, 表示支持远程SADP
    //bySupport & 0x20, 表示支持Raid卡功能
    //bySupport & 0x40, 表示支持IPSAN搜索
    //bySupport & 0x80, 表示支持rtp over rtsp
    byEsataUseage: BYTE;  //Esata的默认用途，0-默认备份，1-默认录像
    byIPCPlug: BYTE;  //0-关闭即插即用，1-打开即插即用
    byStorageMode: BYTE;  //0-盘组模式,1-磁盘配额, 2抽帧模式, 3-自动
    bySupport1: BYTE;  //能力，位与结果为0表示不支持，1表示支持
    //bySupport1 & 0x1, 表示是否支持snmp v30
    //bySupport1 & 0x2, 支持区分回放和下载
    //bySupport1 & 0x4, 是否支持布防优先级
    //bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
    //bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
    //bySupport1 & 0x20, 表示是否支持rtsp over http
    wDevType: WORD;  //设备型号
    byDevTypeName: array[0..DEV_TYPE_NAME_LEN-1] of BYTE;  //设备型号名称
    bySupport2: BYTE;  //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport2 & 0x1, 表示是否支持扩展的OSD字符叠加(终端和抓拍机扩展区分)
    byAnalogAlarmInPortNum: BYTE;  //模拟报警输入个数
    byStartAlarmInNo: BYTE;  //模拟报警输入起始号
    byStartAlarmOutNo: BYTE;  //模拟报警输出起始号
    byStartIPAlarmInNo: BYTE;  //IP报警输入起始号
    byStartIPAlarmOutNo: BYTE;  //IP报警输出起始号
    byHighIPChanNum: BYTE;  //数字通道个数，高8位
    byEnableRemotePowerOn: BYTE;  //是否启用在设备休眠的状态下远程开机功能，0-不启用，1-启用
    wDevClass: WORD;  //设备大类备是属于哪个产品线，0 保留，1-50 DVR，51-100 DVS，101-150 NVR，151-200 IPC，65534 其他，具体分类方法见《设备类型对应序列号和类型值.docx》
    byRes2: array[0..6-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEVICECFG_V40 = ^NET_DVR_DEVICECFG_V40;

type
  NET_DVR_DEVICECFG_V50 = record 
    dwSize: DWORD;  
    sDVRName: array[0..NET_DEV_NAME_LEN-1] of BYTE;  //DVR名称
    dwDVRID: DWORD;  //DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
    dwRecycleRecord: DWORD;  //是否循环录像,0:不是; 1:是
    //以下不可更改
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    dwSoftwareVersion: DWORD;  //软件版本号,高16位是主版本,低16位是次版本
    dwSoftwareBuildDate: DWORD;  //软件生成日期,0xYYYYMMDD
    dwDSPSoftwareVersion: DWORD;  //DSP软件版本,高16位是主版本,低16位是次版本
    dwDSPSoftwareBuildDate: DWORD;  // DSP软件生成日期,0xYYYYMMDD
    dwPanelVersion: DWORD;  // 前面板版本,高16位是主版本,低16位是次版本
    dwHardwareVersion: DWORD;  // 硬件版本,高16位是主版本,低16位是次版本
    byAlarmInPortNum: BYTE;  //DVR报警输入个数
    byAlarmOutPortNum: BYTE;  //DVR报警输出个数
    byRS232Num: BYTE;  //DVR 232串口个数
    byRS485Num: BYTE;  //DVR 485串口个数 --
    byNetworkPortNum: BYTE;  //网络口个数
    byDiskCtrlNum: BYTE;  //DVR 硬盘控制器个数
    byDiskNum: BYTE;  //DVR 硬盘个数
    byDVRType: BYTE;  //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......--
    byChanNum: BYTE;  //DVR 通道个数
    byStartChan: BYTE;  //起始通道号,例如DVS-1,DVR - 1
    byDecordChans: BYTE;  //DVR 解码路数
    byVGANum: BYTE;  //VGA口的个数 --
    byUSBNum: BYTE;  //USB口的个数
    byAuxoutNum: BYTE;  //辅口的个数
    byAudioNum: BYTE;  //语音口的个数
    byIPChanNum: BYTE;  //最大数字通道数  --
    byZeroChanNum: BYTE;  //零通道编码个数
    bySupport: BYTE;  //能力，位与结果为0表示不支持，1表示支持，
    //bySupport & 0x1, 表示是否支持智能搜索
    //bySupport & 0x2, 表示是否支持备份
    //bySupport & 0x4, 表示是否支持压缩参数能力获取
    //bySupport & 0x8, 表示是否支持多网卡
    //bySupport & 0x10, 表示支持远程SADP
    //bySupport & 0x20, 表示支持Raid卡功能
    //bySupport & 0x40, 表示支持IPSAN搜索
    //bySupport & 0x80, 表示支持rtp over rtsp
    byEsataUseage: BYTE;  //Esata的默认用途，0-默认备份，1-默认录像
    byIPCPlug: BYTE;  //0-关闭即插即用，1-打开即插即用
    byStorageMode: BYTE;  //0-盘组模式,1-磁盘配额,2抽帧模式
    bySupport1: BYTE;  //能力，位与结果为0表示不支持，1表示支持
    //bySupport1 & 0x1, 表示是否支持snmp v30
    //bySupport1 & 0x2, 支持区分回放和下载
    //bySupport1 & 0x4, 是否支持布防优先级
    //bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
    //bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
    //bySupport1 & 0x20, 表示是否支持rtsp over http
    wDevType: WORD;  //设备型号扩展
    byDevTypeName: array[0..NET_DEV_TYPE_NAME_LEN-1] of BYTE;  //设备型号名称
    bySupport2: BYTE;  //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport2 & 0x1, 表示是否支持扩展的OSD字符叠加(终端和抓拍机扩展区分)
    byAnalogAlarmInPortNum: BYTE;  //模拟报警输入数目
    byStartAlarmInNo: BYTE;  //模拟报警输入起始号
    byStartAlarmOutNo: BYTE;  //模拟报警输出起始号
    byStartIPAlarmInNo: BYTE;  //IP报警输入起始号
    byStartIPAlarmOutNo: BYTE;  //IP报警输出起始号
    byHighIPChanNum: BYTE;  //数字通道个数，高8位
    byEnableRemotePowerOn: BYTE;  //是否启用在设备休眠的状态下远程开机功能，0-不启用，1-启用
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEVICECFG_V50 = ^NET_DVR_DEVICECFG_V50;
const
  MAX_ZEROCHAN_NUM = 16;    
//零通道压缩配置参数
type
  NET_DVR_ZEROCHANCFG = record 
    dwSize: DWORD;  //结构长度
    byEnable: BYTE;  //0-停止零通道编码，1-表示启用零通道编码
    byRes1: array[0..3-1] of BYTE;  //保留
    dwVideoBitrate: DWORD;  //视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
    dwVideoFrameRate: DWORD;  //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    byRes2: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_ZEROCHANCFG = ^NET_DVR_ZEROCHANCFG;

//零通道缩放参数
type
  NET_DVR_ZERO_ZOOMCFG = record 
    dwSize: DWORD;  //结构长度
    struPoint: NET_VCA_POINT;  //画面中的坐标点
    byState: BYTE;  //现在的状态，0-缩小，1-放大
    byPreviewNumber: BYTE;  //预览数目,0-1画面,1-4画面,2-9画面,3-16画面 该参数只读
    byPreviewSeq: array[0..MAX_WINDOW_V30-1] of BYTE;  //画面通道信息 该参数只读
    byRes: array[0..30-1] of BYTE;  //保留
  end;
  LPNET_DVR_ZERO_ZOOMCFG = ^NET_DVR_ZERO_ZOOMCFG;

const
  DESC_LEN_64 = 64;    
type
  NET_DVR_SNMPCFG = record 
    dwSize: DWORD;  //结构长度
    byEnable: BYTE;  //0-禁用SNMP，1-表示启用SNMP
    byRes1: array[0..3-1] of BYTE;  //保留
    wVersion: WORD;  //snmp 版本  v1 = 1, v2 =2, v3 =3，设备目前不支持 v3
    wServerPort: WORD;  //snmp消息接收端口，默认 161
    byReadCommunity: array[0..NAME_LEN-1] of BYTE;  //读共同体，最多31,默认"public"
    byWriteCommunity: array[0..NAME_LEN-1] of BYTE;  //写共同体,最多31 字节,默认 "private"
    byTrapHostIP: array[0..DESC_LEN_64-1] of BYTE;  //自陷主机ip地址描述，支持IPV4 IPV6和域名描述
    wTrapHostPort: WORD;  // trap主机端口
    byTrapName: array[0..NAME_LEN-1] of BYTE;  
    byRes2: array[0..70-1] of BYTE;  //保留
  end;
  LPNET_DVR_SNMPCFG = ^NET_DVR_SNMPCFG;

type
  NET_DVR_SNMPv3_USER = record 
    byUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名
    bySecLevel: BYTE;  // 安全级别 0-保留 1-无校验 2-无授权校验 3-授权校验
    byAuthtype: BYTE;  // 认证类型 0-MD5认证 1-SHA认证 2: none
    byPrivtype: BYTE;  // 0: DES; 1: AES; 2: none;
    byRes: array[0..5-1] of BYTE;  
    byAuthpass: array[0..PASSWD_LEN-1] of BYTE;  // 认证密码
    byPrivpass: array[0..PASSWD_LEN-1] of BYTE;  // 加密密码
  end;
  LPNET_DVR_SNMPv3_USER = ^NET_DVR_SNMPv3_USER;

// snmpv30
type
  NET_DVR_SNMPCFG_V30 = record 
    dwSize: DWORD;  //结构长度
    byEnableV1: BYTE;  //0-禁用SNMP V1，1-表示启用SNMP V1
    byEnableV2: BYTE;  //0-禁用SNMP V2，1-表示启用SNMP V2
    byEnableV3: BYTE;  //0-禁用SNMP V3，1-表示启用SNMP V3
    byRes1: array[0..3-1] of BYTE;  
    wServerPort: WORD;  //snmp消息接收端口，默认 161
    byReadCommunity: array[0..NAME_LEN-1] of BYTE;  //读共同体，最多31,默认"public"
    byWriteCommunity: array[0..NAME_LEN-1] of BYTE;  //写共同体,最多31 字节,默认 "private"
    byTrapHostIP: array[0..DESC_LEN_64-1] of BYTE;  //自陷主机ip地址描述，支持IPV4 IPV6和域名描述
    wTrapHostPort: WORD;  // trap主机端口
    byRes2: array[0..2-1] of BYTE;  
    struRWUser: NET_DVR_SNMPv3_USER;  // 读写用户
    struROUser: NET_DVR_SNMPv3_USER;  // 只读用户
    byTrapName: array[0..NAME_LEN-1] of BYTE;  
  end;
  LPNET_DVR_SNMPCFG_V30 = ^NET_DVR_SNMPCFG_V30;

const
  PROCESSING = 0;    //正在处理
  PROCESS_SUCCESS = 100;    //过程完成
  PROCESS_EXCEPTION = 400;    //过程异常
  PROCESS_FAILED = 500;    //过程失败
  PROCESS_QUICK_SETUP_PD_COUNT = 501;    //一键配置至少3块硬盘

const
  SOFTWARE_VERSION_LEN = 48;    
  NET_SDK_DEVICE_MODEL_LEN = 24;    //设备型号长度
type
  NET_DVR_SADPINFO = record 
    struIP: NET_DVR_IPADDR;  // 设备IP地址
    wPort: WORD;  // 设备端口号
    wFactoryType: WORD;  // 设备厂家类型
    chSoftwareVersion: array[0..SOFTWARE_VERSION_LEN-1] of AnsiChar;  
    chSerialNo: array[0..16-1] of AnsiChar;  // 序列号
    wEncCnt: WORD;  // 编码通道个数
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // MAC 地址
    struSubDVRIPMask: NET_DVR_IPADDR;  // DVR IP地址掩码
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关
    struDnsServer1IpAddr: NET_DVR_IPADDR;  // 域名服务器1的IP地址 
    struDnsServer2IpAddr: NET_DVR_IPADDR;  // 域名服务器2的IP地址 
    byDns: BYTE;  
    byDhcp: BYTE;  
    szGB28181DevID: array[0..DEV_ID_LEN-1] of BYTE;  //GB28181协议接入时的设备ID，用于IPC以GB28181协议接入
    byActivated: BYTE;  //0-无效，1-已激活，2-未激活
    byDeviceModel: array[0..NET_SDK_DEVICE_MODEL_LEN{24}-1] of BYTE;  //设备型号
    byRes: array[0..101-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SADPINFO = ^NET_DVR_SADPINFO;

const
  MAX_SADP_NUM = 256;    // 搜索到设备最大数目
type
  NET_DVR_SADPINFO_LIST = record 
    dwSize: DWORD;  //  结构大小
    wSadpNum: WORD;  // 搜索到设备数目
    byRes: array[0..6-1] of BYTE;  // 保留字节
    struSadpInfo: array[0..MAX_SADP_NUM-1] of NET_DVR_SADPINFO;  // 搜索
  end;
  LPNET_DVR_SADPINFO_LIST = ^NET_DVR_SADPINFO_LIST;

type
  NET_DVR_SADP_VERIFY = record 
    chPassword: array[0..PASSWD_LEN-1] of AnsiChar;  
    struOldIP: NET_DVR_IPADDR;  
    wOldPort: WORD;  
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_SADP_VERIFY = ^NET_DVR_SADP_VERIFY;

//******************************备份接口 begin*******************************
//获取备份设备信息接口定义
const
  DESC_LEN_32 = 32;    //描述字长度
  MAX_NODE_NUM = 256;    //节点个数

type
  NET_DVR_DESC_NODE = record 
    iValue: INT;  
    byDescribe: array[0..DESC_LEN_32-1] of BYTE;  //描述字段
    dwFreeSpace: DWORD;  //获取磁盘列表专用,单位为M
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_DVR_DESC_NODE = ^NET_DVR_DESC_NODE;

type
  NET_DVR_DISKABILITY_LIST = record 
    dwSize: DWORD;  //结构长度
    dwNodeNum: DWORD;  //能力结点个数
    struDescNode: array[0..MAX_NODE_NUM-1] of NET_DVR_DESC_NODE;  //描述参数
  end;
  LPNET_DVR_DISKABILITY_LIST = ^NET_DVR_DISKABILITY_LIST;

//备份进度列表
const
  BACKUP_SUCCESS = 100;    //备份完成
  BACKUP_CHANGE_DEVICE = 101;    //备份设备已满，更换设备继续备份

const
  BACKUP_SEARCH_DEVICE = 300;    //正在搜索备份设备
  BACKUP_SEARCH_FILE = 301;    //正在搜索录像文件
  BACKUP_SEARCH_LOG_FILE = 302;    //正在搜索日志文件
  BACKUP_CHANGE_DISK = 303;    //正在更换光盘

const
  BACKUP_EXCEPTION = 400;    //备份异常
  BACKUP_FAIL = 500;    //备份失败

const
  BACKUP_TIME_SEG_NO_FILE = 501;    //时间段内无录像文件
  BACKUP_NO_RESOURCE = 502;    //申请不到资源
  BACKUP_DEVICE_LOW_SPACE = 503;    //备份设备容量不足
  BACKUP_DISK_FINALIZED = 504;    //刻录光盘封盘
  BACKUP_DISK_EXCEPTION = 505;    //刻录光盘异常
  BACKUP_DEVICE_NOT_EXIST = 506;    //备份设备不存在
  BACKUP_OTHER_BACKUP_WORK = 507;    //有其他备份操作在进行
  BACKUP_USER_NO_RIGHT = 508;    //用户没有操作权限
  BACKUP_OPERATE_FAIL = 509;    //操作失败
  BACKUP_NO_LOG_FILE = 510;    //硬盘中无日志

//备份过程接口定义
type
  NET_DVR_BACKUP_NAME_PARAM = record 
    dwFileNum: DWORD;  //文件个数
    struFileList: array[0..MAX_RECORD_FILE_NUM-1] of NET_DVR_FINDDATA_V30;  //文件列表
    byDiskDes: array[0..DESC_LEN_32-1] of BYTE;  //备份磁盘描述
    byWithPlayer: BYTE;  //是否备份播放器
    byContinue: BYTE;  //是否继续备份 0不继续 1继续
    byRes: array[0..34-1] of BYTE;  //保留
  end;
  LPNET_DVR_BACKUP_NAME_PARAM = ^NET_DVR_BACKUP_NAME_PARAM;

type
  NET_DVR_BACKUP_TIME_PARAM = record 
    lChannel: LONG;  //按时间备份的通道
    struStartTime: NET_DVR_TIME;  //备份的起始时间
    struStopTime: NET_DVR_TIME;  //备份的终止时间
    byDiskDes: array[0..DESC_LEN_32-1] of BYTE;  //备份磁盘描述
    byWithPlayer: BYTE;  //是否备份播放器
    byContinue: BYTE;  //是否继续备份 0不继续 1继续
    byDrawFrame: BYTE;  //0 不抽帧  1 抽帧
    byUseBackCfgParam: BYTE;  //使用备份配置中的参数，0-无效，1-启用(启用后，通道号无效)，2-不启用
    dwStreamType: DWORD;  //备份码流类型，按位表示
    //&0x1-表示主码流
    //&0x2-表示子码流
    //&0x4-表示码流三
    byRes: array[0..28-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_BACKUP_TIME_PARAM = ^NET_DVR_BACKUP_TIME_PARAM;
//******************************** end ******************************************

type
  COMPRESSION_ABILITY_TYPE =  
  (  
    COMPRESSION_STREAM_ABILITY = 0,  //码流压缩类型
    MAIN_RESOLUTION_ABILITY = 1,  //主码流压缩分辨率
    SUB_RESOLUTION_ABILITY = 2,  //子码流压缩分辨率
    EVENT_RESOLUTION_ABILITY = 3,  //事件压缩参数分辨率
    FRAME_ABILITY = 4,  //帧率能力
    BITRATE_TYPE_ABILITY = 5,  //位率类型能力
    BITRATE_ABILITY = 6,  //位率上限
    THIRD_RESOLUTION_ABILITY = 7,  //三码流压缩分辨率
    STREAM_TYPE_ABILITY = 8,  //码流类型
    PIC_QUALITY_ABILITY = 9,  //图像质量
    INTERVAL_BPFRAME_ABILITY = 10,  //BP帧间隔
    VIDEO_ENC_ABILITY = 11,  //视频编码能力
    AUDIO_ENC_ABILITY = 12,  //音频编码能力
    VIDEO_ENC_COMPLEXITY_ABILITY = 13,  //视频编码复杂度能力
    FORMAT_ABILITY = 14  //封装格式能力
  );

//能力列表
type
  NET_DVR_ABILITY_LIST = record 
    dwAbilityType: DWORD;  //能力类型 COMPRESSION_ABILITY_TYPE
    byRes: array[0..32-1] of BYTE;  //保留字节
    dwNodeNum: DWORD;  //能力结点个数
    struDescNode: array[0..MAX_NODE_NUM-1] of NET_DVR_DESC_NODE;  //描述参数
  end;
  LPNET_DVR_ABILITY_LIST = ^NET_DVR_ABILITY_LIST;

const
  MAX_ABILITYTYPE_NUM = 12;    //最大能力项
// 压缩参数能力列表
type
  NET_DVR_COMPRESSIONCFG_ABILITY = record 
    dwSize: DWORD;  //结构长度
    dwAbilityNum: DWORD;  //能力类型个数
    struAbilityNode: array[0..MAX_ABILITYTYPE_NUM-1] of NET_DVR_ABILITY_LIST;  //描述参数
  end;
  LPNET_DVR_COMPRESSIONCFG_ABILITY = ^NET_DVR_COMPRESSIONCFG_ABILITY;
//*******************************9000RH begin***************************************
const
  SUPPORT_PD_NUM = 16;    
  SUPPORT_ARRAY_NUM = 8;    
  SUPPORT_VD_NUM = 128;    
  SUPPORT_PD_NUM_ = 16;    
  SUPPORT_PD_NUM_PARTTWO = 8;    

type
  RAID_MODE =  
  (  
    RAID0 = 1,  
    RAID1,  
    RAID10,  
    RAID1E,  
    RAID5,  
    RAID6,  
    RAID50,  
    JBOD,  
    RAID60  
  );

type
  HD_SUPPORT_TYPE =  
  (  
    HD_TYPE_SATA = $01,  
    HD_TYPE_PATA = $02,  
    HD_TYPE_SAS = $04,  
    HD_TYPE_ATAPI = $08,  
    HD_TYPE_TAPE = $10,  
    HD_TYPE_SES = $20  
  );

// 按位表示 位为0表示不支持  1表示支持
type
  SUPPORT_RAID_TYPE =  
  (  
    RAID0_ABILITY = $0001,  
    RAID1_ABILITY = $0002,  
    RAID10_ABILITY = $0004,  
    RAID1E_ABILITY = $0008,  
    RAID5_ABILITY = $0010,  
    RAID6_ABILITY = $0020,  
    RAID50_ABILITY = $0040,  
    JBOD_ABILITY = $0080,  
    RAID60_ABILITY = $0100  
  );

// 物理磁盘
type
  NET_DVR_PHY_DISK_INFO = record 
    wPhySlot: WORD;  // 硬盘槽位
    byType: BYTE;  // 硬盘信息；0 普通，1全局热备，2-阵列热备 3-阵列盘
    byStatus: BYTE;  // 硬盘状态；  0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 9-休眠 10-有坏块,11-SMR硬盘不支持阵列功能,0xff-不存在
    byMode: array[0..40-1] of BYTE;  // 硬盘类型 字符串
    dwHCapacity: DWORD;  //  磁盘总量高32位 单位kb
    dwLCapacity: DWORD;  //  磁盘总量低32位
    byArrrayName: array[0..MAX_NAMELEN-1] of BYTE;  
    wArrayID: WORD;  // 所属阵列ID
    byArrayInformation: BYTE;  // 是否含有阵列信息：0 否，1是
    byRes: array[0..101-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PHY_DISK_INFO = ^NET_DVR_PHY_DISK_INFO;

type
  NET_DVR_PHY_DISK_LIST = record 
    dwSize: DWORD;  
    dwCount: DWORD;  
    struPhyDiskInfo: array[0..SUPPORT_PD_NUM-1] of NET_DVR_PHY_DISK_INFO;  
  end;
  LPNET_DVR_PHY_DISK_LIST = ^NET_DVR_PHY_DISK_LIST;

type
  BGA_TYPE =  
  (  
    BGA_REBUILD = $01,  // 重建
    BGA_CONSISTENCY_FIX = $02,  // 一致性检查并修复
    BGA_CONSISTENCY_CHECK = $04,  // 一致性检查
    BGA_INIT_QUICK = $08,  // 初始化(快)
    BGA_INIT_BACK = $10,  // 初始化(完全)
    BGA_MIGRATION = $20,  // 迁移
    BGA_INIT_FORE = $40,  // 初始化
    BGA_COPYBACK = $80  // 回迁
  );

type
  BGA_STATE =  
  (  
    BGA_STATE_NONE = 0,  //  无后台任务
    BGA_STATE_RUNNING,  //  后台任务正在运行
    BGA_STATE_ABORTED,  //  后台任务取消
    BGA_STATE_PAUSED  //  后台任务暂停
  );
type
  NET_DVR_BGA_INFO = record 
    byBga: BYTE;  // 后台任务及类型
    byBgaState: BYTE;  //函数返回值--后台任务状态
    wBgaPercentage: WORD;  //函数返回值--后台任务执行百分比
    byRes: array[0..4-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_BGA_INFO = ^NET_DVR_BGA_INFO;

// 阵列信息
type
  NET_DVR_ARRAY_INFO = record 
    wArrayID: WORD;  // 阵列ID
    byRaidMode: BYTE;  // raid模式  参照RAID_MODE
    byStatus: BYTE;  // 0-在线 1-磁盘丢失 2-下线 3-降级 4-异常 5-次正常 6-外来盘  7-已删除 8-SMART状态异常 0xff-不存在
    dwHCapacity: DWORD;  // 阵列容量高32位
    dwLCapacity: DWORD;  // 阵列容量低32位
    dwHFreeSpace: DWORD;  // 阵列剩余空间高32位
    dwLFreeSpace: DWORD;  // 阵列剩余空间高32位
    byArrayName: array[0..MAX_NAMELEN-1] of BYTE;  // 阵列名称
    byPDCount: BYTE;  // 物理磁盘数目
    bySpareCount: BYTE;  // 热备数目
    byRes1: array[0..2-1] of BYTE;  
    wPDSlots: array[0..SUPPORT_PD_NUM-1] of WORD;  // 物理磁盘索引
    wSparePDSlots: array[0..SUPPORT_PD_NUM-1] of WORD;  // 热备磁盘索引
    struBgaInfo: NET_DVR_BGA_INFO;  // 后台任务运行状态
    wPDSlotsPartTwo: array[0..SUPPORT_PD_NUM_PARTTWO-1] of WORD;  //物理磁盘索引扩展，0表示无效
    wSparePDSlotsPartTwo: array[0..SUPPORT_PD_NUM_PARTTWO-1] of WORD;  // 热备磁盘索引扩展，0表示无效
    byRes2: array[0..48-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ARRAY_INFO = ^NET_DVR_ARRAY_INFO;


type
  NET_DVR_ARRAY_LIST = record 
    dwSize: DWORD;  // 结构体大小
    dwCount: DWORD;  // 阵列个数
    struArrayInfo: array[0..SUPPORT_ARRAY_NUM-1] of NET_DVR_ARRAY_INFO;  
  end;
  LPNET_DVR_ARRAY_LIST = ^NET_DVR_ARRAY_LIST;

//虚拟磁盘信息
type
  NET_DVR_VD_INFO = record 
    wSlot: WORD;  //虚拟磁盘槽位
    byStatus: BYTE;  // 状态0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 0xff-不存在
    byRaidMode: BYTE;  // Raid 模式 参照 RAID_MODE
    wArrayID: WORD;  // 所属阵列ID
    byRepair: BYTE;  // 是否需要修复 0 不需要 1需要
    byUsage: BYTE;  //LUN卷的使用方式  0-IPSAN 1-FCSAN 2-DVR网盘 3-NAS 4-录像卷
    byArrayName: array[0..MAX_NAMELEN-1] of BYTE;  
    byName: array[0..MAX_NAMELEN-1] of BYTE;  // 虚拟磁盘名名称
    dwHCapacity: DWORD;  // 虚拟磁盘容量高32位
    dwLCapacity: DWORD;  // 虚拟磁盘容量低32位
    dwHFreeSpace: DWORD;  // 虚拟磁盘剩余空间高32位
    dwLFreeSpace: DWORD;  // 虚拟磁盘剩余空间低32位
    struBgaInfo: NET_DVR_BGA_INFO;  // 后台运行状态
    dwBlockSize: DWORD;  //最小存储单元块大小
    struWarrantIP: NET_DVR_IPADDR;  // 授权的DVR网盘IP
    szArrayGroup: array[0..NAME_LEN-1] of AnsiChar;  //使用的阵列名称组，以逗号隔开，为空则使用默认阵列
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_VD_INFO = ^NET_DVR_VD_INFO;

type
  NET_DVR_VD_LIST = record 
    dwSize: DWORD;  // 结构体大小
    dwCount: DWORD;  // 虚拟磁盘个数
    struVDInfo: array[0..SUPPORT_VD_NUM-1] of NET_DVR_VD_INFO;  //虚拟磁盘数组
  end;
  LPNET_DVR_VD_LIST = ^NET_DVR_VD_LIST;

type
  NET_DVR_ADAPTER_VERSION = record 
    wMajorVersion: WORD;  
    wMinorVersion: WORD;  
    wRevisionNumber: WORD;  
    wBuildNumber: WORD;  
  end;
  LPNET_DVR_ADAPTER_VERSION = ^NET_DVR_ADAPTER_VERSION;

type
  NET_DVR_VD_SLOT = record 
    wVDSlot: WORD;  
    byAlloc: BYTE;  // 是否已经分配
    byRes: array[0..5-1] of BYTE;  
    dwHVDSlotSize: DWORD;  // 虚拟磁盘空间大小高32位
    dwLVDSlotSize: DWORD;  // 虚拟磁盘空间大小低32位
  end;
  LPNET_DVR_VD_SLOT = ^NET_DVR_VD_SLOT;

type
  NET_DVR_ARRAY_SPACE_ALLOC_INFO = record 
    byVDSlotCount: BYTE;  //current number of slots in DG
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struVDSlots: array[0..SUPPORT_VD_NUM-1] of NET_DVR_VD_SLOT;  
  end;
  LPNET_DVR_ARRAY_SPACE_ALLOC_INFO = ^NET_DVR_ARRAY_SPACE_ALLOC_INFO;

type
  NET_DVR_RAID_ADAPTER_INFO = record 
    dwSize: DWORD;  // 结构体大小
    struVersion: NET_DVR_ADAPTER_VERSION;  // 适配器版本号
    bySlotCount: BYTE;  //适配器槽位数
    bySupportMigrate: BYTE;  // 迁移(1-支持  0-不支持)
    bySupportExpand: BYTE;  // 扩容  (1-支持  0-不支持)
    bySupportRebuild: BYTE;  // 是否支持重建阵列 (1、支持 0-不支持)
    wSlotSupportType: WORD;  //  按位表示 HD_SUPPORT_TYPE
    wSupportRaidType: WORD;  // 支持Raid 类型 按位表示
    byAutoRebuild: BYTE;  // 0 不自动重建 1自动重建 可设
    byRes: array[0..27-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_RAID_ADAPTER_INFO = ^NET_DVR_RAID_ADAPTER_INFO;

type
  NET_DVR_OPERATE_ARRAY_PARAM = record 

    //是否一键创建  如果为一键创建，则创建时时候的之需要array名称，而不需要其他参数
    // 其他参数有设备自行创建
    byRaidMode: BYTE;  // 创建/迁移时Raid的类型
    byPDCount: BYTE;  // 物理磁盘数目
    wArrayID: WORD;  // 迁移或者重建时需要指出阵列ID
    wPDSlots: array[0..SUPPORT_PD_NUM-1] of WORD;  // 物理磁盘
    byName: array[0..MAX_NAMELEN-1] of BYTE;  // array 名称
    byInitMode: BYTE;  //初始化方式
    byRes1: BYTE;  
    wPDSlotsPartTwo: array[0..SUPPORT_PD_NUM_PARTTWO-1] of WORD;  //物理磁盘信息
    byRes2: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_OPERATE_ARRAY_PARAM = ^NET_DVR_OPERATE_ARRAY_PARAM;


const
  INIT_QUICK = 0;    //快速初始化
  INIT_FULLFOREGROUND = 1;    //完全初始化(前台)
  INIT_FULLBACKGROUND = 2;    //完全初始化(后台)

type
  NET_DVR_OPERATE_VD_PARAM = record 
    wArrayID: WORD;  // 阵列ID
    bySlot: BYTE;  // 创建虚拟磁盘指定槽位
    byInitType: BYTE;  // 创建虚拟磁盘时初始化类型 0 - 快速初始化 1 - 前台完全初始化 2 - 后台完全初始化
    dwHCapacity: DWORD;  // 虚拟磁盘大小高32位
    dwLCapacity: DWORD;  // 虚拟磁盘大小低32位
    byName: array[0..MAX_NAMELEN-1] of BYTE;  // 虚拟磁盘名称
    byRes2: array[0..16-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_OPERATE_VD_PARAM = ^NET_DVR_OPERATE_VD_PARAM;


type
  NET_DVR_SPARE_DISK_PARAM = record 
    wPDSlot: WORD;  // 物理磁盘槽位
    wArrayID: WORD;  // 所属的阵列
    bySpareType: BYTE;  // 热备类型 1-全局热备  2 指定阵列  当为指定阵列的时候需要指出所属阵列的ID
    byRes: array[0..7-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SPARE_DISK_PARAM = ^NET_DVR_SPARE_DISK_PARAM;

//*******************************9000RH End***************************************


const
  MATRIX_MAXDECSUBSYSTEMCHAN = 4;    //视频综合平台解码子系统通道号

//获取解码子系统关联信息
type
  NET_DVR_DECSUBSYSTEMJIONSTATUS = record 
    byJoinStatus: BYTE;  //关联状态，0-没有关联，1-已经关联
    byJoinSubSystem: BYTE;  //所关联子系统槽位号
    byJoinDispNum: BYTE;  //所关联显示通道号
    byJoinSubWindowNum: BYTE;  //所关联子窗口号
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_DECSUBSYSTEMJIONSTATUS = ^NET_DVR_DECSUBSYSTEMJIONSTATUS;

type
  NET_DVR_SINGLESUBSYSTEMJOININFO = record 
    bySubSystemType: BYTE;  //子系统类型，0-无，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统,5-码分子系统，6-报警子系统
    byConnectStatus: BYTE;  //级联系统关联状态，1-连接正常，2-连接断开
    byMatrixNum: BYTE;  //级联视频综合平台号，子系统类型是3或4时可用
    bySubSystemNum: BYTE;  //级联子系统槽位号，0~79，子系统类型是3或4时可用
    struDecSub: array[0..MATRIX_MAXDECSUBSYSTEMCHAN-1] of NET_DVR_DECSUBSYSTEMJIONSTATUS;  
    byBindStatus: BYTE;  //绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_SINGLESUBSYSTEMJOININFO = ^NET_DVR_SINGLESUBSYSTEMJOININFO;

type
  NET_DVR_ALLDECSUBSYSTEMJOININFO = record 
    dwSize: DWORD;  
    struSingleSubSystemJoinInfo: array[0..MAX_SUBSYSTEM_NUM-1] of NET_DVR_SINGLESUBSYSTEMJOININFO;  //80
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ALLDECSUBSYSTEMJOININFO = ^NET_DVR_ALLDECSUBSYSTEMJOININFO;

//2010-04-13 增加NAT功能相关配置
type
  NET_DVR_NATASSOCIATECFG = record 
    dwSize: DWORD;  
    struNatIpAddress: array[0..2-1] of NET_DVR_NETCFG_V30;  //NAT IP地址
    byNATEnable: BYTE;  //是否启用NAT功能，0-不启用，非0-启用
    byNATCfgMode: BYTE;  //NAT配置模式，0-手动分配，1-自动分配
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_NATASSOCIATECFG = ^NET_DVR_NATASSOCIATECFG;

//2010-06-01 视频综合平台报警配置
type
  NET_DVR_TEMPERATUREALARMCFG = record 
    byEnableTemperatureAlarm: BYTE;  //使能温度超限报警，0-报警，1-不报警
    byRes1: array[0..3-1] of BYTE;  
    iTemperatureUpLimited: INT;  //精确到小数点后两位，如1234表示温度12.34度
    iTemperatureDownLimited: INT;  
    struTempHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_TEMPERATUREALARMCFG = ^NET_DVR_TEMPERATUREALARMCFG;

type
  NET_DVR_BOARDALARMCFG = record 
    byEnablePullAlarm: BYTE;  //热插拔报警使能，1-报警，0-不报警
    byRes1: array[0..3-1] of BYTE;  
    struBoardHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_BOARDALARMCFG = ^NET_DVR_BOARDALARMCFG;


type
  NET_DVR_VIDEOPLATFORMALARMCFG = record 
    dwSize: DWORD;  
    struTempAlarmCfg: NET_DVR_TEMPERATUREALARMCFG;  
    struBoardAlarmCfg: NET_DVR_BOARDALARMCFG;  
    struHandleException: array[0..MAX_EXCEPTIONNUM-1] of NET_DVR_HANDLEEXCEPTION_V30;  //0-风扇异常，1-子系统异常，2-IP地址冲突，3-网线断，4-非法访问，5-光纤异常，6-前面板异常
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOPLATFORMALARMCFG = ^NET_DVR_VIDEOPLATFORMALARMCFG;
//2010-05-17
type
  NET_DVR_CODESPLITTERASSOCIATE = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  //编码器IP地址
    wPort: WORD;  //编码器端口号
    byRes1: array[0..6-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名（32） 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码 （16）
    byChan: BYTE;  //编码器通道号
    byRes2: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_CODESPLITTERASSOCIATE = ^NET_DVR_CODESPLITTERASSOCIATE;

//2010-06-01 视频综合平台报警上传结构
type
  NET_DVR_MATRIXSUBSYSTEMINFO = record 
    byMatrixNum: BYTE;  //视频综合平台号
    bySubSystemNum: BYTE;  //子系统槽位号
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXSUBSYSTEMINFO = ^NET_DVR_MATRIXSUBSYSTEMINFO;

type
  NET_DVR_VIDEOPLATFORM_ALRAMINFO = record 
    dwSize: DWORD;  //结构体大小
    byAlarmType: BYTE;  // 0-拔出子板，1-插入子板,2-温度超上限报警，3-温度超下限报警，4-风扇状态异常，5-子系统异常,6-非法访问，7-光纤异常报警,8-前面板异常报警
    byBoardNum: BYTE;  //子板号，从1起，B10不支持该字段，无效，置为0xff
    byRes1: array[0..2-1] of BYTE;  
    bySubSystemChan: array[0..8-1] of BYTE;  //子板槽位号,一个子板中有8个子系统，其分别对应的槽位号，子系统异常时，bySubSystemChan[0]表示对应子系统序号
    iTemperature: INT;  //温度超限报警时有用，温度值
    byMainboardSeq: BYTE;  //温度超限报警时有用，0-非主板，1-主板
    byRes2: array[0..3-1] of BYTE;  
    byFanSequence: array[0..32-1] of BYTE;  //异常风扇，byFanSequence[i] = 1表示风扇i+1异常，byFanSequence[i] = 0表示风扇i+1正常
    struInputNote: NET_DVR_MATRIXSUBSYSTEMINFO;  // 光纤异常报警时使用，输入结点
    struOutputNote: NET_DVR_MATRIXSUBSYSTEMINFO;  //光纤异常报警时使用，输出结点
    byRes3: array[0..68-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOPLATFORM_ALRAMINFO = ^NET_DVR_VIDEOPLATFORM_ALRAMINFO;

//**************************审讯DVR begin ****************************
const
  MAX_INQUEST_PIP_NUM = 3;    //单通道显示的画中画数目
  MAX_INQUEST_CDRW_NUM = 4;    //最大刻录机数目
  MAX_INQUEST_PIP_NUM_EX = 16;    //审讯机画中画最大个数

type
  NET_DVR_INQUEST_CDRW_CFG = record 
    dwSize: DWORD;  
    dwNum: DWORD;  //刻录机的数量
    dwRwSelectPara: array[0..MAX_CHANNUM_V30-1] of DWORD;  // 是否选中该光驱
    dwModeSelect: DWORD;  //0表示循环刻录模式  1表示并行刻录模式(默认模式)
    byRes: array[0..24-1] of BYTE;  //保留
    dwStartCDRW: DWORD;  //DVR 本地已经开始刻录
    dwHdExcp: DWORD;  //硬盘有异 常
    dwInterval: DWORD;  //时间间隔，10分钟(0)、20分钟(1)、30分钟(2)
    sLable: array[0..64-1] of AnsiChar;  //光盘名称
  end;
  LPNET_DVR_INQUEST_CDRW_CFG = ^NET_DVR_INQUEST_CDRW_CFG;

type
  NET_DVR_INQUEST_FILEINFO = record 
    sFileName: array[0..36-1] of AnsiChar;  //文件名
    dwFileLen: DWORD;  //文件长度
  end;
  LPNET_DVR_INQUEST_FILEINFO = ^NET_DVR_INQUEST_FILEINFO;

type
  NET_DVR_INQUEST_FILES = record 
    dwFileNum: DWORD;  // 需要刻录或者删除的文件数，最多一次20个
    struFileInfo: array[0..MAX_RECORD_FILE_NUM-1] of NET_DVR_INQUEST_FILEINFO;  
    //下面两个参数在表示刻录的文件时使用
    dwCDIndex: DWORD;  //刻录机的索引：1:选择1号刻录机；2:选择2号刻录机； 3:3号刻录机,4:4号刻录机,5:所有刻录机
    bFinalizeDisc: DWORD;  // 0=刻录完之后不封盘；1=刻录完之后封盘
  end;
  LPNET_DVR_INQUEST_FILES = ^NET_DVR_INQUEST_FILES;

type
  NET_DVR_INQUEST_CDRW = record 
    dwEnable: DWORD;  //刻录机状态是否有效,0-无效,1-有效
    dwStatus: DWORD;  { 当dwType=0时，
                                                            0-光盘正常，1-无光盘或光盘异常,
                                                            当dwType=1或2时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足，
                                                            4-异常导致审讯终止(81不支持)
                                                            当dwType=3时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=4时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=5时,
                                                            0-光盘正常， 1-无光盘或光盘异常,
                                                            2-光盘已封盘(81不支持)
                                                            当dwType=6或7时,
                                                            0-刻录正常, 1-无光盘或光盘异常,
                                2-光盘已封盘(81不支持), 3-光盘空间不足}
    dwVolumn: DWORD;  //光盘容量,单位M
    dwFreeSpace: DWORD;  //光盘剩余容量,单位M
    dwTimeLeft: DWORD;  // 光盘剩余时间，单位秒
    byCDType: BYTE;  // 光盘类型
    byRes: array[0..3-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_INQUEST_CDRW = ^NET_DVR_INQUEST_CDRW;

type
  NET_DVR_INQUEST_CDRW_STATUS = record 

{运行状态：0-审讯开始，
1-审讯过程中刻录，2-审讯停止，
3-刻录审讯文件,
4-备份(事后备份和本地备份)
5-空闲
6-初始化硬盘
    7-恢复审讯}
    dwType: DWORD;  
    strCDRWNum: array[0..MAX_INQUEST_CDRW_NUM-1] of NET_DVR_INQUEST_CDRW;  //数组0表示刻录机1
    struInquestStartTime: NET_DVR_TIME_EX;  //审讯开始的时间点
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_CDRW_STATUS = ^NET_DVR_INQUEST_CDRW_STATUS;

type
  NET_DVR_INQUEST_PIP_PARAM = record 
    byPipChan: BYTE;  //画中画显示的通道 0xFF关闭
    byRes: array[0..3-1] of BYTE;  //保留字节
    wTopLeftX: WORD;  //画中画的x坐标
    wTopLeftY: WORD;  //画中画的Y坐标
  end;
  LPNET_DVR_INQUEST_PIP_PARAM = ^NET_DVR_INQUEST_PIP_PARAM;

type
  NET_DVR_INQUEST_PIP_STATUS = record 
    byBaseChan: BYTE;  //显示画中画所在的通道
    byBackChan: BYTE;  //显示画中画背景通道
    byPIPMode: BYTE;  {是否开启,
                                                                0 当前窗口无小画面
                                                                1 当前窗口有1个小画面
                                                                2 当前窗口有2个小画面
                                                                3 当前窗口有3个小画面
                                  }
    byRes: BYTE;  //保留字节
    strPipPara: array[0..MAX_INQUEST_PIP_NUM-1] of NET_DVR_INQUEST_PIP_PARAM;  //画面位置的参数
  end;
  LPNET_DVR_INQUEST_PIP_STATUS = ^NET_DVR_INQUEST_PIP_STATUS;

//V40扩展，将画中画个数扩展为32个
type
  NET_DVR_INQUEST_PIP_PARAM_V40 = record 
    byPipChan: BYTE;  //画中画显示的通道 0xFF关闭
    byRes1: array[0..3-1] of BYTE;  
    wTopLeftX: WORD;  //画中画的x坐标
    wTopLeftY: WORD;  //画中画的Y坐标
    wHeight: WORD;  //画中画的高 
    wWidth: WORD;  //画中画的宽 
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_INQUEST_PIP_PARAM_V40 = ^NET_DVR_INQUEST_PIP_PARAM_V40;

type
  NET_DVR_INQUEST_PIP_STATUS_V40 = record 
    struStructHead: NET_DVR_STRUCTHEAD;  
    byBaseChan: BYTE;  //显示画中画所在的通道
    byBackChan: BYTE;  //显示画中画背景通道
    byPIPMode: BYTE;  {是否开启, 0 当前窗口无小画面
                                                                    1 当前窗口有1个小画面
                                                                    2 当前窗口有2个小画面
                                                                    3 当前窗口有3个小画面
                                                                    4 当前窗口有4个小画面
                                                                    5 当前窗口有5个小画面
                                                                    6 当前画面有6个小画面
                                                                    7 当前窗口有7个小画面
                                                                    8 当前窗口有8个小画面
                                                                    9 当前窗口有9个小画面
                                    255  当前窗口关闭预览画面}
    byPipCount: BYTE;  //小画面的个数
    byPicShowMode: BYTE;  //画面显示模式，0-画中画，1-画面均分2-画面拼接
    byRes: array[0..31-1] of BYTE;  //保留
    strPipPara: array[0..MAX_INQUEST_PIP_NUM_EX-1] of NET_DVR_INQUEST_PIP_PARAM_V40;  //画面位置的参数
  end;
  LPNET_DVR_INQUEST_PIP_STATUS_V40 = ^NET_DVR_INQUEST_PIP_STATUS_V40;

type
  NET_DVR_INQUEST_SECRET_INFO = record 
    sSecretKey: array[0..16-1] of BYTE;  //码流加密密钥
    byRes: array[0..64-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_INQUEST_SECRET_INFO = ^NET_DVR_INQUEST_SECRET_INFO;


//**************************审讯DVR end ****************************


//*******************************接口参数结构(end)********************************
const
  MAX_BIGSCREENNUM = 100;    //最多大屏拼接数

type
  NET_DVR_SINGLESCREENCFG = record 
    byScreenSeq: BYTE;  //屏幕序号，0xff表示不用此屏,64-T解码器第一个表示主屏
    bySubSystemNum: BYTE;  //解码子系统槽位号,解码器此值没有用
    byDispNum: BYTE;  //解码子系统上对应显示通道号，64-T解码器中该值表示解码器的显示通道号
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_SINGLESCREENCFG = ^NET_DVR_SINGLESCREENCFG;

type
  NET_DVR_BIGSCREENCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //大屏拼接使能，0-不使能，1-使能
    byModeX: BYTE;  //大屏拼接模式
    byModeY: BYTE;  
    byMainDecodeSystem: BYTE;  //综合平台的解码板中该值表示主屏槽位号，64-T解码器中该值表示解码通道号
    byMainDecoderDispChan: BYTE;  //主屏所用显示通道号，1.1netra版本新增，netra解码器有两个显示通道，都能够作为主屏。64-T中该值无效
    byVideoStandard: BYTE;  //大屏每个子屏制式相同 1:NTSC,2:PAL
    byRes1: array[0..2-1] of BYTE;  
    dwResolution: DWORD;  //大屏每个子屏分辨率相同
    //大屏拼接从屏幕信息
    struFollowSingleScreen: array[0..MAX_BIGSCREENNUM-1] of NET_DVR_SINGLESCREENCFG;  
    //起始坐标必须为基准坐标的整数倍
    wBigScreenX: WORD;  //大屏在电视墙中起始X坐标
    wBigScreenY: WORD;  //大屏在电视墙中起始Y坐标
    byRes2: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_BIGSCREENCFG = ^NET_DVR_BIGSCREENCFG;


const
  DECODEPIC_LEFTADJUST = 1;    //图像左移
  DECODEPIC_RIGHTADJUST = 2;    //图像右移
  DECODEPIC_UPADJUST = 3;    //图像上移
  DECODEPIC_DOWNADJUST = 4;    //图像下移
  DECODEPIC_REDUCEADJUST = 5;    //图像缩小
  DECODEPIC_FULL_SCREEN_ADJUST = 6;    //图像全屏
  DECODEPIC_CANCEL_FULL_SCREEN_ADJUST = 7;    //图像取消全屏显示
  DECODEPIC_AUTOADJUST = 8;    //  图像自动调整 
  DECODEPIC_HEIGHTADJUST = 9;    // 图像高度调整 
  DECODEPIC_WIDTHADJUST = 10;    // 图像宽度调整 

const
  MAX_UNITEDMATRIX_NUM = 8;    //级联中最多视频综合平台数量
  MAX_SUBDOMAIN_NUM = 4;    //级联中最多子域数量
type
  NET_DVR_SUBSERVERINFO = record 
    bySequence: BYTE;  //序号，对于子域，是子域号，对于视频综合平台，是平台号，0表示无此平台\子域
    byBelongSubDomain: BYTE;  //对于平台有效，表示属于哪个子域
    byRes1: array[0..6-1] of BYTE;  
    dwMaxIpcNums: DWORD;  //连接的最多IPC数量
    struSubMatrixIP: NET_DVR_IPADDR;  //IP地址
    wSubMatrixPort: WORD;  //子系统端口号
    byRes2: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_SUBSERVERINFO = ^NET_DVR_SUBSERVERINFO;

type
  NET_DVR_UNITEDMATRIXINFO = record 
    dwSize: DWORD;  
    struDomainInfo: NET_DVR_SUBSERVERINFO;  
    struSubDomainInfo: array[0..MAX_SUBDOMAIN_NUM-1] of NET_DVR_SUBSERVERINFO;  //子域信息
    struMatrixInfo: array[0..MAX_UNITEDMATRIX_NUM-1] of NET_DVR_SUBSERVERINFO;  //视频综合平台信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_UNITEDMATRIXINFO = ^NET_DVR_UNITEDMATRIXINFO;

type
  NET_DVR_REGCALLBACKPARAM = record 
    sDeviceID: array[0..NAME_LEN-1] of AnsiChar;  //设备ID串
    sPassword: array[0..PASSWD_LEN-1] of AnsiChar;  
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  // 设备序列号 
    dwDeviceType: DWORD;  //设备类型
    nStatus: BYTE;  // 上下线状态（0下线，1上线）
    // net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks 
    byNetType: BYTE;  
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_REGCALLBACKPARAM = ^NET_DVR_REGCALLBACKPARAM;

type
  NET_DVR_LOGONREPONSEPARAM = record 

    //心跳时间间隔，单位：秒, 5的倍数，180秒以内。默认是15秒。
    wHeartbeatTime: WORD;  
    byOvertimes: BYTE;  // 设备心跳超时次数，默认是3次
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_LOGONREPONSEPARAM = ^NET_DVR_LOGONREPONSEPARAM;


type
  NET_DVR_PREVIEWPARAM = record 
    byTransProtol: BYTE;  //传输协议，0-TCP, 1-UDP
    byTransMode: BYTE;  ///* 传输码流模式 0－主码流 1－子码流}
    struCuIp: NET_DVR_IPADDR;  //CU端IP地址
    wPort: WORD;  //CU端口
    wUdpPort: WORD;  
    bySupportQos: BYTE;  //是否启用QOS,1-启用，0-不启用
    //是否是NAT预览请求，0-否，1-是(只需byTransMode字段)
    byNatRequest: BYTE;  
    byPreviewType: BYTE;  // 0-普通预览 1-延时预览
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEWPARAM = ^NET_DVR_PREVIEWPARAM;
type
  NET_DVR_DEVICENATINFO = record 
    struPuIp: NET_DVR_IPADDR;  //PU端外网IP地址
    wOuterPort: WORD;  //PU外网端口
    wInterPort: WORD;  //PU发送视频的本地端口
    nSessionID: DWORD;  //CMS分配的sessionID
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_DEVICENATINFO = ^NET_DVR_DEVICENATINFO;


type
  NET_DVR_PREVIEWCALLBACKPARAM = record 
    lChannel: LONG;  
    nLinkProtocol: BYTE;  
    nTransMode: BYTE;  
    byPreviewType: BYTE;  //0-普通预览 1-延时预览
    byRes: array[0..5-1] of BYTE;  
    nSessionID: DWORD;  //CMS分配的sessionID
  end;
  LPNET_DVR_PREVIEWCALLBACKPARAM = ^NET_DVR_PREVIEWCALLBACKPARAM;

//回放
type
  NET_DVR_PLAYBACKREQUESTPARAM = record 
    byPlayBackMode: BYTE;  // 回放下载模式 1－按名字 2－按时间 
    byRes1: array[0..3-1] of BYTE;  
    playbackmode: record 
      case Byte of
      0: (sFileName: array[0..100-1] of AnsiChar);  // 回放的文件名 
      1: (struPlayBackbyTime: record
        lChannel: LONG;  //回放的通道号
        struStartTime: NET_DVR_TIME;  // 按时间回放的开始时间 
        struStopTime: NET_DVR_TIME;  // 按时间回放的结束时间 
        byRes: array[0..48-1] of BYTE;  
      end);  
    end;  
    struCuIp: NET_DVR_IPADDR;  //CU端IP地址
    wPort: WORD;  //CU端口
    byRes2: array[0..2-1] of BYTE;  
    dwSessionID: DWORD;  //CMS分配的sessionID,输出参数
    byRes3: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PLAYBACKREQUESTPARAM = ^NET_DVR_PLAYBACKREQUESTPARAM;

//2010-10-06
type
  NET_DVR_PLAYBACKCALLBACKPARAM = record 
    byPlayBackMode: BYTE;  // 回放下载模式 1－按名字 2－按时间 
    byRes1: array[0..3-1] of BYTE;  
    playbackmode: record 
      case Byte of
      0: (sFileName: array[0..100-1] of AnsiChar);  // 回放的文件名 
      1: (struPlayBackbyTime: record
        lChannel: LONG;  //回放的通道号
        struStartTime: NET_DVR_TIME;  // 按时间回放的开始时间 
        struStopTime: NET_DVR_TIME;  // 按时间回放的结束时间 
        byRes: array[0..48-1] of BYTE;  
      end);  
    end;  
    nSessionID: DWORD;  //CMS分配的sessionID
    byRes2: array[0..44-1] of BYTE;  
  end;
  LPNET_DVR_PLAYBACKCALLBACKPARAM = ^NET_DVR_PLAYBACKCALLBACKPARAM;

type
  NET_DVR_VOICEREQUESTPARAM = record 
    nVoiceChannel: BYTE;  //对讲通道号
    byRes1: array[0..3-1] of BYTE;  
    struCuIp: NET_DVR_IPADDR;  //CU端IP地址
    wPort: WORD;  //CU端口
    byRes2: array[0..10-1] of BYTE;  
  end;
  LPNET_DVR_VOICEREQUESTPARAM = ^NET_DVR_VOICEREQUESTPARAM;

type
  NET_DVR_ALARMSETUPREQUESTPARAM = record 
    struCuIp: NET_DVR_IPADDR;  //CU端IP地址
    wPort: WORD;  //CU端口
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_ALARMSETUPREQUESTPARAM = ^NET_DVR_ALARMSETUPREQUESTPARAM;

type
  NET_DVR_GPSALARMINFO = record 
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
    struGpsTime: NET_DVR_TIME_EX;  //GPS上传的时间
    dwLongitude: DWORD;  // 经度
    dwLatitude: DWORD;  // 纬度
    iTimeZone: INT;  //时区，用分钟数表示，+60代表东1区，+480代表东8区，-60代表西区，-480代表西8区，该字段和GPSTime构成一个完整的时间描述
    dwDirection: DWORD;  //车辆方向=实际方向（以度为单位，正北方向为，顺时针方向计算）*100
    wSatellites: WORD;  //卫星数量
    wPrecision: WORD;  //精度
    dwHeight: DWORD;  //高度:厘米，预留
    dwGPSSeq: DWORD;  //GPS序号，GPS补传时要用到
    wSpeed: WORD;  //速度，单位，km/h
    // direction[0]:'E'or'W'(东经/西经), direction[1]:'N'or'S'(北纬/南纬)
    sDirection: array[0..2-1] of AnsiChar;  
    byLocateMode: BYTE;  //定位模式(初值0)，1,自主定位,2,差分3,估算,4,数据无效，65,有效定位，78，无效定位
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_GPSALARMINFO = ^NET_DVR_GPSALARMINFO;

//图片信息上传
type
  NET_DVR_PICTUREINFO = record 
    dwSize: DWORD;  //结构长度
    byChanIndex: BYTE;  //通道号
    byRes1: array[0..3-1] of BYTE;  //保留
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
    byAbsTime: array[0..32-1] of BYTE;  //绝对时间点, yyyymmddhhmmssxxx,
    dwPicLen: DWORD;  //图片长度
    byRes2: array[0..32-1] of BYTE;  
    pPicBuffer: PBYTE;  
  end;
  LPNET_DVR_PICTUREINFO = ^NET_DVR_PICTUREINFO;

//平台参数
type
  NET_DVR_CMSPARAM = record 
    dwSize: DWORD;  
    struCmsAddr: NET_DVR_IPADDR;  
    wCmsPort: WORD;  
    byRes1: array[0..2-1] of BYTE;  
    sDeviceID: array[0..NAME_LEN-1] of BYTE;  
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  
    struPicServerAddr: NET_DVR_IPADDR;  
    wPicServerPort: WORD;  
    wCmsUdpPort: WORD;  //CMS用于UDP外网查询的端口
    byRes2: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_CMSPARAM = ^NET_DVR_CMSPARAM;

///拨号功能
const
  DIALPASSWD_LEN = 32;    //拨号密码长度

type
  NET_DVR_QOSPARAM = record 
    wMaxBitUL: WORD;  // the maximum number of kbits/s in up-link traffic 
    wMaxBitDL: WORD;  // the maximum number of kbits/s in down-link traffic 
    byTrafficClass: BYTE;  // 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) 
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_QOSPARAM = ^NET_DVR_QOSPARAM;


type
  NET_DVR_PPPDPARAM = record 
    byDialNum: array[0..NAME_LEN-1] of BYTE;  // dial number, eg. "#777" 
    byUserName: array[0..NAME_LEN-1] of BYTE;  // user name, eg. "card" 
    byPassword: array[0..DIALPASSWD_LEN-1] of BYTE;  // password, eg. "card" 
    byApn: array[0..NAME_LEN-1] of BYTE;  // access point name, eg. "cmnet" 
    struLocalIp: NET_DVR_IPADDR;  // local IP address 
    struRemoteIp: NET_DVR_IPADDR;  // remote IP address 
    wMtuSize: WORD;  // max transfer unit of ppp interface 
    byVerifyProtocal: BYTE;  // IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP 
    byRes: array[0..25-1] of BYTE;  
  end;
  LPNET_DVR_PPPDPARAM = ^NET_DVR_PPPDPARAM;

const
  MAX_PHONE_NUM = 32;    //最长号码长度

type
  NET_DVR_DIALPARAM = record 
    dwSize: DWORD;  
    bEnable3G: BYTE;  // 0: disable; 1: enable 3g 
    byDialMethod: BYTE;  // dial methold: 0: auto dial; 1: manual dial; 
    bySwitchMethod: BYTE;  // switch methold: 0: auto switch;1：3G优先，2: manual switch to 2G; 3: manual switch to 3G; 
    byEnaAlarmInDial: BYTE;  // 使能报警输入触发拨号; 0: disable; 1: enable 
    byRes1: array[0..10-1] of BYTE;  
    wOffLineTime: WORD;  // auto off line when no connection exist,单位：分钟，范围：5~65535分钟 
    struPppdParam: NET_DVR_PPPDPARAM;  
    struQosParam: NET_DVR_QOSPARAM;  
    byUimNumber: array[0..MAX_PHONE_NUM-1] of BYTE;  
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_DIALPARAM = ^NET_DVR_DIALPARAM;

type
  NET_DVR_DIALREQUEST = record 
    byConnNum: BYTE;  //网卡序号
    byNetType: BYTE;  // 指定获得某个网络的默认拨号参数，设置时此参数没用。0：自动；1：CDMA；2：EVDO；3：WCDMA；4：TD-SCDMA 
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_DIALREQUEST = ^NET_DVR_DIALREQUEST;


// UIM card information 
type
  UIM_INFO =  
  (  
    UIM_UNKNOWN = 0,  
    UIM_VALID = 1,  
    UIM_NOVALID = 4,  
    UIM_ROAM = 11,  
    UIM_NOEXIST = 255  
  );

// real 3g mode 
type
  REAL_MODE =  
  (  
    // evdo 
    RMODE_CDMA1X = 12,  
    RMODE_EVDO = 14,  
    RMODE_CDMAHYBRID = 18,  
        // wcdma 
    RMODE_GSM = 21,  
    RMODE_GPRS = 22,  
    RMODE_EDGE = 23,  
    RMODE_WCDMA = 24,  
    RMODE_HSDPA = 25,  
    RMODE_HSUPA = 26,  
    RMODE_HSPA = 27,  
        // tdscdma 
    RMODE_TGSM = 31,  
    RMODE_TGPRS = 32,  
    RMODE_TEDGE = 33,  
    RMODE_TDSCDMA = 34,  
    RMODE_TDHSDPA = 35,  
    RMODE_TDHSUPA = 36,  
    RMODE_TDHSPA = 37  
  );

type
  NET_DVR_DIALSTATUS = record 
    byRealMode: BYTE;  // REAL_MODE ,real 3g mode networks 
    byUimCard: BYTE;  // UIM_INFO ,UIM card information 
    byRes1: array[0..6-1] of BYTE;  
    dwSignal: DWORD;  // signal RSSI 
    dwDialStatus: DWORD;  // dial status 
    struLocalIp: NET_DVR_IPADDR;  // wireless networks IP address 
    struRemoteIp: NET_DVR_IPADDR;  // wireless networks gateway 
    struNetMask: NET_DVR_IPADDR;  // wireless networks netmask 
    struDns: NET_DVR_IPADDR;  // wireless networks DNS 
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_DIALSTATUS = ^NET_DVR_DIALSTATUS;

//短信功能
const
  MAX_ALLOWLIST_NUM = 8;    //最大允许名单数
  NET_SDK_MAX_ALLOWLIST_NUM_32 = 32;    //最大允许名单数

const
  HARDDISKFULL_EXCEPTION = $0;    //硬盘满
  HARDDISKERROR_EXCEPTION = $1;    //硬盘错
  ETHERNETBROKEN_EXCEPTION = $2;    //网线断
  IPADDRCONFLICT_EXCEPTION = $3;    //IP地址冲突
  ILLEGALACCESS_EXCEPTION = $4;    //非法访问
  VI_EXCEPTION = $5;    //视频信号异常
  VS_MISMATCH_EXCEPTION = $6;    //输入/输出视频制式不匹配 
  VIDEOCABLELOSE_EXCEPTION = $7;    //视频无信号
  AUDIOCABLELOSE_EXCEPTION = $8;    //音频无信号
  ALARMIN_EXCEPTION = $9;    //报警输入
  MASKALARM_EXCEPTION = $a;    //遮挡报警
  MOTDET_EXCEPTION = $b;    //移动侦测
  RECORDING_EXCEPTION = $c;    //录像异常
  WIRELESS_EXCEPTION = $d;    //PIR报警
  PIR_EXCEPTION = $e;    //无线报警
  CALLHELP_EXCEPTION = $f;    //呼救报警

const
  AUDIO_DETECTION_EXCEPTION = $10;    //音频异常侦测报警
  SCENECHANGE_DETECTION_EXCEPTION = $11;    //场景侦测报警
  DEFOCUS_DETECTION_EXCEPTION = $12;    //虚焦侦测报警
  FACE_DETECTION_ENTRANCE_EXCEPTION = $13;    //人脸侦测报警
  LINE_DETECTION_ENTRANCE_EXCEPTION = $14;    //越界侦测报警
  FIELD_DETECTION_ENTRANCE_EXCEPTION = $15;    //区域入侵侦测报警
  REGION_EXITING_EXCEPTION = $16;    //离开区域侦测报警
  REGION_ENTRANCE_EXCEPTION = $17;    //进入区域报警
  LOITERING_EXCEPTION = $18;    //人员徘徊侦测报警
  GROUP_EXCEPTION = $19;    //人员聚集侦测报警
  RAPIDMOVE_EXCEPTION = $1a;    //快速移动侦测报警
  PARKING_EXCEPTION = $1b;    //停车侦测报警
  UNATTENDEDBAGGAGE_EXCEPTION = $1c;    //物品遗留侦测报警
  ATTENDEDBAGGAGE_EXCEPTION = $1d;    //物品拿取侦测报警
  DATATRAFFIC_EXCESS = $1e;    //流量超额
  VOLTAGEINSTABLE_EXCEPTION = $1f;    //电源电压异常报警
  ALL_EXCEPTION = $ff;    //所有事件，根据事件联动方式判断是否开启短信联动


const
  PHONECFG_RECEIVE_SMS = $0;    // 支持接收报警短信 
  PHONECFG_SMS_CONTROL = $1;    // 支持短信控制上下线 
  PHONECFG_CALL_CONTROL = $2;    // 支持呼叫控制上线 
  PHONECFG_SMS_REBOOT = $3;    //支持短信重启
  PHONECFG_DOOR_CONTROL = $4;    // 支持门操作控制
  PHONECFG_SMS_GET_DAIL_STATUS = $5;    // 支持短信获取拨号状态


type
  NET_DVR_PHONECFG = record 
    byAllowList: array[0..MAX_PHONE_NUM-1] of BYTE;  
    byPhonePerssion: array[0..32-1] of BYTE;  {按字节表示是否使能该号码的某功能，具体位代表的含义
    见PHONECFG_RECEIVE_SMS等定义 }
    byAlarmHandler: array[0..32-1] of BYTE;  //按字节表示是否使能对某个报警类型的短信发送
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PHONECFG = ^NET_DVR_PHONECFG;

type
  NET_DVR_SMSRELATIVEPARAM = record 
    dwSize: DWORD;  
    bEnableSmsAlarm: BYTE;  // 0: disable; 1: enable 3g 
    byRes1: array[0..7-1] of BYTE;  
    struAllowList: array[0..MAX_ALLOWLIST_NUM-1] of NET_DVR_PHONECFG;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SMSRELATIVEPARAM = ^NET_DVR_SMSRELATIVEPARAM;

type
  NET_DVR_PHONECFG_V50 = record 
    byAllowList: array[0..MAX_PHONE_NUM-1] of BYTE;  
    byPhonePerssion: array[0..32-1] of BYTE;  {按字节表示是否使能该号码的某功能，具体位代表的含义
                              见PHONECFG_RECEIVE_SMS等定义 }
    byAlarmHandler: array[0..32-1] of BYTE;  //按字节表示是否使能对某个报警类型的短信发送(门禁主机暂时用不到)
    byAcsPassword: array[0..16-1] of BYTE;  //开门命令
    byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
    byRes: array[0..80-1] of BYTE;  
  end;
  LPNET_DVR_PHONECFG_V50 = ^NET_DVR_PHONECFG_V50;

type
  NET_DVR_SMSRELATIVEPARAM_V50 = record 
    dwSize: DWORD;  
    bEnableSmsAlarm: BYTE;  // 0: disable; 1: enable 3g 
    byRes1: array[0..7-1] of BYTE;  
    struAllowList: array[0..NET_SDK_MAX_ALLOWLIST_NUM_32-1] of NET_DVR_PHONECFG_V50;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SMSRELATIVEPARAM_V50 = ^NET_DVR_SMSRELATIVEPARAM_V50;

const
  NET_SDK_MONITOR_ID_LEN = 64;    //布防点ID长度

type
  NET_DVR_ACS_EVENT_COND = record 
    dwSize: DWORD;  
    dwMajor: DWORD;  //报警主类型，参考事件上传宏定义，0-全部
    dwMinor: DWORD;  //报警次类型，参考事件上传宏定义，0-全部
    struStartTime: NET_DVR_TIME;  //开始时间
    struEndTime: NET_DVR_TIME;  //结束时间
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    byName: array[0..NAME_LEN-1] of BYTE;  //持卡人姓名
    byPicEnable: BYTE;  //是否带图片，0-不带图片，1-带图片
    byTimeType: BYTE;  //时间类型：0-设备本地时间（默认），1-UTC时间（struStartTime和struEndTime的时间）
    byRes2: array[0..2-1] of BYTE;  //保留
    dwBeginSerialNo: DWORD;  //起始流水号（为0时默认全部）
    dwEndSerialNo: DWORD;  //结束流水号（为0时默认全部）
    dwIOTChannelNo: DWORD;  //IOT通道号，0-无效
    wInductiveEventType: WORD;  //归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    bySearchType: BYTE;  //搜索方式：0-保留，1-按事件源搜索（此时通道号为非视频通道号），2-按布防点ID搜索
    byEventAttribute: BYTE;  //事件属性：0-未定义，1-合法事件，2-其它
    szMonitorID: array[0..NET_SDK_MONITOR_ID_LEN{64}-1] of AnsiChar;  //布防点ID（由设备序列号、通道类型、编号组成，例如门禁点：设备序列号+“DOOR”+门编号）
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byRes: array[0..140-1] of BYTE;  //保留
  end;
  LPNET_DVR_ACS_EVENT_COND = ^NET_DVR_ACS_EVENT_COND;

type
  NET_DVR_ACS_EVENT_DETAIL = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号（mac地址），为0无效
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    byAllowListNo: BYTE;  //允许名单单号,1-8，为0无效
    byReportChannel: BYTE;  //报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
    byCardReaderKind: BYTE;  //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    dwCardReaderNo: DWORD;  //读卡器编号，为0无效
    dwDoorNo: DWORD;  //门编号（楼层编号），为0无效
    dwVerifyNo: DWORD;  //多重卡认证序号，为0无效
    dwAlarmInNo: DWORD;  //报警输入号，为0无效
    dwAlarmOutNo: DWORD;  //报警输出号，为0无效
    dwCaseSensorNo: DWORD;  //事件触发器编号
    dwRs485No: DWORD;  //RS485通道号，为0无效
    dwMultiCardGroupNo: DWORD;  //群组编号
    wAccessChannel: WORD;  //人员通道号
    byDeviceNo: BYTE;  //设备编号，为0无效（有效范围1-255）
    byDistractControlNo: BYTE;  //分控器编号，为0无效
    dwEmployeeNo: DWORD;  //工号，为0无效
    wLocalControllerID: WORD;  //就地控制器编号，0-门禁主机，1-64代表就地控制器
    byInternetAccess: BYTE;  //网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理地址，为0无效
    bySwipeCardType: BYTE;  //刷卡类型，0-无效，1-二维码
    byEventAttribute: BYTE;  //事件属性：0-未定义，1-合法认证，2-其它
    dwSerialNo: DWORD;  //事件流水号，为0无效
    byChannelControllerID: BYTE;  //通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
    byChannelControllerLampID: BYTE;  //通道控制器灯板ID，为0无效（有效范围1-255）
    byChannelControllerIRAdaptorID: BYTE;  //通道控制器红外转接板ID，为0无效（有效范围1-255）
    byChannelControllerIREmitterID: BYTE;  //通道控制器红外对射ID，为0无效（有效范围1-255）
    dwRecordChannelNum: DWORD;  //录像通道数目
    pRecordChannelData: PAnsiChar;  //录像通道，大小为sizeof(DWORD)* dwRecordChannelNum
    byUserType: BYTE;  //人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
    byCurrentVerifyMode: BYTE;  //读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，
            //13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码，28-人脸或密码，29-工号+人脸+密码，30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    byAttendanceStatus: BYTE;  //考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
    byStatusValue: BYTE;  //考勤状态值
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
    byRes1: BYTE;  //保留
    byMask: BYTE;  //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    byThermometryUnit: BYTE;  //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    byIsAbnomalTemperature: BYTE;  //人脸抓拍测温是否温度异常：1-是，0-否
    fCurrTemperature: FLOAT;  //人脸温度（精确到小数点后一位）
    struRegionCoordinates: NET_VCA_POINT;  //人脸温度坐标
    wXCoordinate: WORD;  //x坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wYCoordinate: WORD;  //y坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wWidth: WORD;  //人脸框宽度，范围0-1000
    wHeight: WORD;  //人脸框高度，范围0-1000
    byHealthCode: BYTE;  //健康码状态, 0-保留, 1-未请求, 2-未申领, 3-绿码, 4-黄码, 5-红码, 6-无此人员, 7-其他错误信息（如接口异常导致查询失败）, 8-查询健康码超时
    byNADCode: BYTE;  //核酸检测结果, 0-保留, 1-未查询到核酸检测结果, 2-核酸检测阴性（代表正常）, 3-核酸检测阳性（代表确诊）, 4-核酸检测有效期已过
    byTravelCode: BYTE;  //行程编码, 0-保留, 1-14天内一直在当地, 2-14天内离开过当地, 3-14天内到过疫区, 4-其他
    byVaccineStatus: BYTE;  //打疫苗状态, 0-保留, 1-未打疫苗, 2-部分注射疫苗, 3-打过疫苗
    byRes: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EVENT_DETAIL = ^NET_DVR_ACS_EVENT_DETAIL;

type
  NET_DVR_ACS_EVENT_CFG = record 
    dwSize: DWORD;  
    dwMajor: DWORD;  //报警主类型，参考宏定义
    dwMinor: DWORD;  //报警次类型，参考宏定义
    struTime: NET_DVR_TIME;  //时间
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    struAcsEventInfo: NET_DVR_ACS_EVENT_DETAIL;  //详细参数
    dwPicDataLen: DWORD;  //图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  
    wInductiveEventType: WORD;  //归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    byTimeType: BYTE;  //时间类型：0-设备本地时间（默认），1-UTC时间（struTime的时间）
    byRes1: BYTE;  
    dwQRCodeInfoLen: DWORD;  //二维码信息长度，不为0是表示后面带数据
    dwVisibleLightDataLen: DWORD;  //热成像相机可见光图片长度，不为0是表示后面带数据
    dwThermalDataLen: DWORD;  //热成像图片长度，不为0是表示后面带数据
    pQRCodeInfo: PAnsiChar;  //二维码信息指针
    pVisibleLightData: PAnsiChar;  //热成像相机可见光图片指针
    pThermalData: PAnsiChar;  //热成像图片指针
    byRes: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EVENT_CFG = ^NET_DVR_ACS_EVENT_CFG;

type
  NET_DVR_SMSLISTINFO = record 
    dwSize: DWORD;  
    dwTotalSmsNum: DWORD;  //短信条数
    byRes: array[0..8-1] of BYTE;  
    pSmsParam: PBYTE;  
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_SMSLISTINFO = ^NET_DVR_SMSLISTINFO;

type
  NET_DVR_SMSPARAM = record 
    dwIndex: DWORD;  // the index of sms 
    byStatus: BYTE;  // read yet or not 
    byRes: array[0..7-1] of BYTE;  
    struRecvTime: NET_DVR_TIME_EX;  // sms receive time 
  end;
  LPNET_DVR_SMSPARAM = ^NET_DVR_SMSPARAM;

const
  MAX_SMSCONTENT_LEN = 140;    //短信内容长度
type
  NET_DVR_SMSCONTENT = record 
    byPhoneNum: array[0..MAX_PHONE_NUM-1] of BYTE;  
    byMsg: array[0..MAX_SMSCONTENT_LEN-1] of BYTE;  
  end;
  LPNET_DVR_SMSCONTENT = ^NET_DVR_SMSCONTENT;

//pin码配置
type
  PIN_READY =  
  (  
    CPIN_READY = 1,  
    CPIN_PIN = 2,  
    CPIN_PUK = 3,  
    CPIN_PIN2 = 4,  
    CPIN_PUK2 = 5  
  );

type
  NET_DVR_PINSTATUS = record 
    dwSize: DWORD;  
    byStatus: BYTE;  // PIN status, defination see enum: PIN_READY 
    byPinTimes: BYTE;  // remain input PIN times 
    byPukTimes: BYTE;  // remain input PUK times 
    bEnableLock: BYTE;  // now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled 
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_PINSTATUS = ^NET_DVR_PINSTATUS;

type
  PIN_CMD =  
  (  
    PIN_ENABLE = 1,  
    PIN_DISABLE = 2,  
    PIN_VERIFY = 3,  
    PUK_VERIFY = 4,  
    PIN_CHANGE = 5  
  );
const
  MAX_PIN_LEN = 12;    //PIN码最大长度
type
  NET_DVR_PINCODEPARAM = record 
    dwSize: DWORD;  
    byPinCmd: BYTE;  // PIN command, defination see enum: PIN_CMD 
    byRes1: array[0..3-1] of BYTE;  
    byPinCode: array[0..MAX_PIN_LEN-1] of BYTE;  // pin/puk code 
    byNewPinCode: array[0..MAX_PIN_LEN-1] of BYTE;  // new pin code 
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PINCODEPARAM = ^NET_DVR_PINCODEPARAM;


//图片质量
type
  NET_DVR_PUSHJPEGPARA = record 

    // 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA
    wPicSize: WORD;  
    wPicQuality: WORD;  // 图片质量系数 0-最好 1-较好 2-一般 
    //抓图图片处理方式，1-上传中心，2-设备本地保存，3-上传中心同时设备本地保存
    byPicTackleMode: BYTE;  
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_PUSHJPEGPARA = ^NET_DVR_PUSHJPEGPARA;


const
  COM_PUSHALARM = $1200;    //设备基本报警信息上传，推模式设备使用
  COM_PUSHALARM_V30 = $1201;    //设备基本报警信息上传v30，推模式设备使用
type
  NET_DVR_PUSHALARMINFO = record 
    dwAlarmType: DWORD;  //0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问
    dwAlarmInputNumber: DWORD;  //报警输入端口
    dwAlarmOutputNumber: array[0..MAX_ALARMOUT-1] of DWORD;  //触发的输出端口，哪一位为1表示对应哪一个输出
    dwAlarmRelateChannel: array[0..MAX_CHANNUM-1] of DWORD;  //触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道
    dwChannel: array[0..MAX_CHANNUM-1] of DWORD;  //dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道
    dwDiskNumber: array[0..MAX_DISKNUM-1] of DWORD;  //dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_PUSHALARMINFO = ^NET_DVR_PUSHALARMINFO;

type
  NET_DVR_PUSHALARMINFO_V30 = record 
    dwAlarmType: DWORD;  //0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 
    dwAlarmInputNumber: DWORD;  //报警输入端口
    byAlarmOutputNumber: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //触发的输出端口，为1表示对应输出
    byAlarmRelateChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道
    byChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //dwAlarmType为2或3,6，9，10时，表示哪个通道，dwChannel[0]对应第1个通道
    byDiskNumber: array[0..MAX_DISKNUM_V30-1] of BYTE;  //dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_PUSHALARMINFO_V30 = ^NET_DVR_PUSHALARMINFO_V30;

//2011-04-20
//启动控制
type
  NET_DVR_MB_AUTOWORKPARA = record 

    //当前启动控制方式 0:  预留,  1:  延时关机,  2:  自动开关机
    byCurPowerCtrlType: BYTE;  
    byRes: array[0..3-1] of BYTE;  
    struWorkTime: array[0..MAX_DAYS-1, 0..2-1] of NET_DVR_SCHEDTIME;  
  end;
  LPNET_DVR_MB_AUTOWORKPARA = ^NET_DVR_MB_AUTOWORKPARA;

type
  NET_DVR_MB_POWERCTRLPARA = record 
    dwSize: DWORD;  
    dwHaltDelay: DWORD;  // 关机延迟时间,单位min 
    struAutoWorkPara: NET_DVR_MB_AUTOWORKPARA;  //启动控制相关参数设置
    byEnableUnderVoltProtect: BYTE;  //是否开启欠压保护
    byUnderVoltPercent: BYTE;  //欠压保护百分比，有85、90、95三个有效值
    byRes: array[0..34-1] of BYTE;  
  end;
  LPNET_DVR_MB_POWERCTRLPARA = ^NET_DVR_MB_POWERCTRLPARA;
//注：1）、关机延迟时间, 可选时间为 0，5分钟，10分钟 ，20分钟 25分钟 30分钟 35分钟 40分钟 ，45 分钟 50分钟 ，60分钟 ，60*2分钟 ，60*3  60 *4   60*5  60*6 

//自动备份
type
  NET_DVR_MB_AUTOBACKUPPARA = record 
    dwSize: DWORD;  
    byEnableAutoBackup: BYTE;  // 是否开启自动备份 0 关闭 ，1 开启 
    byRes1: array[0..3-1] of BYTE;  
    byBackupChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //需要备份的通道
    byBackupDays: array[0..MAX_CHANNUM_V30-1] of BYTE;  //备份天数
                                        { 备份文件类型
                                        <0,ALL_RECORD_TYPE,全部>,
                                        <1,TIMING_REC,定时>,
                                        <2,MOTION_DETECT_REC,移动侦测 >,
                                        <3,ALARM_REC,报警 >,
    <4,MANUAL_REC,手动录像>}
    byBackupFileType: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    struBackupTime: array[0..MAX_CHANNUM_V30-1, 0..2-1] of NET_DVR_SCHEDTIME;  // 自动备份时间段
    byRes2: array[0..36-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_MB_AUTOBACKUPPARA = ^NET_DVR_MB_AUTOBACKUPPARA;


type
  NET_DVR_MB_GPSPARA = record 
    dwSize: DWORD;  
    byEnableGPS: BYTE;  //是否启用GPS 
    byGpsInterface: BYTE;  //gps接收接口0-rs232, 1-rs485, 2-frontpanel, 3-lcd 
    bySpeedUnit: BYTE;  //速度单位，0：公里/小时，1 ：英里/小时
    byEnableRetrieve: BYTE;  // 盲区补发(1启用，0不启用) 
    iAdjustTime: INT;  //时区
    byEnableAdjustTime: BYTE;  //是否启用GPS校时， 1-启用, 0-不启动
    byRes1: array[0..5-1] of BYTE;  
    wGpsUploadInterval: WORD;  // GPS上传间隔, 秒
    byGpsOsdChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //OSD 显示，每字节代表一路 
    dwSpeedLimit: DWORD;  // 限速报警
    struGpsAlarm: NET_DVR_HANDLEEXCEPTION_V30;  
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_MB_GPSPARA = ^NET_DVR_MB_GPSPARA;
//注：1）、当单位为公里/小时 时范围为（0 ,965）；当采用英里/小时做单位的时候 ，最大速度范围为：0-600

const
  SENSOR_IN_NUMBER = 8;    
type
  NET_DVR_MB_SENSORINPARA = record 
    dwSize: DWORD;  
    byTriggerType: array[0..SENSOR_IN_NUMBER-1] of BYTE;  //行车状态相关触发的联动，只用后4个，分别代表刹车、左转、右转、倒车，0-高电平，1-低电平
    byTriggerChannel: array[0..SENSOR_IN_NUMBER-1] of BYTE;  
    byOsdDisplay: array[0..MAX_CHANNUM_V30-1] of BYTE;  //OSD显示,每位代表一路
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MB_SENSORINPARA = ^NET_DVR_MB_SENSORINPARA;


type
  NET_DVR_ACCELERATIONCFG = record 
    dwMaxXAcc: DWORD;  // X轴加速度报警值 ，该取值为实际数值乘以10,最小为0
    dwMaxYAcc: DWORD;  // Y轴加速度报警值 ，该取值为实际数值乘以10.最小为0
    dwMaxZAcc: DWORD;  // Z轴加速度报警值， 该取值为实际数值乘以10,最小为0
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_ACCERATIONCFG = ^NET_DVR_ACCELERATIONCFG;

type
  NET_DVR_GSENSORPARA = record 
    dwSize: DWORD;  
    struAccelerationCfg: NET_DVR_ACCELERATIONCFG;  
    byModuleSelect: BYTE;  //模块选择：0内置/1外置
    byRes1: array[0..3-1] of BYTE;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V30;  
    byRes2: array[0..24-1] of BYTE;  //保留扩展字节
  end;
  LPNET_DVR_GSENSORPARA = ^NET_DVR_GSENSORPARA;

type
  NET_DVR_MB_DOWNLOADSVRPARA = record 
    dwSize: DWORD;  
    struDownloadSvrIp: NET_DVR_IPADDR;  // 自动下载服务器地址 
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MB_DOWNLOADSVRPARA = ^NET_DVR_MB_DOWNLOADSVRPARA;

// 车牌识别的相关参数
type
  NET_DVR_PLATERECOG_PARA = record 
    dwSize: DWORD;  
    byPrMode: BYTE;  // 车牌识别的模式, 静态图像0/动态视频1 
    byPrScene: BYTE;  // 车牌识别的场景, 低速场景0/高速场景1 
    byPrDetRect: BYTE;  // 0:全屏幕;1:中心区域 
    byPrPicQuality: BYTE;  // 车牌识别返回的图片质量, 0:最低/3:最高 
    byPrPicMode: BYTE;  //车牌识别返回的图片分辨率: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF 
    byPlateOsdDisplay: BYTE;  // 车牌OSD是否显示 0:不显示/1:显示 
    byPrProvCharIndex: BYTE;  // 车牌识别省份首汉字对应的索引 
    byPrProvCharIndex1: BYTE;  // 车牌识别常见首汉字1对应的索引 
    byPrProvCharIndex2: BYTE;  // 车牌识别常见首汉字2对应的索引 
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_PLATERECOG_PARA = ^NET_DVR_PLATERECOG_PARA;


// 动态取证系统,限速设置参数的结构
type
  NET_DVR_SPEEDLMT_PARA = record 
    bStartMaxSpeedLimit: BYTE;  // 开启高速限制 
    bStartMinSpeedLimit: BYTE;  // 开启低速限制 
    byRes: array[0..6-1] of BYTE;  
    dwMaxSpeedLimit: DWORD;  // 最高限速 
    dwMinSpeedLimit: DWORD;  // 最低限速 
  end;
  LPNET_DVR_SPEEDLMT_PARA = ^NET_DVR_SPEEDLMT_PARA;

// 动态取证系统,车牌比对参数的结构
type
  NET_DVR_PLATECHECK_PARA = record 
    bAlarmWhenChecked: BYTE;  // 稽查成功是否报警 
    bInformWhenChecked: BYTE;  // 稽查成功是否对话框提示 
    byRes: array[0..6-1] of BYTE;  
    struBlockFtpServer: NET_DVR_IPADDR;  // 禁止名单FTP服务器地址 
  end;
  LPNET_DVR_PLATECHECK_PARA = ^NET_DVR_PLATECHECK_PARA;

type
  NET_DVR_ENFORCESYS_PARA = record 
    dwSize: DWORD;  
    struSpeedLmtPara: NET_DVR_SPEEDLMT_PARA;  //限速设置
    struPlateCheckPara: NET_DVR_PLATECHECK_PARA;  //车牌比对
    bySelPeccType: BYTE;  //是否选择违章类型
    byEnfOptHabit: BYTE;  //取证操作习惯, 0:长按取证;1:短按两次取证
                           {预览帧率调节模式分三种：
                           A 关闭 adjPrevFpsMode=0
                           以固定高帧率(25FPS)预览
                           B 标准 adjPrevFpsMode=1
                           以固定低帧率(6FPS)预览
                           C 自适应 adjPrevFpsMode=2
                           根据GPS速度信息动态调整预览帧率，
    3秒无有效GPS的情况下，以固定高帧率预览}
    byAdjPrevFpsMode: BYTE;  
    byRes1: BYTE;  
    struUploadServerIp: NET_DVR_IPADDR;  //上传服务器地址
    wUploadServerPort: WORD;  
    byRes2: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_ENFORCESYS_PARA = ^NET_DVR_ENFORCESYS_PARA;

type
  NET_DVR_PUSHMODEPARAM = record 

    //直连模式下UDP预览模式，1-同端口多路流，2-一端口一路流
    byUdpPreviewMode: BYTE;  
    //语音对讲工作模式，0-语音对讲，1-语音转发（SDK不进行语音的采集和播放）
    byVoiceWorkMode: BYTE;  
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_PUSHMODEPARAM = ^NET_DVR_PUSHMODEPARAM;

const
  MAX_ALARMHOST_ALARMIN_NUM = 512;    //网络报警主机最大报警输入口数
  MAX_ALARMHOST_ALARMOUT_NUM = 512;    //网络报警主机最大报警输出口数

const
  ALARMHOST_MAX_AUDIOOUT_NUM = 32;    //网络报警主机最大语音输出数
  ALARMHOST_MAX_ELECTROLOCK_NUM = 32;    //网络报警主机最大电锁数
  ALARMHOST_MAX_MOBILEGATE_NUM = 32;    //网络报警主机最大移动门数
  ALARMHOST_MAX_SIREN_NUM = 8;    // 最大警号数目
  MAX_ALARMHOST_SUBSYSTEM = 32;    //报警主机最大子系统数
  ALARMHOST_DETECTOR_SERIAL_LEN = 9;    //报警主机关联探测器序列号长度
  ALARMHOST_DETECTOR_SERIAL_LEN_V50 = 16;    //报警主机关联探测器序列号V50长度
  MAX_DETECTOR_NUM = 128;    //最大关联探测器数
  MAX_DETECTOR_NUM_V51 = 256;    //最大关联探测器数
  MAX_REPEATER_NUM = 16;    //最大中继器数
  MAX_OUTPUT_MODULE_NUM = 64;    //最大输出模块数
  MAX_ELECTRIC_LOCK_NUM = 64;    //最大电锁数量

//传感器类型
type
  SENSOR_TYPE =  
  (  
    SENSOR_TYPE_NONE = 0,  // 无
    SENSOR_TYPE_TEMPERATURE = 1,  // 温度
    SENSOR_TYPE_HUMIDITY,  // 湿度
    SENSOR_TYPE_WINDSPEED,  // 风速
    SENSOR_TYPE_GAS,  // 气体
    SENSOR_AC_VOLTAGE,  // 交流电压
    SENSOR_AC_CURRENT,  // 交流电流
    SENSOR_DC_VOLTAGE,  // 直流电压
    SENSOR_DC_CURRENT,  // 直流电流
    SENSOR_WATER_PRESSURE,  // 水压
    SENSOR_PRESSURE_TRANSMITTER,  // 压力变送器
    SENSOR_FLOW_TRANSMITTER,  // 流量变送器
    SENSOR_WATER_LEAKAGE,  // 漏水传感器
    SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,  //一体化温变
    SENSOR_ISOLATION_TEMPERATURE_DETECTOR,  //隔离式温变
    SENSOR_RESIDUAL_CHLORINE,  //在线余氯仪
    SENSOR_TYPE_AC_TERMINAL = 16,  // AC端子
    SENSOR_TYPE_AC_SOCKET = 17,  // AC插座
    SENSOR_TYPE_HUMITURE,  // 温湿度
    SENSOR_TYPE_FLOW,  // 流量
    SENSOR_LIQUID_LEVEL,  // 液位
    SENSOR_TYPE_ARC,  // 电弧
    SENSOR_TYPE_UNKNOW = 255  // 未定义
  );

type
  NET_DVR_SENSOR_INFO = record 
    dwSize: DWORD;  // 结构体大小
    byName: array[0..NAME_LEN-1] of BYTE;  // 传感器名称
    byEnable: BYTE;  // 是否启用
    byValid: BYTE;  // 是否有效 传感器正常不正常(该参数只能获取不能个配置)
    byType: BYTE;  // 模拟量类型 参照SENSOR_TYPE
    byAlarmMode: BYTE;  //报警模式，五种，15-HHHH、14-HHHL、12-HHLL、8HLLL、0-LLLL，即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    fMeasureHigh: FLOAT;  // 量程上限
    fMeasureLow: FLOAT;  // 量程下限
    fAlarm1: FLOAT;  //报警限1,报警限1-4 依次增大
    fAlarm2: FLOAT;  //报警限2
    fAlarm3: FLOAT;  //报警限3
    fAlarm4: FLOAT;  //报警限4
    dwOsdCfg: DWORD;  //模拟量字符叠加，按位表示0-15对应视频通道1-16
    fSensitive: FLOAT;  // 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化大于0.1，需要上传。如果为1，则表示变化超过1时上报。
    bySensorStandard: BYTE;  //传感器规格，0- 0~20mA，1- 0~5V，2- 0~2.5Mpa，3- 0~1.6Mpa，4- 0~5m
    byChan: BYTE;  //模拟量通道号
    byRes3: array[0..114-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SENSOR_INFO = ^NET_DVR_SENSOR_INFO;

type
  NET_DVR_SIREN_PARAM = record 
    dwSize: DWORD;  // 结构大小
    byName: array[0..NAME_LEN-1] of BYTE;  // 名称
    wDelay: WORD;  // 输出延迟 单位为秒, 范围 0~5599s 0表示一直有输出
    byRes1: array[0..2-1] of BYTE;  
    dwOverallEventJointSirenOn: DWORD;  //全局事件联动警号输出开启，事件类型按位表示，bit0-主机防拆, bit1-全局键盘紧急报警,bit2-交流电断电，bit3-电池电压低,bit4-电话线掉线,bit5-有线网络异常,bit6-无线网络异常,  bit7-键盘485断线，bit8- WIFI通信故障，bit9-RF信号干扰故障
    dwSubsystemEventJointSirenOn: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of DWORD;  //子系统事件联动警号输出开启。数组下标表示子系统号，每一个元素按位表示事件类型，bit0-紧急报警
    byRes2: array[0..448-1] of BYTE;  // 保留字节　　
  end;
  LPNET_DVR_SIREN_PARAM = ^NET_DVR_SIREN_PARAM;

type
  NET_DVR_AIR_CONDITION_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  // 0--关机 1--开机
    byMode: BYTE;  // 空调模式
    byTemperature: BYTE;  // 温度，具体值表示 通常为16-30度
    byAirConditionNo: BYTE;  // 空调编号
    byRes: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AIR_CONDITION_PARAM = ^NET_DVR_AIR_CONDITION_PARAM;

type
  DETECTOR_TYPE =  
  (  
    PANIC_BUTTON = 0,  // 紧急按钮
    MAGNETIC_CONTACT,  // 门磁
    SMOKE_DETECTOR,  // 烟感探测器
    ACTIVE_INFRARED_DETECTOR,  // 主动红外探测器
    PASSIVE_INFRARED_DETECTOR,  // 被动红外探测器
    GLASS_BREAK_DETECTOR,  // 玻璃破碎探测器
    VIBRATION_DETECTOR,  // 震动探测器
    DUAL_TECHNOLOGY_PIR_DETECTOR,  // 双鉴探测器
    TRIPLE_TECHNOLOGY_PIR_DETECTOR,  // 三技术探测器
    HUMIDITY_DETECTOR,  // 湿度探测器
    TEMPERATURE_DETECTOR,  // 温感探测器
    COMBUSTIBLE_GAS_DETECTOR,  // 可燃气体探测器
    DYNAMIC_SWITCH,  //随动开关
    CONTROL_SWITCH,  //控制开关
    SMART_LOCK,  //智能锁
    WATER_DETECTOR,  //水浸探测器
    DISPLACEMENT_DETECTOR,  //位移探测器
    SINGLE_INFRARED_DETECTOR,  //单体门磁探测器
    SINGLE_ZONE_MODULE,  //无线单防区模块
    CURTAIN_INFRARED_DETECTOR,  //幕帘红外人体探测器19
    UNKNOWN,  //未知20
    DOORBELL_SWITCH = 21,  //门铃开关21
    MEDICAL_HELP_BUTTON,  //医疗求助按钮
    OUTDOOR_DUAL_TECH,  //室外双鉴传感器

    OTHER_DETECTOR = $ffff  // 其它探测器
  );

type
  NET_DVR_ALARMIN_PARAM = record 
    dwSize: DWORD;  
    byName: array[0..NAME_LEN-1] of BYTE;  
    wDetectorType: WORD;  // DETECTOR_TYPE
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 ，12-超时防区，13-紧急防区，0xff-无
    byUploadAlarmRecoveryReport: BYTE;  //是否上传防区报警恢复报告，0-不上传，1-上传
    dwParam: DWORD;  // 防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间时间段
    byAssociateAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  // 报警输入关联报警输出
    byAssociateSirenOut: array[0..8-1] of BYTE;  //  警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    bySensitivityParam: BYTE;  //防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
    byArrayBypass: BYTE;  //是否加入旁路组,0-不支持组旁路,1-支持组旁路
    byJointSubSystem: BYTE;  //防区所属的子系统号，该参数只能获取
    byModuleStatus: BYTE;  //模块状态 1-在线 2-离线
    wModuleAddress: WORD;  //模块地址，扩展模块从0~255，0xFFFF表示无效
    byModuleChan: BYTE;  //模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    byModuleType: BYTE;  //模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
    wZoneIndex: WORD;  //防区号，该参数只能获取
    wInDelay: WORD;  //进入延时，0-255秒
    wOutDelay: WORD;  //退出延时，0-255秒
    byAlarmType: BYTE;  //报警器类型 0-无效，1-常开，2-常闭
    byZoneResistor: BYTE;  //防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
    fZoneResistorManual: FLOAT;  //防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效
    byDetectorSerialNo: array[0..ALARMHOST_DETECTOR_SERIAL_LEN-1] of BYTE;  //探测器序列号，只读
    byZoneSignalType: BYTE;  //防区信号传输类型(只读)，0-有线防区，1-无线防区
    byDisableDetectorTypeCfg: BYTE;  //探测是类型是否不可配，0-可配，1-不可配
    byTimeOutRange: BYTE;  // 超时时间范围，0:1~599s,1:1~65535s
    byAssociateLampOut: array[0..8-1] of BYTE;  //  警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
    wTimeOut: WORD;  //超时时间，秒
    byDetectorSignalIntensity: BYTE;  // 探测器信号强度（只读），0~100
    byTimeOutMethod: BYTE;  //超时防区计时方式：0-触发计时，1-恢复计时
    byRes3: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMIN_PARAM = ^NET_DVR_ALARMIN_PARAM;

type
  NET_DVR_ALARMIN_PARAM_V50 = record 
    dwSize: DWORD;  
    byName: array[0..NAME_LEN-1] of BYTE;  
    wDetectorType: WORD;  // DETECTOR_TYPE
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区 ，12-超时防区，13-紧急防区，14-燃气防区，0xff-无
    byUploadAlarmRecoveryReport: BYTE;  //是否上传防区报警恢复报告，0-不上传，1-上传
    dwParam: DWORD;  // 防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;  //布防时间时间段
    byAssociateAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  // 报警输入关联报警输出
    byAssociateSirenOut: array[0..8-1] of BYTE;  //  警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    bySensitivityParam: BYTE;  //防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
    byArrayBypass: BYTE;  //是否加入旁路组,0-不支持组旁路,1-支持组旁路
    byJointSubSystem: BYTE;  //防区所属的子系统号，该参数只能获取
    byModuleStatus: BYTE;  //模块状态 1-在线 2-离线
    wModuleAddress: WORD;  //模块地址，扩展模块从0~255，0xFFFF表示无效
    byModuleChan: BYTE;  //模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    byModuleType: BYTE;  //模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
    wZoneIndex: WORD;  //防区号，该参数只能获取
    wInDelay: WORD;  //进入延时，0-255秒
    wOutDelay: WORD;  //退出延时，0-255秒
    byAlarmType: BYTE;  //报警器类型 0-无效，1-常开，2-常闭
    byZoneResistor: BYTE;  //防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
    fZoneResistorManual: FLOAT;  //防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效
    byDetectorSerialNo: array[0..ALARMHOST_DETECTOR_SERIAL_LEN_V50-1] of BYTE;  //探测器序列号，只读
    byZoneSignalType: BYTE;  //防区信号传输类型(只读)，0-有线防区，1-无线防区
    byDisableDetectorTypeCfg: BYTE;  //探测是类型是否不可配，0-可配，1-不可配
    wTimeOut: WORD;  //超时时间，秒
    byAssociateLampOut: array[0..8-1] of BYTE;  //  警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
    byVoiceFileName: array[0..32-1] of BYTE;  //语音文件名
    byTimeOutRange: BYTE;  // 超时时间范围，0:1~599s,1:1~65535s
    byDetectorSignalIntensity: BYTE;  // 探测器信号强度（只读），0~100
    byTimeOutMethod: BYTE;  //超时防区计时方式：0-触发计时，1-恢复计时
    byAssociateFlashLamp: BYTE;  //  闪光灯输出 0-无效，1-不输出，2-输出
    byStayAwayEnabled: BYTE;  //  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    bySilentModeEnabled: BYTE;  //  静音模式使能 0-无效，1-不使能，2-使能
    byRelativeChannel: array[0..RELATIVE_CHANNEL_LEN-1] of BYTE;  // 关联的通道号，0表示无效，一个byte字节表示一个通道号
    byDetectorVersion: array[0..VERSION_INFO_LEN-1] of BYTE;  //探测器版本，只读
    byDetectorMAC: array[0..MACADDR_LEN-1] of BYTE;  //探测器MAC地址，只读
    byLinkageAlarmType: BYTE;  //关联报警类型：1-火警，2-监管，3-联动，4-屏蔽，5-故障
    byRes3: array[0..465-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMIN_PARAM_V50 = ^NET_DVR_ALARMIN_PARAM_V50;

const
  MAX_MAX_ALARMIN_NUM = 64;    // 批量获取最大防区数
type
  NET_DVR_MULTI_ALARMIN_COND = record 
    dwSize: DWORD;  
    iZoneNo: array[0..MAX_MAX_ALARMIN_NUM-1] of INT;  //防区号,从0开始，小于0表示无效
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_ALARMIN_COND = ^NET_DVR_MULTI_ALARMIN_COND;

type
  NET_DVR_SINGLE_ALARMIN_PARAM = record 
    dwSize: DWORD;  
    wZoneNo: WORD;  //防区号，该参数只能获取
    byJointSubSystem: BYTE;  //防区所属的子系统号，该参数只能获取
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
    byName: array[0..NAME_LEN-1] of BYTE;  
    wDetectorType: WORD;  // DETECTOR_TYPE
    wInDelay: WORD;  //进入延时，0-255秒
    wOutDelay: WORD;  //退出延时，0-255秒
    byAlarmType: BYTE;  //报警器类型  0-无效 1-常开 1-常闭
    byZoneSignalType: BYTE;  //防区信号传输类型，0-有线防区，1-无线防区
    byDetectorSerialNo: array[0..ALARMHOST_DETECTOR_SERIAL_LEN-1] of BYTE;  //探测器序列号，只读
    byDisableDetectorTypeCfg: BYTE;  //探测是类型是否不可配，0-可配，1-不可配
    byTimeOutRange: BYTE;  // 超时时间范围，0:1~599s,1:1~65535s
    byDetectorSignalIntensity: BYTE;  // 探测器信号强度（只读），0~100
    wTimeOut: WORD;  //超时时间，秒
    byTimeOutMethod: BYTE;  //超时防区计时方式：0-触发计时，1-恢复计时
    byAssociateFlashLamp: BYTE;  //  闪光灯输出 0-无效，1-不输出，2-输出
    byStayAwayEnabled: BYTE;  //  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    bySilentModeEnabled: BYTE;  //  静音模式使能 0-无效，1-不使能，2-使能
    byRes2: array[0..110-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SINGLE_ALARMIN_PARAM = ^NET_DVR_SINGLE_ALARMIN_PARAM;

type
  NET_DVR_SINGLE_ALARMIN_PARAM_V50 = record 
    dwSize: DWORD;  
    wZoneNo: WORD;  //防区号，该参数只能获取
    byJointSubSystem: BYTE;  //防区所属的子系统号，该参数只能获取
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
    byName: array[0..NAME_LEN-1] of BYTE;  
    wDetectorType: WORD;  // DETECTOR_TYPE
    wInDelay: WORD;  //进入延时，0-255秒
    wOutDelay: WORD;  //退出延时，0-255秒
    byAlarmType: BYTE;  //报警器类型  0-无效 1-常开 1-常闭
    byZoneSignalType: BYTE;  //防区信号传输类型，0-有线防区，1-无线防区
    byDetectorSerialNo: array[0..ALARMHOST_DETECTOR_SERIAL_LEN-1] of BYTE;  //探测器序列号，只读
    byDisableDetectorTypeCfg: BYTE;  //探测是类型是否不可配，0-可配，1-不可配
    byTimeOutRange: BYTE;  // 超时时间范围，0:1~599s,1:1~65535s
    byDetectorSignalIntensity: BYTE;  // 探测器信号强度（只读），0~100
    wTimeOut: WORD;  //超时时间，秒
    byTimeOutMethod: BYTE;  //超时防区计时方式：0-触发计时，1-恢复计时
    byAssociateFlashLamp: BYTE;  //  闪光灯输出 0-无效，1-不输出，2-输出
    byStayAwayEnabled: BYTE;  //  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    bySilentModeEnabled: BYTE;  //  静音模式使能 0-无效，1-不使能，2-使能
    byRes3: array[0..2-1] of BYTE;  
    byAssociateAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  // 报警输入关联报警输出
    byRes2: array[0..128-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SINGLE_ALARMIN_PARAM_V50 = ^NET_DVR_SINGLE_ALARMIN_PARAM_V50;

type
  NET_DVR_ALARMIN_PARAM_LIST = record 
    dwSize: DWORD;  
    struSingleAlarmInParam: array[0..MAX_MAX_ALARMIN_NUM-1] of NET_DVR_SINGLE_ALARMIN_PARAM;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMIN_PARAM_LIST = ^NET_DVR_ALARMIN_PARAM_LIST;

type
  NET_DVR_ALARMIN_PARAM_LIST_V50 = record 
    dwSize: DWORD;  
    struSingleAlarmInParam: array[0..MAX_MAX_ALARMIN_NUM-1] of NET_DVR_SINGLE_ALARMIN_PARAM_V50;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMIN_PARAM_LIST_V50 = ^NET_DVR_ALARMIN_PARAM_LIST_V50;

type
  NET_DVR_ALARMOUT_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    byName: array[0..NAME_LEN-1] of BYTE;  // 名称
    wDelay: WORD;  // 输出延迟 单位s, 范围：0~3599s 0 表示一直有输出
    wTriggerIndex: WORD;  //触发器号，该参数只能获取
    byAssociateAlarmIn: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //表示警号的报警输入通道 （多个报警输入同时触发一个警号输出）数组下标0表示报警输入1，依次类推 0-不 1-
    byModuleType: BYTE;  //外接触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器 4-单防区触发器，5-32路触发器，6-1门就地控制器、7-2门就地控制器、8-4门就地控制器,9-2路触发器，10-键盘，11-扩展触发器
    byModuleStatus: BYTE;  //外接触发器状态 1-在线 2-离线
    wModuleAddress: WORD;  //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    byModuleChan: BYTE;  //外接触发器通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    byWorkMode: BYTE;  //工作模式，1-联动，2-随动
    byAlarmOutMode: BYTE;  //输出模式，1-非脉冲模式，2-脉冲模式
    byTimeOn: BYTE;  //开时间 1~60s
    byTimeOff: BYTE;  //关时间 1~60s
    byDurationConstOutputEnable: BYTE;  //继电器常开使能
    byRes2: array[0..50-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMOUT_PARAM = ^NET_DVR_ALARMOUT_PARAM;

type
  NET_DVR_ALARMIN_SETUP = record 
    byAssiciateAlarmIn: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入通道 数组下标0对应报警输入口1，依次类推
    byRes: array[0..100-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMIN_SETUP = ^NET_DVR_ALARMIN_SETUP;

type
  NET_DVR_ALARMHOST_MAIN_STATUS = record 
    dwSize: DWORD;  
    bySetupAlarmStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口布防状态，(最大支持512个报警输入口查询)，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    byAlarmInStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口报警状态，(最大支持512个报警输入口查询)，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    byAlarmOutStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //报警输出口状态，(最大支持512个报警输出口查询)，0-对应报警输出口无报警，1-对应报警输出口有报警
    byBypassStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  // 旁路状态 数组下标表示0对应报警输入口1 0-表示报警输入口没有旁路 1-表示报警输入口旁路
    bySubSystemGuardStatus: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of BYTE;  //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    byAlarmInFaultStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口故障状态，0-对应报警输入口处于正常状态，1-对应报警输入口处于故障状态
    byRes: array[0..56-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_ALARMHOST_MAIN_STATUS = ^NET_DVR_ALARMHOST_MAIN_STATUS;

type
  NET_DVR_ALARMHOST_MAIN_STATUS_V40 = record 
    dwSize: DWORD;  
    bySetupAlarmStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区布防状态，(最大支持512个防区查询)，0-对应防区处于撤防状态，1-对应防区处于布防状态
    byAlarmInStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区报警状态，(最大支持512个防区查询)，0-对应防区当前无报警，1-对应防区当前有报警
    byAlarmOutStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //触发器状态，(最大支持512个触发器查询)，0-对应触发器无报警，1-对应触发器有报警
    byBypassStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //旁路状态 数组下标表示0对应防区1 0-表示防区没有旁路 1-表示防区旁路
    bySubSystemGuardStatus: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of BYTE;  //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    byAlarmInFaultStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区故障状态，0-对应防区处于正常状态，1-对应防区处于故障状态
    byAlarmInMemoryStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区报警记忆状态， 0-对应防区当前无报警，1-对应防区当前有报警
    byAlarmInTamperStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区防拆状态，0-对应防区无报警，1-对应防区有报警
    byEnableSubSystem: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of BYTE;  //子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
    bySubSystemGuardType: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of BYTE;  //子系统布放状态，0-无效，1-外出布防，2-即时布防，3-在家布防
    byRes: array[0..448-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMHOST_MAIN_STATUS_V40 = ^NET_DVR_ALARMHOST_MAIN_STATUS_V40;

type
  NET_DVR_ALARMHOST_MAIN_STATUS_V51 = record 
    dwSize: DWORD;  
    bySetupAlarmStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区布防状态，(最大支持512个防区查询)，0xff-无效，0-对应防区处于撤防状态，1-对应防区处于布防状态，2-对应防区处于布防中
    byAlarmInStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区报警状态（触发状态），(最大支持512个防区查询)，0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
    byAlarmOutStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //触发器状态，(最大支持512个触发器查询)，0xff-无效，0-对应触发器无报警，1-对应触发器有报警，2-未关联，3-离线，4-心跳异常
    byBypassStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区旁路状态，数组下标表示0对应防区1，0xff-无效，0-表示防区没有旁路 1-表示防区旁路
    bySubSystemGuardStatus: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of BYTE;  //子系统布防状态，0xff-无效，0-对应子系统处于撤防状态，1-对应子系统处于布防状态，2-对应子系统处于布防中
    byAlarmInFaultStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区故障状态，0xff-无效，0-对应防区处于正常状态，1-对应防区处于故障状态
    byAlarmInMemoryStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区报警记忆状态（报警状态）， 0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
    byAlarmInTamperStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区防拆状态，0xff-无效，0-对应防区无报警，1-对应防区有报警
    byEnableSubSystem: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of BYTE;  //子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
    bySubSystemGuardType: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of BYTE;  //子系统布防类型，0-无效，1-外出布防，2-即时布防，3-在家布防
    bySubSystemAlarm: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of BYTE;  //子系统报警状态，0-无效，1-正常，2-报警
    byAlarmOutCharge: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //触发器电量状态，(最大支持512个触发器查询)，0-无效，1-正常，2-电量低
    byAlarmOutTamperStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //触发器防拆状态，(最大支持512个触发器查询)，0-无效，1-防拆，2-无防拆
    byAlarmInShieldedStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区屏蔽状态，0-无效，1-屏蔽，2-非屏蔽
    byAlarmOutLinkage: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //触发器联动事件类型，(最大支持512个触发器查询)，0-无效，1-报警，2-布防，3-撤防，4-手动控制
    byRes: array[0..512-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMHOST_MAIN_STATUS_V51 = ^NET_DVR_ALARMHOST_MAIN_STATUS_V51;

type
  NET_DVR_ALARMHOST_OTHER_STATUS = record 
    dwSize: DWORD;  
    bySirenStatus: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  // 警号输出状态 0-警号处于无报警状态，1-警号处于有报警状态
    byRes: array[0..92-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMHOST_OTHER_STATUS = ^NET_DVR_ALARMHOST_OTHER_STATUS;

type
  NET_DVR_ALARMHOST_OTHER_STATUS_V50 = record 
    dwSize: DWORD;  
    //对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
    bySirenStatus: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线，4-心跳异常
    byDetetorPower: array[0..MAX_DETECTOR_NUM-1] of BYTE;  //探测器电量状态，0xff-无效，电量值为0-100，默认电量小于20为欠压状态
    byDetetorConnection: array[0..MAX_DETECTOR_NUM-1] of BYTE;  //探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线，3-心跳异常
    bySirenPower: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号电量状态，0-无效，1-正常，2-欠压
    bySirenTamperStatus: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号防拆状态，0-无效，1-防拆，2-无防拆
    byPowerStausEnabled: array[0..MAX_DETECTOR_NUM div 8-1] of BYTE;  //探测器电量状态是否有效，按位表示，0-无效，1-有效
    byDetetorPowerStatus: array[0..MAX_DETECTOR_NUM div 8-1] of BYTE;  //探测器电量状态，按位表示，0-正常，1-电量低
    byDetetorPowerType: BYTE;  //探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
    byRes: array[0..975-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMHOST_OTHER_STATUS_V50 = ^NET_DVR_ALARMHOST_OTHER_STATUS_V50;

type
  NET_DVR_ALARMHOST_OTHER_STATUS_V51 = record 
    dwSize: DWORD;  
    //对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
    bySirenStatus: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线
    byDetetorPower: array[0..MAX_DETECTOR_NUM_V51-1] of BYTE;  //探测器电量，0xff-无效，电量值为0-100，默认电量小于20为欠压状态，byDetetorPowerType为0时有效
    byDetetorConnection: array[0..MAX_DETECTOR_NUM_V51-1] of BYTE;  //探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线
    bySirenPower: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号电量状态，0-无效，1-正常，2-欠压
    bySirenTamperStatus: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号防拆状态，0-无效，1-防拆，2-无防拆
    byPowerStausEnabled: array[0..MAX_DETECTOR_NUM_V51 div 8-1] of BYTE;  //探测器电量状态是否有效，按位表示，0-无效，1-有效
    byDetetorPowerStatus: array[0..MAX_DETECTOR_NUM_V51 div 8-1] of BYTE;  //探测器电量状态，按位表示，0-正常，1-电量低
    byDetetorPowerType: BYTE;  //探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
    byRes2: array[0..3-1] of BYTE;  
    byRepeaterStatus: array[0..MAX_REPEATER_NUM-1] of BYTE;  //中继器状态，0-无效，1-离线，2-在线，3-未关联
    byRepeaterTamperStatus: array[0..MAX_REPEATER_NUM div 8-1] of BYTE;  //中继器防拆状态，按位表示，0-对应中继器无报警，1-对应中继器有报警
    byAlarmOutTamperStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM div 8-1] of BYTE;  //报警输出（继电器）防拆状态，按位表示，0-对应报警输出无报警，1-对应报警输出有报警
    byOutputModuleTamperStatus: array[0..MAX_OUTPUT_MODULE_NUM div 8-1] of BYTE;  //输出模块防拆状态，按位表示，0-对应输出模块无报警，1-对应输出模块有报警
    byElectricLockStatus: array[0..MAX_ELECTRIC_LOCK_NUM-1] of BYTE;  //电锁状态 0-关闭，1 C打开，为确保兼容性，第一个电锁的状态在bySirenStatus第0位也需要填写
    byRes: array[0..274-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ALARMHOST_OTHER_STATUS_V51 = ^NET_DVR_ALARMHOST_OTHER_STATUS_V51;


//使能状态配置
type
  NET_DVR_ALARMHOST_ENABLECFG = record 
    dwSize: DWORD;  
    byAudioOutEnable: array[0..ALARMHOST_MAX_AUDIOOUT_NUM-1] of BYTE;  //语音输出使能，0-禁能，1-使能
    byElectroLockEnable: array[0..ALARMHOST_MAX_ELECTROLOCK_NUM-1] of BYTE;  //电锁使能，0-禁能，1-使能
    byMobileGateEnable: array[0..ALARMHOST_MAX_MOBILEGATE_NUM-1] of BYTE;  //移动门使能，0-禁能，1-使能
    bySirenEnable: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //警号使能， 0-禁能，1-使能
    bySerialPurpose: BYTE;  //串口用途，0-用于级联报警主机，1-用于PTZ控制
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ENABLECFG = ^NET_DVR_ALARMHOST_ENABLECFG;

type
  NET_DVR_ALARMHOST_ABILITY = record 
    dwSize: DWORD;  // 结构体大小
    wTotalAlarmInNum: WORD;  // 报警输入口总数(防区),包括级联
    wLocalAlarmInNum: WORD;  // 本地报警输入口
    wExpandAlarmInNum: WORD;  // 可扩展的报警输入口
    wTotalAlarmOutNum: WORD;  // 报警输出口总数 （设备支持的总数）
    wLocalAlarmOutNum: WORD;  // 本地报警输出口个数
    wExpandAlarmOutNum: WORD;  // 可扩展的报警输出口
    wTotalRs485Num: WORD;  // 报警输出口总数 （设备支持的总数）
    wLocalRs485Num: WORD;  // 本地485口数
    wExpandRs485Num: WORD;  // 可扩展的485口数
    wFullDuplexRs485Num: WORD;  // 全双工的485口数
    wTotalSensorNum: WORD;  // 模拟量最大个数 (设备支持的总数)
    wLocalSensorNum: WORD;  // 本地模拟量个数
    wExpandSensorNum: WORD;  // 可扩展的模拟量个数
    wAudioOutNum: WORD;  //语音输出个数
    wGatewayNum: WORD;  //门禁个数
    wElectroLockNum: WORD;  //电锁个数
    wSirenNum: WORD;  // 主机警号数目
    wSubSystemNum: WORD;  // 可划分子系统数目
    wNetUserNum: WORD;  // 网络用户数
    wKeyboardNum: WORD;  // 键盘数
    wOperatorUserNum: WORD;  // 操作用户数
    bySupportDetector: BYTE;  //是否支持常开、常闭探测器，1-支持，0-不支持
    bySupportSensitivity: BYTE;  //是否支持防区灵敏度，1-支持，0-不支持
    bySupportArrayBypass: BYTE;  //是否支持组旁路，1-支持，0-不支持
    bySupportAlarmInDelay: BYTE;  //是否支持防区延迟,1-支持，0-不支持
    //如果bySupportAlarmInDelay为1时，表示客户端应该使用NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间，动环报警主机和自助行报警主机使用这种配置延时方式;
    //如果bySupportAlarmInDelay为0时，表示通过NET_DVR_ALARMSUBSYSTEMPARAM 中的wEnterDelay 、wExitDelay 来设置
    bySupportAlarmInType: array[0..16-1] of BYTE;  //支持的防区类型,数组0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区 8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区15-无
    byTelNum: BYTE;  //支持电话个数
    byCenterGroupNum: BYTE;  //中心组个数
    byGPRSNum: BYTE;  //GPRS中心数，最多4个
    byNetNum: BYTE;  //网络中心数，最多4个
    byAudioNum: BYTE;  //音频个数
    by3GNum: BYTE;  //3G模块个数
    byAnalogVideoChanNum: BYTE;  //模拟视频通道个数
    byDigitalVideoChanNum: BYTE;  //数字视频通道个数
    bySubSystemArmType: BYTE;  //子系统布防类型，0-表示不支持，1-表示支持。bit0-普通布防（注：网络小主机只支持普通布防，在能力集中加这个字段的时候网络小主机已经发布，所以网络小主机中该字段为0，所以用0表示支持，1表示不支持。对外接口中SDK内部会做兼容），bit1-即时布防，bit2-留守布防。
    byPublicSubSystemNum: BYTE;  //公共子系统个数
    dwSupport1: DWORD;  //按位表示，结果非0表示支持，0表示不支持
    // bit0:     是否支持子系统内配置警号输出时间，如果支持则警号输出时间在每个子系统内配置，如果不支持，警号时间在警号参数配置里面设置
    // bit1:    是否支持事件触发报警输出开启
    // bit2:    是否支持事件触发报警输出关闭
    // bit3:    是否支持子系统使能
    // bit4;    是否支持防区布防
    // bit5;    是否支持子系统自动布撤防
    // bit6:    是否支持具体故障关联声音输出
    // bit7:    是否支持故障状态查询
    // bit8:    是否支持子系统扩展配置
    // bit9:    是否支持钥匙防区操作子系统
    // bit10:   是否支持"键盘提示成功发送报告"配置
    // bit11:   是否支持导入导出参数配置
    // bit12:   是否支持LED屏幕参数配置
    // bit13: 是否支持故障关联本地故障灯输出
    dwSubSystemEvent: DWORD;  //子系统事件，按位表示，0表示不支持，非0表示支持,bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆
    dwOverallEvent: DWORD;  //全局事件，按位表示，0表示不支持，非0表示支持，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常，bit5-硬盘故障,bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线,bit8-WIFI通信故障，bit9-RF信号干扰故障
    dwFaultType: DWORD;  //设备支持的故障类型，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-主键盘掉线，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常
    byPublicSubsystemAssociateSubsystemNum: BYTE;  //公共子系统可关联的子系统个数
    byOverallKeyboard: BYTE;  //全局键盘个数
    wSafetyCabinSupport: WORD;  //防护舱控制器能力，按位表示，结果非0表示支持，0表示不支持
    //bit0: 是否支持防护舱控制器工作模式配置
    //bit1: 是否支持人信号传感器类型配置
    //bit2: 是否支持幕帘传感器参数配置（探测延迟时间、人状态变化响应时间）
    //bit3: 是否支持红外对射传感器参数配置（滤波）
    //bit4: 是否支持防护舱使用超时时间配置
    by485SlotNum: BYTE;  //485虚拟槽位号
    bySubSystemAttributeAbility: BYTE;  // 值恒为1，禁止1号子系统关闭使能
    wKeyboardAddrNum: WORD;  // 键盘地址数
    byAlarmLampNum: BYTE;  //警灯数目
    byRes: array[0..117-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_ALARMHOST_ABILITY = ^NET_DVR_ALARMHOST_ABILITY;

const
  MAX_485CHAN = 256;    //485通道号
  MAX_485SLOT = 256;    //485槽位号
type
  NET_DVR_485_SLOT_LIST_INFO = record 
    dwSize: DWORD;  
    byAll: BYTE;  //0-不是全部获取，1-全部获取
    byres: array[0..3-1] of BYTE;  
    byIndex: array[0..MAX_485SLOT-1] of BYTE;  //485槽位号
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_485_SLOT_LIST_INFO = ^NET_DVR_485_SLOT_LIST_INFO;

type
  NET_DVR_485LIST_INFO = record 
    dwSize: DWORD;  
    byAll: BYTE;  //0-不是全部获取，1-全部获取
    byres: array[0..3-1] of BYTE;  
    byIndex: array[0..MAX_485CHAN-1] of BYTE;  //485通道号 下标表示通道号，值0-表示不使用，1表示使用
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_485LIST_INFO = ^NET_DVR_485LIST_INFO;

type
  NET_DVR_ALARM_RS485CFG = record 
    dwSize: DWORD;  // 结构体大小
    sDeviceName: array[0..NAME_LEN-1] of BYTE;  // 前端设备名称
    wDeviceType: WORD;  // 前端设备类型,通过NET_DVR_GetDeviceTypeList获取
    wDeviceProtocol: WORD;  // 前端设备协议 通过获取协议列表获取
    dwBaudRate: DWORD;  //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
    byDataBit: BYTE;  // 数据有几位：0-5位，1-6位，2-7位，3-8位
    byStopBit: BYTE;  // 停止位：0-1位，1-2位
    byParity: BYTE;  //是否校验：0-无校验，1-奇校验，2-偶校验
    byFlowcontrol: BYTE;  // 是否流控：0-无，1-软流控,2-硬流控
    byDuplex: BYTE;  // 0 - 半双工1- 全双工  只有通道1可以是全双工其他都只能是半双工
    byWorkMode: BYTE;  // 工作模式 0-控制台 1-透明通道,2-梯控，3-读卡器,4-门禁安全模块,0xfe-自定义，0xff-禁用
    byChannel: BYTE;  //485通道号
    bySerialType: BYTE;  //串口类型: 0--485, 1--232
    byMode: BYTE;  //模式 0-连接读卡器 1-连接客户端 2-连接扩展模块 3-连接门禁主机 4-连接梯控主机  0xff-禁用
    byOutputDataType: BYTE;  //0-无效，1-输出卡号，2-输出工号
    byAddress: BYTE;  //串口地址
    byStairsOutputDataType: BYTE;  //0-无效，1-输出楼层号，2-输出卡号，当byMode为梯控主机时有效
    byRes: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARM_RS485CFG = ^NET_DVR_ALARM_RS485CFG;

const
  MAX_DEVICE_PROTO_NUM = 256;    
  MAX_DEVICE_TYPE_NUM = 256;    

// 485前端设备支持协议列表
type
  NET_DVR_DEVICE_PROTO_LIST = record 
    dwSize: DWORD;  // 结构体大小
    dwProtoNum: DWORD;  // 协议个数
    struProtoType: array[0..MAX_DEVICE_PROTO_NUM-1] of NET_DVR_PROTO_TYPE;  // 协议类型
    byRes: array[0..12-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DEVICE_PROTO_LIST = ^NET_DVR_DEVICE_PROTO_LIST;

type
  NET_DVR_DEVICE_TYPE = record 
    dwType: DWORD;  
    byDescribe: array[0..DESC_LEN-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_TYPE = ^NET_DVR_DEVICE_TYPE;

type
  NET_DVR_DEVICE_TYPE_LIST = record 
    dwSize: DWORD;  // 结构体大小
    dwTypeNum: DWORD;  // 类型个数
    struDeviceType: array[0..MAX_DEVICE_TYPE_NUM-1] of NET_DVR_DEVICE_TYPE;  
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_TYPE_LIST = ^NET_DVR_DEVICE_TYPE_LIST;

const
  MAX_ALARMHOST_VIDEO_CHAN = 64;    
type
  NET_DVR_ALARM_DEVICE_USER = record 
    dwSize: DWORD;  // 结构体大小
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址) 
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址 
    byUserType: BYTE;  // 0-普通用户（操作员） 1-管理员用户 2-安装员用户 3-制造商用户
    byAlarmOnRight: BYTE;  // 布防权限
    byAlarmOffRight: BYTE;  // 撤防权限
    byBypassRight: BYTE;  // 旁路权限
    byOtherRight: array[0..MAX_RIGHT-1] of BYTE;  // 其他权限
    // 0 -- 日志权限
    // 1 -- 重启关机
    // 2 -- 参数设置权限
    // 3 -- 参数获取权限
    // 4 -- 恢复默认参数权限
    // 5 -- 警号输出权限
    // 6 -- PTZ 控制权限
    // 7 -- 远程升级权限
    // 8 -- 远程预览
    // 9 -- 远程手动录像
    // 10 -- 远程回放
    // 11 -- 消警
    // 12 -- 强制布防
    // 13 -- 永久旁路
    // 14 -- 添加更改个人授权代码
    // 15 -- 调试模式
    byNetPreviewRight: array[0..MAX_ALARMHOST_VIDEO_CHAN div 8-1] of BYTE;  // 远程可以预览的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    byNetRecordRight: array[0..MAX_ALARMHOST_VIDEO_CHAN div 8-1] of BYTE;  // 远程可以录像的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    byNetPlaybackRight: array[0..MAX_ALARMHOST_VIDEO_CHAN div 8-1] of BYTE;  // 远程可以回放的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    byNetPTZRight: array[0..MAX_ALARMHOST_VIDEO_CHAN div 8-1] of BYTE;  // 远程可以PTZ的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    //BYTE    byPriority;                                        // 优先级，0xff-无，0--低，1--中，2--高
    //无（表示不支持优先级的设置）
    //低（默认权限：包括远程回放，远程查看日志和状态，远程关机/重启）
    //中（包括远程控制云台，远程手动录像，远程回放，语音对讲和远程预览，本地备份，本地/远程关机/重启）
    //高（管理员）
    sOriginalPassword: array[0..PASSWD_LEN-1] of BYTE;  // 原始密码
    sKeypadPassword: array[0..PASSWD_LEN-1] of BYTE;  // 键盘密码
    byUserEnabled: BYTE;  // 用户是否开启使用：0-无效，1-开启，2-不开启
    byRes2: array[0..135-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARM_DEVICE_USER = ^NET_DVR_ALARM_DEVICE_USER;

type
  NET_DVR_KEYBOARD_USER = record 
    dwSize: DWORD;  // 结构体大小
    dwID: DWORD;  // 键盘用户ID
    byDefanceArea: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区权限  按数组下标表示 最大支持512个防区 0 - 无权限 1- 有权限
    byRes: array[0..560-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_KEYBOARD_USER = ^NET_DVR_KEYBOARD_USER;

type
  NET_DVR_OPERATE_USER = record 
    dwSize: DWORD;  // 结构体大小
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码
    bySubSystemPermission: BYTE;  {0-安装员权限 操作员权限（所有子系统）如下： 1-单布防，无布防报告，不能旁路 2-单撤防，无撤防报告，不能旁路 3-布撤防，无布撤防报告，不能旁路
                                                                 4-单布防，有布//防报告，不能旁路 5-单撤防，有撤防报告，不能旁路 6-布撤防，有布撤防报告，不能旁路  7-单布防，无布撤防报告，允许旁路
                                                                 8-单撤防，无布撤防报告，允许旁路 9-布撤防，无布撤防报告，允许旁路 10-单布防，有布防报告，允许旁路 11-单撤防，有撤防报告，允许旁路 1
                                    2-布撤防，有布撤防报告，允许旁路}
    byRes: array[0..63-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_OPERATE_USER = ^NET_DVR_OPERATE_USER;

type
  NET_DVR_GATEWAY_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byName: array[0..NAME_LEN-1] of BYTE;  //  门禁名称
    byEnable: BYTE;  // 是否启用
    byLocalEnable: BYTE;  //  本地是否启用
    wDelayTime: WORD;  // 开启延时时间    单位为秒0-65535 0为一直开启
    byLockWorkMode: BYTE;  //电锁工作模式，0-通电启动，1-断电启动
    byRes: array[0..31-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_GATEWAY_CFG = ^NET_DVR_GATEWAY_CFG;

type
  NET_DVR_SENSOR_ALARM = record 
    dwSize: DWORD;  // 结构体大小
    dwAbsTime: DWORD;  // 绝对时标信息  OSD显示信息
    byName: array[0..NAME_LEN-1] of BYTE;  // sensor 名称
    bySensorChannel: BYTE;  // 模拟量通道
    byType: BYTE;  // 模拟量类型
    byAlarmType: BYTE;  // 1-上4、2-上3、3-上2、4-上1、5-下1、6-下2、7-下3、8-下4 和当前模式有关
    // 例如当为1000时,有上1下1，2，3报警四种报警
    byAlarmMode: BYTE;  //报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL， 作为平台报警程度判断功能,即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    fValue: FLOAT;  // 但前模拟量的值
    fOriginalValue: FLOAT;  //原始电流电压值，保留小数点后三位，具体值表示电流还是电压根据NET_DVR_SENSOR_INFO的bySensorStandard类型
    byRes2: array[0..28-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SENSOR_ALARM = ^NET_DVR_SENSOR_ALARM;

const
  PROTOCOL_VERTION_LEN = 32;    

type
  NET_DVR_RS485_PROTOCOL_VERSION = record 
    dwSize: DWORD;  
    byProtocleVersion: array[0..PROTOCOL_VERTION_LEN-1] of BYTE;  //RS485协议库版本信息
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_RS485_PROTOCOL_VESRION = ^NET_DVR_RS485_PROTOCOL_VERSION;


type
  NET_DVR_ALARMHOST_ALARMINFO = record 

    //预留，目前报警主机的报警没有类型(布防网络序，监听主机序)
    dwAlarmType: DWORD;  
    //数组0对应第1个输入端口
    byAlarmInputNumber: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  
    byRes: array[0..160-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ALARMINFO = ^NET_DVR_ALARMHOST_ALARMINFO;
// 开关量报警上传
type
  NET_DVR_SWITCH_ALARM = record 
    dwSize: DWORD;  
    byName: array[0..NAME_LEN-1] of BYTE;  // switch 名称
    wSwitchChannel: WORD;  // 开关量通道, 0-255
    byAlarmType: BYTE;  // 报警类型 0--正常，1--短路，2--断路,3-异常
    byRes: array[0..41-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SWITCH_ALARM = ^NET_DVR_SWITCH_ALARM;

type
  NET_DVR_ALARMHOST_EXCEPTION_PARAM = record 
    case Byte of
    0: (dwUnionSize: array[0..20-1] of DWORD);  // 联合体大小
  end;
  LPNET_DVR_ALARMHOST_EXCEPTION_PARAM = ^NET_DVR_ALARMHOST_EXCEPTION_PARAM;

type
  NET_DVR_ALARMHOST_EXCEPTION_ALARM = record 
    dwSize: DWORD;  // 结构体大小
    // 异常参数  1-设备防拆报警 2-设备防拆后后恢复正常 3-主电源掉电报警 4-主电源掉电后恢复正常 5-内部通信故障报警
    // 6-内部通信故障后恢复正常  7-电话线断线 8-电话线断线恢复 9-自检失败报警  10-自检失败后恢复正常
    // 11蓄电池欠压  12蓄电池电压恢复正常，13-蓄电池故障；14-MBUS模块掉线；15-MBUS模块掉线恢复；16-键盘掉线；
    //17-键盘掉线恢复；18-设备被移动；19-设备被移动复位  20-485外设线路断报警  21-485外设线路断后恢复正常
    //25-子板1插上,26-子板1拔出, 27-子板2插上,28-子板2拔出
    dwExceptionType: DWORD;  
    byRes: array[0..36-1] of BYTE;  // 保留
  end;
  LPNET_DVR_ALARMHOST_EXCEPTION_ALARM = ^NET_DVR_ALARMHOST_EXCEPTION_ALARM;

//自助行拨号参数配置及启用方式配置
const
  MAX_CENTERNUM = 4;    //G1,G2 G3 G4或者N1，N2，N3，N4或者T1，T2，T3，T4
type
  NET_DVR_PHONECENTERDIALCFG = record 
    sCenterName: array[0..NAME_LEN-1] of BYTE;  
    byPhoneNum: array[0..MAX_PHONE_NUM{32}-1] of BYTE;  //中心号码
    byRepeatCall: BYTE;  //重复拨号次数，1~15次
    byPstnProtocol: BYTE;  //通信协议，0-CID；
    byDialDelay: BYTE;  //拨号延时，最大150s, 0-150
    byPstnTransMode: BYTE;  //传输方式，0-DTMF 5/S，1-DTMF 10/S；
    byEnable: BYTE;  //使能，0-关闭，1-启用
    byRes1: array[0..5-1] of BYTE;  
    byReceiverId: array[0..6-1] of BYTE;  //接收机识别账号；
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PHONECENTERDIALCFG = ^NET_DVR_PHONECENTERDIALCFG;

type
  NET_DVR_ALARMHOSTDIALCFG = record 
    dwSize: DWORD;  
    struPhoneCenterParam: array[0..MAX_CENTERNUM-1] of NET_DVR_PHONECENTERDIALCFG;  //主中心参数
    wReportPeriod: WORD;  //测试报告上传周期，小时，（最大值支持7天，即168小时), 范围；1-168
    wFirstReportTime: WORD;  //从设备启动到第一条测试报告上传，1~3600分钟
    byReportValid: BYTE;  //0-不启用测试报告上传 1-启用测试报告上传
    byRes: array[0..19-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOSTDIALCFG = ^NET_DVR_ALARMHOSTDIALCFG;

type
  NET_DVR_ALARMHOSTDIALSETUPMODE = record 
    dwSize: DWORD;  
    byEnableMode: BYTE;  //启用方式，0：不启用，1：一直启用，2:网线断启用，正常时关闭；
    byCallType: BYTE;  //上传中心方式，1-单中心，2-双中心，3，一报一备
    byRes1: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOSTDIALSETUPMODE = ^NET_DVR_ALARMHOSTDIALSETUPMODE;

const
  MAX_PU_CHAN_NUM = 512;    

type
  NET_DVR_PU_CHAN_INFO = record 
    struIpAddr: NET_DVR_IPADDR;  // ip地址
    wPort: WORD;  // 端口
    wChannel: WORD;  // 通道
    byRes: array[0..24-1] of BYTE;  //
  end;
  LPNET_DVR_PU_CHAN_INFO = ^NET_DVR_PU_CHAN_INFO;

type
  NET_DVR_PU_CHAN_LIST = record 
    dwSize: DWORD;  // 结构体
    dwNum: DWORD;  // 前端通道个数
    struPuChanInfo: array[0..MAX_PU_CHAN_NUM-1] of NET_DVR_PU_CHAN_INFO;  
  end;
  LPNET_DVR_PU_CHAN_LIST = ^NET_DVR_PU_CHAN_LIST;

const
  MAX_ALARM_CAM_NUM = 32;    // 报警触发CAM最大个数

type
  NET_DVR_PTZ_CTRL = record 
    byEnable: BYTE;  // 是否启用PTZ控制
    byType: BYTE;  // PTZ 控制的类型 1- 预置点 2 -巡航  3-
    byPtzNo: BYTE;  //  ptz 控制的预置点 巡航 号
    byRes: array[0..5-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PTZ_CTRL = ^NET_DVR_PTZ_CTRL;

type
  NET_DVR_ALARM_CAM_INFO = record 
    dwCamID: DWORD;  // 触发的CAM通道操作
    dwRecordTime: DWORD;  // 触发录像时间 单位为s  -1表示一直录像 0 表示不录像
    dwMonID: DWORD;  // 触发Cam到Mon号显示
    dwResidentTime: DWORD;  // 轮巡停留时间单位为s  -1表示一直停留 0 表示不停留
    struPtzCtrl: NET_DVR_PTZ_CTRL;  // PTZ控制信息
    byAlarmOffMode: BYTE;  // 报警切换上墙取消模式   0-立即取消，1-自动取消，2-手动取消 立即取消，报警取消时立即取消解码上墙   自动取消，报警取消时等待一定时间后取消解码上墙，我们约定是20秒  手动取消，用户通过手动的方式取消
    byDevType: BYTE;  // 当设备为智能设备时，生效表示智能报警设备取流源 1-解码卡     2-编码卡
    byDecChan: BYTE;  // 当为解码通道为解码通道号
    byRes: array[0..17-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARM_CAM_INFO = ^NET_DVR_ALARM_CAM_INFO;

type
  NET_DVR_ALARM_CAM_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  // 是否启用报警触发CAM联动 设备默认不启用
    byRes: array[0..7-1] of BYTE;  // 保留字节
    dwNum: DWORD;  // 触发CAM联动的个数 即取数组的前几个有效处理
    struAlarmCam: array[0..MAX_ALARM_CAM_NUM-1] of NET_DVR_ALARM_CAM_INFO;  
  end;
  LPNET_DVR_ALARM_CAM_CFG = ^NET_DVR_ALARM_CAM_CFG;

const
  MAX_GATEWAY_NUM = 8;    // 最大门禁个数
type
  NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM = record 
    dwSize: DWORD;  
    byEnterDoor: array[0..8-1] of BYTE;  // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    byExitDoor: array[0..8-1] of BYTE;  // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    byAlarmIn: array[0..MAX_ALARMHOST_ALARMIN_NUM{512}-1] of BYTE;  //关联报警输入，下标表示报警输入号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM = ^NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

//数据上传下载（语音上传下载的扩展）
type
  NET_DVR_UPLOAD_PARAM = record 
    dwSize: DWORD;  
    byUploadType: BYTE;  //上传方式，1-根据文件名绝对地址读取数据文件上传， 2-从缓冲区读取数据上传
    byDataType: BYTE;  //数据类型：1-音频数据
    byDataNum: BYTE;  //数据编号，如：上传语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    byAudioType: BYTE;  //语音格式，0-wave
    sFileName: array[0..260-1] of AnsiChar;  //数据文件的全路径
    lpBuffer: PAnsiChar;  //数据缓冲区
    dwBufferSize: DWORD;  //缓冲区大小
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_PARAM = ^NET_DVR_UPLOAD_PARAM;

type
  DATADOWNLOAD = procedure(nDownloadHandle: LONG; dwDataType: DWORD; pBuffer: PVOID; dwBufSize: DWORD; pUser: PVOID); stdcall;
type
  NET_DVR_DOWNLOAD_PARAM = record 
    dwSize: DWORD;  
    byDownType: BYTE;  //下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据
    byDataType: BYTE;  //数据类型：1-音频数据
    byDataNum: BYTE;  //数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    byRes1: BYTE;  
    sFileName: array[0..260-1] of AnsiChar;  //数据文件的全路径
    lpDataCallBack: DATADOWNLOAD;  //下载时的回调函数句柄
    pUserData: PVOID;  //用户数据，将在回调函数中传回
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_PARAM = ^NET_DVR_DOWNLOAD_PARAM;


type
  NET_DVR_ALARMHOST_DOWNLOAD_PARAM = record 
    dwSize: DWORD;  
    byDownType: BYTE;  //下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据
    byDataType: BYTE;  //数据类型：1-音频数据
    byDataNum: BYTE;  //数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    byRes1: BYTE;  
    sFileName: array[0..260-1] of AnsiChar;  //数据文件的全路径
    lpDataCallBack: DATADOWNLOAD;  //下载时的回调函数句柄
    pUserData: PVOID;  //用户数据，将在回调函数中传回
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM = ^NET_DVR_ALARMHOST_DOWNLOAD_PARAM;

//LED屏幕参数
type
  NET_DVR_LED_SCREEN_CFG = record 
    dwSize: DWORD;  
    sLEDName: array[0..NAME_LEN{32}-1] of BYTE;  // LED屏幕名称
    byTransMode: BYTE;  // 现只支持串口通讯 1-串口通信
    byProtocolType: BYTE;  // 协议类型，对应LED屏的厂家
    byLEDColor: BYTE;  // 1-单色， 2-双色， 3-256级灰度双基色， 4- 全彩色（目前只用单色）
    byDataPolarity: BYTE;  // 数据极性 .0-负极，1-正极
    byOEPolarity: BYTE;  // 0-低有效 1-高有效
    byScanMode: BYTE;  // 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-静态
    byRes1: array[0..2-1] of BYTE;  
    //屏幕宽度和高度最小是16*16点，间隔是8个点
    wLEDWidth: WORD;  // 16~2048
    wLEDHeight: WORD;  // 16~2048
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LED_SCREEN_CFG = ^NET_DVR_LED_SCREEN_CFG;

//LED屏显内容
const
  MAX_CONTENT_LEN = 512;    
type
  NET_DVR_LED_CONTENT_CFG = record 
    dwSize: DWORD;  
    sLEDContent: array[0..MAX_CONTENT_LEN-1] of BYTE;  // LED屏幕显示内容
    byContentAct: BYTE;  // 1-静态，2-快速打出，3-向左移动，4-向右移动， 5-向上移动， 6-向下移动
    byContentSpeed: BYTE;  // 1-24（1最快，24最慢）
    byContentStayTime: BYTE;  // 0-127.5s(精度0.5s， SDK传送时候*2，即传送数值0-255，设备端在使用的时候需除以2)
    byRes: array[0..33-1] of BYTE;  
  end;
  LPNET_DVR_LED_CONTENT_CFG = ^NET_DVR_LED_CONTENT_CFG;

//LED定时开关机
const
  LED_TIMER_NUM = 3;    // LED开机、关机时间组数
  TIME_SEGMENT_A_DAY = 48;    // 时间段个数，一天24小时，半小时一个段

type
  NET_DVR_SWITCH_TIME = record 
    byValid: BYTE;  // 该组定时时间是否有效，时间是成对设置的
    byRes: array[0..3-1] of BYTE;  
    struTimeOn: NET_DVR_TIME_EX;  // 开机时间
    struTimeOff: NET_DVR_TIME_EX;  // 关机时间
  end;
  LPNET_DVR_SWITCH_TIME = ^NET_DVR_SWITCH_TIME;


type
  NET_DVR_LED_SWITCH_TIME = record 
    dwSize: DWORD;  
    struTimer: array[0..LED_TIMER_NUM{3}-1] of NET_DVR_SWITCH_TIME;  //定时开关机时间，结构体中只有小时和分钟两个参数有效，每组开机时间要早于该组的关机时间，但比前一组的关机时间要晚，例如：struTimer[0]的关机时间是10：00那么，struTimer[0]的开机时间须设置为10:00之前， struTimer[1]的开机时间须设置为10：:00以后。
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LED_SWITCH_TIME = ^NET_DVR_LED_SWITCH_TIME;

//分时亮度调节
type
  NET_DVR_LED_BRIGHTNESS_STEP = record 
    dwSize: DWORD;  
    byValid: BYTE;  //分时亮度调节是否有效
    byRes1: array[0..3-1] of BYTE;  
    byBrightnessStep: array[0..TIME_SEGMENT_A_DAY{48}-1] of BYTE;  //将全天24个小时分为48个时段，每30分钟一个时段，用48个字节表示每个时段的亮度级别，亮度共16级，用0~15表示。
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_LED_BRIGHTNESS_STEP = ^NET_DVR_LED_BRIGHTNESS_STEP;

type
  NET_DVR_LED_STATUS = record 
    dwSize: DWORD;  
    bySwitchState: BYTE;  //1-开机状态 2-关机状态
    byBrightness: BYTE;  //亮度值，范围0-15
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_LED_STATUS = ^NET_DVR_LED_STATUS;

//2010-12-28 高清解码卡能力集 begin
//新的解码卡服务器能力集
const
  MAX_DECODE_CARD_NUM = 6;    //最多高清解码卡数
//*******************高清解码卡输出模式宏定义*******************
type
  HD_DISPLAY_FORMAT =  
  (  
    HD_DISPLAY_FORMAT_INVALID = $00000000,  
    HD_DISPLAY_FORMAT_CVBS = $00000001,  
    HD_DISPLAY_FORMAT_DVI = $00000002,  
    HD_DISPLAY_FORMAT_VGA = $00000004,  
    HD_DISPLAY_FORMAT_HDMI = $00000008,  
    HD_DISPLAY_FORMAT_YPbPr = $00000010  
  );
  LPHD_DISPLAY_FORMAT = ^HD_DISPLAY_FORMAT;

//*******************高清解码卡输出模式宏定义*******************
type
  NET_DVR_DECCARD_ABILITY = record //高清解码卡能力集
    byCardType: BYTE;  //解码卡类型(0:MD,1:MD+,2:HD)
    byDecNums: BYTE;  //解码通道数
    byDispNums: BYTE;  //显示通道数
    byDecStartIdx: BYTE;  //首个解码通道在所有解码通道中的索引
    byDispStartIdx: BYTE;  //首个显示通道在所有显示通道中的索引
    byDispResolution: array[0..80-1] of BYTE;  //输出模式支持的分辨率
    byDispFormat: array[0..8-1] of BYTE;  //支持的输出模式(按HD_DISPLAY_FORMAT)
    byWindowMode: array[0..4-1, 0..8-1] of BYTE;  //支持的窗口模式(比如1,2,4,9,16))
    byRes: array[0..35-1] of BYTE;  
  end;
  LPNET_DVR_DECCARD_ABILITY = ^NET_DVR_DECCARD_ABILITY;

type
  NET_DVR_DECODESVR_ABILITY = record 
    dwSize: DWORD;  // 结构体大小 
    byCardNums: BYTE;  // 解码卡数 
    byStartChan: BYTE;  // 起始通道号 
    byRes1: array[0..2-1] of BYTE;  
    struDecCardAbility: array[0..MAX_DECODE_CARD_NUM-1] of NET_DVR_DECCARD_ABILITY;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DECODESVR_ABILITY = ^NET_DVR_DECODESVR_ABILITY;

type
  NET_MATRIX_DEV_CHAN_INFO = record 
    struIP: NET_DVR_IPADDR;  //DVR IP地址
    wDVRPort: WORD;  //端口号
    byChannel: BYTE;  //通道号
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    byUsedSlotNum: BYTE;  //是否使用槽位号，0-不使用，1-使用
    bySlotNum: BYTE;  //槽位号
    byRes: array[0..68-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //布防主机登陆帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //布防主机密码
  end;
  LPNET_MATRIX_DEV_CHAN_INFO = ^NET_MATRIX_DEV_CHAN_INFO;

type
  NET_MATRIX_PU_STREAM_CFG = record 
    dwSize: DWORD;  
    struStreamMediaSvrCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  
    struDevChanInfo: NET_MATRIX_DEV_CHAN_INFO;  
  end;
  LPNET_MATRIX_PU_STREAM_CFG = ^NET_MATRIX_PU_STREAM_CFG;

//camera配置单元结构
type
  NET_DVR_MATRIX_CAMERACFG = record 
    dwGlobalIndex: DWORD;  //全局编号
    dwInterIndex: DWORD;  //局部编号
    sCamName: array[0..NAME_LEN-1] of BYTE;  
    struPuStreamCfg: NET_MATRIX_PU_STREAM_CFG;  
  end;
  LPNET_DVR_MATRIX_CAMERACFG = ^NET_DVR_MATRIX_CAMERACFG;

type
  NET_DVR_MATRIX_CAMERALIST = record 
    dwSize: DWORD;  
    byRes: array[0..12-1] of BYTE;  
    dwCamNum: DWORD;  //CAM数量
    pBuffer: PBYTE;  
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_MATRIX_CAMERALIST = ^NET_DVR_MATRIX_CAMERALIST;

type
  NET_DVR_DISP_CHAN_INFO = record 
    struIP: NET_DVR_IPADDR;  // 解码器 IP地址 
    wDVRPort: WORD;  // 端口号 
    byDispChannel: BYTE;  // 显示通道号 
    byUsedSlotNum: BYTE;  //是否使用槽位号，0-使用，1-不使用
    bySlotNum: BYTE;  //槽位号
    byRes: array[0..7-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //登陆帐号 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码 
  end;
  LPNET_DVR_DISP_CHAN_INFO = ^NET_DVR_DISP_CHAN_INFO;

//monitor配置单元结构
type
  NET_DVR_MATRIX_MONITORCFG = record 
    dwGlobalIndex: DWORD;  //全局编号
    dwInterIndex: DWORD;  
    sMonName: array[0..NAME_LEN-1] of BYTE;  
    struDispChanCfg: NET_DVR_DISP_CHAN_INFO;  
  end;
  LPNET_DVR_MATRIX_MONITORCFG = ^NET_DVR_MATRIX_MONITORCFG;

type
  NET_DVR_MATRIX_MONITORLIST = record 
    dwSize: DWORD;  
    byRes: array[0..12-1] of BYTE;  
    dwMonNum: DWORD;  //MON数量
    pBuffer: PBYTE;  
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_MATRIX_MONITORLIST = ^NET_DVR_MATRIX_MONITORLIST;

const
  MAX_SUBMATRIX_NUM = 8;    //级联中子最多从系统数量
type
  NET_DVR_SUBMATRIXINFO = record 
    byMainMatrix: BYTE;  //是否是主系统，1-是，0-否
    bySubMatrixSequence: BYTE;  //级联子视频综合平台系统序号
    byLoginType: BYTE;  //注册类型，1-直连，2-DNS，3-花生壳
    byRes1: array[0..9-1] of BYTE;  
    struSubMatrixIP: NET_DVR_IPADDR;  //IP地址（可修改）
    wSubMatrixPort: WORD;  //子系统端口号（可修改）
    byRes2: array[0..6-1] of BYTE;  
    struSubMatrixIPMask: NET_DVR_IPADDR;  //IP地址掩码
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 （此参数只能获取）
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码 （此参数只能获取）
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //域名(可修改)
    sDnsAddress: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //DNS域名或IP地址
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号（此参数只能获取）
    byRes3: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SUBMATRIXINFO = ^NET_DVR_SUBMATRIXINFO;

type
  NET_DVR_ALLUNITEDMATRIXINFO = record 
    dwSize: DWORD;  
    struSubMatrixInfo: array[0..MAX_SUBMATRIX_NUM-1] of NET_DVR_SUBMATRIXINFO;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALLUNITEDMATRIXINFO = ^NET_DVR_ALLUNITEDMATRIXINFO;

const
  MAX_GATEWAYTRUNKNUM = 1024;    //级联视频综合平台中最大路由干线数

type
  NET_DVR_MATRIXGATEWAYNOTE = record 
    wTrunkInToOutAbility: WORD;  //干线带宽，按D1的标准衡量，如4表示支持4个D1
    wTrunkOutToInAbility: WORD;  //干线带宽，按D1的标准衡量，如4表示支持4个D1，双向光纤时用到此值
    byRes: array[0..4-1] of BYTE;  
    struInputNote: NET_DVR_MATRIXSUBSYSTEMINFO;  
    struOutputNote: NET_DVR_MATRIXSUBSYSTEMINFO;  
  end;
  LPNET_DVR_MATRIXGATEWAYNOTE = ^NET_DVR_MATRIXGATEWAYNOTE;

type
  NET_DVR_MATRIXGATEWAYINFO = record 
    dwSize: DWORD;  
    struGatewayNote: array[0..MAX_GATEWAYTRUNKNUM-1] of NET_DVR_MATRIXGATEWAYNOTE;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXGATEWAYINFO = ^NET_DVR_MATRIXGATEWAYINFO;

type
  NET_DVR_MATRIXCODESYSTEMINFO = record 
    byMatrixNum: BYTE;  //视频综合平台号
    bySubSystemNum: BYTE;  //子系统槽位号
    byChan: BYTE;  //编码通道
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXCODESYSTEMINFO = ^NET_DVR_MATRIXCODESYSTEMINFO;
type
  NET_DVR_MATRIXDECODESYSTEMINFO = record 
    byMatrixNum: BYTE;  //视频综合平台号
    bySubSystemNum: BYTE;  //子系统槽位号
    byDispChan: BYTE;  //显示通道
    bySubDispChan: BYTE;  //显示通道子通道号
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXDECODESYSTEMINFO = ^NET_DVR_MATRIXDECODESYSTEMINFO;

type
  NET_DVR_MATRIXSWITCH = record 
    struInputNote: NET_DVR_MATRIXCODESYSTEMINFO;  
    struOutputNote: NET_DVR_MATRIXDECODESYSTEMINFO;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXSWITCH = ^NET_DVR_MATRIXSWITCH;

type
  DEV_TYPE =    (  
    ENC_CARD = 0,  
    DEC_CARD,  
    SD_DEC_CARD,  
    FPGA_CARD,  
    CS_CARD,  
    ALERTOR_CARD,  
    NAT_0,  
    NAT_1,  
    VCA_CARD,  
    VGA_DEC_CARD,  
    VGA_ENC_CARD,  
    ERR_CARD  
  );

type
  NET_DVR_MATRIXSWITCHCTRL = record 
    dwCamId: DWORD;  //摄像机全局编号
    dwMonId: DWORD;  //显示器全局编号
    bySubWindowNum: BYTE;  //显示器对应子窗口号
    bySwitchType: BYTE;  //切换类型，0:正常切换，1:报警触发切换，2:报警取消，0xff:表示此MON上所有报警全部取消
    wAlarmType: WORD;  //报警设备类型，1:报警主机，2：智能设备
    dwResidentTime: DWORD;  // 显示驻留时间，0xFFFFFFFF 时 为常驻情况，保持显示
    byVcaDevType: BYTE;  //当报警设备类型是"智能设备"时，按DEV_TYPE类型
    byWallNo: BYTE;  //墙号
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXSWITCHCTRL = ^NET_DVR_MATRIXSWITCHCTRL;

type
  NET_DVR_MATRIXDATABASE = record 

    //配置文件类型，1-域数据库配置文件，2-子域数据库配置文件，3-平台数据库配置文件，4-场景配置文件，0xff最后一次失败的数据库语句
    dwDevType: DWORD;  
    dwParam: DWORD;  //参数，代表域号、子域号、平台号，场景配置文件时此值无用
    byFileType: BYTE;  //文件类型，1-sql语句，2-db语句，3-场景配置文件
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXDATABASE = ^NET_DVR_MATRIXDATABASE;

type
  NET_DVR_SUBSYSTEMINFO_V40 = record 

{子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，
    9-V6子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板，14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-音频子系统，0-NULL（此参数只能获取）}
    bySubSystemType: BYTE;  
    //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    byChan: BYTE;  
    byLoginType: BYTE;  //注册类型，1-直连，2-DNS，3-花生壳
    bySlotNum: BYTE;  //槽位号，此参数只能获取
    byRes1: array[0..4-1] of BYTE;  
    struSubSystemIP: NET_DVR_IPADDR;  //IP地址（可修改）
    struSubSystemIPMask: NET_DVR_IPADDR;  //子网掩码
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    wSubSystemPort: WORD;  //子系统端口号（可修改）
    byRes2: array[0..6-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 （此参数只能获取）
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码(可修改)
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //域名(可修改)
    sDnsAddress: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //DNS域名或IP地址
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号（此参数只能获取）
    byBelongBoard: BYTE;  //所属子板号，从1开始，0xff表示无效
    byInterfaceType: BYTE;  //接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，16-TVI,17-VSCREEN,18-miniDP,0xff-无效
    byInterfaceNums: BYTE;  //接口个数，0xff表示无效
    byInterfaceStartNum: BYTE;  //接口起始号，0xff表示无效
    byDeviceName: array[0..20-1] of BYTE;  //子系统名称
    byAudioChanNums: BYTE;  //音频通道个数
    byAudioChanStartNum: BYTE;  //音频通道起始号
    byAudioChanType: BYTE;  //音频通道类型，0-无效，1-音频输入，2-音频输出
    byRes3: array[0..33-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEMINFO_V40 = ^NET_DVR_SUBSYSTEMINFO_V40;

const
  MAX_SUBSYSTEM_NUM_V40 = 120;    
type
  NET_DVR_ALLSUBSYSTEMINFO_V40 = record 
    dwSize: DWORD;  
    struSubSystemInfo: array[0..MAX_SUBSYSTEM_NUM_V40-1] of NET_DVR_SUBSYSTEMINFO_V40;  
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ALLSUBSYSTEMINFO_V40 = ^NET_DVR_ALLSUBSYSTEMINFO_V40;

type
  NET_DVR_SUBSYSTEM_BASIC_INFO = record 
    dwSize: DWORD;  
    //子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-信号接入子系统,0-NULL（此参数只能获取）
    bySubSystemType: BYTE;  
    //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    bySubSystemNo: BYTE;  //子系统号，此参数只能获取
    byInterfaceType: BYTE;  //接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YprPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，0xff-无效
    byRes1: BYTE;  
    dwChan: DWORD;  
    struSubSystemIP: NET_DVR_IPADDR;  //IP地址（可修改）
    struSubSystemIPMask: NET_DVR_IPADDR;  //子网掩码
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址 
    wSubSystemPort: WORD;  //子系统端口号（可修改）
    byRes2: array[0..6-1] of BYTE;  
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //序列号（此参数只能获取）
    byBelongBoard: BYTE;  //所属子板号，从1开始，0xff表示无效，但当byBelongBoardH不为0时该字段可以为0xff
    byBelongBoardH: BYTE;  //所属子板号高位
    byRes3: array[0..2-1] of BYTE;  
    byDeviceName: array[0..20-1] of BYTE;  //子系统名称
    dwStartChanNo: DWORD;  //起始通道号
    byDevNo: BYTE;  //设备号
    byRes4: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEM_BASIC_INFO = ^NET_DVR_SUBSYSTEM_BASIC_INFO;

type
  NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE = record 
    dwSize: DWORD;  
    dwErrorCode: DWORD;  //错误
    byDevNo: BYTE;  //设备号
    bySubSystemNo: BYTE;  //子系统号
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE = ^NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE;

type
  NET_DVR_CAMERA_INFO_RESPONSE = record 
    dwErrorCode: DWORD;  //错误
    dwCamId: DWORD;  //cam 的统一编号
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_CAMERA_INFO_RESPONSE = ^NET_DVR_CAMERA_INFO_RESPONSE;

type
  NET_DVR_MONITOR_INFO_RESPONSE = record 
    dwErrorCode: DWORD;  //错误
    dwMonId: DWORD;  //mon 的统一编号
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_MONITOR_INFO_RESPONSE = ^NET_DVR_MONITOR_INFO_RESPONSE;

type
  NET_DVR_AUDIO_INFO = record 
    dwSize: DWORD;  
    byAudioChanType: BYTE;  //音频通道类型，1-音频输入，2-音频输出
    byRes1: array[0..3-1] of BYTE;  
    dwAudioNo: DWORD;  //音频号(1字节设备号+1字节子板号+2字节音频口号)
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_INFO = ^NET_DVR_AUDIO_INFO;


type
  NET_DVR_SINGLESUBSYSTEMJOININFO_V40 = record 

    //子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）
    bySubSystemType: BYTE;  
    byConnectStatus: BYTE;  //级联系统关联状态，1-连接正常，2-连接断开
    byMatrixNum: BYTE;  //级联视频综合平台号，子系统类型是3或4时可用
    bySubSystemNum: BYTE;  //级联子系统槽位号，0~79，子系统类型是3或4时可用
    struDecSub: array[0..MATRIX_MAXDECSUBSYSTEMCHAN-1] of NET_DVR_DECSUBSYSTEMJIONSTATUS;  
    byBindStatus: BYTE;  //绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    bySlotNum: BYTE;  //槽位号，此参数只能获取
    //子系统类型为1的时可用，0-未关联，1-D1，2-720，3-1080
    byDecodeAbility: BYTE;  
    byUsedTrunk: BYTE;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40 = ^NET_DVR_SINGLESUBSYSTEMJOININFO_V40;

type
  NET_DVR_ALLDECSUBSYSTEMJOININFO_V40 = record 
    dwSize: DWORD;  
    struSingleSubSystemJoinInfo: array[0..MAX_SUBSYSTEM_NUM_V40-1] of NET_DVR_SINGLESUBSYSTEMJOININFO_V40;  
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 = ^NET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

const
  MAX_OPTICALFIBER_NUM = 16;    
type
  NET_DVR_SUBSYSTEM_ABILITY = record 

{子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，
    10-转码子系统，11-X86服务器子系统，板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，0-NULL（此参数0-NULL（此参数只能获取）}
    bySubSystemType: BYTE;  
    byChanNum: BYTE;  //子系统通道数
    byStartChan: BYTE;  //子系统起始通道数
    bySlotNum: BYTE;  //槽位号
    byRes1: array[0..4-1] of BYTE;  
    struAbility: record 
      case Byte of
      0: (byRes: array[0..200-1] of BYTE);  
      1: (struVACSystemAbility: record
        byDecode: BYTE;  //是否是带解码功能的智能板,1-是，0-否
        byNeedPreAllocDec: BYTE;  //是否需要预分配解码资源，1-是，0-否
        byVACType: BYTE;  //智能子系统类型，0-普通型，1-增强型
        byRes: array[0..197-1] of BYTE;  
      end);  
      2: (struDecoderSystemAbility: record
        byVGANums: BYTE;  //VGA显示通道个数（从1开始）
        byBNCNums: BYTE;  //BNC显示通道个数（从9开始）
        byHDMINums: BYTE;  //HDMI显示通道个数（从25开始）
        byDVINums: BYTE;  //DVI显示通道个数（从29开始）
        byLayerNums: BYTE;  //大屏拼接中，做主屏时所支持图层数
        bySpartan: BYTE;  //畅显功能，0-不支持，1-支持
        byDecType: BYTE;  //解码子系统类型，0-普通型,1-增强型(普通型分屏时前4窗口需使用自身资源，增强型无此限制，增强型最多可被其他子系统借16路D1解码资源
            //增强型被大屏关联为子屏后资源可被借用，普通型则不能被借用)
            //2-智能关联解码子系统，3-转码关联解码子系统（智能和转码关联子系统不能用于解码上墙）
        byOutputSwitch: BYTE;  //是否支持HDMI/DVI互相切换，0-不支持，1-支持
        bySDINums: BYTE;  //SDI显示通道个数（从33开始）
        byRes1: array[0..38-1] of BYTE;  
        byDecoderType: BYTE;  //解码板是否支持多厂家码流解码，0-不支持，1-支持
        byRes2: array[0..152-1] of BYTE;  
      end);  
      3: (struCoderSystemAbility: record
        byCoderType: BYTE;  //编码器类型，0-标清，1-高清, 2-模拟高清
        byOptical: BYTE;  //光端机接入，0-否，1-是
        byOpticalSubChan: BYTE;  //每个光口信道数
        bySupportAVSeparate: BYTE;  //是否支持音视频分离，0-不支持，1-支持
        byRes: array[0..196-1] of BYTE;  
      end);  
      4: (struInputSystemAbility: record
        wTrunkAbility: WORD;  //干线带宽，按D1的标准衡量，如4表示支持4个D1
        byOpticalFiberNum: BYTE;  //光纤条数
        byRes: array[0..197-1] of BYTE;  
      end);  
      5: (struOutputSystemAbility: record
        wTrunkAbility: WORD;  //干线带宽，按D1的标准衡量，如4表示支持4个D1
        byOpticalFiberNum: BYTE;  //光纤条数
        byRes: array[0..197-1] of BYTE;  
      end);  
      6: (struCodeSpitterSystemAbility: record
        by485Num: BYTE;  //码分子系统中485数量
        bySlotNum: BYTE;  //每个485槽位数
        byRes: array[0..198-1] of BYTE;  
      end);  
      7: (struAlarmHostSystemAbility: record
        wAlarmInNums: WORD;  
        wAlarmOutNums: WORD;  
            // 标识报警盒是否连接， 1表示已连接， 为0 表示未连接 
        byAlarmBoxEnable: array[0..4-1, 0..8-1] of BYTE;  
        bySupportContact: BYTE;  // 视频综合平台内部报警联动，0-不支持,1-支持 
        byRes: array[0..163-1] of BYTE;  
      end);  
      8: (struInOutputSystemAbility: record
        byOpticalFiberNum: BYTE;  //光纤条数
        byRes1: array[0..3-1] of BYTE;  
            //光纤带宽，按D1的标准衡量，如4表示支持4个D1
        wTrunkAbility: array[0..MAX_OPTICALFIBER_NUM{16}-1] of WORD;  
        byRes2: array[0..164-1] of BYTE;  
      end);  
      9: (struFiberSwitchSystemAbility: record
        bySupportRingProtocol: BYTE;  //是否支持环网协议
        bySupportRingNums: BYTE;  //支持环网数量
        bySupportPortNums: BYTE;  //支持的端口数量
        byRes: array[0..1-1] of BYTE;  
        dwPortSupportRingProto: DWORD;  //每个端口是否支持环网协议，按位算，1～32位分别表示1～32端口，0-不支持，1-表示支持
        byRes2: array[0..192-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_SUBSYSTEM_ABILITY = ^NET_DVR_SUBSYSTEM_ABILITY;

type
  NET_DVR_VIDEOPLATFORM_ABILITY_V40 = record 
    dwSize: DWORD;  
    byCodeSubSystemNums: BYTE;  //编码子系统数量
    byDecodeSubSystemNums: BYTE;  //解码子系统数量
    bySupportNat: BYTE;  //是否支持NAT，0-不支持，1-支持
    byInputSubSystemNums: BYTE;  //级联输入子系统数量
    byOutputSubSystemNums: BYTE;  //级联输出子系统数量
    byCodeSpitterSubSystemNums: BYTE;  //码分子系统数量
    byAlarmHostSubSystemNums: BYTE;  //报警子系统数量
    bySupportBigScreenNum: BYTE;  //所支持最多组成大屏的个数
    byVCASubSystemNums: BYTE;  //智能子系统数量
    byV6SubSystemNums: BYTE;  //V6子系统数量
    byV6DecoderSubSystemNums: BYTE;  //V6解码子系统数量
    bySupportBigScreenX: BYTE;  //大屏拼接的模式：m×n
    bySupportBigScreenY: BYTE;  
    bySupportSceneNums: BYTE;  //支持场景模式的个数
    byVcaSupportChanMode: BYTE;  //智能支持的通道使用模式，0-使用解码通道，1-使用显示通道及子通道号
    bySupportScreenNums: BYTE;  //所支持的大屏的屏幕最大个数
    bySupportLayerNums: BYTE;  //所支持的图层数，0xff-无效
    byNotSupportPreview: BYTE;  //是否支持预览,1-不支持，0-支持
    byNotSupportStorage: BYTE;  //是否支持存储,1-不支持，0-支持
    byUploadLogoMode: BYTE;  //上传logo模式，0-上传给解码通道，1-上传给显示通道
    struSubSystemAbility: array[0..MAX_SUBSYSTEM_NUM_V40-1] of NET_DVR_SUBSYSTEM_ABILITY;  
    by485Nums: BYTE;  //485串口个数
    by232Nums: BYTE;  //232串口个数
    bySerieStartChan: BYTE;  //起始通道
    byScreenMode: BYTE;  //大屏模式，0-主屏由客户端分配，1-主屏由设备端分配
    byDevVersion: BYTE;  //设备版本，0-B10/B11/B12，1-B20
    bySupportBaseMapNums: BYTE;  //所支持的底图数，底图号从1开始
    wBaseLengthX: WORD;  //每个屏大小的基准值，B20使用
    wBaseLengthY: WORD;  
    bySupportPictureTrans: BYTE;  //是否支持图片回显，0-不支持，1-支持
    bySupportPreAllocDec: BYTE;  //是否支持智能解码资源预分配，0-不支持，1-支持
    bySupportDecAutoManage: BYTE;  //是否支持解码资源管理
    byTranDevSubSystemNums: BYTE;  //转码子系统数量
    byFiberSwitchNums: BYTE;  //网络光纤子系统数量
    byRes2: array[0..625-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOPLATFORM_ABILITY_V40 = ^NET_DVR_VIDEOPLATFORM_ABILITY_V40;

type
  NET_DVR_VIDEOPLATFORM_ABILITY = record 
    dwSize: DWORD;  
    byCodeSubSystemNums: BYTE;  //编码子系统数量
    byDecodeSubSystemNums: BYTE;  //解码子系统数量
    bySupportNat: BYTE;  //是否支持NAT，0-不支持，1-支持
    byInputSubSystemNums: BYTE;  //级联输入子系统数量
    byOutputSubSystemNums: BYTE;  //级联输出子系统数量
    byCodeSpitterSubSystemNums: BYTE;  //码分子系统数量
    byAlarmHostSubSystemNums: BYTE;  //报警子系统数量
    bySupportBigScreenNum: BYTE;  //所支持最多大屏拼接数量
    byVCASubSystemNums: BYTE;  //智能子系统数量
    byRes1: array[0..11-1] of BYTE;  
    struSubSystemAbility: array[0..MAX_SUBSYSTEM_NUM-1] of NET_DVR_SUBSYSTEM_ABILITY;  
    by485Nums: BYTE;  //485串口个数
    by232Nums: BYTE;  //485串口个数
    bySerieStartChan: BYTE;  //起始通道
    byRes2: array[0..637-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOPLATFORM_ABILITY = ^NET_DVR_VIDEOPLATFORM_ABILITY;
//获取能力集接口

//模式A
type
  NET_DVR_HOLIDATE_MODEA = record 
    byStartMonth: BYTE;  // 开始月 从1开始
    byStartDay: BYTE;  // 开始日 从1开始
    byEndMonth: BYTE;  // 结束月
    byEndDay: BYTE;  // 结束日
    byRes: array[0..4-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_HOLIDATE_MODEA = ^NET_DVR_HOLIDATE_MODEA;

type
  NET_DVR_HOLIDATE_MODEB = record 
    byStartMonth: BYTE;  // 从1开始
    byStartWeekNum: BYTE;  // 第几个星期 从1开始
    byStartWeekday: BYTE;  // 星期几
    byEndMonth: BYTE;  // 从1开始
    byEndWeekNum: BYTE;  // 第几个星期 从1开始
    byEndWeekday: BYTE;  // 星期几
    byRes: array[0..2-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_HOLIDATE_MODEB = ^NET_DVR_HOLIDATE_MODEB;

type
  NET_DVR_HOLIDATE_MODEC = record 
    wStartYear: WORD;  // 年
    byStartMon: BYTE;  // 月
    byStartDay: BYTE;  // 日
    wEndYear: WORD;  // 年
    byEndMon: BYTE;  // 月
    byEndDay: BYTE;  // 日
  end;
  LPNET_DVR_HOLIDATE_MODEC = ^NET_DVR_HOLIDATE_MODEC;

type
  NET_DVR_HOLIDATE_UNION = record 
    case Byte of

    // 联合体大小 12字节
    0: (dwSize: array[0..3-1] of DWORD);  
    1: (struModeA: NET_DVR_HOLIDATE_MODEA);  // 模式A
    2: (struModeB: NET_DVR_HOLIDATE_MODEB);  // 模式B
    3: (struModeC: NET_DVR_HOLIDATE_MODEC);  // 模式C
  end;
  LPNET_DVR_HOLIDATE_UNION = ^NET_DVR_HOLIDATE_UNION;

type
  HOLI_DATE_MODE =  
  (  
    HOLIDATE_MODEA = 0,  
    HOLIDATE_MODEB,  
    HOLIDATE_MODEC  
  );

type
  NET_DVR_HOLIDAY_PARAM = record 
    byEnable: BYTE;  // 是否启用
    byDateMode: BYTE;  // 日期模式 0-模式A 1-模式B 2-模式C
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    uHolidate: NET_DVR_HOLIDATE_UNION;  // 假日日期
    byName: array[0..NAME_LEN-1] of BYTE;  // 假日名称
    byRes2: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_HOLIDAY_PARAM = ^NET_DVR_HOLIDAY_PARAM;

const
  MAX_HOLIDAY_NUM = 32;    

type
  NET_DVR_HOLIDAY_PARAM_CFG = record 
    dwSize: DWORD;  // 结构体大小
    struHolidayParam: array[0..MAX_HOLIDAY_NUM-1] of NET_DVR_HOLIDAY_PARAM;  // 假日参数
    byRes: array[0..40-1] of DWORD;  // 保留参数
  end;
  LPNET_DVR_HOLIDAY_PARAM_CFG = ^NET_DVR_HOLIDAY_PARAM_CFG;

// 假日报警处理方式
type
  NET_DVR_HOLIDAY_HANDLE = record 
    dwSize: DWORD;  // 结构体大小
    struAlarmTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  // 布防时间段
    byRes2: array[0..240-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_HOLIDAY_HANDLE = ^NET_DVR_HOLIDAY_HANDLE;

type
  NET_DVR_HOLIDAY_HANDLE_COND = record 
    dwSize: DWORD;  // 结构体大小
    dwChannel: DWORD;  //通道号
    dwSMDHandleType: DWORD;  //简易智能假日布防类型 0-音频异常侦测，1-虚焦侦测，2-场景变更侦测
    byRes2: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_HOLIDAY_HANDLE_COND = ^NET_DVR_HOLIDAY_HANDLE_COND;

type
  NET_DVR_HOLIDAY_RECORD = record 
    dwSize: DWORD;  
    struRecDay: NET_DVR_RECORDDAY;  // 录像参数
    struRecordSched: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_RECORDSCHED;  // 录像时间段
    byRes: array[0..20-1] of BYTE;  //  保留字节
  end;
  LPNET_DVR_HOLIDAY_RECORD = ^NET_DVR_HOLIDAY_RECORD;

const
  MAX_LINK_V30 = 128;    

type
  NET_DVR_ONE_LINK = record 
    struIP: NET_DVR_IPADDR;  // 客户端IP
    lChannel: LONG;  // 通道号
    byRes: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ONE_LINK = ^NET_DVR_ONE_LINK;

type
  NET_DVR_LINK_STATUS = record 
    dwSize: DWORD;  // 结构体大小
    wLinkNum: WORD;  // 连接的数目
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    struOneLink: array[0..MAX_LINK_V30-1] of NET_DVR_ONE_LINK;  // 连接的客户端信息
    byRes: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_LINK_STATUS = ^NET_DVR_LINK_STATUS;

const
  MAX_BOND_NUM = 2;    

type
  NET_DVR_ONE_BONDING = record 
    byMode: BYTE;  // 工作模式0 - 网络容错 1 - 负载均衡
    byUseDhcp: BYTE;  // 是否使能dhcp
    byMasterCard: BYTE;  //  指定哪张网卡为主网卡
    byStatus: BYTE;  // BONDING的状态  0 - 异常 1-正常 只能获取不能设置
    byBond: array[0..MAX_NETWORK_CARD-1] of BYTE;  // byBond[0]== 1 表示使用eh0  0表示不使用eh0
    struEtherNet: NET_DVR_ETHERNET_V30;  // 网卡参数
    struGatewayIpAddr: NET_DVR_IPADDR;  // 网关地址
    byEnableDNS: BYTE;  //DNS使能, 0-关闭，1-打开
    byBondMode: BYTE;  //绑定方式, 0-无效，1-主备模式，2-轮转模式，3-XOR模式，4-广播模式，5-802.3ad模式，6-T1b模式，7-虚拟化模式
    byRes1: array[0..2-1] of BYTE;  
    byBond2: array[0..MAX_NETWORK_CARD_EX{12}-1] of BYTE;  // byBond2[0]== 1 表示使用eh4  0表示不使用eh4，基于byBond扩展
    byRes: array[0..4-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ONE_BONDING = ^NET_DVR_ONE_BONDING;

type
  NET_DVR_NETWORK_BONDING = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  // 是否启用bonding功能
    byNum: BYTE;  // Bonding网卡的个数
    byRes1: array[0..2-1] of BYTE;  //  保留字节
    struOneBond: array[0..MAX_BOND_NUM-1] of NET_DVR_ONE_BONDING;  
    byRes2: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_NETWORK_BONDING = ^NET_DVR_NETWORK_BONDING;


// 磁盘配额
type
  NET_DVR_DISK_QUOTA = record 
    byQuotaType: BYTE;  // 磁盘配额类型,1 - 按容量 2-按比例，3-按时间
    byRes1: array[0..5-1] of BYTE;  // 保留字节
    wStoragePeriod: WORD;  //录像存储周期，单位天，配额类型为按时间时有效
    dwHCapacity: DWORD;  // 分配的磁盘容量高32位 单位MB
    dwLCapacity: DWORD;  // 分配的磁盘容量低32位 单位MB
    dwHUsedSpace: DWORD;  // 已使用的磁盘大小高32位 单位MB
    dwLUsedSpace: DWORD;  // 已使用的磁盘大小低32位 单位MB
    byQuotaRatio: BYTE;  //    分配的磁盘比例,单位:%
    byRes2: array[0..21-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DISK_QUOTA = ^NET_DVR_DISK_QUOTA;

type
  NET_DVR_DISK_QUOTA_CFG = record 
    dwSize: DWORD;  // 结构体大小
    struPicQuota: NET_DVR_DISK_QUOTA;  //  图片配额
    struRecordQuota: NET_DVR_DISK_QUOTA;  //  录像配额
    struAddInfoQuota: NET_DVR_DISK_QUOTA;  //  附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
    byRes: array[0..12-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_DISK_QUOTA_CFG = ^NET_DVR_DISK_QUOTA_CFG;

type
  NET_DVR_DISK_QUOTA_V60 = record 
    byQuotaType: BYTE;  // 磁盘配额类型,1 - 按容量 2-按比例，3-按时间
    byRes1: array[0..5-1] of BYTE;  // 保留字节
    wStoragePeriod: WORD;  //录像存储周期，单位天，配额类型为按时间时有效
    dwHCapacity: DWORD;  // 分配的磁盘容量高32位 单位MB
    dwLCapacity: DWORD;  // 分配的磁盘容量低32位 单位MB
    dwHUsedSpace: DWORD;  // 已使用的磁盘大小高32位 单位MB
    dwLUsedSpace: DWORD;  // 已使用的磁盘大小低32位 单位MB
    byQuotaRatio: BYTE;  //    分配的磁盘比例,单位:%
    byRes2: array[0..23-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DISK_QUOTA_V60 = ^NET_DVR_DISK_QUOTA_V60;

type
  NET_DVR_DISK_QUOTA_CFG_V60 = record 
    dwSize: DWORD;  // 结构体大小
    struPicQuota: NET_DVR_DISK_QUOTA_V60;  //  图片配额
    struRecordQuota: NET_DVR_DISK_QUOTA_V60;  //  录像配额
    struAddInfoQuota: NET_DVR_DISK_QUOTA_V60;  //  附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
    struPubInfoFile: NET_DVR_DISK_QUOTA_V60;  // 发布信息文件配额百分比
    byRes: array[0..256-1] of BYTE;  //保留字节字节
  end;
  LPNET_DVR_DISK_QUOTA_CFG_V60 = ^NET_DVR_DISK_QUOTA_CFG_V60;


type
  NET_DVR_TIMING_CAPTURE = record 
    struJpegPara: NET_DVR_JPEGPARA;  // 定时抓图图片质量
    dwPicInterval: DWORD;  // 定时抓图时间间隔,单位s   1-1s 2-2s 3-3s 4-4s 5-5s
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    byRes: array[0..12-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_TIMING_CAPTURE = ^NET_DVR_TIMING_CAPTURE;

type
  NET_DVR_REL_CAPTURE_CHAN = record 
    byChan: array[0..16-1] of BYTE;  // 按位表示
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_REL_CAPTURE_CHAN = ^NET_DVR_REL_CAPTURE_CHAN;

const
  MAX_PIC_EVENT_NUM = 32;    
  MAX_ALARMIN_CAPTURE = 16;    

type
  NET_DVR_REL_CAPTURE_CHAN_V40 = record 
    dwMaxRelCaptureChanNum: DWORD;  //最大可触发的关联通道数-只读属性
    dwChanNo: array[0..MAX_CHANNUM_V40-1] of DWORD;  //触发的关联抓图通道号，按值表示，采用紧凑型排列,0xffffffff表示后续无效
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_REL_CAPTURE_CHAN_V40 = ^NET_DVR_REL_CAPTURE_CHAN_V40;

type
  NET_DVR_EVENT_CAPTURE_V40 = record 
    struJpegPara: NET_DVR_JPEGPARA;  // 事件抓图图片质量
    dwPicInterval: DWORD;  // 事件抓图时间间隔  单位为秒
    struRelCaptureChan: array[0..MAX_PIC_EVENT_NUM-1] of NET_DVR_REL_CAPTURE_CHAN_V40;  // 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图
    struAlarmInCapture: array[0..MAX_ALARMIN_CAPTURE-1] of NET_DVR_REL_CAPTURE_CHAN_V40;  // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    dwMaxGroupNum: DWORD;  //设备支持的最大报警输入组数，每组16个报警输入
    byCapTimes: BYTE;  //抓图张数
    byRes: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_CAPTURE_V40 = ^NET_DVR_EVENT_CAPTURE_V40;


type
  NET_DVR_EVENT_CAPTURE = record 
    struJpegPara: NET_DVR_JPEGPARA;  // 事件抓图图片质量
    dwPicInterval: DWORD;  // 事件抓图时间间隔  单位为秒  1-1s 2-2s 3-3s 4-4s 5-5s
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    {
    数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图，2 视频丢失触发抓图,数组3表示PIR报警抓图，
    数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图,数组7 表示人脸侦测抓图，
    数组8 表示-越界侦测侦测抓图，数组9 表示区域入侵侦测抓图,数组10表示场景变更侦测抓图,
    数组11-进入区域侦测,数组12-离开区域侦测,数组13-徘徊侦测,数组14-人员聚集侦测,数组15-快速运动侦测,
    数组16-停车侦测,数组17-物品遗留侦测,数组18-物品拿取侦测。
    }
    struRelCaptureChan: array[0..MAX_PIC_EVENT_NUM-1] of NET_DVR_REL_CAPTURE_CHAN;  
    struAlarmInCapture: array[0..MAX_ALARMIN_CAPTURE-1] of NET_DVR_REL_CAPTURE_CHAN;  // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    byCapTimes: BYTE;  //抓图张数
    byRes: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_CAPTURE = ^NET_DVR_EVENT_CAPTURE;

type
  NET_DVR_JPEG_CAPTURE_CFG_V40 = record 
    dwSize: DWORD;  //结构体长度
    struTimingCapture: NET_DVR_TIMING_CAPTURE;  
    struEventCapture: NET_DVR_EVENT_CAPTURE_V40;  
    byStreamType: BYTE;  //抓图码流类型 0-主码流，1-子码流
    byRes3: array[0..19-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_JPEG_CAPTURE_CFG_V40 = ^NET_DVR_JPEG_CAPTURE_CFG_V40;

type
  NET_DVR_JPEG_CAPTURE_CFG = record 
    dwSize: DWORD;  // 结构体大小
    struTimingCapture: NET_DVR_TIMING_CAPTURE;  
    struEventCapture: NET_DVR_EVENT_CAPTURE;  
    byStreamType: BYTE;  //抓图码流类型 0-主码流，1-子码流
    byRes3: array[0..19-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_JPEG_CAPTURE_CFG = ^NET_DVR_JPEG_CAPTURE_CFG;

type
  NET_DVR_CAPTURE_DAY = record 
    byAllDayCapture: BYTE;  // 是否全天抓图
    byCaptureType: BYTE;  // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件 ,39-离线测温抓图,40-防区报警，41-紧急求助,42业务咨询  43-废气排放显示 44-灰度报警
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_DAY = ^NET_DVR_CAPTURE_DAY;

type
  NET_DVR_CAPTURE_SCHED = record 
    struCaptureTime: NET_DVR_SCHEDTIME;  // 抓图时间段
    byCaptureType: BYTE;  // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件  ,39-离线测温抓图 ,40-防区报警，41-紧急求助,42业务咨询 43-废气排放显示 44-灰度报警
    byRes: array[0..3-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_CAPTURE_SCHED = ^NET_DVR_CAPTURE_SCHED;

// 通道抓图计划
type
  NET_DVR_SCHED_CAPTURECFG = record 
    dwSize: DWORD;  // 结构体
    byEnable: BYTE;  // 是否抓图
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struCaptureDay: array[0..MAX_DAYS-1] of NET_DVR_CAPTURE_DAY;  // 全天抓图计划
    struCaptureSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_CAPTURE_SCHED;  // 时间段抓图布防计划
    struCaptureHoliday: NET_DVR_CAPTURE_DAY;  // 假日抓图计划
    struHolidaySched: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_CAPTURE_SCHED;  // 时间段假日抓图布防计划
    dwRecorderDuration: DWORD;  // 抓图保存最长时间 0xffffffff表示该值无效
    dwDelayTime: DWORD;  // 抓图延时时间 0- 无延时， 1-3秒， 2-4秒， 3-5秒， 4-10秒， 5-30秒， 6-60秒， 7- 120秒，8-300秒
    byRes: array[0..36-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SCHED_CAPTURECFG = ^NET_DVR_SCHED_CAPTURECFG;


type
  NET_DVR_FLOW_TEST_PARAM = record 
    dwSize: DWORD;  //结构大小
    lCardIndex: LONG;  //网卡索引
    dwInterval: DWORD;  //设备上传流量时间间隔, 单位:100ms
    byRes: array[0..8-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_FLOW_TEST_PARAM = ^NET_DVR_FLOW_TEST_PARAM;

type
  NET_DVR_FLOW_INFO = record 
    dwSize: DWORD;  //结构大小
    dwSendFlowSize: DWORD;  //发送流量大小,单位kbps
    dwRecvFlowSize: DWORD;  //接收流量大小,单位kbps
    byRes: array[0..20-1] of BYTE;  //保留
  end;
  LPNET_DVR_FLOW_INFO = ^NET_DVR_FLOW_INFO;

//  录像标签
const
  LABEL_NAME_LEN = 40;    
type
  NET_DVR_RECORD_LABEL = record 
    dwSize: DWORD;  // 结构体大小
    struTimeLabel: NET_DVR_TIME;  // 标签的时间
    byQuickAdd: BYTE;  // 是否快速添加 快速添加时标签名称无效
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    sLabelName: array[0..LABEL_NAME_LEN-1] of BYTE;  // 标签的名称 长度为40字节
    byRes2: array[0..40-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_RECORD_LABEL = ^NET_DVR_RECORD_LABEL;

const
  LABEL_IDENTIFY_LEN = 64;    
type
  NET_DVR_LABEL_IDENTIFY = record 
    sLabelIdentify: array[0..LABEL_IDENTIFY_LEN-1] of BYTE;  // 64字节标识
    byRes: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_LABEL_IDENTIFY = ^NET_DVR_LABEL_IDENTIFY;

const
  MAX_DEL_LABEL_IDENTIFY = 20;    // 删除的最大标签标识个数

type
  NET_DVR_DEL_LABEL_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    byMode: BYTE;  // 按位表示,0x01表示按标识删除
    byRes1: BYTE;  
    wLabelNum: WORD;  // 标签数目
    struIndentify: array[0..MAX_DEL_LABEL_IDENTIFY-1] of NET_DVR_LABEL_IDENTIFY;  // 标签标识
    byRes2: array[0..160-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_DEL_LABEL_PARAM = ^NET_DVR_DEL_LABEL_PARAM;

type
  NET_DVR_MOD_LABEL_PARAM = record 
    struIndentify: NET_DVR_LABEL_IDENTIFY;  //要修改的标签标识
    byRes1: array[0..24-1] of BYTE;  
    sLabelName: array[0..LABEL_NAME_LEN-1] of BYTE;  //修改后的标签名称
    byRes2: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_MOD_LABEL_PARAM = ^NET_DVR_MOD_LABEL_PARAM;

// 标签搜索结构体
type
  NET_DVR_FIND_LABEL = record 
    dwSize: DWORD;  // 结构体大小
    lChannel: LONG;  // 查找的通道
    struStartTime: NET_DVR_TIME;  // 开始时间
    struStopTime: NET_DVR_TIME;  // 结束时间
    sLabelName: array[0..LABEL_NAME_LEN-1] of BYTE;  //  录像标签名称 如果标签名称为空，则搜索起止时间所有标签
    byDrawFrame: BYTE;  //0:不抽帧，1：抽帧
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..34-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_FIND_LABEL = ^NET_DVR_FIND_LABEL;

// 标签信息结构体
type
  NET_DVR_FINDLABEL_DATA = record 
    sLabelName: array[0..LABEL_NAME_LEN-1] of BYTE;  // 标签名称
    struTimeLabel: NET_DVR_TIME;  // 标签时间
    struLabelIdentify: NET_DVR_LABEL_IDENTIFY;  // 标签标识
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..29-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_FINDLABEL_DATA = ^NET_DVR_FINDLABEL_DATA;

const
  CARDNUM_LEN_V30 = 40;    
//国家枚举
type
  COUNTRY_INDEX =  
  (  
    COUNTRY_NONSUPPORT = 0,  //0-算法库不支持牌识国家
    //五大洲 一共有235国家和地区 
    //欧洲 48个国家和地区 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
    COUNTRY_CZE = 1,  //Czech Republic 捷克共和国
    COUNTRY_FRA = 2,  //France 法国
    COUNTRY_DEU = 3,  //Germany 德国
    COUNTRY_ESP = 4,  //Spain 西班牙
    COUNTRY_ITA = 5,  //Italy 意大利
    COUNTRY_NLD = 6,  //Netherlands 荷兰
    COUNTRY_POL = 7,  //Poland 波兰
    COUNTRY_SVK = 8,  //Slovakia 斯洛伐克
    COUNTRY_BLR = 9,  //Belarus 白俄罗斯
    COUNTRY_MDA = 10,  //Moldova 摩尔多瓦
    COUNTRY_RUS = 11,  //Russia 俄罗斯
    COUNTRY_UKR = 12,  //Ukraine 乌克兰
    COUNTRY_BEL = 13,  //Belgium 比利时
    COUNTRY_BGR = 14,  //Bulgaria 保加利亚
    COUNTRY_DNK = 15,  //Denmark 丹麦
    COUNTRY_FIN = 16,  //Finland 芬兰
    COUNTRY_GBR = 17,  //United Kingdom 英国
    COUNTRY_GRC = 18,  //Greece 希腊
    COUNTRY_HRV = 19,  //Croatia 克罗地亚
    COUNTRY_HUN = 20,  //Hungary 匈牙利
    COUNTRY_ISR = 21,  //Israel 以色列(亚洲)
    COUNTRY_LUX = 22,  //Luxembourg 卢森堡
    COUNTRY_MKD = 23,  //Macedonia 马其顿共和国
    COUNTRY_NOR = 24,  //Norway  挪威
    COUNTRY_PRT = 25,  //Portuga 葡萄牙
    COUNTRY_ROU = 26,  //Romania 罗马尼亚
    COUNTRY_SRB = 27,  //Serbia 塞尔维亚
    COUNTRY_AZE = 28,  //Azerbaijan 阿塞邦疆共和国(亚洲)
    COUNTRY_GEO = 29,  //Georgia  格鲁吉亚(亚洲)
    COUNTRY_KAZ = 30,  //Kazakhstan 哈萨克斯坦(亚洲)
    COUNTRY_LTU = 31,  //Lithuania 立陶宛共和国
    COUNTRY_TKM = 32,  //Turkmenistan 土库曼斯坦(亚洲)
    COUNTRY_UZB = 33,  //Uzbekistan 乌兹别克斯坦(亚洲)
    COUNTRY_LVA = 34,  //Latvia 拉脱维亚
    COUNTRY_EST = 35,  //Estonia 爱沙尼亚
    COUNTRY_ALB = 36,  //Albania 阿尔巴尼亚
    COUNTRY_AUT = 37,  //Austria 奥地利
    COUNTRY_BIH = 38,  //Bosnia and Herzegovina 波斯尼亚和黑塞哥维那
    COUNTRY_IRL = 39,  //Ireland 爱尔兰
    COUNTRY_ISL = 40,  //Iceland 冰岛
    COUNTRY_VAT = 41,  //Vatican 梵蒂冈
    COUNTRY_MLT = 42,  //Malta 马耳他
    COUNTRY_SWE = 43,  //Sweden 瑞典
    COUNTRY_CHE = 44,  //Switzerland 瑞士
    COUNTRY_CYP = 45,  //Cyprus 塞浦路斯
    COUNTRY_TUR = 46,  //Turkey 土耳其
    COUNTRY_SVN = 47,  //Slovenia 斯洛文尼亚
    COUNTRY_MTG = 48,  //Montenegro 黑山共和国
    COUNTRY_KOV = 49,  //Kosovo 科索沃
    COUNTRY_ADR = 50,  //Andorra 安道尔
    COUNTRY_ARM = 51,  //Armenia 亚美尼亚(亚洲)
    COUNTRY_MON = 52,  //Monaco 摩纳哥
    COUNTRY_LIE = 53,  //Liechtenstein 列支敦士登
    COUNTRY_SMO = 54,  //San Marino 圣马力诺
    COUNTRY_ORN = 55,  //Aland 奥兰(芬兰自治区)
    COUNTRY_RES2 = 56,  //保留字段
    COUNTRY_RES3 = 57,  //保留字段
    COUNTRY_RES4 = 58,  //保留字段
    //亚洲 48个国家 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
    COUNTRY_CHI = 59,  //China 中国
    COUNTRY_IBN = 60,  //In bahrain 巴林
    COUNTRY_SKR = 61,  //South Korea 韩国
    COUNTRY_LEB = 62,  //Lebanon 黎巴嫩
    COUNTRY_NEP = 63,  //Nepal 尼泊尔
    COUNTRY_THA = 64,  //Thailand 泰国
    COUNTRY_PAK = 65,  //Pakistan 巴基斯坦
    COUNTRY_EMI = 66,  //The united Arab emirates 阿拉伯联合酋长国
    COUNTRY_BHU = 67,  //Bhutan 不丹
    COUNTRY_OMA = 68,  //Oman 阿曼
    COUNTRY_KOR = 69,  //North Korea 朝鲜
    COUNTRY_PHI = 70,  //The Philippines 菲律宾
    COUNTRY_CAM = 71,  //Cambodia 柬埔寨
    COUNTRY_QAT = 72,  //Qatar 卡塔尔
    COUNTRY_KYR = 73,  //Kyrgyzstan 吉尔吉斯斯坦
    COUNTRY_MAL = 74,  //The maldives 马尔代夫
    COUNTRY_MLY = 75,  //Malaysia 马来西亚
    COUNTRY_MOG = 76,  //Mongolia 蒙古
    COUNTRY_ARA = 77,  //Saudi Arabia 沙特阿拉伯
    COUNTRY_BRU = 78,  //brunei 文莱
    COUNTRY_LAO = 79,  //Laos 老挝
    COUNTRY_JAP = 80,  //Japan 日本
    COUNTRY_RES19 = 81,  //保留字段
    COUNTRY_PAS = 82,  //Palestinian state 巴勒斯坦国
    COUNTRY_TAJ = 83,  //Tajikistan 塔吉克斯坦
    COUNTRY_KUW = 84,  //Kuwait 科威特
    COUNTRY_SYR = 85,  //Syria 叙利亚
    COUNTRY_IND = 86,  //India 印度
    COUNTRY_ISA = 87,  //Indonesia 印度尼西亚
    COUNTRY_AFG = 88,  //Afghanistan 阿富汗
    COUNTRY_LAN = 89,  //Sri Lanka 斯里兰卡
    COUNTRY_IRQ = 90,  //Iraq 伊拉克
    COUNTRY_VIE = 91,  //Vietnam 越南
    COUNTRY_IRA = 92,  //Iran 伊朗
    COUNTRY_YEM = 93,  //yemen 也门
    COUNTRY_JOR = 94,  //Jordan 约旦
    COUNTRY_BUR = 95,  //Burma 缅甸
    COUNTRY_SIK = 96,  //Sikkim 锡金
    COUNTRY_BAN = 97,  //Bangladesh 孟加拉国
    COUNTRY_SGA = 98,  //Singapore 新加坡
    COUNTRY_EAT = 99,  //East timor 东帝汶（已宣布独立，但世界上许多国家不承认）
    COUNTRY_RES5 = 100,  //保留字段
    COUNTRY_RES6 = 101,  //保留字段
    COUNTRY_RES7 = 102,  //保留字段
    COUNTRY_RES8 = 103,  //保留字段
    //非洲 60个国家和地区
    COUNTRY_EGT = 104,  //Egypt 埃及
    COUNTRY_LIY = 105,  //Libya 利比亚
    COUNTRY_SUA = 106,  //Sudan 苏丹
    COUNTRY_TUN = 107,  //Tunisia 突尼斯
    COUNTRY_ALG = 108,  //Algeria 阿尔及利亚
    COUNTRY_MCC = 109,  //Morocco 摩洛哥
    COUNTRY_ETH = 110,  //Ethiopia 埃塞俄比亚
    COUNTRY_ERI = 111,  //Eritrea 厄立特里亚
    COUNTRY_SDE = 112,  //Somalia Democratic 索马里
    COUNTRY_DJI = 113,  //Djibouti 吉布提
    COUNTRY_KEN = 114,  //Kenya 肯尼亚
    COUNTRY_TAI = 115,  //Tanzania 坦桑尼亚
    COUNTRY_UGA = 116,  //Uganda 乌干达
    COUNTRY_RWA = 117,  //Rwanda 卢旺达
    COUNTRY_BUD = 118,  //Burundi 布隆迪
    COUNTRY_SEY = 119,  //Seychelles 塞舌尔
    COUNTRY_CHA = 120,  //Chad 乍得
    COUNTRY_CEA = 121,  //Central African 中非
    COUNTRY_CON = 122,  //Cameroon 喀麦隆
    COUNTRY_EQG = 123,  //Equatorial Guinea赤道几内亚
    COUNTRY_GAB = 124,  //Gabon 加蓬
    COUNTRY_TCO = 125,  //the Congo 刚果共和国（即：刚果（布））
    COUNTRY_DRC = 126,  //Democratic Republic of the Congo 刚果民主共和国（即：刚果（金））
    COUNTRY_STP = 127,  //Sao Tome and Principe 圣多美和普林西比
    COUNTRY_MAN = 128,  //Mauritania 毛里塔尼亚
    COUNTRY_WSA = 129,  //Western Sahara 西撒哈拉（撒拉威）
    COUNTRY_SEL = 130,  //Senegal 塞内加尔
    COUNTRY_TGA = 131,  //the Gambia 冈比亚
    COUNTRY_MAI = 132,  //Mali 马里
    COUNTRY_BUF = 133,  //Burkina Faso 布基纳法索
    COUNTRY_GUI = 134,  //Guinea 几内亚
    COUNTRY_GUB = 135,  //Guinea-Bissau 几内亚比绍
    COUNTRY_CAV = 136,  //Cape Verde 佛得角
    COUNTRY_SLE = 137,  //Sierra Leone 塞拉利昂
    COUNTRY_LIR = 138,  //Liberia 利比里亚
    COUNTRY_IVC = 139,  //Ivory Coast 科特迪瓦
    COUNTRY_GHA = 140,  //Ghana 加纳
    COUNTRY_TGO = 141,  //Togo 多哥
    COUNTRY_BEN = 142,  //Benin 贝宁
    COUNTRY_NIG = 143,  //Niger 尼日尔
    COUNTRY_ZAB = 144,  //Zambia 赞比亚
    COUNTRY_ANG = 145,  //Angola 安哥拉
    COUNTRY_ZBE = 146,  //Zimbabwe 津巴布韦
    COUNTRY_MAW = 147,  //Malawi 马拉维
    COUNTRY_MOQ = 148,  //Mozambique 莫桑比克
    COUNTRY_BOT = 149,  //Botswana 博茨瓦纳
    COUNTRY_NAM = 150,  //Namibia 纳米比亚
    COUNTRY_SAF = 151,  //South Africa 南非
    COUNTRY_SWD = 152,  //Swaziland 斯威士兰
    COUNTRY_LES = 153,  //Lesotho 莱索托
    COUNTRY_MAG = 154,  //Madagasca 马达加斯加
    COUNTRY_UOC = 155,  //Union of Comoros 科摩罗
    COUNTRY_MAT = 156,  //Mauritius 毛里求斯
    COUNTRY_NGE = 157,  //Nigeria 尼日利亚
    COUNTRY_SSD = 158,  //South Sudan 南苏丹
    COUNTRY_SAH = 159,  //Saint Helena 圣赫勒拿（英国海外省）
    COUNTRY_MYT = 160,  //Mayotte 马约特（法国海外省）
    COUNTRY_REN = 161,  //Reunion 留尼旺（法国海外省）
    COUNTRY_CAI = 162,  //Canary Islands 加那利群岛（西班牙海外领土）
    COUNTRY_AZO = 163,  //AZORES 亚速尔群岛（北大西洋非洲西海岸（葡萄牙））
    COUNTRY_MAD = 164,  //Madeira 马德拉群岛（北大西洋非洲西海岸（葡萄牙））
    COUNTRY_RES9 = 165,  //保留字段
    COUNTRY_RES10 = 166,  //保留字段
    COUNTRY_RES11 = 167,  //保留字段
    COUNTRY_RES12 = 168,  //保留字段
    //美洲 55个国家和地区
    COUNTRY_CAD = 169,  //Canada 加拿大
    COUNTRY_GRE = 170,  //Greenland Nuuk 格陵兰（丹麦王国的海外自治领土）
    COUNTRY_PIE = 171,  //Pierre and Miquelon 圣皮埃尔和密克隆（法国海外领土）
    COUNTRY_USA = 172,  //United States 美国
    COUNTRY_BER = 173,  //Bermuda 百慕大（英国海外领土）
    COUNTRY_MEX = 174,  //Mexico 墨西哥
    COUNTRY_GUA = 175,  //Guatemala 危地马拉
    COUNTRY_BLI = 176,  //Belize 伯利兹
    COUNTRY_SAR = 177,  //El Salvador 萨尔瓦多
    COUNTRY_HOR = 178,  //Honduras 洪都拉斯
    COUNTRY_NIC = 179,  //Nicaragua 尼加拉瓜
    COUNTRY_COR = 180,  //Costa Rica 哥斯达黎加
    COUNTRY_PAN = 181,  //Panama 巴拿马
    COUNTRY_TBM = 182,  //The Bahamas 巴哈马
    COUNTRY_TCI = 183,  //The Turks and Caicos Islands 特克斯群岛和凯科斯群岛（英国海外领土）
    COUNTRY_CUB = 184,  //Cuba 古巴
    COUNTRY_JAM = 185,  //Jamaica 牙买加
    COUNTRY_CAY = 186,  //Cayman Islands 开曼群岛（英国海外领土）
    COUNTRY_HAT = 187,  //Haiti 海地
    COUNTRY_TDO = 188,  //The Dominican 多米尼加
    COUNTRY_PUR = 189,  //Puerto Rico 波多黎各（美国海外领土）
    COUNTRY_VIL = 190,  //The United States Virgin Islands美属维尔京群岛
    COUNTRY_BVI = 191,  //The British Virgin Islands 英属维尔京群岛
    COUNTRY_ATV = 192,  //Anguilla The Valley 安圭拉（英国海外领土）
    COUNTRY_ANB = 193,  //Antigua and Barbuda 安提瓜和巴布达
    COUNTRY_CSM = 194,  //Collectivité de Saint-Martin 法属圣马丁（法国海外领土）
    COUNTRY_ACY = 195,  //Autonomous country 荷属圣马丁（荷兰王国的自治国 ）
    COUNTRY_SBY = 196,  //Saint-Barthélemy 圣巴泰勒米岛（法国海外领土）
    COUNTRY_SKN = 197,  //Saint Kitts and Nevis 圣基茨和尼维斯
    COUNTRY_MOT = 198,  //Montserrat 蒙特塞拉特（英国海外领土）
    COUNTRY_GLP = 199,  //Guadeloupe 瓜德罗普（法国海外领土）
    COUNTRY_DOM = 200,  //Dominica 多米尼克
    COUNTRY_MTE = 201,  //Martinique 马提尼克（法国海外领土）
    COUNTRY_LUC = 202,  //St. Lucia 圣卢西亚
    COUNTRY_SVG = 203,  //Saint Vincent and the Grenadines 圣文森特和格林纳丁斯
    COUNTRY_GRD = 204,  //Grenada 格林纳达
    COUNTRY_BAR = 205,  //Barbados 巴巴多斯
    COUNTRY_TRT = 206,  //Trinidad and Tobago 特立尼达和多巴哥
    COUNTRY_CUR = 207,  //Cura?ao 库拉索（荷兰王国的一个自治国）
    COUNTRY_ARB = 208,  //Aruba 阿鲁巴（荷兰王国的一个自治国）
    COUNTRY_NEA = 209,  //Netherlands Antilles 荷属安的列斯
    COUNTRY_COL = 210,  //Colombia 哥伦比亚
    COUNTRY_VEN = 211,  //Venezuela 委内瑞拉
    COUNTRY_GUY = 212,  //Guyana 圭亚那
    COUNTRY_SUR = 213,  //Suriname 苏里南
    COUNTRY_FRN = 214,  //Guyane Francaise 法属圭亚那
    COUNTRY_ECU = 215,  //Ecuador 厄瓜多尔
    COUNTRY_PER = 216,  //Peru 秘鲁
    COUNTRY_BOL = 217,  //Bolivia 玻利维亚
    COUNTRY_PAR = 218,  //Paraguay 巴拉圭
    COUNTRY_CLE = 219,  //Chile 智利
    COUNTRY_BRA = 220,  //Brazil 巴西
    COUNTRY_UGY = 221,  //Uruguay 乌拉圭
    COUNTRY_ARG = 222,  //Argentina 阿根廷
    COUNTRY_RES13 = 223,  //保留字段
    COUNTRY_RES14 = 224,  //保留字段
    COUNTRY_RES15 = 225,  //保留字段
    COUNTRY_RES16 = 226,  //保留字段
    //大洋洲 25个国家和地区 
    COUNTRY_ATN = 227,  //Australien 澳大利亚
    COUNTRY_NED = 228,  //Neuseeland 新西兰
    COUNTRY_PNG = 229,  //Papua New Guinea 巴布亚新几内亚
    COUNTRY_SAN = 230,  //Salomonen 所罗门群岛
    COUNTRY_VAU = 231,  //Vanuatu 瓦努阿图
    COUNTRY_NCN = 232,  //New Caledonia 新喀里多尼亚（法国的海外属地）
    COUNTRY_PAU = 233,  //Palau 帕劳
    COUNTRY_FSM = 234,  //Federated States of Micronesia 密克罗尼西亚联邦
    COUNTRY_MRI = 235,  //Marshall Island  马绍尔群岛
    COUNTRY_CNM = 236,  //Commonwealth of the Northern Mariana Islands 北马里亚纳群岛（美国的海外属地）
    COUNTRY_TEG = 237,  //The Territory of Guahan 关岛（美国的海外属地）
    COUNTRY_NUR = 238,  //Nauru 瑙鲁
    COUNTRY_KIB = 239,  //Kiribati 基里巴斯
    COUNTRY_FID = 240,  //Fidschi 斐济群岛
    COUNTRY_TNG = 241,  //Tonga 汤加
    COUNTRY_TUV = 242,  //Tuvalu 图瓦卢
    COUNTRY_WEF = 243,  //Wallis et Futuna  瓦利斯和富图纳（法国的海外属地）
    COUNTRY_TIS = 244,  //The Independent State of Samoa 萨摩亚
    COUNTRY_EAS = 245,  //Eastern Samoa 美属萨摩亚
    COUNTRY_TOE = 246,  //Tokelau 托克劳（新西兰）
    COUNTRY_NUE = 247,  //Niue 纽埃（新西兰）
    COUNTRY_TCD = 248,  //The Cook Islands 库克群岛（新西兰）
    COUNTRY_PFP = 249,  //Polynésie fran?aiseFrench Polynesia 法属波利尼西亚
    COUNTRY_PID = 250,  //Pitcairn Islands 皮特凯恩群岛（英国的海外属地）
    COUNTRY_HAW = 251,  //Hawaii State 夏威夷（美国的海外属地）
    COUNTRY_RES17 = 252,  //保留字段
    COUNTRY_INVALID = $fd,  //字段无效，需要使用扩展字段CRIndex(_CR_INDEX_)
    COUNTRY_UNRECOGNIZED = $fe,  //Unrecognized 无法识别
    COUNTRY_ALL = $ff  //ALL  全部
  );

// 国家 / 区域枚举
type
  CR_INDEX =  
  (  
    CR_NONSUPPORT = 0,  //0-算法库不支持牌识国家
    //五大洲 一共有235国家和地区 
    //欧洲 48个国家和地区 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
    CR_CZE = 1,  //Czech Republic 捷克共和国
    CR_FRA = 2,  //France 法国
    CR_DEU = 3,  //Germany 德国
    CR_ESP = 4,  //Spain 西班牙
    CR_ITA = 5,  //Italy 意大利
    CR_NLD = 6,  //Netherlands 荷兰
    CR_POL = 7,  //Poland 波兰
    CR_SVK = 8,  //Slovakia 斯洛伐克
    CR_BLR = 9,  //Belarus 白俄罗斯
    CR_MDA = 10,  //Moldova 摩尔多瓦
    CR_RUS = 11,  //Russia 俄罗斯
    CR_UKR = 12,  //Ukraine 乌克兰
    CR_BEL = 13,  //Belgium 比利时
    CR_BGR = 14,  //Bulgaria 保加利亚
    CR_DNK = 15,  //Denmark 丹麦
    CR_FIN = 16,  //Finland 芬兰
    CR_GBR = 17,  //United Kingdom 英国
    CR_GRC = 18,  //Greece 希腊
    CR_HRV = 19,  //Croatia 克罗地亚
    CR_HUN = 20,  //Hungary 匈牙利
    CR_ISR = 21,  //Israel 以色列(亚洲)
    CR_LUX = 22,  //Luxembourg 卢森堡
    CR_MKD = 23,  //Macedonia 马其顿共和国
    CR_NOR = 24,  //Norway  挪威
    CR_PRT = 25,  //Portuga 葡萄牙
    CR_ROU = 26,  //Romania 罗马尼亚
    CR_SRB = 27,  //Serbia 塞尔维亚
    CR_AZE = 28,  //Azerbaijan 阿塞邦疆共和国(亚洲)
    CR_GEO = 29,  //Georgia  格鲁吉亚(亚洲)
    CR_KAZ = 30,  //Kazakhstan 哈萨克斯坦(亚洲)
    CR_LTU = 31,  //Lithuania 立陶宛共和国
    CR_TKM = 32,  //Turkmenistan 土库曼斯坦(亚洲)
    CR_UZB = 33,  //Uzbekistan 乌兹别克斯坦(亚洲)
    CR_LVA = 34,  //Latvia 拉脱维亚
    CR_EST = 35,  //Estonia 爱沙尼亚
    CR_ALB = 36,  //Albania 阿尔巴尼亚
    CR_AUT = 37,  //Austria 奥地利
    CR_BIH = 38,  //Bosnia and Herzegovina 波斯尼亚和黑塞哥维那
    CR_IRL = 39,  //Ireland 爱尔兰
    CR_ISL = 40,  //Iceland 冰岛
    CR_VAT = 41,  //Vatican 梵蒂冈
    CR_MLT = 42,  //Malta 马耳他
    CR_SWE = 43,  //Sweden 瑞典
    CR_CHE = 44,  //Switzerland 瑞士
    CR_CYP = 45,  //Cyprus 塞浦路斯
    CR_TUR = 46,  //Turkey 土耳其
    CR_SVN = 47,  //Slovenia 斯洛文尼亚
    CR_MTG = 48,  //Montenegro 黑山共和国
    CR_KOV = 49,  //Kosovo 科索沃
    CR_ADR = 50,  //Andorra 安道尔
    CR_ARM = 51,  //Armenia 亚美尼亚(亚洲)
    CR_MON = 52,  //Monaco 摩纳哥
    CR_LIE = 53,  //Liechtenstein 列支敦士登
    CR_SMO = 54,  //San Marino 圣马力诺
    CR_ORN = 55,  //Aland 奥兰(芬兰自治区)
    CR_RES2 = 56,  //保留字段
    CR_RES3 = 57,  //保留字段
    CR_RES4 = 58,  //保留字段
    //亚洲 48个国家 其中 塞浦路斯(Cyprus)属于亚欧两洲交界国家
    CR_CHI = 59,  //China 中国
    CR_IBN = 60,  //In bahrain 巴林
    CR_SKR = 61,  //South Korea 韩国
    CR_LEB = 62,  //Lebanon 黎巴嫩
    CR_NEP = 63,  //Nepal 尼泊尔
    CR_THA = 64,  //Thailand 泰国
    CR_PAK = 65,  //Pakistan 巴基斯坦
    CR_EMI = 66,  //The united Arab emirates 阿拉伯联合酋长国
    CR_BHU = 67,  //Bhutan 不丹
    CR_OMA = 68,  //Oman 阿曼
    CR_KOR = 69,  //North Korea 朝鲜
    CR_PHI = 70,  //The Philippines 菲律宾
    CR_CAM = 71,  //Cambodia 柬埔寨
    CR_QAT = 72,  //Qatar 卡塔尔
    CR_KYR = 73,  //Kyrgyzstan 吉尔吉斯斯坦
    CR_MAL = 74,  //The maldives 马尔代夫
    CR_MLY = 75,  //Malaysia 马来西亚
    CR_MOG = 76,  //Mongolia 蒙古
    CR_ARA = 77,  //Saudi Arabia 沙特阿拉伯
    CR_BRU = 78,  //brunei 文莱
    CR_LAO = 79,  //Laos 老挝
    CR_JAP = 80,  //Japan 日本
    CR_RES19 = 81,  //保留字段
    CR_PAS = 82,  //Palestinian state 巴勒斯坦国
    CR_TAJ = 83,  //Tajikistan 塔吉克斯坦
    CR_KUW = 84,  //Kuwait 科威特
    CR_SYR = 85,  //Syria 叙利亚
    CR_IND = 86,  //India 印度
    CR_ISA = 87,  //Indonesia 印度尼西亚
    CR_AFG = 88,  //Afghanistan 阿富汗
    CR_LAN = 89,  //Sri Lanka 斯里兰卡
    CR_IRQ = 90,  //Iraq 伊拉克
    CR_VIE = 91,  //Vietnam 越南
    CR_IRA = 92,  //Iran 伊朗
    CR_YEM = 93,  //yemen 也门
    CR_JOR = 94,  //Jordan 约旦
    CR_BUR = 95,  //Burma 缅甸
    CR_SIK = 96,  //Sikkim 锡金
    CR_BAN = 97,  //Bangladesh 孟加拉国
    CR_SGA = 98,  //Singapore 新加坡
    CR_EAT = 99,  //East timor 东帝汶（已宣布独立，但世界上许多国家不承认）
    CR_RES5 = 100,  //保留字段
    CR_RES6 = 101,  //保留字段
    CR_RES7 = 102,  //保留字段
    CR_RES8 = 103,  //保留字段
    //非洲 60个国家和地区
    CR_EGT = 104,  //Egypt 埃及
    CR_LIY = 105,  //Libya 利比亚
    CR_SUA = 106,  //Sudan 苏丹
    CR_TUN = 107,  //Tunisia 突尼斯
    CR_ALG = 108,  //Algeria 阿尔及利亚
    CR_MCC = 109,  //Morocco 摩洛哥
    CR_ETH = 110,  //Ethiopia 埃塞俄比亚
    CR_ERI = 111,  //Eritrea 厄立特里亚
    CR_SDE = 112,  //Somalia Democratic 索马里
    CR_DJI = 113,  //Djibouti 吉布提
    CR_KEN = 114,  //Kenya 肯尼亚
    CR_TAI = 115,  //Tanzania 坦桑尼亚
    CR_UGA = 116,  //Uganda 乌干达
    CR_RWA = 117,  //Rwanda 卢旺达
    CR_BUD = 118,  //Burundi 布隆迪
    CR_SEY = 119,  //Seychelles 塞舌尔
    CR_CHA = 120,  //Chad 乍得
    CR_CEA = 121,  //Central African 中非
    CR_CON = 122,  //Cameroon 喀麦隆
    CR_EQG = 123,  //Equatorial Guinea赤道几内亚
    CR_GAB = 124,  //Gabon 加蓬
    CR_TCO = 125,  //the Congo 刚果共和国（即：刚果（布））
    CR_DRC = 126,  //Democratic Republic of the Congo 刚果民主共和国（即：刚果（金））
    CR_STP = 127,  //Sao Tome and Principe 圣多美和普林西比
    CR_MAN = 128,  //Mauritania 毛里塔尼亚
    CR_WSA = 129,  //Western Sahara 西撒哈拉（撒拉威）
    CR_SEL = 130,  //Senegal 塞内加尔
    CR_TGA = 131,  //the Gambia 冈比亚
    CR_MAI = 132,  //Mali 马里
    CR_BUF = 133,  //Burkina Faso 布基纳法索
    CR_GUI = 134,  //Guinea 几内亚
    CR_GUB = 135,  //Guinea-Bissau 几内亚比绍
    CR_CAV = 136,  //Cape Verde 佛得角
    CR_SLE = 137,  //Sierra Leone 塞拉利昂
    CR_LIR = 138,  //Liberia 利比里亚
    CR_IVC = 139,  //Ivory Coast 科特迪瓦
    CR_GHA = 140,  //Ghana 加纳
    CR_TGO = 141,  //Togo 多哥
    CR_BEN = 142,  //Benin 贝宁
    CR_NIG = 143,  //Niger 尼日尔
    CR_ZAB = 144,  //Zambia 赞比亚
    CR_ANG = 145,  //Angola 安哥拉
    CR_ZBE = 146,  //Zimbabwe 津巴布韦
    CR_MAW = 147,  //Malawi 马拉维
    CR_MOQ = 148,  //Mozambique 莫桑比克
    CR_BOT = 149,  //Botswana 博茨瓦纳
    CR_NAM = 150,  //Namibia 纳米比亚
    CR_SAF = 151,  //South Africa 南非
    CR_SWD = 152,  //Swaziland 斯威士兰
    CR_LES = 153,  //Lesotho 莱索托
    CR_MAG = 154,  //Madagasca 马达加斯加
    CR_UOC = 155,  //Union of Comoros 科摩罗
    CR_MAT = 156,  //Mauritius 毛里求斯
    CR_NGE = 157,  //Nigeria 尼日利亚
    CR_SSD = 158,  //South Sudan 南苏丹
    CR_SAH = 159,  //Saint Helena 圣赫勒拿（英国海外省）
    CR_MYT = 160,  //Mayotte 马约特（法国海外省）
    CR_REN = 161,  //Reunion 留尼旺（法国海外省）
    CR_CAI = 162,  //Canary Islands 加那利群岛（西班牙海外领土）
    CR_AZO = 163,  //AZORES 亚速尔群岛（北大西洋非洲西海岸（葡萄牙））
    CR_MAD = 164,  //Madeira 马德拉群岛（北大西洋非洲西海岸（葡萄牙））
    CR_RES9 = 165,  //保留字段
    CR_RES10 = 166,  //保留字段
    CR_RES11 = 167,  //保留字段
    CR_RES12 = 168,  //保留字段
    //美洲 55个国家和地区
    CR_CAD = 169,  //Canada 加拿大
    CR_GRE = 170,  //Greenland Nuuk 格陵兰（丹麦王国的海外自治领土）
    CR_PIE = 171,  //Pierre and Miquelon 圣皮埃尔和密克隆（法国海外领土）
    CR_USA = 172,  //United States 美国
    CR_BER = 173,  //Bermuda 百慕大（英国海外领土）
    CR_MEX = 174,  //Mexico 墨西哥
    CR_GUA = 175,  //Guatemala 危地马拉
    CR_BLI = 176,  //Belize 伯利兹
    CR_SAR = 177,  //El Salvador 萨尔瓦多
    CR_HOR = 178,  //Honduras 洪都拉斯
    CR_NIC = 179,  //Nicaragua 尼加拉瓜
    CR_COR = 180,  //Costa Rica 哥斯达黎加
    CR_PAN = 181,  //Panama 巴拿马
    CR_TBM = 182,  //The Bahamas 巴哈马
    CR_TCI = 183,  //The Turks and Caicos Islands 特克斯群岛和凯科斯群岛（英国海外领土）
    CR_CUB = 184,  //Cuba 古巴
    CR_JAM = 185,  //Jamaica 牙买加
    CR_CAY = 186,  //Cayman Islands 开曼群岛（英国海外领土）
    CR_HAT = 187,  //Haiti 海地
    CR_TDO = 188,  //The Dominican 多米尼加
    CR_PUR = 189,  //Puerto Rico 波多黎各（美国海外领土）
    CR_VIL = 190,  //The United States Virgin Islands美属维尔京群岛
    CR_BVI = 191,  //The British Virgin Islands 英属维尔京群岛
    CR_ATV = 192,  //Anguilla The Valley 安圭拉（英国海外领土）
    CR_ANB = 193,  //Antigua and Barbuda 安提瓜和巴布达
    CR_CSM = 194,  //Collectivité de Saint-Martin 法属圣马丁（法国海外领土）
    CR_ACY = 195,  //Autonomous country 荷属圣马丁（荷兰王国的自治国 ）
    CR_SBY = 196,  //Saint-Barthélemy 圣巴泰勒米岛（法国海外领土）
    CR_SKN = 197,  //Saint Kitts and Nevis 圣基茨和尼维斯
    CR_MOT = 198,  //Montserrat 蒙特塞拉特（英国海外领土）
    CR_GLP = 199,  //Guadeloupe 瓜德罗普（法国海外领土）
    CR_DOM = 200,  //Dominica 多米尼克
    CR_MTE = 201,  //Martinique 马提尼克（法国海外领土）
    CR_LUC = 202,  //St. Lucia 圣卢西亚
    CR_SVG = 203,  //Saint Vincent and the Grenadines 圣文森特和格林纳丁斯
    CR_GRD = 204,  //Grenada 格林纳达
    CR_BAR = 205,  //Barbados 巴巴多斯
    CR_TRT = 206,  //Trinidad and Tobago 特立尼达和多巴哥
    CR_CUR = 207,  //Cura?ao 库拉索（荷兰王国的一个自治国）
    CR_ARB = 208,  //Aruba 阿鲁巴（荷兰王国的一个自治国）
    CR_NEA = 209,  //Netherlands Antilles 荷属安的列斯
    CR_COL = 210,  //Colombia 哥伦比亚
    CR_VEN = 211,  //Venezuela 委内瑞拉
    CR_GUY = 212,  //Guyana 圭亚那
    CR_SUR = 213,  //Suriname 苏里南
    CR_FRN = 214,  //Guyane Francaise 法属圭亚那
    CR_ECU = 215,  //Ecuador 厄瓜多尔
    CR_PER = 216,  //Peru 秘鲁
    CR_BOL = 217,  //Bolivia 玻利维亚
    CR_PAR = 218,  //Paraguay 巴拉圭
    CR_CLE = 219,  //Chile 智利
    CR_BRA = 220,  //Brazil 巴西
    CR_UGY = 221,  //Uruguay 乌拉圭
    CR_ARG = 222,  //Argentina 阿根廷
    CR_RES13 = 223,  //保留字段
    CR_RES14 = 224,  //保留字段
    CR_RES15 = 225,  //保留字段
    CR_RES16 = 226,  //保留字段
    //大洋洲 25个国家和地区 
    CR_ATN = 227,  //Australien 澳大利亚
    CR_NED = 228,  //Neuseeland 新西兰
    CR_PNG = 229,  //Papua New Guinea 巴布亚新几内亚
    CR_SAN = 230,  //Salomonen 所罗门群岛
    CR_VAU = 231,  //Vanuatu 瓦努阿图
    CR_NCN = 232,  //New Caledonia 新喀里多尼亚（法国的海外属地）
    CR_PAU = 233,  //Palau 帕劳
    CR_FSM = 234,  //Federated States of Micronesia 密克罗尼西亚联邦
    CR_MRI = 235,  //Marshall Island  马绍尔群岛
    CR_CNM = 236,  //Commonwealth of the Northern Mariana Islands 北马里亚纳群岛（美国的海外属地）
    CR_TEG = 237,  //The Territory of Guahan 关岛（美国的海外属地）
    CR_NUR = 238,  //Nauru 瑙鲁
    CR_KIB = 239,  //Kiribati 基里巴斯
    CR_FID = 240,  //Fidschi 斐济群岛
    CR_TNG = 241,  //Tonga 汤加
    CR_TUV = 242,  //Tuvalu 图瓦卢
    CR_WEF = 243,  //Wallis et Futuna  瓦利斯和富图纳（法国的海外属地）
    CR_TIS = 244,  //The Independent State of Samoa 萨摩亚
    CR_EAS = 245,  //Eastern Samoa 美属萨摩亚
    CR_TOE = 246,  //Tokelau 托克劳（新西兰）
    CR_NUE = 247,  //Niue 纽埃（新西兰）
    CR_TCD = 248,  //The Cook Islands 库克群岛（新西兰）
    CR_PFP = 249,  //Polynésie fran?aiseFrench Polynesia 法属波利尼西亚
    CR_PID = 250,  //Pitcairn Islands 皮特凯恩群岛（英国的海外属地）
    CR_HAW = 251,  //Hawaii State 夏威夷（美国的海外属地）
    CR_RES17 = 252,  //保留字段
    CR_RES18 = 253,  //保留字段
    CR_UNRECOGNIZED = $fe,  //Unrecognized 无法识别
    CR_ALL = $ff,  //ALL  全部

    //下面是新增的区域
    CR_TAIWAN = 256  //Taiwan(China) 台湾（中国）
  );

//阿拉伯联合酋长国区域枚举
type
  EMI_AREA =  
  (  
    EMI_AREA_UNKNOWN = 0,  //不支持区域识别
    EMI_AREA_AD,  //阿布扎比
    EMI_AREA_FJR,  //富查伊哈
    EMI_AREA_DB,  //迪拜
    EMI_AREA_RAK,  //哈伊马角
    EMI_AREA_AM,  //阿治曼
    EMI_AREA_SJ,  //沙迦
    EMI_AREA_UMW,  //乌姆盖万
    EMI_AREA_OTHER = $ff  //未识别（但是设备支持该算法，由于环境等原因导致未识别）
  );

type
  NET_DVR_FIND_PICTURE_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    lChannel: LONG;  // 通道号
    { 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
    3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
    9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
    0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
    0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
    0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
    0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
    0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
    0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警,
    0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,
    0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,
    0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,
    0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,
    0x36-人员密度（人数预警）,0x37-离岗检测,0x38-人数异常检测,
    0x39-剧烈运动检测, 0x3a-违停, 0x3b-逆行,0x3c-压线,0x3d-机占非,0x3e-变道,0x3f-掉头,0x40-行人检测,0x41-路障,
    0x42-抛洒物,0x43-浓雾检测,0x44-施工,0x45-拥堵,0x46-交通事故检测, 0x47-侧方停车，0x48-手动触发报警,
    0x49-玩手机检测,0x4b-司机驾驶行为,0x4c-高级辅助驾驶,0x4d-挖沙船检测报警,
    0x52-排队检测人数,0x53-排队检测时长,0x54-车辆布防(包括手动布防，日常布防以及平台布防), 0x55-定时唤醒抓拍, 0x56-废气排放显示,
    0x57-灰度报警, 0x58-振动侦测,0x59-人员奔跑,0x5a-人员滞留,0x5b-间距异常,0x5c-人员倒地,0x5d-抽烟检测,0x5e-卡口,0x5f-闯禁令,
    0x60-占用应急车道,0x61-大车占道,0x62-禁止名单,0x63-占用专用车道,0x64-烟雾检测,0x65-ReID,0x66-通道定时抓图事件,
    0x67-AI开放平台事件,0x68-甲烷检测浓度异常,0x69-甲烷检测光强异常,0x70-通道定时抓图,0x71-传感器事件,0x72-紫光电子检测,
    0x73-设备电源状态上报,0xff- 全部类型}
    byFileType: BYTE;  
    byNeedCard: BYTE;  // 是否需要卡号
                           {
                           0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
                           8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
                           15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
                           22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
                           29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
    }
    byProvince: BYTE;  //省份索引值
    byEventType: BYTE;  // 事件类型：0保留，1-交通事件；2-违章取证；3-其他事件
    sCardNum: array[0..CARDNUM_LEN_V30-1] of BYTE;  // 卡号
    struStartTime: NET_DVR_TIME;  //查找图片的开始时间
    struStopTime: NET_DVR_TIME;  // 查找图片的结束时间
    //ITC3.7 新增
    dwTrafficType: DWORD;  //图片检索生效项 参考 VCA_OPERATE _TYPE
    dwVehicleType: DWORD;  //车辆类型 参考 VCA_VEHICLE_TYPE
    //违规检测类型参考 VCA_ILLEGAL_TYPE 当前不支持复选
    dwIllegalType: DWORD;  
    byLaneNo: BYTE;  //车道号(1~99)
    bySubHvtType: BYTE;  //0-保留,1-机动车(机动车子类型中支持车牌检索，省份检索),2-非机动车,3-行人
    bySubDriveType: BYTE;  //驾驶子类型
    //当byFileType为0x4b-司机驾驶行为时，含义为司机驾驶行为类型，具体定义：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜、8-双手脱离方向盘、9-单手脱离方向盘、10-驾驶员身份异常、11-超时驾驶、12-驾驶员变更
    //当byFileType为0x4c-高级辅助驾驶时，含义为高级辅助驾驶类型，具体定义：0-保留、1-前向碰撞、2-车道偏离(左)、3-车道偏离(右)、4-车距过近、5-行人防撞、6-盲区检测(右后方)、7-盲区检测(左后方)、8-盲区检测(后方)
    byRes2: BYTE;  //保留字节
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    byRegion: BYTE;  // 区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS), 4-中东(Middle East),0xff-所有
    byCountry: BYTE;  // 国家索引值，参照：COUNTRY_INDEX
    byArea: BYTE;  //地区
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
  end;
  LPNET_DVR_FIND_PICTURE_PARAM = ^NET_DVR_FIND_PICTURE_PARAM;

//PC NVR的文件搜索条件
type
  NET_DVR_FILE_COND_PCNVR = record 
    dwSize: DWORD;  //结构体大小
    struIpAddr: NET_DVR_IPADDR;  //IP地址
    wIpPort: WORD;  //端口号
    byRes: array[0..2-1] of BYTE;  //保留字节
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //域名(暂时没用)
    sSerial: array[0..SERIALNO_LEN-1] of AnsiChar;  //序列号

    lChannel: DWORD;  //通道号
    dwFileType: DWORD;  //录象文件类型0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像
    dwIsLocked: DWORD;  //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    dwUseCardNo: DWORD;  //是否使用卡号
    sCardNumber: array[0..CARDNUM_LEN_V30-1] of BYTE;  //卡号
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
  end;
  LPNET_DVR_FILE_COND_PCNVR = ^NET_DVR_FILE_COND_PCNVR;

//PCNVR的录像搜索结果文件
type
  NET_DVR_FINDDATA_PCNVR = record 
    sFileName: array[0..100-1] of AnsiChar;  //文件名
    struStartTime: NET_DVR_TIME;  //文件的开始时间
    struStopTime: NET_DVR_TIME;  //文件的结束时间
    dwFileSize: DWORD;  //文件的大小
    sCardNum: array[0..CARDNUM_LEN_V30-1] of AnsiChar;  
    byLocked: BYTE;  //9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    byFileType: BYTE;  //文件类型
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_FINDDATA_PCNVR = ^NET_DVR_FINDDATA_PCNVR;

const
  PICTURE_NAME_LEN = 64;    
  PICTURE_INFO_MAX_SIZE = 640;    

type
  NET_DVR_FIND_PICTURE = record 
    sFileName: array[0..PICTURE_NAME_LEN-1] of AnsiChar;  //图片名
    struTime: NET_DVR_TIME;  //图片的时间
    dwFileSize: DWORD;  //图片的大小
    sCardNum: array[0..CARDNUM_LEN_V30-1] of AnsiChar;  //卡号
    byPlateColor: BYTE;  //参考结构 VCA_PLATE_COLOR
    byVehicleLogo: BYTE;  //参考结构 VLR_VEHICLE_CLASS
    byEventSearchStatus: BYTE;  //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    byRecogResult: BYTE;  //识别结果参考结构VTR_RESULT
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_FIND_PICTURE = ^NET_DVR_FIND_PICTURE;

const
  MAX_RECORD_PICTURE_NUM = 50;    //  最大备份图片张数

type
  NET_DVR_BACKUP_PICTURE_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    dwPicNum: DWORD;  
    struPicture: array[0..MAX_RECORD_PICTURE_NUM-1] of NET_DVR_FIND_PICTURE;  
    byDiskDes: array[0..DESC_LEN_32-1] of BYTE;  
    byWithPlayer: BYTE;  
    byContinue: BYTE;  //是否继续备份 0不继续 1继续
    byRes: array[0..34-1] of BYTE;  
  end;
  LPNET_DVR_BACKUP_PICTURE_PARAM = ^NET_DVR_BACKUP_PICTURE_PARAM;

type
  NET_DVR_COMPRESSION_LIMIT = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byCompressType: BYTE;  //待获取的压缩参数类型1,主码流2,子码流3,事件
    byRes: array[0..15-1] of BYTE;  //保留
    struCurrentCfg: NET_DVR_COMPRESSIONCFG_V30;  //当前压缩参数配置
  end;
  LPNET_DVR_COMPRESSION_LIMIT = ^NET_DVR_COMPRESSION_LIMIT;

const
  STEP_READY = 0;    //准备升级
  STEP_RECV_DATA = 1;    //接收升级包数据
  STEP_UPGRADE = 2;    //升级系统
  STEP_BACKUP = 3;    //备份系统
  STEP_SEARCH = 255;    //搜索升级文件

type
  NET_DVR_VIDEO_EFFECT = record 
    dwBrightValue: DWORD;  //亮度[0,255]
    dwContrastValue: DWORD;  //对比度[0,255]
    dwSaturationValue: DWORD;  //饱和度[0,255]
    dwHueValue: DWORD;  //色调[0,255]
    dwSharpness: DWORD;  //锐度[0,255]
    dwDenoising: DWORD;  //去噪[0,255]
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_VIDEO_EFFECT = ^NET_DVR_VIDEO_EFFECT;

type
  NET_DVR_VIDEO_INPUT_EFFECT = record 
    dwSize: DWORD;  //结构体大小
    wEffectMode: WORD;  //模式 0-标准 1-室内 2-弱光 3-室外  255-自定义
    byRes1: array[0..146-1] of BYTE;  //保留
    struVideoEffect: NET_DVR_VIDEO_EFFECT;  //视频效果参数
    byRes2: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INPUT_EFFECT = ^NET_DVR_VIDEO_INPUT_EFFECT;


type
  NET_DVR_VIDEOPARA_V40 = record 
    dwChannel: DWORD;  // 通道号
    dwVideoParamType: DWORD;  // 视频参数类型 0-亮度 1-对比度 2-饱和度 3-色度 4-锐度 5-去噪
    dwVideoParamValue: DWORD;  //对应的视频参数值，范围依据能力集
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOPARA_V40 = ^NET_DVR_VIDEOPARA_V40;

type
  NET_DVR_DEFAULT_VIDEO_COND = record 
    dwSize: DWORD;  // 结构体大小
    dwChannel: DWORD;  // 通道号
    dwVideoMode: DWORD;  // 模式
    byRes: array[0..32-1] of BYTE;  // 保留
  end;
  LPNET_DVR_DEFAULT_VIDEO_COND = ^NET_DVR_DEFAULT_VIDEO_COND;

type
  NET_DVR_ENCODE_JOINT_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    byJointed: BYTE;  //  0 没有关联 1 已经关联
    byDevType: BYTE;  // 被关联的设备类型  1 代表智能设备
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    struIP: NET_DVR_IPADDR;  // 关联的被取流设备IP地址
    wPort: WORD;  // 关联的被取流设备端口号
    wChannel: WORD;  // 关联的被取流设备通道号
    byRes2: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ENCODE_JOINT_PARAM = ^NET_DVR_ENCODE_JOINT_PARAM;

type
  NET_DVR_VCA_CHAN_WORKSTATUS = record 
    byJointed: BYTE;  // 0-没有关联  1-已经关联
    byRes1: array[0..3-1] of BYTE;  
    struIP: NET_DVR_IPADDR;  // 关联的取流设备IP地址
    wPort: WORD;  // 关联的取流设备端口号
    wChannel: WORD;  // 关联的取流设备通道号
    byVcaChanStatus: BYTE;  // 0 - 未启用 1 - 启用
    byRes2: array[0..19-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VCA_CHAN_WORKSTATUS = ^NET_DVR_VCA_CHAN_WORKSTATUS;

type
  NET_DVR_VCA_DEV_WORKSTATUS = record 
    dwSize: DWORD;  // 结构体大小
    byDeviceStatus: BYTE;  // 设备的状态0 - 正常工作 1- 不正常工作
    byCpuLoad: BYTE;  // CPU使用率0-100 分别代表使用百分率
    struVcaChanStatus: array[0..MAX_VCA_CHAN-1] of NET_DVR_VCA_CHAN_WORKSTATUS;  
    dwRes: array[0..40-1] of DWORD;  // 保留字节
  end;
  LPNET_DVR_VCA_DEV_WORKSTATUS = ^NET_DVR_VCA_DEV_WORKSTATUS;

type
  NET_DVR_VGA_DISP_CHAN_CFG_V40 = record 
    dwSize: DWORD;  
    byAudio: BYTE;  //音频是否开启
    byAudioWindowIdx: BYTE;  //音频开启子窗口
    byVgaResolution: BYTE;  //分辨率，从能力集获取
    byVedioFormat: BYTE;  //1:NTSC,2:PAL，0-NULL
    dwWindowMode: DWORD;  //画面模式，能力集获取
    byJoinDecChan: array[0..MAX_WINDOWS-1] of BYTE;  //各个子窗口关联的解码通道
    byEnlargeStatus: BYTE;  //是否处于放大状态，0：不放大，1：放大
    byEnlargeSubWindowIndex: BYTE;  //放大的子窗口号
    byScale: BYTE;  //显示模式，0---真实显示，1---缩放显示( 针对BNC )
    //区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
    byUnionType: BYTE;  
    struDiff: record 
      case Byte of
      0: (byRes: array[0..160-1] of BYTE);  
      1: (struVideoPlatform: record

            //各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)
        byJoinDecoderId: array[0..MAX_WINDOWS-1] of BYTE;  
            //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通
            //道都分配给此解码通道
        byDecResolution: BYTE;  
        byRes: array[0..143-1] of BYTE;  
      end);  
      2: (struNotVideoPlatform: record
        byRes: array[0..160-1] of BYTE;  
      end);  
    end;  
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_VGA_DISP_CHAN_CFG_V40 = ^NET_DVR_VGA_DISP_CHAN_CFG_V40;

type
  NET_DVR_V6SUBSYSTEMPARAM = record 
    bySerialTrans: BYTE;  //是否透传，0-否，1-是
    byRes: array[0..35-1] of BYTE;  
  end;
  LPNET_DVR_V6SUBSYSTEMPARAM = ^NET_DVR_V6SUBSYSTEMPARAM;




type
  NET_DVR_CORRECT_DEADPIXEL_PARAM = record 
    dwSize: DWORD;  
    dwCommand: DWORD;  //命令：0-进入坏点模式，1-添加坏点，2-保存坏点，3-退出坏点
    dwDeadPixelX: DWORD;  //坏点X坐标
    dwDeadPixelY: DWORD;  //坏点Y坐标
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_DVR_CORRECT_DEADPIXEL_PARAM = ^NET_DVR_CORRECT_DEADPIXEL_PARAM;

const
  MAX_REDAREA_NUM = 6;    //最大红绿灯区域个数

type
  NET_DVR_CORRECT_PARAMS = record 
    byYellowIntervalTime: BYTE;  //黄灯的间隔时间，单位是秒（s）
    byDigTrafficLight: BYTE;  //是否是交通数字黄灯，0-不是，1-是
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_CORRECT_PARAMS = ^NET_DVR_CORRECT_PARAMS;

type
  NET_DVR_REDAREACFG = record 
    dwSize: DWORD;  
    dwCorrectEnable: DWORD;  //是否开启校正功能，0-关闭，1-开启
    dwCorrectLevel: DWORD;  //校正级别，1(校正度最低)-10(校正度最高),默认为5
    dwAreaNum: DWORD;  //校正区域个数
    struLaneRect: array[0..MAX_REDAREA_NUM-1] of NET_VCA_RECT;  //校正区域
    struCorrectParam: array[0..MAX_REDAREA_NUM{6}-1] of NET_DVR_CORRECT_PARAMS;  //校正区域属性和校正区域对应
    byRes2: array[0..8-1] of BYTE;  //保留
  end;
  LPNET_DVR_REDAREACFG = ^NET_DVR_REDAREACFG;

type
  NET_DVR_HISTORICDATACFG = record 
    dwSize: DWORD;  
    dwTotalNum: DWORD;  //历史数据个数
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_HISTORICDATACFG = ^NET_DVR_HISTORICDATACFG;


const
  INQUEST_MESSAGE_LEN = 44;    //审讯重点标记信息长度
  INQUEST_MAX_ROOM_NUM = 2;    //最大审讯室个数
  MAX_RESUME_SEGMENT = 2;    //支持同时恢复的片段数目

type
  NET_DVR_INQUEST_ROOM = record 
    byRoomIndex: BYTE;  //审讯室编号
    byFileType: BYTE;  //0-审讯文件，1-开庭上传文件
    byMode: BYTE;  // 0 使用已有常规配置; 非0，按照mode值，  1-电影 2-画中画1  3-画中画2    4-双画面   5-三画面1   6-三画面2   7-四画面1   8-四画面2 
    byQuick: BYTE;  // 是否为快速配置， 1-快速配置（不配置参数到flash），0-常规配置（配置参数到Flash） ， 仅在mode 非 0 有效
    byRes: array[0..20-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_ROOM = ^NET_DVR_INQUEST_ROOM;

type
  NET_DVR_INQUEST_MESSAGE = record 
    sMessage: array[0..INQUEST_MESSAGE_LEN-1] of AnsiChar;  //重点标记信息
    byRes: array[0..46-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_MESSAGE = ^NET_DVR_INQUEST_MESSAGE;

type
  NET_DVR_INQUEST_SENSOR_DEVICE = record 
    wDeviceType: WORD;  //数据采集设备型号:0-无 1-米乐 2-镭彩 3-优力 4-佳盟 5-永控、6-垅上、7-维纳斯达
    wDeviceAddr: WORD;  //数据采集设备地址
    byRes: array[0..28-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_SENSOR_DEVICE = ^NET_DVR_INQUEST_SENSOR_DEVICE;

type
  NET_DVR_INQUEST_SENSOR_INFO = record 
    struSensorDevice: array[0..INQUEST_MAX_ROOM_NUM-1] of NET_DVR_INQUEST_SENSOR_DEVICE;  
    dwSupportPro: DWORD;  //支持协议类型,按位表示, 新版本走能力集，不再扩展此字段
    //0x1:米乐 0x2:镭彩 0x4:优力
    byRes: array[0..120-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_SENSOR_INFO = ^NET_DVR_INQUEST_SENSOR_INFO;

type
  NET_DVR_INQUEST_ROOM_INFO = record 
    szCDName: array[0..NAME_LEN-1] of AnsiChar;  //光盘名称，单室双刻光盘名称是一样的
    uCalcMode: record 
      case Byte of
      0: (byBitRate: BYTE);  // byCalcType为0时有效，(0-32、1-48、2-64、3-80、4-96、5-128、
                                //6-160、7-192、8-224、9-256、10-320、11-384、12-448、
                                //13-512、14-640、15-768、16-896前16个值保留)17-1024、18-1280、19-1536、
                                //20-1792、21-2048、22-3072、23-4096、24-8192
      1: (byInquestTime: BYTE);  // byCalcType为1时有效，0-1小时, 1-2小时,2-3小时,3-4小时, 4-6小时,5-8小时,6-10小时,7-12小时
        //8-16小时, 9-20小时,10-22小时,11-24小时
    end;  
    byCalcType: BYTE;  //刻录计算类型0-按码率 1-按时间
    byAutoDelRecord: BYTE;  // 是否自动删除录像，0-不删除，即结束时保存录像 1-删除
    byAlarmThreshold: BYTE;  // 声音报警阀值
    byInquestChannelResolution: BYTE;  //审讯通道分辨率，0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    byAutoOpenTray: BYTE;  //是否自动弹仓 0-否，1-是
    byCDPrintEnabled: BYTE;  //恢复完成后，是否使能光盘封面打印功能 0-否 1-开启
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_INQUEST_ROOM_INFO = ^NET_DVR_INQUEST_ROOM_INFO;

type
  NET_DVR_INQUEST_SYSTEM_INFO = record 
    dwRecordMode: DWORD;  //刻录模式:1 单室双刻模式 2 单室轮刻模式 3 双室双刻模式（修改需要重启设备）
    dwWorkMode: DWORD;  //工作模式:0 标准模式 1 通用模式(保留，目前只有标准模式)
    dwResolutionMode: DWORD;  //设备分辨率，0:标清 1:D1 2:720P 3:1080P（高清审讯机不用此字段）
    struSensorInfo: NET_DVR_INQUEST_SENSOR_INFO;  //温湿度传感器配置
    struInquestRoomInfo: array[0..INQUEST_MAX_ROOM_NUM-1] of NET_DVR_INQUEST_ROOM_INFO;  
    byEnableHashCheck: BYTE;  //是否启用对光盘数据HASH值校验 0-无意义，1-不启用，2-启用
    byEnableInitCD: BYTE;  //是否启用初始化光盘 0-无意义，1-不启用，2-启用
    byCDProcessingMode: BYTE;  //1.存盘模式 2-出盘模式 存盘模式：刻录完成的光盘归档到出盘桶上；刻录失败的光盘，机械臂将坏盘直接通过中间的出盘位置弹出。出盘模式：将刻录好的光盘从中间的出盘位置出盘，刻录失败的光盘放到出盘桶里
    byRes: array[0..21-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_SYSTEM_INFO = ^NET_DVR_INQUEST_SYSTEM_INFO;

type
  NET_DVR_INQUEST_ALARM = record 
    dwSize: DWORD;  
    dwAlarmType: DWORD;  //报警类型 0-光盘满 1-光盘错误 2-审讯超时提醒
    byTrayNo: BYTE;  //光驱号
    byRes: array[0..3-1] of BYTE;  
    dwInquestTime: DWORD;  //已审讯时间,当dwAlarmType=2时有效,单位:秒
    dwNotifyChannel: DWORD;  //审讯时间超时提醒通道号
    byRes1: array[0..244-1] of BYTE;  
  end;
  LPNET_DVR_INQUEST_ALARM = ^NET_DVR_INQUEST_ALARM;

type
  NET_DVR_VIDEO_PARKING_POLE_ALARM = record 
    dwSize: DWORD;  //结构体大小
    struTime: NET_DVR_TIME_V30;  //触发时间
    byParkingNum: array[0..32-1] of BYTE;  //车位编号
    byAlarmType: BYTE;  //报警类型，0-未知，1-镜头遮挡报警，2-按钮报警，3-非法占用报警，4-车位状态变化
    byVehicleEnterState: BYTE;  //车辆进入状态，0-未知，1-进入，2-离开
    byRes: array[0..78-1] of BYTE;  
  end;
  LPNET_DVR_VIDEO_PARKING_POLE_ALARM = ^NET_DVR_VIDEO_PARKING_POLE_ALARM;

type
  NET_DVR_INQUEST_RESUME_SEGMENT = record 
    struStartTime: NET_DVR_TIME;  //事件起始时间
    struStopTime: NET_DVR_TIME;  //事件终止时间
    byRoomIndex: BYTE;  //审讯室编号,从1开始
    byDriveIndex: BYTE;  //刻录机编号,从1开始
    wSegmetSize: WORD;  //本片断的大小, 单位M
    dwSegmentNo: DWORD;  //本片断在本次审讯中的序号,从1开始
    byRes: array[0..24-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_RESUME_SEGMENT = ^NET_DVR_INQUEST_RESUME_SEGMENT;

type
  NET_DVR_INQUEST_RESUME_EVENT = record 
    dwResumeNum: DWORD;  //需恢复的事件个数
    struResumeSegment: array[0..MAX_RESUME_SEGMENT-1] of NET_DVR_INQUEST_RESUME_SEGMENT;  
    byResumeMode: BYTE;  //恢复模式，0-单光盘恢复，1-双光盘恢复
    byCDPrintEnbled: BYTE;  //恢复完成后，是否使能光盘封面打印功能 0-否 1-开启
    byRes: array[0..198-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_RESUME_EVENT = ^NET_DVR_INQUEST_RESUME_EVENT;

type
  NET_DVR_INQUEST_DEVICE_VERSION = record 
    byMainVersion: BYTE;  {基线主版本.
                             0 : 未知
                             1 : 8000审讯DVR
                             次版本: 1 : 8000HD-S
                             2 : 8100审讯DVR
                             次版本: 1 : 审讯81SNL
                             2 : 审讯81SH
                             3 : 审讯81SFH
                             3 : 8608高清审讯机NVR
                             次版本: 1 : DS-8608SN-SP
                             2 : DS-8608SN-ST
}
    bySubVersion: BYTE;  //基线次版本
    byUpgradeVersion: BYTE;  //升级版本,未升级为0
    byCustomizeVersion: BYTE;  //定制版本,非定制为0
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_DEVICE_VERSION = ^NET_DVR_INQUEST_DEVICE_VERSION;

type
  NET_DVR_DISK_RAID_INFO = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //磁盘Raid是否禁用
    bySleepStatus: BYTE;  //0-无效， 1-休眠，2-不休眠
    byRes: array[0..34-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_DISK_RAID_INFO = ^NET_DVR_DISK_RAID_INFO;


type
  NET_DVR_SYNCHRONOUS_IPC = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用：为前端IPC同步设备参数
    byRes: array[0..7-1] of BYTE;  //保留
  end;
  LPNET_DVR_SYNCHRONOUS_IPC = ^NET_DVR_SYNCHRONOUS_IPC;

type
  NET_DVR_IPC_PASSWD = record 
    dwSize: DWORD;  //结构体大小
    sOldPasswd: array[0..PASSWD_LEN-1] of AnsiChar;  //IPC的旧密码，传给DVR让DVR验证
    sNewPasswd: array[0..PASSWD_LEN-1] of AnsiChar;  //IPC的新密码
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IPC_PASSWD = ^NET_DVR_IPC_PASSWD;

//通过获取DVR的网络状态：单位bps
type
  NET_DVR_DEVICE_NET_USING_INFO = record 
    dwSize: DWORD;  //结构体大小
    dwPreview: DWORD;  //预览
    dwPlayback: DWORD;  //回放
    dwIPCModule: DWORD;  //IPC接入
    dwNetDiskRW: DWORD;  //网盘读写
    res: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_NET_USING_INFO = ^NET_DVR_DEVICE_NET_USING_INFO;

//通过DVR设置前端IPC的IP地址
type
  NET_DVR_IPC_NETCFG = record 
    dwSize: DWORD;  //结构体大小
    struIP: NET_DVR_IPADDR;  //IPC的IP地址
    wPort: WORD;  //IPC的端口
    res: array[0..126-1] of AnsiChar;  
  end;
  LPNET_DVR_IPC_NETCFG = ^NET_DVR_IPC_NETCFG;

//按时间锁定
type
  NET_DVR_TIME_LOCK = record 
    dwSize: DWORD;  //结构体大小
    strBeginTime: NET_DVR_TIME;  
    strEndTime: NET_DVR_TIME;  
    dwChannel: DWORD;  //通道号, 0xff表示所有通道
    dwRecordType: DWORD;  //录像类型:  0xffffffff－全部，0－定时录像，1-移动侦测，2－报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，7-智能录像(同文件查找)
    dwLockDuration: DWORD;  //锁定持续时间,单位秒,0xffffffff表示永久锁定
    strUnlockTimePoint: NET_DVR_TIME_EX;  //加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_TIME_LOCK = ^NET_DVR_TIME_LOCK;

type
  NET_DVR_LOCK_RETURN = record 
    dwSize: DWORD;  //结构体大小
    strBeginTime: NET_DVR_TIME;  
    strEndTime: NET_DVR_TIME;  
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
    byRes: array[0..17-1] of BYTE;  
  end;
  LPNET_DVR_LOCK_RETURN = ^NET_DVR_LOCK_RETURN;

//67DVS
//证书下载类型
type
  NET_SDK_UPLOAD_TYPE =  
  (  
    UPGRADE_CERT_FILE = 0,  
    UPLOAD_CERT_FILE = 1,  
    TRIAL_CERT_FILE = 2,  
    CONFIGURATION_FILE = 3,  
    UPLOAD_RECORD_FILE = 4,  //上传录像文件
    SCENE_CONFIGURATION_FILE = 5,  //场景配置文件上传
    UPLOAD_PICTURE_FILE = 6,  //上传图片文件
    UPLOAD_VIOLATION_FILE = 7,  //上传违法字典文件
    UPLOAD_TG_FILE = 8,  //上传TG（Timing Generator）文件（用于T1测试）
    UPLOAD_DATA_TO_DB = 9,  //上传文件到视图库
    UPLOAD_BACKGROUND_PIC = 10,  //上传背景图片
    UPLOAD_CALIBRATION_FILE = 11,  //上传标定文件
    UPLOAD_TME_FILE = 12,  //上传出入口管理文件

    //UPLOAD_TME_FILE = 12, //上传出入口管理文件
    UPLOAD_VEHICLE_BLOCKALLOWLIST_FILE = 13,  
    UPLOAD_PICTURE_TO_CLOUD = 15,  //上传图片到云存储
    UPLOAD_VIDEO_FILE = 16,  //上传视频文件
    UPLOAD_SCREEN_FILE = 17,  //上传屏幕服务器文件
    UPLOAD_PUBLISH_MATERIAL = 18,  //上传信息发布静态素材文件
    UPLOAD_PUBLISH_UPGRADE_FILE = 19,  //上传信息发升级文件
    UPLOAD_RING_FILE = 20,  //上传铃音文件
    UPLOAD_ENCRYPT_CERT = 21,  //上传加密证书
    UPLOAD_THERMOMETRIC_FILE = 22,  //上传测温标定文件
    UPLOAD_SUBBRAND_FILE = 23,  //上传车辆子品牌文件
    UPLOAD_LED_CHECK_FILE = 24,  //上传LED校正文件
    BATCH_UPLOAD_PICTURE_FILE = 25,  //批量上传图片文件
    UPLOAD_EDID_CFG_FILE = 26,  //上传EDID配置文件
    UPLOAD_PANORAMIC_STITCH = 27,  //上传全景自动拼接配置文件
    UPLOAD_BINOCULAR_COUNTING = 28,  //上传垂直客流矫正表
    UPLOAD_AUDIO_FILE = 29,  //上传语音文件
    UPLOAD_PUBLISH_THIRD_PARTY_FILE = 30,  //上传第三方文件
    UPLOAD_DEEPEYES_BINOCULAR = 31,  //上传TX1双目矫正表
    UPLOAD_CERTIFICATE_BLOCKLIST = 32,  //上传身份证禁止名单
    UPLOAD_HD_CAMERA_CORRECT_TABLE = 33,  //上传2400W矫正表
    UPLOAD_FD_DATA = 35,  //导入人脸数据到人脸库
    UPLOAD_FACE_DATA = 36,  //导入人脸图片数据到人脸库
    UPLOAD_FACE_ANALYSIS_DATA = 37,  //导入图片数据到设备识别图片目标
    UPLOAD_FILEVOLUME_DATA = 38,  //上传文件卷数据文件(目前只有CVR中实现)
    IMPORT_DATA_TO_FACELIB = 39,  //导入人脸数据（人脸图片+图片附件信息 到设备人脸库）
    UPLOAD_LEFTEYE_4K_CALIBFILE = 40,  //左眼、4K相机标定内参数据上传（针对三目教育录播相机）
    UPLOAD_SECURITY_CFG_FILE = 41,  //配置文件安全导入
    UPLOAD_RIGHT_CONTROLLER_AUDIO = 42,  //上传权限控制器音频文件
    UPLOAD_MODBUS_CFG_FILE = 43,  //导入Modbus协议配置文件
    UPLOAD_NOTICE_VIDEO_DATA = 44,  //公告视频下发
    UPLOAD_RS485_PROTOCOL_DLL_FILE = 45,  //导入RS485协议动态库文件
    UPLOAD_PIC_BY_BUF = 46,  //按图片缓存导入图片文件
    UPLOAD_CLIENT_CALIBFILE = 47,  //客户标定文件导入(.pto格式文件)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W = 48,  //3200W矫正表(.cal格式文件)
    UPLOAD_DOOR_CONTENT = 49,  //上传单元门口联系人信息
    UPLOAD_ASR_CONTROL_FILE = 50,  //语音识别控制文件上传
    UPLOAD_APP_FILE = 51,  //上传HEOP APP文件
    UPLOAD_AI_ALGORITHM_MODEL = 52,  //AI开放平台，主动上传算法模型到设备
    UPLOAD_PUBLISH_PROGRAM_THUMBNAIL = 53,  //上传信息发布节目缩略图
    UPLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 54,  //上传信息发布模板缩略图
    UPLOAD_AI_PICTURE = 55,  //AI开放平台，图片任务，下发图片为二进制格式
    UPLOAD_OFFLINE_CAPTURE_INFO = 56,  //离线采集用户列表导入
    UPLOAD_FONT_TYPE_DLL_FILE = 57,  //字体库导入
    UPLOAD_CLIENT_CALIBFILE_FILE = 58,  //客户标定文件导入(.pto格式文件,带通道)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W_FILE = 59,  //3200W矫正表(.cal格式文件,带通道)
    IMPORT_DATA_TO_HBDLIB = 60,  //导入人体数据到人体库（人体图片+图片附件信息 到设备人体库）
    UPLOAD_SCENE_FILE = 61,  //导入场景文件
    UPLOAD_RATIOSTITCHING_FILE = 62,  // 导入倍率拼接文件
    UPLOAD_LENS_PARAM_FILE = 63,  // 导入镜头参数文件
    UPLOAD_CUSTOMAUDIO_FILE = 64,  //导入自定义音频素材文件
    UPLOAD_VIDEOWALL_MATERIAL_FILE = 65  //导入电视墙窗口素材文件
  );

type
  NET_SDK_DOWNLOAD_TYPE =  
  (  
    NET_SDK_DOWNLOAD_CERT = 0,  //下载证书
    NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,  //下载IPC配置文件
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2,  //下载基准场景图片
    NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3,  //下载VQD报警图片
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE = 4,  //下载配置文件
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5,  //下载场景配置文件
    NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,  //从视图库中下载
    // NET_SDK_DOWNLOAD_TME_FILE = 7  //下载出入口管理文件

    NET_SDK_DOWNLOAD_TME_FILE = 7,  //下载出入口管理文件
    NET_SDK_DOWNLOAD_VEHICLE_BLOCKALLOWLIST_FILE = 8,  //下载名单配置文件
    NET_SDK_DOWNLOAD_GUID_FILE = 9,  //下载GUID文件
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,  //从云存储下载图片
    NET_SDK_DOWNLOAD_PICTURE = 11,  //下载图片
    NET_SDK_DOWNLOAD_VIDEO = 12,  //下载视频
    NET_DVR_DOWNLOAD_SCREEN_FILE = 13,  //下载屏幕服务器文件
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL = 14,  //下载信息发布静态素材文件
    NET_SDK_DOWNLOAD_THERMOMETRIC_FILE = 15,  //下载测温标定文件
    NET_SDK_DOWNLOAD_LED_CHECK_FILE = 16,  //下载LED校正文件
    NET_SDK_DOWNLOAD_VEHICLE_INFORMATION = 17,  //车辆信息导出
    NET_SDK_DOWNLOAD_CERTIFICATE_BLOCKLIST_TEMPLET = 18,  //下载身份证禁止名单模板
    NET_SDK_DOWNLOAD_LOG_FILE = 19,  //日志导出
    NET_SDK_DOWNLOAD_FILEVOLUME_DATA = 20,  //下载文件卷数据文件（目前只有CVR设备支持）
    NET_SDK_DOWNLOAD_FD_DATA = 21,  //导出指定人脸库的数据
    NET_SDK_DOWNLOAD_SECURITY_CFG_FILE = 22,  //配置文件安全导出
    NET_SDK_DOWNLOAD_PUBLISH_SCHEDULE = 23,  //日程导出
    NET_SDK_DOWNLOAD_RIGHT_CONTROLLER_AUDIO = 24,  //下载权限控制器音频文件
    NET_SDK_DOWNLOAD_MODBUS_CFG_FILE = 25,  //导出Modbus协议配置文件
    NET_SDK_DOWNLOAD_RS485_PROTOCOL_DLL_FILE = 26,  //导出RS485协议动态库文件
    NET_SDK_DOWNLOAD_CLUSTER_MAINTENANCE_LOG = 27,  //集群维护日志导出
    NET_SDK_DOWNLOAD_SQL_ARCHIVE_FILE = 28,  //归档数据库记录导出
    NET_SDK_DOWNLOAD_SUBWIND_STREAM = 29,  //导出子窗口码流
    NET_SDK_DOWNLOAD_DEVTYPE_CALIBFILE = 30,  //型号标定文件导出(.cal格式文件)
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE = 31,  // 2400W/3200W矫正表导出(.cal格式文件)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE = 32,  //客户标定文件导出(.pto格式文件)
    NET_SDK_DOWNLOAD_FOUE_CAMERAS_PICTURES = 33,  //四通道图片包导出(.tar格式文件)
    NET_SDK_DOWNLOAD_DOOR_CONTENT = 34,  //下载门口联系人信息
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL_THUMBNAIL = 35,  //下载信息发布静态素材缩略图
    NET_SDK_DOWNLOAD_PUBLISH_PROGRAM_THUMBNAIL = 36,  //下载信息发布节目缩略图
    NET_SDK_DOWNLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 37,  //下载信息发布模板缩略图
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_MAIN = 38,  //黑光矫正表文件(主分区)
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_BACKUP = 39,  //黑光矫正表文件（备份分区）
    NET_SDK_DOWNLOAD_OFFLINE_CAPTURE_INFO_TEMPLATE = 40,  //下载采集用户列表模板
    NET_SDK_DOWNLOAD_CAPTURE_DATA = 41,  //下载离线采集数据
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE_FILE = 42,  // 2400W/3200W矫正表导出(.cal格式文件, 带通道)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE_FILE = 43,  //客户标定文件导出(.pto格式文件, 带通道)
    NET_SDK_DOWNLOAD_FOUR_CAMERAS_PICTURES_FILE = 44,  //四通道图片包导出(.tar格式文件, 带通道)
    NET_SDK_DOWNLOAD_SCENE_FILE = 45,  //导出场景文件
    NET_SDK_DOWNLOAD_OPEN_SOURCE_CERT = 46,  //导出开源合规证书
    NET_SDK_DOWNLOAD_RATIOSTITCHING_FILE = 47,  //导出倍率拼接文件
    NET_SDK_DOWNLOAD_LENS_PARAM_FILE = 48,  // 导出镜头参数文件
    NET_SDK_DOWNLOAD_SELECT_DEVTYPE_CALIBFILE = 49,  //导出指定型号标定文件(.cal格式文件)
    NET_SDK_DOWNLOAD_VIDEOWALL_MATERIAL_FILE = 50  //导出电视墙窗口素材文件
  );

//下载状态
type
  NET_SDK_DOWNLOAD_STATUS =  
  (  
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,  //下载成功
    NET_SDK_DOWNLOAD_STATUS_PROCESSING,  //正在下载
    NET_SDK_DOWNLOAD_STATUS_FAILED,  //下载失败
    NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR,  //未知错误
    NET_SDK_DOWNLOAD_STATUS_RESOURCE,  //内存不足
    NET_SDK_DOWNLOAD_STATUS_GUIDFILE_EXPORT_FAIL  //GUID文件导出失败
  );

//下载控制命令类型
type
  NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM =  
  (  
    ENUM_DOWNLOAD_CONTROL_ERR = -1,  
    ENUM_DOWNLOAD_CONTROL_QOS = 1  //流控
  );

type
  NET_DVR_PANORAMIC_STITCH_UPLOAD = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  // 通道号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PANORAMIC_STITCH_UPLOAD = ^NET_DVR_PANORAMIC_STITCH_UPLOAD;

type
  NET_DVR_FD_DATA_COND = record 
    dwSize: DWORD;  
    szFDID: array[0..NET_SDK_MAX_FDID_LEN{256}-1] of AnsiChar;  //人脸库ID
    szCheckCode: array[0..NET_SDK_CHECK_CODE_LEN{128}-1] of AnsiChar;  //校验码
    byCover: BYTE;  //是否覆盖式导入 0-否，1-是
    szLoginPassword: array[0..PASSWD_LEN{16}-1] of AnsiChar;  //登录密码
    byRes: array[0..111-1] of BYTE;  
  end;
  LPNET_DVR_FD_DATA_COND = ^NET_DVR_FD_DATA_COND;

type
  NET_DVR_UPLOAD_FACE_DATA = record 
    dwSize: DWORD;  
    szFDID: array[0..NET_SDK_MAX_FDID_LEN{256}-1] of AnsiChar;  //人脸库ID
    byFDLibType: BYTE;  //人脸库类型0-保留;1-禁止名单；2-允许名单
    byRes1: array[0..3-1] of BYTE;  
    szCustomInfo: array[0..NET_SDK_FDPIC_CUSTOM_INFO_LEN{96}-1] of AnsiChar;  //人脸库图片自定义信息
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_FACE_DATA = ^NET_DVR_UPLOAD_FACE_DATA;

type
  NET_DVR_UPLOAD_FACE_DATA_OUT = record 
    szPicID: array[0..NET_SDK_MAX_PICID_LEN{256}-1] of AnsiChar;  //图片ID
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_FACE_DATA_OUT = ^NET_DVR_UPLOAD_FACE_DATA_OUT;

type
  NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT = record 
    dwSize: DWORD;  
    dwPID: DWORD;  //图片ID
    dwFaceAnalysisNum: DWORD;  //识别出的人脸区域个数
    struVcaRect: array[0..NET_DVR_MAX_FACE_ANALYSIS_NUM-1] of NET_VCA_RECT;  //识别出来的人脸目标，紧凑排列
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT = ^NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT;

type
  NET_DVR_SECURITY_CFG_FILE_COND = record 
    dwSize: DWORD;  
    szSecretKey: array[0..NET_SDK_SECRETKEY_LEN{128}-1] of AnsiChar;  //校验密钥
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SECURITY_CFG_FILE_COND = ^NET_DVR_SECURITY_CFG_FILE_COND;

type
  NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM = record 
    dwSize: DWORD;  
    byType: BYTE;  //日志类型，0-全部，1-精简，2-默认
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM = ^NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM;


type
  NET_DVR_BONJOUR_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byEnableBonjour: BYTE;  // Bonjour使能 0 ：开启 1：关闭
    byRes1: array[0..3-1] of BYTE;  
    byFriendlyName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 服务名
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_BONJOUR_CFG = ^NET_DVR_BONJOUR_CFG;

type
  NET_DVR_SOCKS_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byEnableSocks: BYTE;  // 使能 0：关闭 1：开启
    byVersion: BYTE;  // SOCKS版本 4：SOCKS4   5：SOCKS5
    wProxyPort: WORD;  // 代理端口，默认1080
    byProxyaddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 代理IP地址，可以是域名
    byUserName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 用户名 SOCKS才用
    byPassword: array[0..NAME_LEN-1] of BYTE;  // 密码SOCKS5才用
    byLocalAddr: array[0..MAX_LOCAL_ADDR_LEN-1] of BYTE;  //不使用socks代理的网段，格式为"ip/netmask;ip/netmask;…"
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SOCKS_CFG = ^NET_DVR_SOCKS_CFG;



type
  NET_DVR_QOS_CFG = record 
    dwSize: DWORD;  
    byManageDscp: BYTE;  // 管理数据的DSCP值 [0-63]
    byAlarmDscp: BYTE;  // 报警数据的DSCP值 [0-63]
    byVideoDscp: BYTE;  // 视频数据的DSCP值 [0-63]，byFlag为0时，表示音视频
    byAudioDscp: BYTE;  // 音频数据的DSCP值 [0-63]，byFlag为1时有效
    byFlag: BYTE;  // 0：音视频合一，1：音视频分开
    byEnable: BYTE;  
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_QOS_CFG = ^NET_DVR_QOS_CFG;

type
  NET_DVR_HTTPS_CFG = record 
    dwSize: DWORD;  
    wHttpsPort: WORD;  // HTTPS端口
    byEnable: BYTE;  // 使能 0：关闭 1：开启
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_HTTPS_CFG = ^NET_DVR_HTTPS_CFG;

//证书相关
type
  NET_DVR_CERT_NAME = record 
    byCountry: array[0..MAX_COUNTRY_NAME_LEN-1] of BYTE;  //国家代号 CN等
    byState: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //洲或省
    byLocality: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //地区
    byOrganization: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //组织
    byUnit: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //单位
    byCommonName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  
    byEmail: array[0..MAX_DOMAIN_NAME-1] of BYTE;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CERT_NAME = ^NET_DVR_CERT_NAME;

type
  NET_DVR_CERT_ADDITION_PARAM = record 
    dwSize: DWORD;  
    csCustomID: array[0..64-1] of AnsiChar;  //用户自定义ID
    byRes1: array[0..2-1] of BYTE;  
    byCertificateMode: BYTE;  //wCertType为1-Certificate时有效，0-自签名证书，1-证书和私钥方式
    byPrivateKeyMode: BYTE;  // byCertificateMode为1-证书和私钥方式时有效 0-独立key 1-PKCS#12
    byPassword: array[0..64-1] of BYTE;  //密码，当PrivateKeyMode为0时为私钥的密码，为1时为PKCS#12的密码
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CERT_ADDITION_PARAM = ^NET_DVR_CERT_ADDITION_PARAM;


type
  NET_DVR_CERT_PARAM = record 
    dwSize: DWORD;  
    wCertFunc: WORD;  //证书种类，0-802.1x(应用于WIFI接入证书),1-HTTPS, 3-ieee802.1x(应用于有线LAN接入认证)
    wCertType: WORD;  //证书类型，0-CA，1-Certificate,2-私钥文件
    byFileType: BYTE;  //证书文件类型，0-PEM,1-PFX
    byRes1: array[0..2-1] of BYTE;  //保留字节
    byAddition: BYTE;  //是否使用附加结构体，0-不使用;1-使用
    pStruAdditionParam: LPNET_DVR_CERT_ADDITION_PARAM;  //附加信息结构体指针
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_CERT_PARAM = ^NET_DVR_CERT_PARAM;

const
  UPLOAD_CERTIFICATE = 1;    //上传证书


type
  NET_DVR_CERT_INFO = record 
    dwSize: DWORD;  
    struCertParam: NET_DVR_CERT_PARAM;  //证书参数
    dwValidDays: DWORD;  //有效天数，类型为自签名时有效
    byPasswd: array[0..NAME_LEN-1] of BYTE;  //私钥密码
    struCertName: NET_DVR_CERT_NAME;  // 证书名称
    struIssuerName: NET_DVR_CERT_NAME;  // 证书发行者名称（自签名证书信息获取时有效）
    struBeginTime: NET_DVR_TIME_EX;  //证书创建时间（自签名证书信息获取时有效）
    struEndTime: NET_DVR_TIME_EX;  //证书截止时间（自签名证书信息获取时有效）
    serialNumber: array[0..NAME_LEN-1] of BYTE;  //证书标识码（自签名证书信息获取时有效）
    byVersion: BYTE;  
    byKeyAlgorithm: BYTE;  //加密类型 0-RSA  1-DSA
    byKeyLen: BYTE;  //加密长度 0-512  1-1024、 2-2048
    bySignatureAlgorithm: BYTE;  //签名算法类型（自签名证书信息获取时有效）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CERT_INFO = ^NET_DVR_CERT_INFO;


//channel record status
//***通道录像状态*****//
type
  NET_DVR_CHANS_RECORD_STATUS = record 
    byValid: BYTE;  //是否有效
                           {(只读)录像类型:0: 不在录像；1：在录像 2-空闲
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中 12-token认证失败}
    byRecord: BYTE;  
    wChannelNO: WORD;  //通道号
    dwRelatedHD: DWORD;  //关联磁盘
    byOffLineRecord: BYTE;  //断网录像功能 0-关闭 1-开启
    byRes: array[0..7-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_CHANS_RECORD_STATUS = ^NET_DVR_CHANS_RECORD_STATUS;


type
  NET_DVR_IP_ALARM_GROUP_NUM = record 
    dwSize: DWORD;  
    dwIPAlarmInGroup: DWORD;  //IP通道报警输入组数
    dwIPAlarmInNum: DWORD;  //IP通道报警输入个数
    dwIPAlarmOutGroup: DWORD;  //IP通道报警输出组数
    dwIPAlarmOutNum: DWORD;  //IP通道报警输出个数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_IP_ALARM_GROUP_NUM = ^NET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

type
  NET_DVR_CHAN_GROUP_RECORD_STATUS = record 
    dwSize: DWORD;  //结构体大小
    struChanStatus: array[0..MAX_CHANNUM_V30-1] of NET_DVR_CHANS_RECORD_STATUS;  //一组64个
  end;
  LPNET_DVR_CHAN_GROUP_RECORD_STATUS = ^NET_DVR_CHAN_GROUP_RECORD_STATUS;


type
  NET_DVR_RECTCFG = record 
    wXCoordinate: WORD;  //矩形左上角起始点X坐标
    wYCoordinate: WORD;  //矩形左上角Y坐标
    wWidth: WORD;  //矩形宽度
    wHeight: WORD;  //矩形高度
  end;
  LPNET_DVR_RECTCFG = ^NET_DVR_RECTCFG;
//窗口信息
type
  NET_DVR_WINCFG = record 
    dwSize: DWORD;  
    byVaild: BYTE;  
    byInputIdx: BYTE;  //输入源索引
    byLayerIdx: BYTE;  //图层，0为最底层
    byTransparency: BYTE;  //透明度，0～100
    struWin: NET_DVR_RECTCFG;  //目的窗口(相对显示墙)
    wScreenHeight: WORD;  //大屏高
    wScreenWidth: WORD;  //大屏宽
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_WINCFG = ^NET_DVR_WINCFG;

const
  MAX_LAYERNUMS = 32;    

type
  NET_DVR_ALLWINCFG = record 
    dwSize: DWORD;  
    struWinCfg: array[0..MAX_LAYERNUMS-1] of NET_DVR_WINCFG;  
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_ALLWINCFG = ^NET_DVR_ALLWINCFG;

type
  NET_DVR_SCREENZOOM = record 
    dwSize: DWORD;  
    dwScreenNum: DWORD;  //大屏号
    struPointFrame: NET_DVR_POINT_FRAME;  
    byLayer: BYTE;  //图层号
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_SCREENZOOM = ^NET_DVR_SCREENZOOM;

//2011-04-18
//摄像机信息,最多9999个，从1开始 
type
  NET_MATRIX_CAMERAINFO = record 
    dwGlobalCamId: DWORD;  // cam的全局编号
    sCamName: array[0..NAME_LEN-1] of BYTE;  //cam的名称
    dwMatrixId: DWORD;  //cam对应矩阵的编号
    dwLocCamId: DWORD;  //cam对应矩阵的内部编号
    byValid: BYTE;  //是否有效，0-否，1-是
    byPtzCtrl: BYTE;  // 是否可控，0-否，1-是
    byUseType: BYTE;  //*使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤}
    byUsedByTrunk: BYTE;  //当前使用状态，0-没有被使用，1-被干线使用
    byTrunkReq: BYTE;  //摄像机分辨率,以D1为单位：1 - 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
    byRes1: array[0..3-1] of BYTE;  
    struInstallTime: NET_DVR_TIME;  //安装时间
    sPurpose: array[0..NAME_LEN-1] of BYTE;  //用途描述
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_MATRIX_CAMERAINFO = ^NET_MATRIX_CAMERAINFO;

//显示器信息，最多2048个
type
  NET_MATRIX_MONITORINFO = record 
    dwGloalMonId: DWORD;  //mon 的统一编号
    sMonName: array[0..NAME_LEN-1] of BYTE;  
    dwMatrixId: DWORD;  //mon所在矩阵的编号
    dwLocalMonId: DWORD;  //mon的内部编号
    byValid: BYTE;  //是否有效，0-否，1-是
    byTrunkType: BYTE;  //使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤
    byUsedByTrunk: BYTE;  //当前使用状态，0-没有被使用，1-被干线使用
    byTrunkReq: BYTE;  //分辨率, 以D1为单位：1- 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
    struInstallTime: NET_DVR_TIME;  //安装时间
    sPurpose: array[0..NAME_LEN-1] of BYTE;  //用途描述
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_MATRIX_MONITORINFO = ^NET_MATRIX_MONITORINFO;

type
  NET_MATRIX_DIGITALMATRIX = record 
    struAddress: NET_DVR_IPADDR;  //设备为数字设备时的IP信息
    wPort: WORD;  
    byNicNum: BYTE;  //0 - eth0, 1 - eth1, 考虑双网口如何通信加入绑定的网口
    byRes: array[0..69-1] of BYTE;  
  end;
  LPNET_MATRIX_DIGITALMATRIX = ^NET_MATRIX_DIGITALMATRIX;
type
  NET_MATRIX_ANALOGMATRIX = record 
    bySerPortNum: BYTE;  //连接的串口号  0xff-环通接入
    byMatrixSerPortType: BYTE;  // 矩阵接入网关的串口与模拟矩阵的键盘口(键盘协议)连接还是与矩阵通信口（矩阵协议）连接 ，0 --- 矩阵协议通讯口 1 --- 键盘通讯口
    byRes1: array[0..2-1] of BYTE;  
    struRS232: NET_DVR_SINGLE_RS232;  //232串口参数  环通接入时此参数无效
    byRes2: array[0..200-1] of BYTE;  
  end;
  LPNET_MATRIX_ANALOGMATRIX = ^NET_MATRIX_ANALOGMATRIX;

type
  NET_MATRIX_UNION = record 
    case Byte of
    0: (struDigitalMatrix: NET_MATRIX_DIGITALMATRIX);  
    1: (struAnalogMatrix: NET_MATRIX_ANALOGMATRIX);  
  end;
  LPNET_MATRIX_UNION = ^NET_MATRIX_UNION;
//矩阵配置信息，最多20个
type
  NET_MATRIX_MATRIXINFO = record 
    dwSize: DWORD;  
    dwMatrixId: DWORD;  //矩阵编号
    sDevName: array[0..NAME_LEN-1] of BYTE;  
    byCtrlType: BYTE;  //指通讯方式是串口通信, 还是网络通信
    byProtocolType: BYTE;  //设置通信控制协议
    byRes1: array[0..6-1] of BYTE;  //预留
    struMatrixUnion: NET_MATRIX_UNION;  
    dwMaxPortsIn: DWORD;  //矩阵输入数
    dwMaxPortsOut: DWORD;  //矩阵输出数
    sUserName: array[0..NAME_LEN-1] of BYTE;  //登录用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //登录密码
    struInstallTime: NET_DVR_TIME;  //安装时间
    sPurpose: array[0..NAME_LEN-1] of BYTE;  //用途描述
    byRes2: array[0..20-1] of BYTE;  //预留
  end;
  LPNET_MATRIX_MATRIXINFO = ^NET_MATRIX_MATRIXINFO;


type
  NET_DVR_MATRIXLIST = record 
    dwSize: DWORD;  
    byRes: array[0..12-1] of BYTE;  
    dwMatrixNum: DWORD;  //设备返回的矩阵数量
    pBuffer: PBYTE;  //矩阵信息缓冲区
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_MATRIXLIST = ^NET_DVR_MATRIXLIST;

//串口配置信息
type
  NET_MATRIX_UARTPARAM = record 
    dwSize: DWORD;  
    byPortName: array[0..NAME_LEN-1] of BYTE;  
    wUserId: WORD;  //用户编号，当连接设备为键盘时，绑定一个用户，用于权限管理
    byPortType: BYTE;  //串口类型，三种0-RS232/1-RS485/2-RS422
    byFuncType: BYTE;  //串口连接的设备的类型0-空闲，1-键盘，2-用作透明通道(485串口不可配置成透明通道),3-模拟矩阵
    byProtocolType: BYTE;  //串口支持的协议类型, 当连接键盘设备时需要该信息,获取键盘支持协议的编号及描述符
    byBaudRate: BYTE;  
    byDataBits: BYTE;  
    byStopBits: BYTE;  //停止位
    byParity: BYTE;  //校验
    byFlowCtrl: BYTE;  //流控，软件流控，无流控
    byRes: array[0..22-1] of BYTE;  //预留
  end;
  LPNET_MATRIX_UARTPARAM = ^NET_MATRIX_UARTPARAM;

//最多256个用户，1～256
type
  NET_MATRIX_USERPARAM = record 
    dwSize: DWORD;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  
    sPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  
    byRole: BYTE;  //用户角色:0-管理员,1-操作员；只有一个系统管理员，255个操作员
    byLevel: BYTE;  //统一级别，用于操作级别管理,1- 255
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_MATRIX_USERPARAM = ^NET_MATRIX_USERPARAM;

//最多255个资源组
type
  NET_MATRIX_RESOURCEGROUPPARAM = record 
    dwSize: DWORD;  
    byGroupName: array[0..NAME_LEN-1] of BYTE;  
    byGroupType: BYTE;  //0-摄像机CAM组，1-显示器MON组
    byRes1: BYTE;  
    wMemNum: WORD;  
    dwGlobalId: array[0..512-1] of DWORD;  
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_MATRIX_RESOURSEGROUPPARAM = ^NET_MATRIX_RESOURCEGROUPPARAM;

//最多255个用户组
type
  NET_MATRIX_USERGROUPPARAM = record 
    dwSize: DWORD;  
    sGroupName: array[0..NAME_LEN-1] of BYTE;  
    wUserMember: array[0..255-1] of WORD;  //包含的用户成员
    wResorceGroupMember: array[0..255-1] of WORD;  //包含的资源组成员
    byPermission: array[0..32-1] of BYTE;  //权限，数组0-ptz权限、切换权限、查询权限
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_MATRIX_USERGROUPPARAM = ^NET_MATRIX_USERGROUPPARAM;

type
  NET_MATRIX_TRUNKPARAM = record 
    dwSize: DWORD;  
    dwTrunkId: DWORD;  
    sTrunkName: array[0..NAME_LEN-1] of BYTE;  
    dwSrcMonId: DWORD;  
    dwDstCamId: DWORD;  
    byTrunkType: BYTE;  //使用类型  1-BNC，2-SP3光纤高清，3-SP3光纤D1， 4-V6光纤，5-其他光纤
    byAbility: BYTE;  //表示光纤的带宽，可以传输几路
    bySubChan: BYTE;  //针对光纤干线而言，表示子通道号
    byLevel: BYTE;  // 干线级别 1-255
    wReserveUserID: WORD;  //预留的用户ID： 1~256 ，0表示释放预留
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_MATRIX_TRUNKPARAM = ^NET_MATRIX_TRUNKPARAM;

type
  NET_DVR_MATRIX_TRUNKLIST = record 
    dwSize: DWORD;  
    byRes: array[0..12-1] of BYTE;  
    dwTrunkNum: DWORD;  //设备返回的干线数量
    pBuffer: PBYTE;  //干线信息缓冲区
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_MATRIX_TRUNKLIST = ^NET_DVR_MATRIX_TRUNKLIST;

const
  MATRIX_PROTOCOL_NUM = 20;    //支持的最大矩阵协议数
  KEYBOARD_PROTOCOL_NUM = 20;    //支持的最大键盘协议数
type
  NET_DVR_PROTO_TYPE_EX = record 
    wType: WORD;  //ipc协议值
    wCommunitionType: WORD;  //0：模拟 1：数字 2：兼容模拟、数字
    byDescribe: array[0..DESC_LEN-1] of BYTE;  //协议描述字段
  end;
  LPNET_DVR_PROTO_TYPE_EX = ^NET_DVR_PROTO_TYPE_EX;

type
  NET_DVR_MATRIXMANAGE_ABILITY = record 
    dwSize: DWORD;  
    dwMaxCameraNum: DWORD;  //最大Camera数量
    dwMaxMonitorNum: DWORD;  //最大显示器数量
    wMaxMatrixNum: WORD;  //最大矩阵数量
    wMaxSerialNum: WORD;  //串口数量
    wMaxUser: WORD;  //最大用户数
    wMaxResourceArrayNum: WORD;  //最大资源组数
    wMaxUserArrayNum: WORD;  //最大用户组数
    wMaxTrunkNum: WORD;  //最大干线数
    nStartUserNum: BYTE;  //起始用户号
    nStartUserGroupNum: BYTE;  //起始用户组号
    nStartResourceGroupNum: BYTE;  //起始资源组号
    nStartSerialNum: BYTE;  //起始串口号
    dwMatrixProtoNum: DWORD;  //有效的矩阵协议数目，从0开始
    struMatrixProto: array[0..MATRIX_PROTOCOL_NUM-1] of NET_DVR_PROTO_TYPE_EX;  //最大协议列表长度
    dwKeyBoardProtoNum: DWORD;  //有效的键盘协议数目，从0开始
    struKeyBoardProto: array[0..KEYBOARD_PROTOCOL_NUM-1] of NET_DVR_PROTO_TYPE_EX;  //最大协议列表长度
    byDelMonitorLongCfg: BYTE;  //是否支持删除monitor长连接配置
    byDelCamonitorLongCfg: BYTE;  //是否支持删除camera长连接配置
    byAudioSwitchContorl: BYTE;  //是否支持音频开关控制
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_MATRIXMANAGE_ABILITY = ^NET_DVR_MATRIXMANAGE_ABILITY;


//人脸抓拍规则(单条)
type
  NET_VCA_SINGLE_FACESNAPCFG = record 
    byActive: BYTE;  //是否激活规则：0-否，1-是
    //******** IPC5.1.7 新增参数 Begin 2014-03-21**********
    //人脸自动ROI开关使能
    byAutoROIEnable: BYTE;  //0-关闭,1-开启
    byRes: array[0..2-1] of BYTE;  //保留
    //******** IPC5.1.7 新增参数 End 2014-03-21**********
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struVcaPolygon: NET_VCA_POLYGON;  //人脸识别区域
  end;
  LPNET_VCA_SINGLE_FACESNAPCFG = ^NET_VCA_SINGLE_FACESNAPCFG;

//人脸抓拍规则参数
type
  NET_VCA_FACESNAPCFG = record 
    dwSize: DWORD;  
    bySnapTime: BYTE;  //单个目标人脸的抓拍次数0-10
    bySnapInterval: BYTE;  //抓拍间隔，单位：帧
    bySnapThreshold: BYTE;  //抓拍阈值，0-100
    byGenerateRate: BYTE;  //目标生成速度,范围[1, 5]
    bySensitive: BYTE;  //目标检测灵敏度，范围[1, 5]
    byReferenceBright: BYTE;  //2012-3-27参考亮度[0,100]
    byMatchType: BYTE;  //2012-5-3比对报警模式，0-目标消失后报警，1-实时报警
    byMatchThreshold: BYTE;  //2012-5-3实时比对阈值，0~100
    struPictureParam: NET_DVR_JPEGPARA;  //图片规格结构
    struRule: array[0..MAX_RULE_NUM-1] of NET_VCA_SINGLE_FACESNAPCFG;  //人脸抓拍规则
    //人脸曝光最短持续时间（两个字节）
    wFaceExposureMinDuration: WORD;  //范围(1~3600秒，默认60)生效于自动模式下
    //人脸曝光模式
    byFaceExposureMode: BYTE;  //1-关闭，2-开启，0-自动（根据人脸判断）
    byBackgroundPic: BYTE;  //背景图上传使能 0-默认值（开启），1-禁止
    dwValidFaceTime: DWORD;  //有效人脸最短持续时间，单位：秒
    dwUploadInterval: DWORD;  //人脸抓拍统计数据上传间隔时间，单位：秒，默认900秒
    dwFaceFilteringTime: DWORD;  //人脸停留时间过滤,默认5秒，范围0-100秒。0秒表示不过滤
    bySceneID: BYTE;  //场景号,目前支持1~4场景，0为无效
    byInvalCapFilterEnable: BYTE;  //无效抓拍过滤使能，0为关闭，1为开启，默认为0
    byInvalCapFilterThreshold: BYTE;  //无效抓拍过滤阈值，0~100，当byInvalCapFilterEnable为1时生效
    byRes2: array[0..81-1] of BYTE;  
  end;
  LPNET_VCA_FACESNAPCFG = ^NET_VCA_FACESNAPCFG;

type
  NET_DVR_FIRMWARE_VERSION_IFNO = record 
    dwSize: DWORD;  //结构体大小
    szFirmwareVersion: array[0..LEN_PROPERTY{128}-1] of AnsiChar;  //主控版本属性 只读
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FIRMWARE_VERSION_IFNO = ^NET_DVR_FIRMWARE_VERSION_IFNO;


//人脸表情
type
  FACE_EXPRESSION_GROUP_ENUM =  
  (  
    ENUM_EXPRESSION_GROUP_SURPRISED = 1,  //惊讶
    ENUM_EXPRESSION_GROUP_PANIC = 2,  //害怕
    ENUM_EXPRESSION_GROUP_DISGUUSTED = 3,  //厌恶
    ENUM_EXPRESSION_GROUP_HAPPY = 4,  //高兴
    ENUM_EXPRESSION_GROUP_SAD = 5,  //难过
    ENUM_EXPRESSION_GROUP_ANGRY = 6,  //愤怒
    ENUM_EXPRESSION_GROUP_POKER = 7,  //中性
    ENUM_EXPRESSION_GROUP_ALL = $fe,  //全部
    ENUM_EXPRESSION_GROUP_UNKNOW = $ff  //未知,算法支持未检出
  );

type
  NET_DVR_LLI_PARAM = record 
    fSec: FLOAT;  //秒[0.000000,60.000000]
    byDegree: BYTE;  //度:纬度[0,90] 经度[0,180]
    byMinute: BYTE;  //分[0,59]
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_LLI_PARAM = ^NET_DVR_LLI_PARAM;

type
  NET_DVR_LLPOS_PARAM = record 
    byLatitudeType: BYTE;  //纬度类型，0-北纬，1-南纬
    byLongitudeType: BYTE;  //经度类型，0-东经，1-西经
    byRes1: array[0..2-1] of BYTE;  
    struLatitude: NET_DVR_LLI_PARAM;  //纬度
    struLongitude: NET_DVR_LLI_PARAM;  //经度
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_LLPOS_PARAM = ^NET_DVR_LLPOS_PARAM;

//人脸抓拍附加信息结构体
type
  NET_VCA_FACESNAP_ADDINFO = record 

    //人脸矩形框,该坐标为人脸小图(头肩照)中人脸的坐标
    struFacePicRect: NET_VCA_RECT;  
    iSwingAngle: INT;  //旋转角, -90~90度
    iTiltAngle: INT;  //俯仰角, -90~90度
    dwPupilDistance: DWORD;  //瞳距,范围为：最小值为10像素,最大值为当前分辨率宽度/1.6
    byBlockingState: BYTE;  //目标遮挡状态， 0-表示“未知”（算法不支持）,1~无遮挡,2~瞬时轻度遮挡，3~持续轻度遮挡，4~严重遮挡
    byFaceSnapThermometryEnabled: BYTE;  //人脸抓拍测温使能 1-开启 0-关闭
    byIsAbnomalTemperature: BYTE;  //人脸抓拍测温是否温度异常 1-是 0-否
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    struEnterTime: NET_DVR_TIME_EX;  // 最佳抓拍下进入时间
    struExitTime: NET_DVR_TIME_EX;  // 最佳抓拍下离开时间
    fFaceTemperature: FLOAT;  // 人脸温度（ - 20.0℃~150.0℃，精确到小数点后1位。其中0xffff（65535）表示无效，开启隐藏温度值功能时返回）
    fAlarmTemperature: FLOAT;  // 测温报警警阈值（精确到小数点后1位）
    dwThermalPicLen: DWORD;  //热成像图片长度
    pThermalPicBuff: PBYTE;  // 热成像图片指针
    szCustomChanID: array[0..65-1] of BYTE;  // 自定义布防点通道号  string  max.len = 64
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struLLPos: NET_DVR_LLPOS_PARAM;  //设备经纬度位置信息
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pEventNotificationAlertBuff: PAnsiChar;  //其Buff对应EventNotificationAlert JSON Block("eventType":  "faceCapture")
{$ELSE}
    pEventNotificationAlertBuff: PAnsiChar;  //其Buff对应EventNotificationAlert JSON Block("eventType":  "faceCapture")
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    dwEventNotificationAlertLen: DWORD;  //长度对应EventNotificationAlert JSON Block("eventType":  "faceCapture")数据长度
    byRes: array[0..340-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FACESNAP_ADDINFO = ^NET_VCA_FACESNAP_ADDINFO;

//人脸抓拍结果
type
  NET_VCA_FACESNAP_RESULT = record 
    dwSize: DWORD;  // 结构大小
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    dwFacePicID: DWORD;  //人脸图ID
    dwFaceScore: DWORD;  //人脸评分,0-100
    struTargetInfo: NET_VCA_TARGET_INFO;  //报警目标信息
    struRect: NET_VCA_RECT;  //人脸子图区域
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwFacePicLen: DWORD;  //人脸子图的长度，为0表示没有图片，大于0表示有图片
    dwBackgroundPicLen: DWORD;  //背景图的长度，为0表示没有图片，大于0表示有图片(保留)
    bySmart: BYTE;  //IDS设备返回0(默认值)，Smart Functiom Return 1
    byAlarmEndMark: BYTE;  //报警结束标记0-保留，1-结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，主要提供给NVR使用，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）
    byRepeatTimes: BYTE;  //重复报警次数，0-无意义
    byUploadEventDataType: BYTE;  //人脸图片数据长传方式：0-二进制数据，1-URL
    struFeature: NET_VCA_HUMAN_FEATURE;  //人体属性
    fStayDuration: FLOAT;  //停留画面中时间(单位: 秒)
    sStorageIP: array[0..16-1] of AnsiChar;  //存储服务IP地址
    wStoragePort: WORD;  //存储服务端口号
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    {人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
    新增人脸抓拍质量评分机制与原有的人脸评分区别：
    原有的人脸评分是在人脸抓拍中实现，目的是确保一次人脸抓拍中获取最好的图像效果，是一个相对图像质量的评分；新增人脸抓拍质量评分机制是针对已经抓拍完成的人脸图片，使用图像算法对图像中人脸，人眼，肩宽等相对重要的信息进行分析，按照统一的标准对人脸图片效果质量进行评分}
    byFacePicQuality: BYTE;  
    byUIDLen: BYTE;  // 上传报警的标识长度
    byLivenessDetectionStatus: BYTE;  // 活体检测状态：0-保留，1-未知(检测失败)，2-非真人人脸，3-真人人脸，4-未开启活体检测
    //附加信息标识位（即是否有NET_VCA_FACESNAP_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
    byAddInfo: BYTE;  
    pUIDBuffer: PBYTE;  //标识指针
    //附加信息指针,指向NET_VCA_FACESNAP_ADDINFO结构体
    pAddInfoBuffer: PBYTE;  
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不是重传数据，1-重传数据
    pBuffer1: PBYTE;  //人脸子图的图片数据
    pBuffer2: PBYTE;  //背景图的图片数据（保留，通过查找背景图接口可以获取背景图）
  end;
  LPNET_VCA_FACESNAP_RESULT = ^NET_VCA_FACESNAP_RESULT;

type
  NET_VCA_SUB_PROCIMG_V50 = record 
    dwImageLen: DWORD;  //图片数据长度
    dwFaceScore: DWORD;  //人脸评分,0-100
    struVcaRect: NET_VCA_RECT;  //人脸子图区域
    struLeftEyePoint: NET_VCA_POINT;  //左眼位置
    struRightEyePoint: NET_VCA_POINT;  //右眼位置
    byDistance: BYTE;  //两眼间距
    bySex: BYTE;  
    byRes1: BYTE;  
    byEyeGlass: BYTE;  
    struPosRect: NET_VCA_RECT;  //人脸位置区域
    byRes: array[0..20-1] of BYTE;  //保留
    pImage: PBYTE;  //图片数据
  end;
  LPNET_VCA_SUB_PROCIMG_V50 = ^NET_VCA_SUB_PROCIMG_V50;

type
  NET_DVR_FACE_DETECTION = record 
    dwSize: DWORD;  //结构大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    dwBackgroundPicLen: DWORD;  //背景图的长度，为0表示没有图片，大于0表示有图片
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    struFacePic: array[0..MAX_FACE_PIC_NUM{30}-1] of NET_VCA_RECT;  //人脸子图区域
    byFacePicNum: BYTE;  //子图数量
    byUploadEventDataType: BYTE;  //图片数据长传方式：0-二进制数据，1-URL
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byRes: array[0..249-1] of BYTE;  
    pBackgroundPicpBuffer: PBYTE;  //背景图的图片数据
  end;
  LPNET_DVR_FACE_DETECTION = ^NET_DVR_FACE_DETECTION;

type
  NET_DVR_UPGRADE_PARAM = record 
    dwUpgradeType: DWORD;  
    sFileName: PAnsiChar;  
    pInbuffer: PVOID;  
    dwBufferLen: DWORD;  
    pUnitIdList: array[0..64-1] of PAnsiChar;  
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    sCustomURL: PAnsiChar;  
{$ELSE}
    sCustomURL: PAnsiChar;  
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    dwCustomURLLen: DWORD;  
    byRes: array[0..100-1] of BYTE;  
  end;
  LPNET_DVR_UPGRADE_PARAM = ^NET_DVR_UPGRADE_PARAM;


type
  NET_VCA_FD_PROCIMG_RESULT_V50 = record 
    dwSize: DWORD;  //结构大小
    dwImageId: DWORD;  //大图ID
    byRes: array[0..20-1] of BYTE;  //保留
    dwSubImageNum: DWORD;  //人脸子图张数
    struProcImg: array[0..MAX_TARGET_NUM-1] of NET_VCA_SUB_PROCIMG_V50;  //单张子图信息
  end;
  LPNET_VCA_FD_PROCIMG_RESULT_V50 = ^NET_VCA_FD_PROCIMG_RESULT_V50;

//虚焦侦测结果
type
  NET_DVR_DEFOCUS_ALARM = record 
    dwSize: DWORD;  //结构长度
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRes1: array[0..2-1] of BYTE;  //保留字节
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byRes: array[0..49-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DEFOCUS_ALARM = ^NET_DVR_DEFOCUS_ALARM;

//大雾侦测结果
type
  NET_DVR_DENSEFOGDETECTION_ALARM = record 
    dwSize: DWORD;  //结构长度
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    byFogLevel: BYTE;  //雾的等级，0-无雾~薄雾 ，1-薄雾~中雾， 2-大雾~浓雾， 3-浓雾及以上
    byRes: array[0..259-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DENSEFOGDETECTION_ALARM = ^NET_DVR_DENSEFOGDETECTION_ALARM;

type
  NET_DVR_AUDIOEXCEPTION_ALARM = record 
    dwSize: DWORD;  //结构长度
    byAlarmType: BYTE;  //报警类型，1-音频输入异常，2-音频输入突变（声强陡升），3-声强陡降，4-音频丢失
    byRes1: BYTE;  
    wAudioDecibel: WORD;  //声音强度（音频输入突变时用到）
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRes: array[0..62-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AUDIOEXCEPTION_ALARM = ^NET_DVR_AUDIOEXCEPTION_ALARM;

type
  NET_BUTTON_DOWN_EXCEPTION_ALARM = record 
    dwSize: DWORD;  //结构长度
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    byRes: array[0..64-1] of BYTE;  // 保留字节
  end;
  LPNET_BUTTON_DOWN_EXCEPTION_ALARM = ^NET_BUTTON_DOWN_EXCEPTION_ALARM;

type
  NET_VCA_FD_IMAGE_CFG = record 
    dwWidth: DWORD;  //灰度图像数据宽度
    dwHeight: DWORD;  //灰度图像高度
    dwImageLen: DWORD;  //灰度图像数据长度
    byRes: array[0..20-1] of BYTE;  //保留
    pImage: PBYTE;  //灰度图像数据
  end;
  LPNET_VCA_FD_IMAGE_CFG = ^NET_VCA_FD_IMAGE_CFG;

type
  NET_VCA_FD_PROCIMG_CFG = record 
    dwSize: DWORD;  //结构大小
    byEnable: BYTE;  //是否激活规则;
    bySensitivity: BYTE;  //检测灵敏度，[0,5]
    byRes1: array[0..22-1] of BYTE;  //保留字节
    struSizeFilter: NET_VCA_SIZE_FILTER;  //尺寸过滤器
    struPolygon: NET_VCA_POLYGON;  //多边形
    struFDImage: NET_VCA_FD_IMAGE_CFG;  //图片信息
    byRes2: array[0..20-1] of BYTE;  //保留
  end;
  LPNET_VCA_FD_PROCIMG_CFG = ^NET_VCA_FD_PROCIMG_CFG;

type
  NET_VCA_SUB_PROCIMG = record 
    dwImageLen: DWORD;  //图片数据长度
    dwFaceScore: DWORD;  //人脸评分,0-100
    struVcaRect: NET_VCA_RECT;  //人脸子图区域
    byRes: array[0..20-1] of BYTE;  //保留
    pImage: PBYTE;  //图片数据
  end;
  LPNET_VCA_SUB_PROCIMG = ^NET_VCA_SUB_PROCIMG;

type
  NET_VCA_FD_PROCIMG_RESULT = record 
    dwSize: DWORD;  //结构大小
    dwImageId: DWORD;  //大图ID
    byRes: array[0..20-1] of BYTE;  //保留
    dwSubImageNum: DWORD;  //人脸子图张数
    struProcImg: array[0..MAX_TARGET_NUM-1] of NET_VCA_SUB_PROCIMG;  //单张子图信息
  end;
  LPNET_VCA_FD_PROCIMG_RESULT = ^NET_VCA_FD_PROCIMG_RESULT;

type
  NET_VCA_PICMODEL_RESULT = record 
    dwImageLen: DWORD;  //图片数据长度
    dwModelLen: DWORD;  //模型数据长度
    byRes: array[0..20-1] of BYTE;  //保留
    pImage: PBYTE;  //人脸图片数据指针
    pModel: PBYTE;  //模型数据指针
  end;
  LPNET_VCA_PICMODEL_RESULT = ^NET_VCA_PICMODEL_RESULT;

type
  NET_VCA_REGISTER_PIC = record 
    dwImageID: DWORD;  //大图ID
    dwFaceScore: DWORD;  //人脸评分,0-100
    struVcaRect: NET_VCA_RECT;  //人脸子图区域
    byRes: array[0..20-1] of BYTE;  //保留
  end;
  LPNET_VCA_REGISTER_PIC = ^NET_VCA_REGISTER_PIC;

const
  MAX_HUMAN_PICTURE_NUM = 10;    //最大照片数
  MAX_HUMAN_BIRTHDATE_LEN = 10;    //最大出生年月长度

type
  NET_DVR_AREAINFOCFG = record 
    wNationalityID: WORD;  //国籍
    wProvinceID: WORD;  //省
    wCityID: WORD;  //市
    wCountyID: WORD;  //县
 {
 if (dwCode != 0) dwCode 赋值参照 “全国各省份城市列表.txt”
 else dwCode 赋值解析参照 PROVINCE_CITY_IDX
 }
    dwCode: DWORD;  
  end;
  LPNET_DVR_AREAINFOCFG = ^NET_DVR_AREAINFOCFG;

type
  NET_VCA_HUMAN_ATTRIBUTE = record 
    bySex: BYTE;  //性别：0-男，1-女，0xff-未知
    byCertificateType: BYTE;  //证件类型：0-身份证，1-警官证，2-特种证，3-护照，4-其他，0xff-未知
    byBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //出生年月，如：201106
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    struNativePlace: NET_DVR_AREAINFOCFG;  //籍贯参数
    byCertificateNumber: array[0..NAME_LEN-1] of BYTE;  //证件号
 {
 dwPersonInfoExtendLen && pPersonInfoExtend 对应URL(/ISAPI/System/Video/inputs/channels/<ID>/faceContrast/personInfoExtend)表示的 PersonInfoExtendList XML Block
 意义所在：平台中心管理的时候，导入picture数据的自定义信息，在设备检测匹配报警后，携带作为匹配信息一并上传；平台中心管理匹配；
 }
    dwPersonInfoExtendLen: DWORD;  // 人员标签信息扩展长度
    pPersonInfoExtend: PBYTE;  //人员标签信息扩展信息
    byGroup: BYTE;  //如传入0xff表示未知
    byRes2: array[0..3-1] of BYTE;  //保留字节
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pThermalData: PBYTE;  //热成像图片指针
{$ELSE}
    pThermalData: PBYTE;  //热成像图片指针
    byRes3: array[0..4-1] of BYTE;  //保留字节
{$ENDIF}
  end;
  LPNET_VCA_HUMAN_ATTRIBUTE = ^NET_VCA_HUMAN_ATTRIBUTE;

type
  NET_VCA_HUMANATTRIBUTE_COND = record 
    bySex: BYTE;  //性别：0-不启用，1-男，2-女
    byCertificateType: BYTE;  //证件类型：0-不启用，1-身份证，2-警官证
    byStartBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //起始出生年月，如：201106
    byEndBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //截止出生年月，如201106
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    struNativePlace: NET_DVR_AREAINFOCFG;  //籍贯参数
    byCertificateNumber: array[0..NAME_LEN-1] of BYTE;  //证件号
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_VCA_HUMANATTRIBUTE_COND = ^NET_VCA_HUMANATTRIBUTE_COND;


type
  NET_VCA_BLOCKLIST_INFO = record 
    dwSize: DWORD;  //结构大小
    dwRegisterID: DWORD;  //名单注册ID号（只读）
    dwGroupNo: DWORD;  //分组号
    byType: BYTE;  //名单标志：0-全部，1-允许名单，2-禁止名单
    byLevel: BYTE;  //禁止名单等级，0-全部，1-低，2-中，3-高
    byRes1: array[0..2-1] of BYTE;  //保留
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    byRemark: array[0..NAME_LEN-1] of BYTE;  //备注信息
    dwFDDescriptionLen: DWORD;  //人脸库描述数据长度
    pFDDescriptionBuffer: PBYTE;  //人脸库描述数据指针
    dwFCAdditionInfoLen: DWORD;  //抓拍库附加信息长度
    pFCAdditionInfoBuffer: PBYTE;  //抓拍库附加信息数据指针（FCAdditionInfo中包含相机PTZ坐标、GPS信息）
    dwThermalDataLen: DWORD;  //热成像图片长度，仅人脸比对事件上报支持
  end;
  LPNET_VCA_BLOCKLIST_INFO = ^NET_VCA_BLOCKLIST_INFO;

type
  NET_VCA_BLOCKLIST_PARA = record 
    dwSize: DWORD;  //结构大小
    struBlockListInfo: NET_VCA_BLOCKLIST_INFO;  //禁止名单基本参数
    dwRegisterPicNum: DWORD;  //禁止名单图个数
    struRegisterPic: array[0..MAX_HUMAN_PICTURE_NUM-1] of NET_VCA_PICMODEL_RESULT;  //禁止名单图片信息
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_VCA_BLOCKLIST_PARA = ^NET_VCA_BLOCKLIST_PARA;

type
  NET_VCA_BLOCKLIST_COND = record 
    lChannel: LONG;  //通道号
    dwGroupNo: DWORD;  //分组号
    byType: BYTE;  //名单标志：0-全部，1-允许名单，2-禁止名单
    byLevel: BYTE;  //禁止名单等级，0-全部，1-低，2-中，3-高
    byRes1: array[0..2-1] of BYTE;  //保留
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_VCA_BLOCKLIST_COND = ^NET_VCA_BLOCKLIST_COND;

type
  NET_VCA_BLOCKLIST_PIC = record 
    dwSize: DWORD;  //结构大小
    dwFacePicNum: DWORD;  //人脸图个数
    byRes: array[0..20-1] of BYTE;  //保留
    struBlockListPic: array[0..MAX_HUMAN_PICTURE_NUM-1] of NET_VCA_PICMODEL_RESULT;  //单张照片信息
  end;
  LPNET_VCA_BLOCKLIST_PIC = ^NET_VCA_BLOCKLIST_PIC;

type
  NET_VCA_FIND_PICTURECOND = record 
    lChannel: LONG;  //通道号
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_VCA_FIND_PICTURECOND = ^NET_VCA_FIND_PICTURECOND;

const
  MAX_FACE_PIC_LEN = 6144;    //最大人脸图片数据长度
type
  NET_VCA_SUB_SNAPPIC_DATA = record 
    dwFacePicID: DWORD;  //人脸图ID
    dwFacePicLen: DWORD;  //人脸图数据长度
    struSnapTime: NET_DVR_TIME;  //抓拍时间
    dwSimilarity: DWORD;  //相似度
    byRes: array[0..16-1] of BYTE;  //保留
    sPicBuf: array[0..MAX_FACE_PIC_LEN-1] of AnsiChar;  //图片数据
  end;
  LPNET_VCA_SUB_SNAPPIC_DATA = ^NET_VCA_SUB_SNAPPIC_DATA;

type
  NET_VCA_ADVANCE_FIND = record 
    dwFacePicID: DWORD;  //人脸图片ID
    byRes: array[0..36-1] of BYTE;  
  end;
  LPNET_VCA_ADVANCE_FIND = ^NET_VCA_ADVANCE_FIND;

type
  NET_VCA_NORMAL_FIND = record 
    dwImageID: DWORD;  //大图ID
    dwFaceScore: DWORD;  //人脸评分
    struVcaRect: NET_VCA_RECT;  //人脸子图区域
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_VCA_NORMAL_FIND = ^NET_VCA_NORMAL_FIND;

type
  NET_VCA_FIND_SNAPPIC_UNION = record 
    case Byte of
    0: (struNormalFind: NET_VCA_NORMAL_FIND);  //普通检索
    1: (struAdvanceFind: NET_VCA_ADVANCE_FIND);  //高级检索
  end;
  LPNET_VCA_FIND_SNAPPIC_UNION = ^NET_VCA_FIND_SNAPPIC_UNION;

type
  VCA_FIND_SNAPPIC_TYPE =  
  (  
    VCA_NORMAL_FIND = $00000000,  //普通检索
    VCA_ADVANCE_FIND = $00000001  //高级检索
  );

type
  NET_VCA_FIND_PICTURECOND_ADVANCE = record 
    lChannel: LONG;  //通道号
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
    byThreshold: BYTE;  //阈值，0-100
    byRes: array[0..23-1] of BYTE;  //保留
    dwFindType: VCA_FIND_SNAPPIC_TYPE;  //检索类型，详见VCA_FIND_SNAPPIC_TYPE
    uFindParam: NET_VCA_FIND_SNAPPIC_UNION;  //检索参数
  end;
  LPNET_VCA_FIND_PICTURECOND_ADVANCE = ^NET_VCA_FIND_PICTURECOND_ADVANCE;

type
  NET_VCA_FACESNAP_INFO_ALARM = record 
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    dwSnapFacePicID: DWORD;  //抓拍人脸图ID
    dwSnapFacePicLen: DWORD;  //抓拍人脸子图的长度，为0表示没有图片，大于0表示有图片
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    byFaceScore: BYTE;  //人脸评分，指人脸子图的质量的评分,0-100
    bySex: BYTE;  //性别，0-未知，1-男，2-女,0xff-算法支持，但是没有识别出来
    byGlasses: BYTE;  //是否带眼镜，0-未知，1-是，2-否,3-戴墨镜, 0xff-算法支持，但是没有识别出来
 {
 识别人脸的段范围[byRes1-byDeviation,byRes1+byDeviation]
 }
    byRes1: BYTE;  //0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
    byDeviation: BYTE;  //误差值
    byGroup: BYTE;  //若传入0xff表示未知
    {人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
    该质量评估算法仅针对人脸子图单张图片,具体是通过姿态、清晰度、遮挡情况、光照情况等可影响人脸识别性能的因素综合评估的结果}
    byFacePicQuality: BYTE;  
    byRes: BYTE;  
    dwUIDLen: DWORD;  // 上传报警的标识长度
    pUIDBuffer: PBYTE;  //标识指针
    fStayDuration: FLOAT;  //停留画面中时间(单位: 秒)
    pBuffer1: PBYTE;  //抓拍人脸子图的图片数据
  end;
  LPNET_VCA_FACESNAP_INFO_ALARM = ^NET_VCA_FACESNAP_INFO_ALARM;

type
  NET_VCA_BLOCKLIST_INFO_ALARM = record 
    struBlockListInfo: NET_VCA_BLOCKLIST_INFO;  //禁止名单基本信息
    dwBlockListPicLen: DWORD;  //禁止名单人脸子图的长度，为0表示没有图片，大于0表示有图片
    dwFDIDLen: DWORD;  // 人脸库ID长度
    pFDID: PBYTE;  //人脸库Id指针
    dwPIDLen: DWORD;  // 人脸库图片ID长度
    pPID: PBYTE;  //人脸库图片ID指针
    wThresholdValue: WORD;  //人脸库阈值[0,100]
    byIsNoSaveFDPicture: BYTE;  //0-保存人脸库图片,1-不保存人脸库图片, 若开启了导入图片或者建模时不保存原图功能时,该字段返回1,此时人脸库图片将不再返回
    byRealTimeContrast: BYTE;  //是否实时报警 0-实时 1-非实时
    pBuffer1: PBYTE;  //禁止名单人脸子图的图片数据
  end;
  LPNET_VCA_BLOCKLIST_INFO_ALARM = ^NET_VCA_BLOCKLIST_INFO_ALARM;

type
  NET_VCA_FACESNAP_MATCH_ALARM = record 
    dwSize: DWORD;  // 结构大小
    fSimilarity: FLOAT;  //相似度，[0.001,1]
    struSnapInfo: NET_VCA_FACESNAP_INFO_ALARM;  //抓拍信息
    struBlockListInfo: NET_VCA_BLOCKLIST_INFO_ALARM;  //禁止名单信息
    sStorageIP: array[0..16-1] of AnsiChar;  //存储服务IP地址
    wStoragePort: WORD;  //存储服务端口号
    byMatchPicNum: BYTE;  //匹配图片的数量，0-保留（老设备这个值默认0，新设备这个值为0时表示后续没有匹配的图片信息）
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    dwSnapPicLen: DWORD;  //设备识别抓拍图片长度
    pSnapPicBuffer: PBYTE;  //设备识别抓拍图片指针
    struRegion: NET_VCA_RECT;  //目标边界框，设备识别抓拍图片中，人脸子图坐标
    dwModelDataLen: DWORD;  //建模数据长度
    pModelDataBuffer: PBYTE;  // 建模数据指针
    byModelingStatus: BYTE;  // 建模状态
    byLivenessDetectionStatus: BYTE;  //活体检测状态：0-保留，1-未知（检测失败），2-非真人人脸，3-真人人脸，4-未开启活体检测
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,0xff无效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，0xff无效
    byMask: BYTE;  //抓拍图是否戴口罩，0-保留，1-未知，2-不戴口罩，3-戴口罩
    bySmile: BYTE;  //抓拍图是否微笑，0-保留，1-未知，2-不微笑，3-微笑
    byContrastStatus: BYTE;  //比对结果，0-保留，1-比对成功，2-比对失败
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不是重传数据，1-重传数据
  end;
  LPNET_VCA_FACESNAP_MATCH_ALARM = ^NET_VCA_FACESNAP_MATCH_ALARM;

type
  NET_VCA_BLOCKLIST_INFO_ALARM_LOG = record 
    struBlockListInfo: NET_VCA_BLOCKLIST_INFO;  //禁止名单基本信息
    dwBlockListPicID: DWORD;  //禁止名单人脸子图ID，用于查找图片
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_BLOCKLIST_INFO_ALARM_LOG = ^NET_VCA_BLOCKLIST_INFO_ALARM_LOG;

type
  NET_VCA_FACESNAP_INFO_ALARM_LOG = record 
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    dwSnapFacePicID: DWORD;  //抓拍人脸图ID
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FACESNAP_INFO_ALARM_LOG = ^NET_VCA_FACESNAP_INFO_ALARM_LOG;

type
  NET_VCA_FACESNAP_MATCH_ALARM_LOG = record 
    dwSize: DWORD;  // 结构大小
    fSimilarity: FLOAT;  //相似度，[0.001,1]
    struSnapInfoLog: NET_VCA_FACESNAP_INFO_ALARM_LOG;  //抓拍信息
    struBlockListInfoLog: NET_VCA_BLOCKLIST_INFO_ALARM_LOG;  //禁止名单信息
    byRes: array[0..60-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FACESNAP_MATCH_ALARM_LOG = ^NET_VCA_FACESNAP_MATCH_ALARM_LOG;

type
  NET_VCA_FACEMATCH_PICCOND = record 
    dwSize: DWORD;  // 结构大小
    dwSnapFaceID: DWORD;  //抓拍人脸子图ID
    dwBlockListID: DWORD;  //匹配的禁止名单ID
    dwBlockListFaceID: DWORD;  //比对的禁止名单人脸子图ID
    byRes: array[0..20-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FACEMATCH_PICCOND = ^NET_VCA_FACEMATCH_PICCOND;

type
  NET_VCA_FACEMATCH_PICTURE = record 
    dwSize: DWORD;  // 结构大小
    dwSnapFaceLen: DWORD;  //抓拍人脸子图长度
    dwBlockListFaceLen: DWORD;  //比对的禁止名单人脸子图长度
    byRes: array[0..20-1] of BYTE;  //保留字节
    pSnapFace: PBYTE;  //抓拍人脸子图的图片数据
    pBlockListFace: PBYTE;  //比对的禁止名单人脸子图数据
  end;
  LPNET_VCA_FACEMATCH_PICTURE = ^NET_VCA_FACEMATCH_PICTURE;

type
  NET_VCA_BLOCKLIST_FASTREGISTER_PARA = record 
    dwSize: DWORD;  //结构大小
    struBlockListInfo: NET_VCA_BLOCKLIST_INFO;  //禁止名单基本参数
    dwImageLen: DWORD;  //图像数据长度
    byRes: array[0..124-1] of BYTE;  //保留
    pImage: PBYTE;  //图像数据
  end;
  LPNET_VCA_BLOCKLIST_FASTREGISTER_PARA = ^NET_VCA_BLOCKLIST_FASTREGISTER_PARA;

//******PJ01C20170209084超脑录播NVS软件功能开发定制项目专用*****
//单帧画面人数统计结果上传
type
  NET_DVR_FRAMES_PEOPLE_COUNTING = record 
    dwSize: DWORD;  // 结构体大小
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  // 绝对时标
    dwPeopleCountingNum: DWORD;  //画面中的人数统计数量
    dwPicLen: DWORD;  //设备识别抓拍的全景图片数据长度
    pPicBuffer: PBYTE;  //设备识别抓拍的全景图片数据指针
    byRes: array[0..512-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_FRAMES_PEOPLE_COUNTING = ^NET_DVR_FRAMES_PEOPLE_COUNTING;
//******PJ01C20170209084超脑录播NVS软件功能开发定制项目专用*****

//单个分区配置
type
  NET_VCA_SINGLE_PATH = record 
    byActive: BYTE;  // 是否可用,0-否,1-是
    byType: BYTE;  //0-存储抓拍，1-存储禁止名单比对报警，2-存储抓拍和禁止名单比对报警，0xff-无效
    bySaveAlarmPic: BYTE;  //是否用于保存断网的报警图片，0-否，1-是
    byRes1: array[0..5-1] of BYTE;  //保留
    dwDiskDriver: DWORD;  //盘符号，从0开始
    dwLeftSpace: DWORD;  //预留容量（单位为G）
    byRes2: array[0..8-1] of BYTE;  //保留
  end;
  LPNET_VCA_SINGLE_PATH = ^NET_VCA_SINGLE_PATH;

//存储路径设置
type
  NET_VCA_SAVE_PATH_CFG = record 
    dwSize: DWORD;  //结构大小
    struPathInfo: array[0..MAX_DISKNUM_V30-1] of NET_VCA_SINGLE_PATH;  //单个分区
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_VCA_SAVE_PATH_CFG = ^NET_VCA_SAVE_PATH_CFG;

type
  NET_DVR_DEV_ACCESS_CFG = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  //接入设备的IP地址
    wDevicePort: WORD;  //端口号
    byEnable: BYTE;  //是否启用，0-否，1-是
    byRes1: BYTE;  //保留
    sUserName: array[0..NAME_LEN-1] of BYTE;  //接入设备的登录帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //接入设备的登录密码
    byRes2: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_DEV_ACCESS_CFG = ^NET_DVR_DEV_ACCESS_CFG;

//*******************************智能人脸识别 end***************************
//分辨率
function MAKE_RESOLUTION(interlace, width, height, fps: Integer): Integer;
function GET_RES_INTERLACE(res: Integer): Integer;
function GET_RES_WIDTH(res: Integer): Integer;
function GET_RES_HEIGHT(res: Integer): Integer;
function GET_RES_FPS(res: Integer): Integer;

const
  NOT_AVALIABLE = 0;   //MAKE_RESOLUTION(0, 0, 0, 0);    
  SVGA_60HZ = 11324;   //MAKE_RESOLUTION(0, 800, 600, 60);    
  SVGA_75HZ = 11339;   //MAKE_RESOLUTION(0, 800, 600, 75);    
  XGA_60HZ = 32828;   //MAKE_RESOLUTION(0, 1024, 768, 60);    
  XGA_75HZ = 32843;   //MAKE_RESOLUTION(0, 1024, 768, 75);    
  SXGA_60HZ = 60;   //MAKE_RESOLUTION(0, 1280, 1024, 60);    
  SXGA2_60HZ = 57404;   //MAKE_RESOLUTION(0, 1280, 960, 60);    
  _720P_24HZ = 26648;   //MAKE_RESOLUTION(0, 1280, 720, 24);    
  _720P_25HZ = 26649;   //MAKE_RESOLUTION(0, 1280, 720, 25);    
  _720P_30HZ = 26654;   //MAKE_RESOLUTION(0, 1280, 720, 30);    
  _720P_60HZ = 26684;   //MAKE_RESOLUTION(0, 1280, 720, 60);    
  _720P_50HZ = 26674;   //MAKE_RESOLUTION(0, 1280, 720, 50);    
  _1080I_60HZ = 7228;   //MAKE_RESOLUTION(1, 1920, 1080, 60);    
  _1080I_50HZ = 7218;   //MAKE_RESOLUTION(1, 1920, 1080, 50);    
  _1080P_60HZ = 7228;   //MAKE_RESOLUTION(0, 1920, 1080, 60);    
  _1080P_50HZ = 7218;   //MAKE_RESOLUTION(0, 1920, 1080, 50);    
  _1080P_30HZ = 7198;   //MAKE_RESOLUTION(0, 1920, 1080, 30);    
  _1080P_25HZ = 7193;   //MAKE_RESOLUTION(0, 1920, 1080, 25);    
  _1080P_24HZ = 7192;   //MAKE_RESOLUTION(0, 1920, 1080, 24);    
  UXGA_60HZ = 22588;   //MAKE_RESOLUTION(0, 1600, 1200, 60);    
  UXGA_30HZ = 22558;   //MAKE_RESOLUTION(0, 1600, 1200, 30);    
  WSXGA_60HZ = 3388;   //MAKE_RESOLUTION(0, 1680, 1050, 60);    
  WUXGA_60HZ = 22588;   //MAKE_RESOLUTION(0, 1920, 1200, 60);    
  WUXGA_30HZ = 22558;   //MAKE_RESOLUTION(0, 1920, 1200, 30);    
  WXGA_60HZ = 32828;   //MAKE_RESOLUTION(0, 1360, 768, 60);    
  SXGA_PLUS_60HZ = 3388;   //MAKE_RESOLUTION(0, 1400, 1050, 60);    
  VGA_MODE_3840x2160_30HZ = 14366;   //MAKE_RESOLUTION(0, 3840, 2160, 30);    
  VGA_MODE_3840x2160_60HZ = 14396;   //MAKE_RESOLUTION(0, 3840, 2160, 60);    



//显示通道画面分割模式
const
  MAX_WINDOWS_NUM = 12;    //画面分割模式的数量
  MAX_SUPPORT_RES = 32;    
  MAX_DISPNUM_V41 = 32;    
  MAX_SDI_RES = 16;    //SDI显示通道最大支持分辨率数

type
  NET_DVR_DISPWINDOWMODE = record 
    byDispChanType: BYTE;  //显示通道类型：0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
    byDispChanSeq: BYTE;  //显示通道序号,从1开始，如果类型是VGA，则表示第几个VGA
    byRes: array[0..2-1] of BYTE;  
    byDispMode: array[0..MAX_WINDOWS_NUM{12}-1] of BYTE;  
  end;
  LPNET_DVR_DISPWINDOWMODE = ^NET_DVR_DISPWINDOWMODE;

type
  NET_DVR_DISPINFO = record 
    byChanNums: BYTE;  //通道个数
    byStartChan: BYTE;  //起始通道
    byRes: array[0..2-1] of BYTE;  
    dwSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持分辨率
  end;
  LPNET_DVR_DISPINFO = ^NET_DVR_DISPINFO;

//大屏拼接信息
type
  NET_DVR_SCREENINFO = record 
    bySupportBigScreenNums: BYTE;  //最多大屏拼接数量
    byStartBigScreenNum: BYTE;  //大屏拼接起始号
    byMaxScreenX: BYTE;  //大屏拼接模式
    byMaxScreenY: BYTE;  
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_SCREENINFO = ^NET_DVR_SCREENINFO;

type
  NET_DVR_SDI_INFO = record 
    byChanNums: BYTE;  //通道个数
    byStartChan: BYTE;  //起始通道
    byRes: array[0..2-1] of BYTE;  
    dwSupportResolution: array[0..MAX_SDI_RES{16}-1] of DWORD;  //支持分辨率
  end;
  LPNET_DVR_SDI_INFO = ^NET_DVR_SDI_INFO;

type
  NET_DVR_MATRIX_ABILITY_V41 = record 
    dwSize: DWORD;  
    byDspNums: BYTE;  //DSP个数
    byDecChanNums: BYTE;  //解码通道数
    byStartChan: BYTE;  //起始解码通道
    byRes1: array[0..5-1] of BYTE;  
    struVgaInfo: NET_DVR_DISPINFO;  //VGA显示通道信息
    struBncInfo: NET_DVR_DISPINFO;  //BNC显示通道信息
    struHdmiInfo: NET_DVR_DISPINFO;  //HDMI显示通道信息
    struDviInfo: NET_DVR_DISPINFO;  //DVI显示通道信息
    struDispMode: array[0..MAX_DISPNUM_V41{32}-1] of NET_DVR_DISPWINDOWMODE;  
    struBigScreenInfo: NET_DVR_SCREENINFO;  
    bySupportAutoReboot: BYTE;  //是否支持自动重启，0-不支持，1-支持
    byRes2: array[0..3-1] of BYTE;  
    struSDIInfo: NET_DVR_SDI_INFO;  //SDI显示通道信息
    byRes3: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_ABILITY_V41 = ^NET_DVR_MATRIX_ABILITY_V41;

//显示通道配置
//  MAX_WINDOWS = 16;    
const
  MAX_WINDOWS_V41 = 36;    

const
  STARTDISPCHAN_VGA = 1;    
  STARTDISPCHAN_BNC = 9;    
  STARTDISPCHAN_HDMI = 25;    
  STARTDISPCHAN_DVI = 29;    

type
  NET_DVR_VIDEO_PLATFORM = record 
    case Byte of
    0: (byRes: array[0..160-1] of BYTE);  
    1: (struVideoPlatform: record

        //各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)
        //如果综合平台支持自动分配解码资源，此参数不需要填充
      byJoinDecoderId: array[0..MAX_WINDOWS_V41-1] of BYTE;  
        //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
      byDecResolution: array[0..MAX_WINDOWS_V41-1] of BYTE;  
      struPosition: NET_DVR_RECTCFG;  //显示通道在电视墙中位置
      byRes: array[0..80-1] of BYTE;  
    end);  
    2: (struNotVideoPlatform: record
      byRes: array[0..160-1] of BYTE;  
    end);  
  end;
  LPNET_DVR_VIDEO_PLATFORM = ^NET_DVR_VIDEO_PLATFORM;


type
  NET_DVR_MATRIX_VOUTCFG = record 
    dwSize: DWORD;  
    byAudio: BYTE;  //音频是否开启
    byAudioWindowIdx: BYTE;  //音频开启子窗口
    byDispChanType: BYTE;  //显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI，4-YPbPr(解码卡服务器DECODER_SERVER专用)
    byVedioFormat: BYTE;  //1:NTSC,2:PAL，0-NULL
    dwResolution: DWORD;  //分辨率
    dwWindowMode: DWORD;  //画面模式，能力集获取
    byJoinDecChan: array[0..MAX_WINDOWS_V41-1] of BYTE;  //各个子窗口关联的解码通道,设备支持解码资源自动分配时此参数不用填充
    byEnlargeStatus: BYTE;  //是否处于放大状态，0：不放大，1：放大
    byEnlargeSubWindowIndex: BYTE;  //放大的子窗口号
    byScale: BYTE;  //显示模式，0---真实显示，1---缩放显示( 针对BNC )
    byUnionType: BYTE;  //区分共用体,0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
    struDiff: NET_DVR_VIDEO_PLATFORM;  
    dwDispChanNum: DWORD;  //显示输出号，此参数在全部获取时有效
    wLEDWidth: WORD;  //LED分辨率宽，0为无效
    wLEDHeight: WORD;  //LED分辨率高，0为无效
    byEnableVideoEffect: BYTE;  //显示效果使能， 0-不使能， !0-使能
    byRes: array[0..3-1] of BYTE;  //保留字段
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //显示效果
    byRes2: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_VOUTCFG = ^NET_DVR_MATRIX_VOUTCFG;

//解码器设备状态
type
  NET_DVR_DISP_CHAN_STATUS_V41 = record 
    byDispStatus: BYTE;  //显示状态：0：未显示，1：启动显示
    byBVGA: BYTE;  //0-BNC，1-VGA， 2-HDMI，3-DVI，4-SDI 0xff-无效
    byVideoFormat: BYTE;  //视频制式，1:NTSC,2:PAL,0-NON
    byWindowMode: BYTE;  //画面模式
    byJoinDecChan: array[0..MAX_WINDOWS_V41-1] of BYTE;  //各个子画面关联的解码通道
    byFpsDisp: array[0..MAX_WINDOWS_V41-1] of BYTE;  //每个子画面的显示帧率
    byScreenMode: BYTE;  //屏幕模式0-普通 1-大屏
    byRes1: array[0..3-1] of BYTE;  
    dwDispChan: DWORD;  //获取全部显示通道状态时有效，设置时可填0
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_DISP_CHAN_STATUS_V41 = ^NET_DVR_DISP_CHAN_STATUS_V41;

//解码器设备状态
type
  NET_DVR_DECODER_WORK_STATUS_V41 = record 
    dwSize: DWORD;  
    struDecChanStatus: array[0..32-1] of NET_DVR_MATRIX_CHAN_STATUS;  //解码通道状态
    //显示通道状态
    struDispChanStatus: array[0..MAX_DISPNUM_V41{32}-1] of NET_DVR_DISP_CHAN_STATUS_V41;  
    byAlarmInStatus: array[0..32-1] of BYTE;  //报警输入状态
    byAlarmOutStatus: array[0..32-1] of BYTE;  //报警输出状态
    byAudioInChanStatus: BYTE;  //语音对讲状态
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_DECODER_WORK_STATUS_V41 = ^NET_DVR_DECODER_WORK_STATUS_V41;
//******************************文件回放-远程回放设置******************************
type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  // DVR IP地址 
    wDVRPort: WORD;  // 端口号 
    byChannel: BYTE;  // 通道号 
    byReserve: BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwPlayMode: DWORD;  // 0－按文件 1－按时间
    StartTime: NET_DVR_TIME;  
    StopTime: NET_DVR_TIME;  
    sFileName: array[0..128-1] of AnsiChar;  
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;


const
  MAX_BIGSCREENNUM_SCENE = 100;    
//  MAX_LAYERNUMS = 32;    

//显示通道配置结构
type
  NET_DVR_RECTCFG_SCENE = record 
    wXCoordinate: WORD;  //矩形左上角起始点X坐标
    wYCoordinate: WORD;  //矩形左上角Y坐标
    wWidth: WORD;  //矩形宽度
    wHeight: WORD;  //矩形高度
  end;
  LPNET_DVR_RECTCFGSCENE = ^NET_DVR_RECTCFG_SCENE;

type
  NET_DVR_SCENEDISPCFG = record 
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    bySoltNum: BYTE;  //槽位号
    byRes1: array[0..2-1] of BYTE;  
    byDispChanNum: BYTE;  
    byAudio: BYTE;  //音频是否开启,0-否，1-是
    byAudioWindowIdx: BYTE;  //音频开启子窗口
    byVedioFormat: BYTE;  //1:NTSC,2:PAL，0-NULL
    byWindowMode: BYTE;  //画面模式，从能力集获取
    byEnlargeStatus: BYTE;  //是否处于放大状态，0：不放大，1：放大
    byEnlargeSubWindowIndex: BYTE;  //放大的子窗口号
    byScale: BYTE;  //显示模式，0-真实显示，1-缩放显示( 针对BNC )
    dwResolution: DWORD;  //分辨率
    byJoinDecChan: array[0..MAX_WINDOWS_V41-1] of BYTE;  //各个子窗口关联的解码通道
    byJoinDecoderId: array[0..MAX_WINDOWS_V41-1] of BYTE;  //槽位号
    //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
    byDecResolution: array[0..MAX_WINDOWS_V41-1] of BYTE;  
    byRow: BYTE;  //大屏所在的行的序号
    byColumn: BYTE;  //大屏所在的列的序号
    byRes2: array[0..5-1] of BYTE;  
    struDisp: NET_DVR_RECTCFG;  //电视墙显示位置
  end;
  LPNET_DVR_SCENEDISPCFG = ^NET_DVR_SCENEDISPCFG;

type
  NET_DVR_DEV_CHAN_INFO_SCENE = record 
    struIP: NET_DVR_IPADDR;  // DVR IP地址 
    wDVRPort: WORD;  // 端口号 
    byChannel: BYTE;  // 通道号，对于9000等设备的IPC接入，通道号从33开始 
    byTransProtocol: BYTE;  // 传输协议类型0-TCP，1-UDP ，2-MCAST，3-RTP
    byTransMode: BYTE;  // 传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型
    byDeviceType: BYTE;  //设备类型，1-IPC，2- ENCODER
    byRes: array[0..5-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 布防主机登陆帐号 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 布防主机密码 
  end;
  LPNET_DVR_DEV_CHAN_INFO_SCENE = ^NET_DVR_DEV_CHAN_INFO_SCENE;

//流媒体服务器基本配置
type
  NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE = record 
    byValid: BYTE;  //是否启用流媒体服务器取流,0表示无效
    byRes1: array[0..3-1] of BYTE;  
    struDevIP: NET_DVR_IPADDR;  //流媒体服务器地址
    wDevPort: WORD;  //流媒体服务器端口
    byTransmitType: BYTE;  //传输协议类型0-TCP，1-UDP 
    byRes2: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE = ^NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

type
  NET_DVR_PU_STREAM_CFG_SCENE = record 
    streamMediaServerCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO_SCENE;  
  end;
  LPNET_DVR_PU_STREAM_CFG_SCENE = ^NET_DVR_PU_STREAM_CFG_SCENE;

type
  NET_DVR_CYC_SUR_CHAN_ELE_SCENE = record 
    byEnable: BYTE;  // 是否启用 0－否 1－启用
    byRes: array[0..3-1] of BYTE;  
    struStreamMediaSvrCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;  
    struDecChanInfo: NET_DVR_DEV_CHAN_INFO_SCENE;  //轮巡解码通道信息
  end;
  LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE = ^NET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//轮巡解码结构
type
  NET_DVR_MATRIX_LOOP_DECINFO_SCENE = record 
    wPoolTime: WORD;  //轮询间隔
    byRes1: array[0..2-1] of BYTE;  
    struChanArray: array[0..MAX_CYCLE_CHAN{16}-1] of NET_DVR_CYC_SUR_CHAN_ELE_SCENE;  
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE = ^NET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//单个解码通道配置结构体
type
  NET_DVR_DECODECHANCFG_SCENE = record //struct size : 2064
    byDecodeEnable: BYTE;  //解码起停标志，0-停止，1-启用动态解码，2-启用轮巡解码
    bySlotNum: BYTE;  //槽位号
    byDecChan: BYTE;  
    byJointAllDecodeChan: BYTE;  //是否关联解码通道 0-不关联，1-关联
    byJointSlotNum: BYTE;  //关联的槽位号（解码板的槽位号）
    byJointChanNum: BYTE;  //关联的通道号（解码板通道号）
    byRes: array[0..2-1] of BYTE;  
    struDecCfg: record 
      case Byte of
      0: (struSceneDynamicDecCfg: NET_DVR_PU_STREAM_CFG_SCENE);  
      1: (struSceneCycDecCfg: NET_DVR_MATRIX_LOOP_DECINFO_SCENE);  
    end;  
  end;
  LPNET_DVR_DECODECHANCFG_SCENE = ^NET_DVR_DECODECHANCFG_SCENE;

type
  NET_DVR_BIGSCREENCFG_SCENE = record 
    byAllValid: BYTE;  //漫游使能标志 
    byAssociateBaseMap: BYTE;  //关联的底图序号，0代表不关联
    byEnableSpartan: BYTE;  //大屏畅显使能，1-开，0-关
    byRes: BYTE;  
    struWinCfg: array[0..MAX_LAYERNUMS-1] of NET_DVR_WINCFG;  
    struBigScreen: NET_DVR_BIGSCREENCFG;  
  end;
  LPNET_DVR_BIGSCREENCFG_SCENE = ^NET_DVR_BIGSCREENCFG_SCENE;

type
  NET_DVR_MATRIX_SCENECFG = record 
    dwSize: DWORD;  
    sSceneName: array[0..NAME_LEN-1] of BYTE;  
    byBigScreenNums: BYTE;  //大屏的个数，最大值通过能力集获取
    byRes1: array[0..3-1] of BYTE;  
    wDecChanNums: WORD;  //场景中解码通道的个数
    wDispChanNums: WORD;  //场景中显示通道的个数
    byRes2: array[0..12-1] of BYTE;  
    pBigScreenBuffer: PBYTE;  //大屏配置缓冲区, byBigScreenNums×sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    pDecChanBuffer: PBYTE;  //解码通道配置缓冲区, wDecChanNums×sizeof(NET_DVR_DECODECHANCFG_SCENE)
    pDispChanBuffer: PBYTE;  //显示通道配置缓冲区, wDispChanNums×sizeof(NET_DVR_SCENEDISPCFG)
  end;
  LPNET_DVR_MATRIX_SCENECFG = ^NET_DVR_MATRIX_SCENECFG;



type
  NET_DVR_BIGSCREENASSOCIATECFG = record 
    dwSize: DWORD;  
    byEnableBaseMap: BYTE;  //使能底图显示
    byAssociateBaseMap: BYTE;  //关联的底图序号，0代表不关联
    byEnableSpartan: BYTE;  //大屏畅显使能，1-开，0-关
    byRes: array[0..21-1] of BYTE;  
  end;
  LPNET_DVR_BIGSCREENASSOCIATECFG = ^NET_DVR_BIGSCREENASSOCIATECFG;
//******************************窗口设置******************************
const
  MAX_WIN_COUNT = 224;    //支持的最大开窗数

type
  NET_DVR_SCREEN_WINCFG = record 
    dwSize: DWORD;  
    byVaild: BYTE;  
    byInputType: BYTE;  //见CAM_MDOE
    wInputIdx: WORD;  //输入源索引
    dwLayerIdx: DWORD;  //图层，0为最底层
    struWin: NET_DVR_RECTCFG;  //目的窗口(相对显示墙)
    byWndIndex: BYTE;  //窗口号
    byCBD: BYTE;  //0-无，1-带背景，2-不带背景
    bySubWnd: BYTE;  //0不是，1是
    byRes1: BYTE;  
    dwDeviceIndex: DWORD;  //设备序号
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_WINCFG = ^NET_DVR_SCREEN_WINCFG;

type
  NET_DVR_WINLIST = record 
    dwSize: DWORD;  
    wScreenSeq: WORD;  //设备序号
    byRes: array[0..10-1] of BYTE;  
    dwWinNum: DWORD;  //设备返回的窗口数量
    pBuffer: PBYTE;  //窗口信息缓冲区，最大为224*sizeof(NET_DVR_WINCFG)
    dwBufLen: DWORD;  //所分配指针长度
  end;
  LPNET_DVR_WINLIST = ^NET_DVR_WINLIST;

const
  MAX_LAYOUT_COUNT = 16;    //最大布局数
type
  NET_DVR_LAYOUTCFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  //布局是否有效
    byRes1: array[0..3-1] of BYTE;  
    byLayoutName: array[0..NAME_LEN{32}-1] of BYTE;  //布局名称
    struWinCfg: array[0..MAX_WIN_COUNT{224}-1] of NET_DVR_SCREEN_WINCFG;  //布局内窗口参数
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_LAYOUTCFG = ^NET_DVR_LAYOUTCFG;

type
  NET_DVR_LAYOUT_LIST = record 
    dwSize: DWORD;  
    struLayoutInfo: array[0..MAX_LAYOUT_COUNT{16}-1] of NET_DVR_LAYOUTCFG;  //所有布局
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_LAYOUT_LIST = ^NET_DVR_LAYOUT_LIST;

const
  MAX_CAM_COUNT = 224;    
  MAX_CAM_COUNT_V50 = 512;    

type
  NET_DVR_CAM_MODE =  
  (  
    NET_DVR_UNKNOW = 0,  //无效
    NET_DVR_CAM_BNC,  
    NET_DVR_CAM_VGA,  
    NET_DVR_CAM_DVI,  
    NET_DVR_CAM_HDMI,  
    NET_DVR_CAM_IP,  
    NET_DVR_CAM_RGB,  
    NET_DVR_CAM_DECODER,  
    NET_DVR_CAM_MATRIX,  
    NET_DVR_CAM_YPBPR,  
    NET_DVR_CAM_USB,  
    NET_DVR_CAM_SDI,  
    NET_DVR_CAM_HDI,  
    NET_DVR_CAM_DP,  //此类型视频综合平台不返回
    NET_DVR_CAM_HDTVI,  
    NET_DVR_CAM_JOINT,  //拼接信号源
    NET_DVR_CAM_HDBASET,  
    NET_DVR_CAM_DVIT,  //DVI双链路，此类型视频综合平台不返回
    NET_DVR_CAM_FUSION,  //多IPC拼接
    NET_DVR_CAM_VSCREEN,  //虚拟屏
    NET_DVR_CAM_FIBER,  //光纤
    NET_DVR_CAM_3GSDI,  //3G-SDI
    NET_DVR_CAM_DISTRIBUTED_IP,  //分布式网络源
    NET_DVR_CAM_JONIT_X86,  // x86拼接子系统的拼接通道
    NET_DVR_CAM_TVI  //TVI信号源
  );

type
  NET_DVR_INPUTSTREAMCFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  
    byCamMode: BYTE;  //信号输入源类型，见NET_DVR_CAM_MODE
    wInputNo: WORD;  //信号源序号0-224
    sCamName: array[0..NAME_LEN-1] of BYTE;  //信号输入源名称
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //视频参数
    struPuStream: NET_DVR_PU_STREAM_CFG;  //ip输入时使用
    wBoardNum: WORD;  //信号源所在的板卡号
    wInputIdxOnBoard: WORD;  //信号源在板卡上的位置
    dwResolution: DWORD;  //分辨率
    byVideoFormat: BYTE;  //视频制式，见VIDEO_STANDARD
    byStatus: BYTE;  //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常
    sGroupName: array[0..NAME_LEN{32}-1] of BYTE;  //网络信号源分组 组名
    byJointMatrix: BYTE;  //  关联矩阵 ，0-不关联  1-关联
    byRes: BYTE;  
  end;
  LPNET_DVR_INPUTSTREAMCFG = ^NET_DVR_INPUTSTREAMCFG;

type
  NET_DVR_INPUTSTREAM_LIST = record 
    dwSize: DWORD;  
    struInputStreamInfo: array[0..MAX_CAM_COUNT-1] of NET_DVR_INPUTSTREAMCFG;  //所有信号源
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_INPUTSTREAM_LIST = ^NET_DVR_INPUTSTREAM_LIST;

//******************************输出参数配置******************************
//输出通道管理
type
  NET_DVR_OUTPUTPARAM = record 
    dwSize: DWORD;  
    byMonMode: BYTE;  //输出连接模式,1-BNC,2-VGA,3-DVI,4-HDMI
    byRes1: array[0..3-1] of BYTE;  
    dwResolution: DWORD;  //分辨率，根据能力集获取所支持的进行设置
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //输出通道视频参数配置
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OUTPUTPARAM = ^NET_DVR_OUTPUTPARAM;

type
  NET_DVR_OUTPUTCFG = record 
    dwSize: DWORD;  
    byScreenLayX: BYTE;  //大屏布局-横坐标
    byScreenLayY: BYTE;  //大屏布局-纵坐标
    wOutputChanNum: WORD;  //输出通道个数，0表示设备支持的最大输出通道个数，最大个数从能力集获取，其他值表示实际输出通道个数
    byRes1: array[0..4-1] of BYTE;  
    struOutputParam: NET_DVR_OUTPUTPARAM;  //输出通道视频参数配置
    sWallName: array[0..16-1] of BYTE;  //电视墙名称
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_OUTPUTCFG = ^NET_DVR_OUTPUTCFG;

//******************************能力集******************************
const
  SCREEN_PROTOCOL_NUM = 20;    //支持的最大大屏控制器协议数
//多屏服务器能力集
type
  NET_DVR_SCREENSERVER_ABILITY = record 
    dwSize: DWORD;  //结构长度
    byIsSupportScreenNum: BYTE;  //所支持大屏控制器的数目
    bySerialNums: BYTE;  //串口个数
    byMaxInputNums: BYTE;  
    byMaxLayoutNums: BYTE;  
    byMaxWinNums: BYTE;  
    byRes1: array[0..19-1] of BYTE;  
    byMaxScreenLayX: BYTE;  //大屏布局-最大横坐标大屏数
    byMaxScreenLayY: BYTE;  //大屏布局-最大纵坐标大屏数
    wMatrixProtoNum: WORD;  //有效的大屏协议数目
    struScreenProto: array[0..SCREEN_PROTOCOL_NUM-1] of NET_DVR_PROTO_TYPE;  //最大协议列表
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_SCREENSERVER_ABILITY = ^NET_DVR_SCREENSERVER_ABILITY;

//多屏控制器能力集
type
  NET_DVR_SCREENCONTROL_ABILITY = record 
    dwSize: DWORD;  //结构长度
    byLayoutNum: BYTE;  // 布局个数
    byWinNum: BYTE;  //屏幕窗口个数
    byOsdNum: BYTE;  //OSD个数
    byLogoNum: BYTE;  //Logo个数
    byInputStreamNum: BYTE;  //输入源个数 ---设备支持最大输入通道个数（包括本地输入源和网络输入源）
    byOutputChanNum: BYTE;  //输出通道个数---设备支持最大输出通道个数
    byCamGroupNum: BYTE;  //分组个数
    byPlanNum: BYTE;  //预案个数
    byRes1: array[0..5-1] of BYTE;  
    byIsSupportPlayBack: BYTE;  //是否支持回放
    byMatrixInputNum: BYTE;  //支持输入矩阵最大个数
    byMatrixOutputNum: BYTE;  //支持输出矩阵最大个数
    struVgaInfo: NET_DVR_DISPINFO;  //VGA输出信息
    struBncInfo: NET_DVR_DISPINFO;  //BNC输出信息
    struHdmiInfo: NET_DVR_DISPINFO;  //HDMI输出信息
    struDviInfo: NET_DVR_DISPINFO;  //DVI输出信息
    byMaxUserNums: BYTE;  //支持用户数
    byPicSpan: BYTE;  //底图跨度，一张底图最多可覆盖的屏幕数
    wDVCSDevNum: WORD;  //分布式大屏控制器最大设备数
    wNetSignalNum: WORD;  //最大网络输入源个数
    wBaseCoordinateX: WORD;  //基准坐标
    wBaseCoordinateY: WORD;  
    byExternalMatrixNum: BYTE;  //最大外接矩阵个数
    byRes2: array[0..49-1] of BYTE;  
  end;
  LPNET_DVR_SCREENCONTROL_ABILITY = ^NET_DVR_SCREENCONTROL_ABILITY;

//******************************输入信号状态******************************
type
  NET_DVR_ANALOGINPUTSTATUS = record 
    dwLostFrame: DWORD;  //视频输入丢帧数
    byHaveSignal: BYTE;  //是否有视频信号输入
    byVideoFormat: BYTE;  //视频制式，1：NTSC,2：PAL,0：无
    byRes: array[0..46-1] of BYTE;  
  end;
  LPNET_DVR_ANALOGINPUTSTATUS = ^NET_DVR_ANALOGINPUTSTATUS;

type
  NET_DVR_INPUTSTATUS_UNION = record 
    case Byte of
    0: (struIpInputStatus: NET_DVR_MATRIX_CHAN_STATUS);  
    1: (struAnalogInputStatus: NET_DVR_ANALOGINPUTSTATUS);  
  end;
  LPNET_DVR_INPUTSTATUS_UNION = ^NET_DVR_INPUTSTATUS_UNION;

type
  NET_DVR_INPUTSTATUS = record 
    wInputNo: WORD;  //信号源序号
    byInputType: BYTE;  //见NET_DVR_CAM_MODE
    byRes1: array[0..9-1] of BYTE;  
    struStatusUnion: NET_DVR_INPUTSTATUS_UNION;  
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_INPUTSTATUS = ^NET_DVR_INPUTSTATUS;

type
  NET_DVR_SCREENINPUTSTATUS = record 
    dwSize: DWORD;  
    byRes: array[0..12-1] of BYTE;  
    dwNums: DWORD;  //设备返回的输入源状态的数量
    pBuffer: PBYTE;  //缓冲区
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_SCREENINPUTSTATUS = ^NET_DVR_SCREENINPUTSTATUS;

type
  NET_DVR_SCREENALARMCFG = record 
    dwSize: DWORD;  
    byAlarmType: BYTE;  //报警类型，1-子板拔出，2-子板插入，3-子系统状态异常，4-子系统恢复恢复 5-输入源异常   6-温度报警 7-FPGA版本不匹配 8-预案开始 9-预案结束 10-解码板断网 11-解码板IP地址冲突，12-风扇异常
    byBoardType: BYTE;  // 1-输入板 2-输出板 ，3-主板，4-背板，报警类型为1，2，3，6的时候使用
    bySubException: BYTE;  //输入异常时具体子异常 1- 分辨率正常改变 2-输入端口类型改变3-分辨率错误4-分辨率改变导致解码资源不足，关闭该输入源对应窗口。5-分辨率改变，导致已开窗的缩放比例不在1/8到8倍范围。6-分辨率恢复正常,7-分辨率改变导致输出板数据量超限,设备关闭窗口
    byRes1: BYTE;  
    wStartInputNum: WORD;  // 异常输入源（异常起点）
    wEndInputNum: WORD;  // 异常输入源（异常终点）
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SCREENALARMCFG = ^NET_DVR_SCREENALARMCFG;

type
  NET_DVR_MATRIX_CFG = record 
    byValid: BYTE;  //判断是否是模拟矩阵（是否有效）
    byCommandProtocol: BYTE;  //模拟矩阵的指令（4种）
    byScreenType: BYTE;  //保留
    byRes1: BYTE;  
    byScreenToMatrix: array[0..32-1] of BYTE;  //模拟矩阵的输出与屏幕的对应关系
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_CFG = ^NET_DVR_MATRIX_CFG;

type
  NET_DVR_DIGITALSCREEN = record 
    struAddress: NET_DVR_IPADDR;  //设备为数字设备时的IP信息
    wPort: WORD;  //通道号
    byRes: array[0..26-1] of BYTE;  //保留
  end;
  LPNET_DVR_DIGITALSCREEN = ^NET_DVR_DIGITALSCREEN;
type
  NET_DVR_ANALOGSCREEN = record 
    byDevSerPortNum: BYTE;  //连接设备的串口号
    byScreenSerPort: BYTE;  //连接大屏的串口号
    byRes: array[0..130-1] of BYTE;  
    struMatrixCfg: NET_DVR_MATRIX_CFG;  
  end;
  LPNET_DVR_ANALOGSCREEN = ^NET_DVR_ANALOGSCREEN;

type
  NET_DVR_SCREEN_UNION = record 
    case Byte of
    0: (struDigitalScreen: NET_DVR_DIGITALSCREEN);  
    1: (struAnalogScreen: NET_DVR_ANALOGSCREEN);  
  end;
  LPNET_DVR_SCREEN_UNION = ^NET_DVR_SCREEN_UNION;
type
  NET_DVR_SCREEN_SCREENINFO = record 
    dwSize: DWORD;  
    byValid: BYTE;  //是否有效
    nLinkMode: BYTE;  //连接方式，0-串口，1-网口
    byDeviceType: BYTE;  //设备型号，能力集获取
    byScreenLayX: BYTE;  //大屏布局-横坐标
    byScreenLayY: BYTE;  //大屏布局-纵坐标
    byRes1: array[0..3-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //登录用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //登录密码
    sDevName: array[0..NAME_LEN-1] of BYTE;  //设备名称
    struScreenUnion: NET_DVR_SCREEN_UNION;  
    byInputNum: BYTE;  // 输入源个数
    byOutputNum: BYTE;  // 输出源个数
    byCBDNum: BYTE;  //CBD个数
    byRes2: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_SCREENINFO = ^NET_DVR_SCREEN_SCREENINFO;

//******************************底图上传******************************
type
  NET_DVR_BASEMAP_CFG = record 
    byScreenIndex: BYTE;  //屏幕的序号
    byMapNum: BYTE;  //被分割成了多少块 
    res: array[0..2-1] of BYTE;  
    wSourWidth: WORD;  // 原图片的宽度 
    wSourHeight: WORD;  // 原图片的高度 
  end;
  LPNET_DVR_BASEMAP_CFG = ^NET_DVR_BASEMAP_CFG;


type
  NET_DVR_PICTURECFG = record 
    dwSize: DWORD;  //大小
    byUseType: BYTE;  //1-底图，2-GIF图片，3-CAD图片 4-输出口图片
    bySequence: BYTE;  //序号
    byOverlayEnabled: BYTE;  //图片叠加使能，是否在上传图片包含图片叠加参数 1-包含叠加参数，0-不包含
    byRes: array[0..1-1] of BYTE;  
    struBasemapCfg: NET_DVR_BASEMAP_CFG;  //底图参数对合码器设备无效
    sPicName: array[0..NAME_LEN-1] of BYTE;  //图片名称
    dwVideoWall: DWORD;  //墙号（1字节墙号（对于合码器，该值固定为1即可）+1字节通道输出（合码通道号）+2字节窗口号）
    byFlash: BYTE;  //图片闪烁使能，1-闪烁，0-不闪烁
    byTranslucent: BYTE;  //图片半透明使能，1-半透明，0-不半透明
    byShowEnabled: BYTE;  //图片显示使能，1-显示，0-隐藏
    byPictureType: BYTE;  //图片类型，1-bmp，2-jpg，3-png，……
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_PICTURECFG = ^NET_DVR_PICTURECFG;

//******************************OSD******************************
const
  MAX_OSDCHAR_NUM = 256;    
type
  NET_DVR_OSDCFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  //是否有效 0无效 1有效
    byDispMode: BYTE;  //显示模式，1-透明，2-半透明，3-覆盖三种模式
    byFontColorY: BYTE;  //字体颜色Y,0-255
    byFontColorU: BYTE;  //字体颜色U,0-255
    byFontColorV: BYTE;  //字体颜色V,0-255
    byBackColorY: BYTE;  //背景颜色Y,0-255
    byBackColorU: BYTE;  //背景颜色U,0-255
    byBackColorV: BYTE;  //背景颜色V,0-255
    wXCoordinate: WORD;  //OSD在屏幕左上角位置x
    wYCoordinate: WORD;  //OSD在屏幕左上角位置y
    wWidth: WORD;  //OSD宽度
    wHeight: WORD;  //OSD高度
    dwCharCnt: DWORD;  //字符的个数
    wOSDChar: array[0..MAX_OSDCHAR_NUM-1] of WORD;  //OSD字符内容
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OSDCFG = ^NET_DVR_OSDCFG;


//******************************获取串口信息******************************
type
  NET_DVR_SERIAL_CONTROL = record 
    dwSize: DWORD;  
    bySerialNum: BYTE;  // 串口个数
    byRes1: array[0..3-1] of BYTE;  
    bySerial: array[0..32-1] of BYTE;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SERIAL_CONTROL = ^NET_DVR_SERIAL_CONTROL;

//******************************屏幕控制******************************
//屏幕输入源控制
type
  INPUT_INTERFACE_TYPE =  
  (  
    INTERFACE_VGA = 0,  
    INTERFACE_SVIDEO,  // 2046NL不支持，2046NH支持
    INTERFACE_YPBPR,  
    INTERFACE_DVI,  
    INTERFACE_BNC,  
    INTERFACE_DVI_LOOP,  //(环通) 2046NH不支持，2046NL支持
    INTERFACE_BNC_LOOP,  //(环通) 2046NH不支持，2046NL.支持
    INTERFACE_HDMI,  
    INTERFACE_IP,  
    INTERFACE_USB,  
    INTERFACE_SDI,  
    INTERFACE_DP,  
    INTERFACE_HDBASET  
  );
type
  NET_DVR_INPUT_INTERFACE_CTRL = record 
    byInputSourceType: BYTE;  //见INPUT_INTERFACE_TYPE
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_INTERFACE_CTRL = ^NET_DVR_INPUT_INTERFACE_CTRL;
//显示单元颜色控制
type
  NET_DVR_DISPLAY_COLOR_CTRL = record 
    byColorType: BYTE;  //1-亮度 2-对比度 3-饱和度 4-清晰度
    byScale: AnsiChar;  //-1 、0、+1三个值
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAY_COLOR_CTRL = ^NET_DVR_DISPLAY_COLOR_CTRL;
//显示单元位置控制
type
  NET_DVR_DISPLAY_POSITION_CTRL = record 
    byPositionType: BYTE;  //1-水平位置 2-垂直位置，
    byScale: AnsiChar;  //-1 、0、+1三个值
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAY_POSITION_CTRL = ^NET_DVR_DISPLAY_POSITION_CTRL;


//******************************屏幕控制V41******************************
type
  NET_DVR_RECTCFG_EX = record 
    dwXCoordinate: DWORD;  //矩形左上角起始点X坐标
    dwYCoordinate: DWORD;  //矩形左上角Y坐标
    dwWidth: DWORD;  //矩形宽度
    dwHeight: DWORD;  //矩形高度
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_RECTCFG_EX = ^NET_DVR_RECTCFG_EX;

//******************************预案管理******************************
const
  MAX_PLAN_ACTION_NUM = 32;    //预案动作个数
  DAYS_A_WEEK = 7;    //一周7天
  MAX_PLAN_COUNT = 16;    //预案个数


type
  NET_DVR_PLAN_OPERATE_TYPE =  
  (  
    NET_DVR_SWITCH_LAYOUT = 1,  // 布局切换 默认
    NET_DVR_SCREEN_POWER_OFF,  // 关闭大屏幕显示
    NET_DVR_SCREEN_POWER_ON,  // 打开大屏幕显示
    NET_DVR_SWITCH_BASEMAP  //底图切换
  );

//预案项信息
type
  NET_DVR_PLAN_INFO = record 
    byValid: BYTE;  // 该项是否有效
    byType: BYTE;  // 见定义NET_DVR_PLAN_OPERATE_TYPE
    wLayoutNo: WORD;  // 布局号
    byScreenStyle: BYTE;  //屏幕型号，开关机所用，1是低亮，2是高亮
    byBaseMapType: BYTE;  //底图类型，1-图片底图，2-超高清输入底图，底图切换时有效
    byRes1: array[0..2-1] of BYTE;  
    dwDelayTime: DWORD;  // 一个项的运行时间, 单位秒
    dwSerialNo: DWORD;  //串口号，屏幕控制时使用
    dwBaseMapWndNo: DWORD;  //底图窗口号，底图切换时有效
    dwBaseMapNo: DWORD;  //底图号，底图切换时有效；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入号（1字节设备号+1字节子板号+2字节显示输入序号）
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_INFO = ^NET_DVR_PLAN_INFO;

type
  NET_DVR_CYCLE_TIME = record 
    byValid: BYTE;  
    byRes: array[0..3-1] of BYTE;  
    struTime: NET_DVR_TIME_EX;  
  end;
  LPNET_DVR_CYCLE_TIME = ^NET_DVR_CYCLE_TIME;
//预案管理
type
  NET_DVR_PLAN_CFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  // 该预案是否有效
    byWorkMode: BYTE;  // 预案工作模式 1表示手动，2自动，3预案循环
    byWallNo: BYTE;  //电视墙号，从1开始
    byPlanNo: BYTE;  //预案号，获取预案列表时有效，0-无效或不支持
    byPlanName: array[0..NAME_LEN{32}-1] of BYTE;  //预案名称
    struTime: NET_DVR_TIME_EX;  // 工作模式为自动时使用
    struTimeCycle: array[0..DAYS_A_WEEK{7}-1] of NET_DVR_CYCLE_TIME;  //循环时间，周期为一个星期，年、月、日三个参数不使用。如：struTimeCycle[0]中的byValid的值是1，表示星期天执行该预案。星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推
    dwWorkCount: DWORD;  // 预案内容执行次数
    strPlanEntry: array[0..MAX_PLAN_ACTION_NUM{32}-1] of NET_DVR_PLAN_INFO;  // 预案执行的内容
    dwPlanNo: DWORD;  //4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
    byRes2: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_CFG = ^NET_DVR_PLAN_CFG;


//******************************获取设备状态******************************
//预案列表
type
  NET_DVR_PLAN_LIST = record 
    dwSize: DWORD;  
    dwPlanNums: DWORD;  //设备输入信号源数量
    pBuffer: PBYTE;  //指向dwInputSignalNums个NET_DVR_PLAN_CFG结构大小的缓冲区
    byWallNo: BYTE;  //墙号，从1开始
    byRes1: array[0..2-1] of BYTE;  
    dwBufLen: DWORD;  //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_PLAN_CFG结构大小）
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_LIST = ^NET_DVR_PLAN_LIST;


//******************************预案控制******************************
//该结构体可作为通用控制结构体
type
  NET_DVR_CONTROL_PARAM = record 
    dwSize: DWORD;  
    sDeviceID: array[0..NAME_LEN-1] of BYTE;  //被控设备的设备ID
    wChan: WORD;  //被控通道
    byIndex: BYTE;  //控制索引，根据命令确定具体表示什么索引
    byRes1: BYTE;  
    dwControlParam: DWORD;  
    byMandatoryAlarm: BYTE;  //1-使能  0-不使能
    byRes2: BYTE;  
    wZoneIndex: WORD;  //防区号
    byOperatorCode: array[0..16-1] of BYTE;  //回控码
    dwPlanNo: DWORD;  //4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
    byRes3: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_CONTROL_PARAM = ^NET_DVR_CONTROL_PARAM;

//******************************获取设备状态******************************
type
  NET_DVR_DEVICE_RUN_STATUS = record 
    dwSize: DWORD;  
    dwMemoryTotal: DWORD;  //内存总量，单位Kbyte
    dwMemoryUsage: DWORD;  //内存使用量，单位Kbyte
    byCPUUsage: BYTE;  //CPU使用率，0-100
    byMainFrameTemp: BYTE;  //机箱温度，单位：摄氏度
    byBackPanelTemp: BYTE;  //背板温度，单位：摄氏度
    byRes1: BYTE;  
    byLeftDecResource: array[0..32-1] of BYTE;  //各解码板剩余解码资源，以解D1分辨率资源为单位，byLeftDecResource[i],表示槽位号i解码板剩余资源，0xff表示无效（非解码板或没插板子）
    fNetworkFlow: FLOAT;  //网络流量，单位：KB/s，归一化处理，保留小数点后两位
    byRes2: array[0..88-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_RUN_STATUS = ^NET_DVR_DEVICE_RUN_STATUS;

// 91系列HD-SDI高清DVR 相机信息
type
  NET_DVR_ACCESS_CAMERA_INFO = record 
    dwSize: DWORD;  
    sCameraInfo: array[0..32-1] of AnsiChar;  // 前端相机信息
    byInterfaceType: BYTE;  // 前端接入接口类型，1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    byRes1: array[0..3-1] of BYTE;  
    dwChannel: DWORD;  
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_ACCESS_CAMERA_INFO = ^NET_DVR_ACCESS_CAMERA_INFO;

type
  NET_DVR_AUDIO_INPUT_PARAM = record 
    byAudioInputType: BYTE;  //音频输入类型，0-mic in，1-line in
    byVolume: BYTE;  //volume,[0-100]
    byEnableNoiseFilter: BYTE;  //是否开启声音过滤-关，-开
    byres: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_INPUT_PARAM = ^NET_DVR_AUDIO_INPUT_PARAM;

type
  NET_DVR_CAMERA_DEHAZE_CFG = record 
    dwSize: DWORD;  
    byDehazeMode: BYTE;  //0-不启用，1-自动模式，2-开
    byLevel: BYTE;  //等级，0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_CAMERA_DEHAZE_CFG = ^NET_DVR_CAMERA_DEHAZE_CFG;

type
  NET_DVR_INPUT_SIGNAL_LIST = record 
    dwSize: DWORD;  
    dwInputSignalNums: DWORD;  //设备输入信号源数量
    pBuffer: PBYTE;  //指向dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小的缓冲区
    byRes1: array[0..3-1] of BYTE;  
    dwBufLen: DWORD;  //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小）
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SIGNAL_LIST = ^NET_DVR_INPUT_SIGNAL_LIST;

// 安全拔盘状态
const
  PULL_DISK_SUCCESS = 1;    // 安全拔盘成功
  PULL_DISK_FAIL = 2;    // 安全拔盘失败
  PULL_DISK_PROCESSING = 3;    // 正在停止阵列
  PULL_DISK_NO_ARRAY = 4;    // 阵列不存在
  PULL_DISK_NOT_SUPPORT = 5;    // 不支持安全拔盘

// 扫描阵列状态
const
  SCAN_RAID_SUC = 1;    // 扫描阵列成功
  SCAN_RAID_FAIL = 2;    // 扫描阵列失败
  SCAN_RAID_PROCESSING = 3;    // 正在扫描阵列
  SCAN_RAID_NOT_SUPPORT = 4;    // 不支持阵列扫描

// 设置前端相机类型状态
const
  SET_CAMERA_TYPE_SUCCESS = 1;    // 成功
  SET_CAMERA_TYPE_FAIL = 2;    // 失败
  SET_CAMERA_TYPE_PROCESSING = 3;    // 正在处理

//9000 2.2
type
  NET_DVR_RECORD_TIME_SPAN_INQUIRY = record 
    dwSize: DWORD;  //结构体大小
    byType: BYTE;  //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_TIME_SPAN_INQUIRY = ^NET_DVR_RECORD_TIME_SPAN_INQUIRY;

type
  NET_DVR_RECORD_TIME_SPAN = record 
    dwSize: DWORD;  //结构体大小
    strBeginTime: NET_DVR_TIME;  //开始时间
    strEndTime: NET_DVR_TIME;  //结束时间
    byType: BYTE;  //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    byRes: array[0..35-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_TIME_SPAN = ^NET_DVR_RECORD_TIME_SPAN;

type
  NET_DVR_DRAWFRAME_DISK_QUOTA_CFG = record 
    dwSize: DWORD;  //结构体大小
    byPicQuota: BYTE;  //图片百分比     [0%,  30%]
    byRecordQuota: BYTE;  //普通录像百分比 [20%, 40%]
    byDrawFrameRecordQuota: BYTE;  //抽帧录像百分比 [30%, 80%]
    byRes: array[0..61-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG = ^NET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

type
  NET_DVR_NAT_PORT = record 
    wEnable: WORD;  //该端口是否使能映射
    wExtPort: WORD;  //映射的外部端口号
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_DVR_NAT_PORT = ^NET_DVR_NAT_PORT;

type
  NET_DVR_NAT_CFG = record 
    dwSize: DWORD;  //结构体大小
    wEnableUpnp: WORD;  //UPNP功能是否启用
    wEnableNat: WORD;  //UPNP端口映射（NAT）功能是否启用(保留，与wEnableUpnp保持一致)
    struIpAddr: NET_DVR_IPADDR;  //NAT路由器LAN IP地址
    struHttpPort: NET_DVR_NAT_PORT;  //web server http端口映射配置
    struCmdPort: NET_DVR_NAT_PORT;  //命令端口映射配置(8000)
    struRtspPort: NET_DVR_NAT_PORT;  //rtsp端口映射配置
    byFriendName: array[0..64-1] of BYTE;  //服务名
    byNatType: BYTE;  //UPNP端口映射类型，0-手动，1-自动
    byRes1: array[0..3-1] of BYTE;  //保留
    struHttpsPort: NET_DVR_NAT_PORT;  //https端口映射配置
    struSDKOverTLSPort: NET_DVR_NAT_PORT;  //SDKOverTLS端口映射配置
    struRtspsPort: NET_DVR_NAT_PORT;  //Rtsps端口映射配置
    byres: array[0..44-1] of BYTE;  //保留
  end;
  LPNET_DVR_NAT_CFG = ^NET_DVR_NAT_CFG;

type
  NET_DVR_UPNP_PORT_STATE = record 
    dwEnabled: DWORD;  //该端口是否被使能映射
    wInternalPort: WORD;  //映射前的端口
    wExternalPort: WORD;  //映射后的端口
    dwStatus: DWORD;  {端口映射状态
                                                                     0 未生效
                                                                     1 未生效：映射源端口与目的端口需一致
                                                                     2 未生效:  映射端口号已被使用
                                                                     3 生效
                                    }
    struNatExternalIp: NET_DVR_IPADDR;  //映射后的外部地址
    struNatInternalIp: NET_DVR_IPADDR;  //NAT路由器LAN IP地址
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_UPNP_PORT_STATE = ^NET_DVR_UPNP_PORT_STATE;


type
  NET_DVR_UPNP_NAT_STATE = record 
    strUpnpPort: array[0..UPNP_PORT_NUM-1] of NET_DVR_UPNP_PORT_STATE;  //端口映射状态,数组0 web server端口 数组1 管理端口 数组2 rtsp端口
    byRes: array[0..200-1] of BYTE;  //保留
  end;
  LPNET_DVR_UPNP_NAT_STATE = ^NET_DVR_UPNP_NAT_STATE;

type
  NET_DVR_PLAYCOND = record 
    dwChannel: DWORD;  
    struStartTime: NET_DVR_TIME;  
    struStopTime: NET_DVR_TIME;  
    byDrawFrame: BYTE;  //0:不抽帧，1：抽帧
    byStreamType: BYTE;  //码流类型，0-主码流 1-子码流 2-码流三
    byStreamID: array[0..STREAM_ID_LEN-1] of BYTE;  
    byCourseFile: BYTE;  //课程文件0-否，1-是
    byDownload: BYTE;  //是否下载 0-否，1-是
    byOptimalStreamType: BYTE;  //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    byVODFileType: BYTE;  // 下载录像文件，文件格式 0-PS码流格式，1-3GP格式
    byRes: array[0..26-1] of BYTE;  //保留
  end;
  LPNET_DVR_PLAYCOND = ^NET_DVR_PLAYCOND;

type
  NET_DVR_ATMFINDINFO = record 
    byTransactionType: BYTE;  //交易类型 0-全部，1-查询， 2-取款， 3-存款， 4-修改密码，5-转账， 6-无卡查询 7-无卡存款， 8-吞钞 9-吞卡 10-自定义
    byRes: array[0..3-1] of BYTE;  //保留
    dwTransationAmount: DWORD;  //交易金额 ;
  end;
  LPNET_DVR_ATMFINDINFO = ^NET_DVR_ATMFINDINFO;

type
  NET_DVR_SPECIAL_FINDINFO_UNION = record 
    case Byte of
    0: (byLenth: array[0..8-1] of BYTE);  
    1: (struATMFindInfo: NET_DVR_ATMFINDINFO);  //ATM查询
  end;
  LPNET_DVR_SPECIAL_FINDINFO_UNION = ^NET_DVR_SPECIAL_FINDINFO_UNION;


type
  NET_DVR_FILECOND_V40 = record 
    lChannel: LONG;  
    dwFileType: DWORD;  {不带卡号录象文件类型0xff-全部，0-定时录像，1-移动侦测，2-报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，
    7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件，15-越界侦测，16-区域入侵，17-声音异常，18-场景变更侦测，19-智能侦测（越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测），
    20-人脸侦测， 21-信号量，22-回传，23-回迁录像，24-遮挡，25-pos录像，26-进入区域侦测, 27-离开区域侦测,28-徘徊侦测,29-人员聚集侦测,30-快速运动侦测,31-停车侦测,32-物品遗留侦测,33-物品拿取侦测,
    34-火点侦测，35-防破坏检测，36-船只检测，37-测温预警,38-测温报警,39-打架斗殴报警，40-起身检测，41-瞌睡检测，42-温差报警，43-离线测温报警,44-防区报警，45-紧急求助,46-业务咨询,47-起身检测,48-折线攀高,49-如厕超时，50-奔跑检测，51-滞留检测，52-人脸抓拍, 53-非法摆摊, 54-目标识别,
    55-剧烈运动，56-离岗检测，57-起立，58-人数变化，59-违停, 60-逆行,61-压线,62-机占非,63-变道,64-掉头,65-行人检测,66-路障,67-抛洒物,68-浓雾检测,69-施工,70-拥堵,71-交通事故检测, 72-侧方停车，73-手动触发报警,74-交通违章，75-挖沙船检测报警 76-废气排放显示77-灰度报警,78-振动侦测,
    79-烟雾检测,80-通道定时录像事件,81-AI开放平台事件,82-传感器事件,83-紫光电子检测,84-设备电源状态上报
}
    dwIsLocked: DWORD;  
    dwUseCardNo: DWORD;  //是否带ATM信息进行查询：0-不带ATM信息，1-按交易卡号查询，2-按交易类型查询，3-按交易金额查询，4-按卡号、交易类型及交易金额的组合查询 5-按课程名称查找，此时卡号表示课程名称
    sCardNumber: array[0..CARDNUM_LEN_OUT-1] of BYTE;  
    struStartTime: NET_DVR_TIME;  
    struStopTime: NET_DVR_TIME;  
    byDrawFrame: BYTE;  //0:不抽帧，1：抽帧
    byFindType: BYTE;  //0:查询普通卷，1：查询存档卷
    byQuickSearch: BYTE;  //0:普通查询，1：快速（日历）查询
    bySpecialFindInfoType: BYTE;  //专有查询条件类型 0-无效， 1-带ATM查询条件
    dwVolumeNum: DWORD;  //存档卷号
    byWorkingDeviceGUID: array[0..GUID_LEN-1] of BYTE;  //工作机GUID，通过获取N+1得到
    uSpecialFindInfo: NET_DVR_SPECIAL_FINDINFO_UNION;  //专有查询条件
    byStreamType: BYTE;  //0-同一个时间段只返回一种录像，优先级顺序为：主码流、子码流、三码流，1-子码流，2-三码流，3-主码流，254-双码流搜索(优先返回主码流录像，没有主码流录像时返回子码流录像)
    byAudioFile: BYTE;  //音频文件 0-非音频文件，1-音频文件
    byRes2: array[0..30-1] of BYTE;  //保留
  end;
  LPNET_DVR_FILECOND_V40 = ^NET_DVR_FILECOND_V40;

//录像文件查找条件结构V50
type
  NET_DVR_FILECOND_V50 = record 
    struStreamID: NET_DVR_STREAM_INFO;  //流ID或通道号
    struStartTime: NET_DVR_TIME_SEARCH_COND;  //开始时间
    struStopTime: NET_DVR_TIME_SEARCH_COND;  //结束时间
    byFindType: BYTE;  //0-查询普通卷，1-查询存档卷 2-查询N+1录像文件
    byDrawFrame: BYTE;  //是否抽帧 0-不抽帧 1-抽帧
    byQuickSearch: BYTE;  //0-普通查询，1-快速（日历）查询
    byStreamType: BYTE;  //0-主码流，1-子码流，2-3码流，0xff-全部
    dwFileType: DWORD;  // 文件类型
    dwVolumeNum: DWORD;  //存档卷号，byFindType为1时有效
    byIsLocked: BYTE;  //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    byNeedCard: BYTE;  //是否需要查询卡，0-不需要 1-需要
    byOnlyAudioFile: BYTE;  //音频文件 0-视频文件 1-音频文件
    bySpecialFindInfoType: BYTE;  //0-无效， 1-带ATM查询条件
    szCardNum: array[0..32-1] of AnsiChar;  //卡号，byNeedCard为1时有效
    szWorkingDeviceGUID: array[0..16-1] of AnsiChar;  //工作机GUID，通过获取N+1得到，byFindType为2时有效
    uSpecialFindInfo: NET_DVR_SPECIAL_FINDINFO_UNION;  //专有查询条件联合体
    dwTimeout: DWORD;  //查找超时时间（指定NET_DVR_FindNextFile_V30/NET_DVR_FindNextFile_V40/NET_DVR_FindNextFile_V50接口的超时时间返回）；单位：毫秒，不填写（默认为0时），接口行为跟以前一样 ;有效值：0, [5000 C 15000]
    byRes: array[0..252-1] of BYTE;  
  end;
  LPNET_DVR_FILECOND_V50 = ^NET_DVR_FILECOND_V50;

type
  NET_DVR_AES_KEY_INFO = record 
    sAESKey: array[0..16-1] of BYTE;  //码流加密密钥
    byRes: array[0..64-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_AES_KEY_INFO = ^NET_DVR_AES_KEY_INFO;

type
  NET_DVR_POE_CFG = record 
    struIP: NET_DVR_IPADDR;  //IP地址
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_POE_CFG = ^NET_DVR_POE_CFG;

const
  MAX_PRO_PATH = 256;    //最大协议路径长度

type
  NET_DVR_CUSTOM_PROTOCAL = record 
    dwSize: DWORD;  //结构体大小
    dwEnabled: DWORD;  //是否启用该协议0 不启用 1 启用
    sProtocalName: array[0..DESC_LEN-1] of AnsiChar;  //自定义协议名称, 16位
    byRes1: array[0..64-1] of BYTE;  //保留,用于协议名称扩展
    dwEnableSubStream: DWORD;  //子码流是否启用0 不启用 1 启用

    byMainProType: BYTE;  //主码流协议类型 1 RTSP
    byMainTransType: BYTE;  //主码流传输类型 0：Auto 1：udp 2：rtp over rtsp
    wMainPort: WORD;  //主码流端口
    sMainPath: array[0..MAX_PRO_PATH-1] of AnsiChar;  //主码流路径

    bySubProType: BYTE;  //子码流协议类型 1 RTSP
    bySubTransType: BYTE;  //子码流传输类型 0：Auto 1：udp 2：rtp over rtsp
    wSubPort: WORD;  //子码流端口
    sSubPath: array[0..MAX_PRO_PATH-1] of AnsiChar;  //子码流路径

    byRes2: array[0..200-1] of BYTE;  //保留
  end;
  LPNET_DVR_CUSTOM_PROTOCAL = ^NET_DVR_CUSTOM_PROTOCAL;


//B10能支持PSIA设备
//循环上墙结构体（实时）
type
  NET_DVR_MATRIX_CHAN_INFO_EX = record 
    dwEnable: DWORD;  // 是否启用 0－否 1－启用
    byType: BYTE;  //设备类型 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    byRes: array[0..3-1] of BYTE;  //保留
    streamMediaServerCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO;  // 轮循解码通道信息 
    sRtspUrl: array[0..128-1] of BYTE;  //流地址
  end;
  LPNET_DVR_MATRIX_CHAN_INFO_EX = ^NET_DVR_MATRIX_CHAN_INFO_EX;

type
  NET_DVR_MATRIX_LOOP_DECINFO_EX = record 
    dwSize: DWORD;  
    dwPoolTime: DWORD;  //轮询间隔
    struchanConInfo: array[0..MAX_CYCLE_CHAN_V30-1] of NET_DVR_MATRIX_CHAN_INFO_EX;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_LOOP_DECINFO_EX = ^NET_DVR_MATRIX_LOOP_DECINFO_EX;

//实时预览上墙结构体
type
  NET_DVR_PU_STREAM_CFG_EX = record 
    dwSize: DWORD;  
    byType: BYTE;  //设备类型 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    byRes: array[0..3-1] of BYTE;  //保留
    struStreamMediaSvrCfg: NET_DVR_STREAM_MEDIA_SERVER_CFG;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO;  
    sRtspUrl: array[0..128-1] of BYTE;  //流地址
  end;
  LPNET_DVR_PU_STREAM_CFG_EX = ^NET_DVR_PU_STREAM_CFG_EX;

type
  NET_DVR_MATRIX_TRUNKCFG = record 
    dwGlobalIndex: DWORD;  //主键
    dwInterIndex: DWORD;  //本地全局编号
    sTrunkName: array[0..NAME_LEN-1] of BYTE;  
    byType: BYTE;  //设备类型1-bnc, 2-SP3, 3-V6
    byDir: BYTE;  //干线方向 1-输入2-输出
    byAbility: BYTE;  //干线能力，D1衡量
    bySubsys: BYTE;  //子系统ID
    byChan: BYTE;  //通道ID
    byRes: array[0..255-1] of BYTE;  //预留
  end;
  LPNET_DVR_MATRIX_TRUNKCFG = ^NET_DVR_MATRIX_TRUNKCFG;

type
  NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 = record 
    byJoinStatus: BYTE;  //关联状态，0-没有关联，1-已经关联，通过其他字段判断被自己关联或被其他子系统关联，2-被占用，byDecodeAbility大于1时有效，3-被大屏主屏关联，4-被大屏子屏关联
    byJoinSubSystem: BYTE;  // 所关联或占用的子系统槽位号
    byJoinDispNum: BYTE;  // 所关联或占用的显示通道号
    byJoinSubWindowNum: BYTE;  // 所关联或占用的子窗口号
    byDecodeAbility: BYTE;  //解码通道的当前解码能力，0-未关联，1-D1，2-720，3-1080
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41 = ^NET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

type
  NET_DVR_SINGLESUBSYSTEMJOININFO_V41 = record 

    //子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）
    bySubSystemType: BYTE;  
    byConnectStatus: BYTE;  //级联系统关联状态，1-连接正常，2-连接断开
    byMatrixNum: BYTE;  //级联视频综合平台号，子系统类型是3或4时可用
    bySubSystemNum: BYTE;  //级联子系统槽位号，子系统类型是3或4时可用
    struSubSystem: array[0..MAX_DECODECHANNUM-1] of NET_DVR_DECSUBSYSTEMJIONSTATUS_V41;  
    byBindStatus: BYTE;  //绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    bySlotNum: BYTE;  //槽位号，此参数只能获取
    byUsedTrunk: BYTE;  //是否被干线使用，0-未被使用，1-被使用
    byRes: array[0..65-1] of BYTE;  
  end;
  LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41 = ^NET_DVR_SINGLESUBSYSTEMJOININFO_V41;

type
  NET_DVR_ALLDECSUBSYSTEMJOININFO_V41 = record 
    dwSize: DWORD;  
    struSingleSubSystemJoinInfo: array[0..MAX_SUBSYSTEM_NUM_V40-1] of NET_DVR_SINGLESUBSYSTEMJOININFO_V41;  
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 = ^NET_DVR_ALLDECSUBSYSTEMJOININFO_V41;

//////////子系统配置/////////////
const
  MAX_ALARMHOSTKEYBOARD = 64;    //网络报警主机最大键盘数
type
  NET_DVR_PUBLIC_SUB_SYSTEM = record 

    //关联子系统号，按位表示，bit0表示该公共子系统关联子系统1.
    dwJointSubSystem: DWORD;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PUBLIC_SUB_SYSTEM = ^NET_DVR_PUBLIC_SUB_SYSTEM;

type
  NET_DVR_NOAMAL_SUB_SYSTEM = record 

    //表示被哪些公共子系统关联，按位表示，bit0 表示，该子系统.被关联到公共子系统1
    dwBeJoinedSubSystem: DWORD;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_NOAMAL_SUB_SYSTEM = ^NET_DVR_NOAMAL_SUB_SYSTEM;

type
  NET_DVR_JOINT_SUB_SYSTEM = record 
    case Byte of

    // byPublicAttributeEnable为0时使用该变量
    0: (struNormalSubSystem: NET_DVR_NOAMAL_SUB_SYSTEM);  
    //byPublicAttributeEnable为1时使用该变量
    1: (struPublicSubSystem: NET_DVR_PUBLIC_SUB_SYSTEM);  
    2: (byRes: array[0..20-1] of BYTE);  
  end;
  LPNET_DVR_JOINT_SUB_SYSTEM = ^NET_DVR_JOINT_SUB_SYSTEM;

const
  MAX_SUBSYSTEM_ID_LEN = 16;    //子系统ID最大长度

//////////GPRS参数配置/////////////
const
  ACCOUNTNUM_LEN = 6;    
  ACCOUNTNUM_LEN_32 = 32;    
  ACCOUNTNUM_LEN_V40 = 9;    
  APN_NAME_LEN = 32;    
  APN_USERNAME_LEN = 24;    
  APN_USERPASSWORD_LEN = 16;    

type
  NET_DVR_ALARMSUBSYSTEMPARAM = record 
    dwSize: DWORD;  
    wEnterDelay: WORD;  //进入延时,单位:秒, 范围：10-150 动环报警主机和自助行报警主机的延时时间在 NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间
    //具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    wExitDelay: WORD;  //退出延时,单位:秒， 范围10-300
    byHostageReport: BYTE;  //挟持报告，0禁能 1使能
    bySubsystemEnable: BYTE;  //子系统使能
    byKeyToneOfArmOrDisarm: BYTE;  // 成功发送布撤防报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    byKeyToneOfManualTestReport: BYTE;  //成功发送测试报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    wDelayTime: WORD;  //警号输出延时，当能力集中dwSupport1中的bit0位为1时，使用该参数设置警号输出时间。bit0为0时，使用NET_DVR_SIREN_PARAM中的wDelay参数设置警号输出时间
    byEnableAlarmInDelay: BYTE;  //0--不启用(使用子系统延时),1--启用(使用防区延时)，默认不启用
    byPublicAttributeEnable: BYTE;  //是否为公共子系统
    struJointSubSystem: NET_DVR_JOINT_SUB_SYSTEM;  
    byKeyZoneArm: BYTE;  //是否支持钥匙防区对子系统进行布防操作
    byKeyZoneArmReport: BYTE;  //是否支持钥匙防区对子系统布防时发送布防报告
    byKeyZoneDisarm: BYTE;  //是否支持钥匙防区对子系统进行撤防操作
    byKeyZoneDisarmReport: BYTE;  //是否支持钥匙防区对子系统进行撤防操作时发送撤防报告
    bySubSystemID: array[0..MAX_SUBSYSTEM_ID_LEN-1] of BYTE;  //子系统ID
    byKeyZoneArmReportEnable: BYTE;  //钥匙防区上传布防报告使能 0-禁能 1-使能
    byKeyZoneArmEnable: BYTE;  //钥匙防区使能， 0 -禁能 1-使能
    byOneKeySetupAlarmEnable: BYTE;  //一键布防使能
    bySingleZoneSetupAlarmEnable: BYTE;  //单防区布撤防使能
    byCenterType: BYTE;  //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    sCenterAccount: array[0..ACCOUNTNUM_LEN{6}-1] of BYTE;  //中心帐号
    sCenterAccountV40: array[0..ACCOUNTNUM_LEN_32{32}-1] of BYTE;  //中心账号V40,使用此字段时sCenterAccount无效
    byRes2: array[0..565-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMSUBSYSTEMPARAM = ^NET_DVR_ALARMSUBSYSTEMPARAM;

type
  NET_DVR_REMIND_TIME = record //8
    byEnable: BYTE;  //是否启用本次提醒 0-不启用，1-启用
    byHour: BYTE;  //0~24
    byMinute: BYTE;  //0~60
    bySecond: BYTE;  //0~60
  end;
  LPNET_DVR_REMIND_TIME = ^NET_DVR_REMIND_TIME;

//子系统参数配置扩展
const
  MAX_KEYBOARD_USER_NUM = 256;    
type
  NET_DVR_SUBSYSTEM_PARAM_EX = record 
    dwSize: DWORD;  
    struAlarmTime: array[0..MAX_DAYS{7}-1, 0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_SCHEDTIME;  //布撤防时间
    byAlarmInAdvance: BYTE;  // 布撤防提前提示时间0~45分
    byRes1: array[0..3-1] of BYTE;  
    byJointAlarmIn: array[0..MAX_ALARMHOST_ALARMIN_NUM div 8-1] of BYTE;  //按位，表示子系统关联的报警输入通道号，0-不加入，1-加入
    byJointKeyboard: array[0..MAX_ALARMHOSTKEYBOARD{64} div 8-1] of BYTE;  //按位，表示支持的键盘号，0-不加入，1-加入
    byJointOpetaterUser: array[0..MAX_KEYBOARD_USER_NUM div 8-1] of BYTE;  //按位表示，bit0表示键盘操作用户1 ，0-不关联 1-关联
    struAlarmRemindTime: array[0..MAX_DAYS{7}-1, 0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_REMIND_TIME;  //MAX_TIMESEGMENT_V30表示每天最多支持8个提醒
    byJointNetUser: array[0..NET_SDK_MAX_NET_USER_NUM div 8-1] of BYTE;  //关联网络用户（按位表示，bit0表示网络用户1；0-不关联 1-关联）
    byRes2: array[0..280-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SUBSYSTEM_PARAM_EX = ^NET_DVR_SUBSYSTEM_PARAM_EX;


type
  NET_DVR_ALARMHOST_PRINTER_CFG = record 
    dwSize: DWORD;  
    byPrinterEnable: BYTE;  //是否启用打印机
    byPrintTime: BYTE;  //是否打印时间
    byFaultDetect: BYTE;  //是否检测打印机故障
    byRes1: BYTE;  
    dwAlarmInfo: DWORD;  //报警信息，按位表示。bit0-防区报警，bit1-防区报警恢复，bit2-紧急报警，bit-3挟持报警
    dwDeviceInfo: DWORD;  //设备信息，按位表示。bit0-交流电断电、bit1-交流电断电恢复，bit2-蓄电池欠压、bit3-蓄电池欠压恢复，bit4-电话线断线、bit5-电话线断线恢复，bit6-测试报告、bit7-防拆、bit8-防拆恢复、bit9-485设备掉线、bit10-485设备掉线恢复、bit11-无线网络异常、bit12-无线网络恢复正常、bit13-有线网络异常、bit14-有线网络恢复正常、bit15-扩展总线异常、bit17-扩展总线恢复正常、bit17-硬盘故障、bit18-硬盘故障恢复、bit19-键盘锁定
    dwOperateInfo: DWORD;  //操作信息，按位表示。bit0-布防、bit1-撤防、bit2-消警、bit3-旁路、bit4-旁路恢复、bit5-进入编程、bit6-退出编程、bit7-主机复位
    byRes2: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMHOST_PRINTER_CFG = ^NET_DVR_ALARMHOST_PRINTER_CFG;

type
  NET_DVR_ALARMHOST_NETPARAM = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  
    wPort: WORD;  
    byAddressType: BYTE;  //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    byRes1: array[0..1-1] of BYTE;  
    byDomainName: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //域名，GPRS参数配置、网络参数配置时该字段均有效
    byReportProtocol: BYTE;  //1-private 2-NAL2300, 3-Ehome
    byDevID: array[0..ACCOUNTNUM_LEN_32{32}-1] of BYTE;  //协议为NAL2300时有效
    byRes2: array[0..7-1] of BYTE;  //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
  end;
  LPNET_DVR_ALARMHOST_NETPARAM = ^NET_DVR_ALARMHOST_NETPARAM;

type
  NET_DVR_REGISTER_RS485CFG = record 
    dwSize: DWORD;  // 结构体大小
    wDeviceProtocol: WORD;  // 前端设备协议 通过获取协议列表获取
    byRes: array[0..2-1] of BYTE;  
    dwBaudRate: DWORD;  //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
    byRes1: array[0..124-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_REGISTER_RS485CFG = ^NET_DVR_REGISTER_RS485CFG;

type
  NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG = record 
    dwSize: DWORD;  
    struNetCenter: array[0..MAX_CENTERNUM-1] of NET_DVR_ALARMHOST_NETPARAM;  //中心 GPRS网络相关参数的配置
    byAPNName: array[0..APN_NAME_LEN{32}-1] of BYTE;  
    byAPNUserName: array[0..APN_USERNAME_LEN{24}-1] of BYTE;  
    byAPNPassWord: array[0..APN_USERPASSWORD_LEN{16}-1] of BYTE;  
    byReconnTime: BYTE;  //重连时间，连接失效后启用重连的时间，10秒为单位,取值范围1-30
    byOverTime: BYTE;  //超时时间，超过OverTime时间没有收到有效数据则重连，范围1-254，单位30秒
    byDetectLinkTime: BYTE;  //    //探测链路是否还保持，范围1-30，单位10s
    byRes1: BYTE;  
    bySIMNum: array[0..NAME_LEN{32}-1] of BYTE;  //SIM卡号（手机号）
    struSIMIP: NET_DVR_IPADDR;  //登陆网络后网络给分配的IP地址，只能获取
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG = ^NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////网络参数配置/////////////
type
  NET_DVR_ALARMHOST_NETCFG = record 
    dwSize: DWORD;  
    struNetCenter: array[0..MAX_CENTERNUM-1] of NET_DVR_ALARMHOST_NETPARAM;  
    byRes1: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_NETCFG = ^NET_DVR_ALARMHOST_NETCFG;

//////////积木上传方式/////////////
const
  MAX_REPORTCHAN_NUM = 4;    
  MAX_CENTERGROUP_NUM = 16;    
type
  NET_DVR_ALARMHOST_REPORTCENTER_CFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  //是否启用
    byRes: array[0..3-1] of BYTE;  //保留1
    byChanAlarmMode: array[0..MAX_REPORTCHAN_NUM{4}-1] of BYTE;  //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2
    byDealFailCenter: array[0..MAX_CENTERGROUP_NUM{16}-1] of BYTE;  //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    byDataType: BYTE;  //1-报警数据 2-非报警数据 3-所有数据
    byRes2: array[0..15-1] of BYTE;  //保留2
  end;
  LPNET_DVR_ALARMHOST_REPORTCENTER_CFG = ^NET_DVR_ALARMHOST_REPORTCENTER_CFG;

const
  MAX_EVENT_NUM = 32;    //网络报警主机最大事件数
type
  NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40 = record 
    dwSize: DWORD;  
    byValid: BYTE;  //是否启用
    byDataType: BYTE;  //1-所有报警数据 2-所有非报警数据 3-所有数据，4-防区报警报告，5-非防区报警报告
    byRes: array[0..2-1] of BYTE;  //保留1
    byChanAlarmMode: array[0..MAX_REPORTCHAN_NUM{4}-1] of BYTE;  //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2、7-N3、 8-N4、9-CMK-4G、10-CMK-NET(如果设备支持3G，G1，G2表示3G模块，如果不支持，表示GPRS模块，一款设备中3G模块和GPRS模块只会出现一种)
    byDealFailCenter: array[0..MAX_CENTERGROUP_NUM{16}-1] of BYTE;  //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    byZoneReport: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //防区报告类型，0-不上传，1-上传
    byNonZoneReport: array[0..MAX_EVENT_NUM-1] of BYTE;  //非防区报警报告, 每一个元素表示一种事件类型，0-不上传，1-上传，byNonZoneReport[0]-软防区报告 byNonZoneReport[1]-系统状态报告 byNonZoneReport[2]-取消报告 byNonZoneReport[3]-测试报告 byNonZoneReport[4]-布防报告 byNonZoneReport[5]-撤防报告 byNonZoneReport[6]-挟持报告 byNonZoneReport[7]-报警恢复报告 byNonZoneReport[8]-旁路报告 byNonZoneReport[9]-旁路恢复报告。byNonZoneReport[10]-探测器连接状态报告（上线、离线）。byNonZoneReport[11]-探测器电量状态报告（电压正常、欠压）byNonZoneReport[12]-视频报警报告
    byAlarmNetCard: array[0..MAX_REPORTCHAN_NUM{4}-1] of BYTE;  //中心组报警网卡中心，0-主网卡中心1，1-主网卡中心2，2-扩展网卡中心1,3-扩展网卡中心2（报警通道为N1、N2、N3、N4时有效）
    byRes2: array[0..252-1] of BYTE;  //保留2
  end;
  LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40 = ^NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;


//////////防护舱状态上传/////////////
type
  NET_DVR_ALARMHOST_SAFETYCABINSTATE = record 
    dwSize: DWORD;  
    byEnterButton: BYTE;  //进门按钮状态 0-不按下 1-按钮按下
    byExitButton: BYTE;  //出门按钮状态 0-不按下 1-按钮按下
    byDoorState: BYTE;  //门状态    0-门关闭 1-门打开
    byLockState: BYTE;  //锁状态 0-锁关    1-锁开
    byUrgencyButton: BYTE;  //紧急按钮状态    0-不按下 1-按钮按下
    byManState: BYTE;  //人状态     0-没人 1-有人
    byAbnormal: BYTE;  //异常状态  0-正常 1-异常(防护舱使用超时上传异常)
    byLightState: BYTE;  //灯光状态 0-关 ，1-开
    byFanState: BYTE;  //风扇状态 0-关，1-开
    byFollow: BYTE;  //尾随进入状态 0-无尾随，1-有尾随
    byFighting: BYTE;  //打斗状态 0-无打斗，1-有打斗
    byFaint: BYTE;  //晕倒状态 0-无晕倒，1-有人晕倒
    byManyPerson: BYTE;  //多人状态 0-无多人进舱，1-多人进舱
    byRes: array[0..59-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARMHOST_SAFETYCABINSTATE = ^NET_DVR_ALARMHOST_SAFETYCABINSTATE;

/////////警号输出口，警号状态上传/////////////
type
  NET_DVR_ALARMHOST_ALARMOUTSTATUS = record 
    dwSize: DWORD;  
    byName: array[0..32-1] of BYTE;  //报警输出口名称或警号名称
    byAlarmType: BYTE;  //1-报警输出口状态， 2-警号状态
    wChan: WORD;  //如果是报警输出口状态，该值的范围为0-511；如果是警号状态，范围1-8（防护舱只有1个警号输出）
    byAlarmStatus: BYTE;  //报警状态 0-无报警 1-有报警
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ALARMOUTSTATUS = ^NET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////语音上传下载/////////////
type
  NET_DVR_AUDIO_PARAM = record 
    dwSize: DWORD;  
    byAudioFormat: BYTE;  //音频格式，1-G711，2-G722
    byRes1: BYTE;  
    wChannels: WORD;  // number of channels (i.e. mono, stereo...)
    dwSamplesPerSec: DWORD;  //采样率
    byRes2: array[0..20-1] of BYTE;  //保留
    dwAudioSize: DWORD;  //音频长度大小，压缩后的大小
  end;
  LPNET_DVR_AUDIO_PARAM = ^NET_DVR_AUDIO_PARAM;

//预览V40接口
type
  NET_DVR_PREVIEWINFO = record 
    lChannel: LONG;  //通道号
    dwStreamType: DWORD;  // 码流类型，0-主码流，1-子码流，2-码流3，3-码流4, 4-码流5,5-码流6,7-码流7,8-码流8,9-码流9,10-码流10
    dwLinkMode: DWORD;  // 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP ,6- HRUDP（可靠传输） ,7-RTSP/HTTPS
    hPlayWnd: HWND;  //播放窗口的句柄,为NULL表示不播放图象
    bBlocked: DWORD;  //0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
    bPassbackRecord: DWORD;  //0-不启用录像回传,1启用录像回传
    byPreviewMode: BYTE;  //预览模式，0-正常预览，1-延迟预览
    byStreamID: array[0..STREAM_ID_LEN{32}-1] of BYTE;  //流ID，lChannel为0xffffffff时启用此参数
    byProtoType: BYTE;  //应用层取流协议，0-私有协议，1-RTSP协议,2-SRTP码流加密（对应此结构体中dwLinkMode 字段，支持如下方式, 为1，表示udp传输方式，信令走TLS加密，码流走SRTP加密，为2，表示多播传输方式，信令走TLS加密，码流走SRTP加密）
    byRes1: BYTE;  
    byVideoCodingType: BYTE;  //码流数据编解码类型 0-通用编码数据 1-热成像探测器产生的原始数据（温度数据的加密信息，通过去加密运算，将原始数据算出真实的温度值）
    dwDisplayBufNum: DWORD;  //播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1
    byNPQMode: BYTE;  //NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
    byRecvMetaData: BYTE;  //是否接收metadata数据，设备是否支持该功能通过GET /ISAPI/System/capabilities 中DeviceCap.SysCap.isSupportMetadata是否存在且为true
    byDataType: BYTE;  //数据类型，0-码流数据，1-音频数据
    byRes: array[0..213-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEWINFO = ^NET_DVR_PREVIEWINFO;

//连接类型枚举
type
  NET_DVR_LINK_KIND =  
  (  
    ENUM_LINK_PREVIEW = 1,  //预览
    ENUM_LINK_PLAYBACK,  //回放，下载
    ENUM_LINK_VOICEPLAY  //语音对讲/转发
  );

//连接地址结构体，RTSP取流时存在一个句柄创建多个端口通信的情况
type
  NET_DVR_LINK_ADDR = record 
    uLocalIP: NET_DVR_IPADDR_UNION;  //本地IP地址
    wLocalPort: array[0..10-1] of WORD;  //本地端口号
    byLocalPortNum: BYTE;  //本地端口数
    byRes1: array[0..3-1] of BYTE;  
    uDevIP: NET_DVR_IPADDR_UNION;  //设备IP地址
    wDevPort: array[0..10-1] of WORD;  //设备端口号
    byDevPortNum: BYTE;  //设备端口数
    byRes2: array[0..3-1] of BYTE;  
    byRes: array[0..80-1] of BYTE;  
  end;
  LPNET_DVR_LINK_ADDR = ^NET_DVR_LINK_ADDR;

//中心智能设备取流
type
  NET_DVR_PREVIEWINFO_SPECIAL = record 
    sURL: array[0..1024-1] of AnsiChar;  //取流URL，对应/ISAPI/SDT/Management/Region/ID返回的取流URL，部分设备返回的URL不合法，需要增加用户名密码节点，其中用户名和密码信息来自deviceUser和devicePassword节点
    //示例：rtsp://admin:abcd12345@10.7.37.2:554/Streaming/Channels/101?transportmode=unicast
    dwLinkMode: DWORD;  // 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP
    hPlayWnd: HWND;  //播放窗口的句柄,为NULL表示不播放图象
    bBlocked: DWORD;  //0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
    dwDisplayBufNum: DWORD;  //播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEWINFO_SPECIAL = ^NET_DVR_PREVIEWINFO_SPECIAL;


//事件触发报警输出

type
  NET_DVR_TRIGGER_EVENT = record 
    dwSize: DWORD;  
    dwOverallEventTriggerAlarmoutOn: DWORD;  //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
    dwOverallEventTriggerAlarmoutOff: DWORD;  //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
    dwSubSystemEventTriggerAlarmoutOn: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of DWORD;  //子系统事件触发报警输出开启,dwSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    dwSubSystemEventTriggerAlarmoutOff: array[0..MAX_ALARMHOST_SUBSYSTEM{32}-1] of DWORD;  //子系统事件触发报警输出关闭,wSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_TRIGGER_EVENT = ^NET_DVR_TRIGGER_EVENT;

//故障处理配置
type
  NET_DVR_ALARMHOST_FAULT_CFG = record 
    dwSize: DWORD;  
    dwCheckFault: DWORD;  //是否检测故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，bit9- FPGA故障，bit10- 模拟量故障, bit11-防区扩展板异常，bit12-WIFI通信故障，bit13-RF信号干扰故障，具体支持的故障类型从能力集获取
    dwOverallFaultJointLED: DWORD;  //故障关联全局键盘指示灯输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    dwOverallFaultJointSound: DWORD;  //故障关联全局键盘声音输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    dwSubSystemFaultJointLED: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of DWORD;  //故障关联子系统键盘指示灯输出，dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointLED[0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointLED[1]表示子系统2，以此类推
    dwSubSystemFaultJointSound: array[0..MAX_ALARMHOST_SUBSYSTEM-1] of DWORD;  //故障关联子系统键盘声音输出（声音在键盘上输出）dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointSound [0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointSound [1]表示子系统2，以此类推
    dwFaultJointFaultLight: DWORD;  //故障关联故障灯输出
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_FAULT_CFG = ^NET_DVR_ALARMHOST_FAULT_CFG;

type
  NET_DVR_LIST_INFO = record 
    dwSize: DWORD;  
    byIndex: BYTE;  //子系统号，0xff表示所有子系统
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_LIST_INFO = ^NET_DVR_LIST_INFO;

const
  CID_CODE_LEN = 4;    
  DEV_SERIAL_LEN = 9;    
type
  NET_DVR_ALARMHOST_REPORT_TYPE =  
  (  
    NET_DVR_DEFENCE_ALARM = 1,  //防区报警
    NET_DVR_VIDEO_ALARM,  //视频报警
    NET_DVR_VIRTUAL_DEFENCE_ALARM,  //软防区报警
    NET_DVR_HOSTAGE_ALARM,  //挟持报警
    NET_DVR_KNOCK_DOWN_ALARM,  //防拆报警
    NET_DVR_OPERATE_ALARM,  //操作报告
    NET_DVR_OHTER_ABNORMAL_ALARM  //异常报告
  );


type
  NET_DVR_ALARMHOST_CID_MAIN_TYPE =  
  (  
    CID_ENTER = 1000,  //触发报告的基数
    CID_EXIT = 3000  //恢复报告的基数
  );


type
  NET_DVR_ALARMHOST_CID_MINOR_TYPE =  
  (  
    CID_MEDICAL_ALARM = 100,  //救护报警
    CID_ALARM = 103,  //报警
    CID_FIRE_ALARM = 110,  //火警
    CID_ABDUCT_REPORT = 121,  //挟持报告
    CID_SILENT_24 = 122,  //24小时无声
    CID_AUDIO_24 = 123,  //24小时有声
    CID_AUXILIARY_24 = 124,  //24小时辅助
    CID_SHOCK_24 = 125,  //24小时震动
    CID_OVERTIME_ALARM = 126,  //超时报警
    CID_EMERGENCE_CALL_HELP = 129,  //紧急报警求助
    CID_BURGLARY_ALARM = 130,  //盗窃报警
    CID_PERIMETER_ALARM = 131,  //周界
    CID_INNET_ALARM = 132,  //内部防区
    CID_ENTER_EXIT = 134,  //出入
    CID_DEVICE_OPEN = 137,  //设备防拆
    CID_ZONE_BUS_BREAK = 141,  //总线开路
    CID_ZONE_BUS_SHORT = 142,  //总线短路
    CID_MOTION_ALARM = 148,  //移动报警
    CID_GAS_LEAKAGE = 151,  //燃气泄漏
    CID_ZONE_EARLY_WARNING = 207,  //防区预警
    CID_AC_LOSS = 301,  //交流掉电
    CID_LOW_BATT_VOL = 302,  //蓄电池电压低
    CID_DEV_RESET = 305,  //主机复位
    CID_MBUS_MODEL_FAULT = 333,  //扩展模块故障
    CID_PRINTER_FAIL = 336,  //打印机掉线
    CID_LOW_EXPANDER_VOL = 338,  //扩展模块电压低
    CID_EXPANDER_OPEN = 341,  //扩展模块被拆
    CID_EXPANDER_AC_POWER_DOWN = 342,  //扩展模块交流电掉电
    CID_WIRELESS_REPEATER_TAMPERED = 343,  //无线中继器防拆触发
    CID_WIRELESS_SIREN_TAMPERED = 344,  //无线警号防拆触发
    CID_WIRELESS_SIREN_DISCONNECTED = 345,  //无线警号掉线
    CID_LINE_LOSS = 354,  //电话线通讯失败
    CID_BUS_LOSS = 382,  //扩展总线模块掉线
    CID_DETECTOR_OPEN = 383,  //防区感应器被拆
    CID_ZONE_OPEN_CIRCUIT = 386,  //防区开路提醒
    CID_ZONE_SHORT_CIRCUIT = 387,  //防区短路提醒
    CID_GUARD = 401,  //布防撤防
    CID_GUARD_AUTO = 403,  //自动布撤防
    CID_CANCEL_ARM = 406,  //消警
    CID_GUARD_IMME = 408,  //即时布撤防
    CID_KEY_ZONE_GUARD = 409,  //钥匙防区布撤防
    CID_GUARD_STAY = 441,  //留守布撤防
    CID_FORCED_ARM = 442,  //强制布防
    CID_AUTOCTRL_TRIG = 443,  //定时开/关触发器
    CID_ONETOUCH_AWAY_ARMING = 444,  //一键外出布防
    CID_ONETOUCH_STAY_ARMING = 445,  //一键留守布防
    CID_CARD_ARMING_OR_DISARMING = 446,  //刷卡布撤防
    CID_LATE_TO_DISARM = 452,  //迟到撤防
    CID_AUTOGUARD_FAIL = 455,  //自动布防失败
    CID_AOPEN_TRIG_FAIL = 460,  //定时开启触发器失败
    CID_ACLOSE_TRIG_FAIL = 461,  //定时关闭触发器失败
    CID_AUTOUNGUARD_FAIL = 462,  //自动撤防失败
    CID_BYPASS = 570,  //旁路事件
    CID_GROUP_BYPASS = 574,  //组旁路
    CID_MANUAL_TEST_RPT = 601,  //手动测试报告
    CID_AUTO_TEST_RPT = 602,  //定时测试报告
    CID_PHONE_CONNET_TEST = 617,  //电话链路测试
    CID_ENTER_PROG = 627,  //进入编程
    CID_EXIT_PROG = 628,  //退出编程
    CID_FIELD_DETECTION = 759,  //区域入侵
    CID_LINE_DETECTION = 773,  //跨界报警
    CID_PIR_ALARM = 774,  //PIR报警
    CID_SOUND_INTENSITY_RISE = 775,  //声强陡升报警
    CID_SOUND_INTENSITY_DROP = 776,  //声强陡降报警
    CID_AUDIO_INPUT_EXCEPTION = 777,  //音频输入异常报警
    CID_SOFT_INSTAND = 810,  //软防区紧急报警
    CID_SOFT_FIRE = 811,  //软防区火警
    CID_SOFT_MOBS = 812,  //软防区匪警mobster
    CID_KEYPAD_LOCKED = 862,  //键盘锁定
    CID_ABSENCE_ALARM = 863,  //值守离岗
    CID_KEY_FAIL = 910,  //键盘掉线
    CID_TRIGGER_FAIL = 911,  //键盘总线上触发器掉线
    CID_GPK_FAIL = 912,  //键盘总线上GP/K掉线
    CID_MODULE_FAIL = 913,  //键盘总线上MN/K掉线
    CID_WIRELESS_DETECTOR_FAIL = 914,  //无线探测器掉线
    CID_WIRELESS_DETECTOR_BATTERY_LOW = 915,  //无线探测器欠压/电量恢复正常
    CID_EXPANDER_DISCONNECT = 916,  //扩展模块掉线
    CID_WIRELESS_REPEATER_DISCONNECT = 917,  //无线中继器掉线
    CID_RADAR_TRANS_FAULT = 918,  //雷达信号异常
    CID_WIRELESS_SIREN_LOW_BATTERY = 919,  //无线警号电量低
    CID_WRIE_LESS_NET = 920,  //无线网络故障
    CID_SIM_FAULT = 921,  //SIM卡故障
    CID_WIFI_ABNORMAL = 922,  //WIFI通信异常/恢复正常
    CID_RF_ABNORMAL = 923,  //RF信号异常/恢复正常
    CID_DATE_TRAFFIC_OVERFLOW = 924,  //流量超额
    CID_IPADDR_CONFLICT = 930,  //IP冲突
    CID_ETHERNET_BROKEN = 931,  //网线断
    CID_GROUP_OUT_RP = 932,  //组间通讯失败
    CID_GROUP_IN_RP = 933,  //通道通讯失败
    CID_MOTION_DECTECT = 940,  //移动侦测报警开始/结束
    CID_MASK_ALARM = 941,  //遮挡报警开始/结束
    CID_VI_LOST = 942,  //视频丢失开始/结束
    CID_VS_MISMATCH = 943,  //输入/输出视频制式不匹配
    CID_VI_EXCEPTION = 944,  //视频输入异常/恢复正常
    CID_HD_FULL = 945,  //硬盘满/恢复正常
    CID_HD_ERROR = 946,  //硬盘错/恢复正常
    CID_PIC_SEND_FAILED = 947,  //图片上传失败
    CID_KEY_LOCKED = 948,  //键盘锁定
    CID_NETWORK_CAMERA_DISCONNECT = 949,  //IPC断开连接
    CID_DUTY_CHECKING = 960,  //值守查岗
    CID_POST_RESPONSE = 961,  //值守应答
    CID_ZONE_BUS_SEARCH = 970,  //总线搜索
    CID_ZONE_BUS_REGIST = 971,  //总线注册
    CID_GUARD_DELAY_OP = 972,  //自动布撤防延时操作
    CID_GUARD_SINGLE = 973,  //单防区布撤防
    CID_SINGLE_ZONE_CLEARED = 974,  //单防区消警
    CID_ZONE_ASSOCIATED_DETECTOR = 975,  //防区添加/删除探测器
    CID_ZONE_CONSULTING = 976,  //业务咨询
    CID_EXPANDER_DELETED = 977,  //删除扩展模块
    CID_WIRELESS_REPEATER_DELETED = 978,  //删除无线中继器
    CID_WIRELESS_SIREN_DELETED = 979  //删除无线警号
  );

type
  NET_DVR_ALARMHOST_CID_ALL_MINOR_TYPE =  
  (  
    CID_TYPE_MEDICAL_ALARM = 1100,  //个人救护报警
    CID_TYPE_MEDICAL_ALARM_RESET = 3100,  //个人救护报警恢复
    CID_TYPE_ALARM = 1103,  //即时报警
    CID_TYPE_ALARM_RESET = 3103,  //即时报警恢复
    CID_TYPE_FIRE_ALARM = 1110,  //火警报警
    CID_TYPE_FIRE_ALARM_RESET = 3110,  //火警报警恢复
    CID_TYPE_ABDUCT_REPORT = 1121,  //挟持报告
    CID_TYPE_SILENT_24 = 1122,  //24小时无声报警
    CID_TYPE_SILENT_24_RESET = 3122,  //24小时无声报警恢复
    CID_TYPE_AUDIO_24 = 1123,  //24小时有声报警
    CID_TYPE_AUDIO_24_RESET = 3123,  //24小时有声报警恢复
    CID_TYPE_AUXILIARY_24 = 1124,  //24小时辅助报警
    CID_TYPE_AUXILIARY_24_RESET = 3124,  //24小时辅助报警恢复
    CID_TYPE_SHOCK_24 = 1125,  //24小时震动报警
    CID_TYPE_SHOCK_24_RESET = 3125,  //24小时震动报警恢复
    CID_TYPE_TIMEOUT = 1126,  //超时报警
    CID_TYPE_TIMEOUT_RESET = 3126,  //超时报警恢复
    CID_TYPE_EMERGENCE_CALL_HELP = 1129,  //紧急求助报警
    CID_TYPE_EMERGENCE_CALL_HELP_RESET = 3129,  //紧急求助报警恢复
    CID_TYPE_BURGLARY_ALARM = 1130,  //盗窃报警
    CID_TYPE_BURGLARY_ALARM_RESET = 3130,  //盗窃报警恢复
    CID_TYPE_PERIMETER_ALARM = 1131,  //周界报警
    CID_TYPE_PERIMETER_ALARM_RESET = 3131,  //周界报警恢复
    CID_TYPE_INNET_ALARM = 1132,  //内部延时报警
    CID_TYPE_INNET_ALARM_RESET = 3132,  //内部延时报警恢复
    CID_TYPE_ENTER_EXIT = 1134,  //延时报警
    CID_TYPE_ENTER_EXIT_RESET = 3134,  //延时报警恢复
    CID_TYPE_DEVICE_OPEN = 1137,  //设备防拆报警
    CID_TYPE_DEVICE_OPEN_RESET = 3137,  //设备防拆报警恢复
    CID_TYPE_ZONE_BUS_BREAK = 1141,  //总线开路报警
    CID_TYPE_ZONE_BUS_BREAK_RESET = 3141,  //总线开路报警恢复
    CID_TYPE_ZONE_BUS_SHORT = 1142,  //总线短路报警
    CID_TYPE_ZONE_BUS_SHORT_RESET = 3142,  //总线短路报警恢复
    CID_TYPE_MOTION_ALARM = 1148,  //设备移动报警
    CID_TYPE_MOTION_ALARM_RESET = 3148,  //设备移动报警恢复
    CID_TYPE_GAS_LEAKAGE_ALARM = 1151,  //燃气泄漏报警
    CID_TYPE_GAS_LEAKAGE_ALARM_RESET = 3151,  //燃气泄漏报警恢复
    CID_TYPE_ZONE_EARLY_WARNING = 1207,  //防区预警
    CID_TYPE_ZONE_EARLY_WARNING_RESET = 3207,  //防区预警恢复
    CID_TYPE_AC_LOSS = 1301,  //交流电掉电
    CID_TYPE_AC_LOSS_RESET = 3301,  //交流电恢复
    CID_TYPE_LOW_BATT_VOL = 1302,  //蓄电池电压低
    CID_TYPE_LOW_BATT_VOL_NORMAL = 3302,  //蓄电池电压正常
    CID_TYPE_DEV_RESET = 1305,  //主机复位
    CID_TYPE_MBUS_MODEL_FAULT = 1333,  //扩展模块故障
    CID_TYPE_MBUS_MODEL_RESET = 3333,  //扩展模块恢复
    CID_TYPE_PRINTER_OFF = 1336,  //打印机掉线
    CID_TYPE_PRINTER_ON = 3336,  //打印机恢复
    CID_TYPE_EXTEND_MODULE_VOL_LOW = 1338,  //扩展模块电压低
    CID_TYPE_EXTEND_MODULE_VOL_NORMAL = 3338,  //扩展模块电压正常
    CID_TYPE_EXTEND_MODULE_REMOVE = 1341,  //扩展模块防拆触发
    CID_TYPE_EXTEND_MODULE_RECOVER = 3341,  //扩展模块防拆恢复
    CID_TYPE_EXTEND_MODULE_AC_LOSS = 1342,  //扩展模块交流电掉电
    CID_TYPE_EXTEND_MODULE_AC_LOSS_RESET = 3342,  //扩展模块交流电恢复
    CID_TYPE_WIRELESS_REPEATER_TAMPER = 1343,  //无线中继器防拆触发
    CID_TYPE_WIRELESS_REPEATER_RESTORE = 3343,  //无线中继器防拆恢复
    CID_TYPE_WIRELESS_SIREN_TAMPER = 1344,  //无线警号防拆触发
    CID_TYPE_WIRELESS_SIREN_RESTORE = 3344,  //无线警号防拆恢复
    CID_TYPE_WIRELESS_SIREN_DISCONNECT = 1345,  //无线警号掉线
    CID_TYPE_WIRELESS_SIREN_CONNECT = 3345,  //无线警号掉线恢复
    CID_TYPE_LINE_LOSS = 1354,  //电话线断开
    CID_TYPE_LINE_LOSS_RESET = 3354,  //电话线连接
    CID_TYPE_BUS_LOSS = 1382,  //扩展总线模块掉线
    CID_TYPE_BUS_LOSS_RESET = 3382,  //扩展总线模块掉线恢复
    CID_TYPE_SENSOR_TAMPER = 1383,  //防区感应器防拆
    CID_TYPE_SENSOR_TAMPER_RESET = 3383,  //防区感应器防拆恢复
    CID_TYPE_ZONE_OPEN_CIRCUIT_ALARM = 1386,  //防区开路提醒
    CID_TYPE_ZONE_SHORT_CIRCUIT_ALARM = 1387,  //防区短路提醒
    CID_TYPE_DISARM = 1401,  //撤防
    CID_TYPE_ARM = 3401,  //外出布防
    CID_TYPE_DISARM_AUTO = 1403,  //自动撤防
    CID_TYPE_ARM_AUTO = 3403,  //自动布防
    CID_TYPE_CANCEL_ARM = 1406,  //消警
    CID_TYPE_ARM_IMME = 3408,  //即时布防
    CID_TYPE_KEY_ZONE_ARM = 1409,  //钥匙防区撤防
    CID_TYPE_KEY_ZONE_DISARM = 3409,  //钥匙防区布防
    CID_TYPE_GUARD_STAY = 3441,  //留守布防
    CID_TYPE_FORCED_ARM = 3442,  //强制布防
    CID_TYPE_AUTOCTRL_TRIG_ON = 1443,  //定时开触发器
    CID_TYPE_AUTOCTRL_TRIG_OFF = 3443,  //定时关触发器
    CID_TYPE_LATE_TO_DISARM = 1452,  //迟到撤防
    CID_TYPE_AUTOGUARD_FAIL = 1455,  //自动布撤防失败
    CID_TYPE_AOPEN_TRIG_FAIL = 1460,  //定时开启触发器失败
    CID_TYPE_ACLOSE_TRIG_FAIL = 1461,  //定时关闭触发器失败
    CID_TYPE_AUTOUNGUARD_FAIL = 1462,  //自动撤防失败
    CID_TYPE_BYPASS = 1570,  //旁路
    CID_TYPE_BYPASS_RESET = 3570,  //旁路恢复
    CID_TYPE_GROUP_BYPASS = 1574,  //子系统组旁路
    CID_TYPE_GROUP_BYPASS_RESET = 3574,  //子系统组旁路恢复
    CID_TYPE_MANUAL_TEST_RPT = 1601,  //手动测试报告
    CID_TYPE_AUTO_TEST_RPT = 1602,  //定时测试报告
    CID_TYPE_LINE_TEST = 1617,  //电话链路测试
    CID_TYPE_ENTER_PROG = 1627,  //进入编程
    CID_TYPE_EXIT_PROG = 1628,  //退出编程
    CID_TYPE_FIELD_DETECTION = 1759,  //区域入侵
    CID_TYPE_FIELD_DETECTION_RESET = 3759,  //区域入侵恢复
    CID_TYPE_LINE_DETECTION = 1773,  //跨界报警
    CID_TYPE_LINE_DETECTION_RESET = 3773,  //跨界报警恢复
    CID_TYPE_PIR_ALARM = 1774,  //PIR报警
    CID_TYPE_PIR_ALARM_RESET = 3774,  //PIR报警恢复
    CID_TYPE_SOUND_INTENSITY_RISE = 1775,  //声强陡升报警
    CID_TYPE_SOUND_INTENSITY_RISE_RESET = 3775,  //声强陡升报警恢复
    CID_TYPE_SOUND_INTENSITY_DROP = 1776,  //声强陡降报警
    CID_TYPE_SOUND_INTENSITY_DROP_RESET = 3776,  //声强陡降报警恢复
    CID_TYPE_AUDIO_INPUT_EXCEPTION = 1777,  //音频输入异常报警
    CID_TYPE_AUDIO_INPUT_EXCEPTION_RESET = 3777,  //音频输入异常报警恢复
    CID_TYPE_SOFT_INSTAND = 1810,  //软防区紧急报警
    CID_TYPE_SOFT_FIRE = 1811,  //软防区火警
    CID_TYPE_SOFT_MOBS = 1812,  //软防区匪警
    CID_TYPE_KEYPAD_LOCK = 1862,  //键盘锁定
    CID_TYPE_KEYPAD_UNLOCK = 3862,  //键盘解锁
    CID_TYPE_ABSENCE_ALARM = 1863,  //值守离岗
    CID_TYPE_KEY_FAIL = 1910,  //键盘掉线
    CID_TYPE_KEY_RESET = 3910,  //键盘恢复
    CID_TYPE_TRIGGER_FAIL = 1911,  //键盘总线上触发器掉线
    CID_TYPE_TRIGGER_RESET = 3911,  //键盘总线上触发器恢复
    CID_TYPE_GPK_FAIL = 1912,  //键盘总线上GP/K掉线
    CID_TYPE_GPK_RESET = 3912,  //键盘总线上GP/K恢复
    CID_TYPE_MODULE_FAIL = 1913,  //键盘总线上MN/K掉线
    CID_TYPE_MODULE_RESET = 3913,  //键盘总线上MN/K恢复
    CID_TYPE_WIRELESS_DETECTOR_FAIL = 1914,  //无线探测器掉线
    CID_TYPE_WIRELESS_DETECTOR_RESET = 3914,  //无线探测器掉线恢复
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_LOW = 1915,  //无线探测器电压低
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_NORMAL = 3915,  //无线探测器电压正常
    CID_TYPE_EXTEND_MODULE_LOSS = 1916,  //扩展模块掉线
    CID_TYPE_EXTEND_MODULE_LOSS_RESET = 3916,  //扩展模块掉线恢复
    CID_TYPE_WIRELESS_REPEATER_DISCONNECT = 1917,  //无线中继器掉线
    CID_TYPE_WIRELESS_REPEATER_CONNECT = 3917,  //无线中继器掉线恢复
    CID_TYPE_RADAR_TRANS_FAULT = 1918,  //雷达信号异常
    CID_TYPE_RADAR_TRANS_RESET = 3918,  //雷达信号异常恢复
    CID_TYPE_WRIELESS_SIREN_LOW_BATTERY = 1919,  //无线警号电量低
    CID_TYPE_NORMAL_WRIELESS_SIREN_BATTERY = 3919,  //无线警号电量正常
    CID_TYPE_WRIELESS_NET_FAULT = 1920,  //无线网络故障
    CID_TYPE_WRIELESS_NET_RESET = 3920,  //无线网络故障恢复
    CID_TYPE_SIM_FAULT = 1921,  //SIM卡异常
    CID_TYPE_SIM_RESET = 3921,  //SIM卡异常恢复
    CID_TYPE_WIFI_ABNORMAL = 1922,  //WIFI通信异常
    CID_TYPE_WIFI_NORMAL = 3922,  //WIFI通信恢复正常
    CID_TYPE_RF_ABNORMAL = 1923,  //RF信号异常
    CID_TYPE_RF_NORMAL = 3923,  //RF信号正常
    CID_TYPE_DATE_TRAFFIC_OVERFLOW = 1924,  //流量超额
    CID_TYPE_IPADDR_CONFLICT = 1930,  //IP冲突
    CID_TYPE_IPADDR_NORMAL = 3930,  //IP正常
    CID_TYPE_ETHERNET_BROKEN = 1931,  //有线网络故障
    CID_TYPE_ETHERNET_NORMAL = 3931,  //有线网络故障恢复
    CID_TYPE_MOTION_DECTECT_START = 1940,  //移动侦测报警开始
    CID_TYPE_MOTION_DECTECT_STOP = 3940,  //移动侦测报警结束
    CID_TYPE_MASK_ALARM_START = 1941,  //遮挡报警开始
    CID_TYPE_MASK_ALARM_STOP = 3941,  //遮挡报警结束
    CID_TYPE_VI_LOST_START = 1942,  //视频信号丢失
    CID_TYPE_VI_LOST_STOP = 3942,  //视频信号恢复
    CID_TYPE_VS_MISMATCH = 1943,  //输入/输出视频制式不匹配
    CID_TYPE_VS_MATCH = 3943,  //输入/输出视频制式恢复正常
    CID_TYPE_VI_EXCEPTION = 1944,  //视频输入异常
    CID_TYPE_VI_NORMAL = 3944,  //视频输入恢复正常
    CID_TYPE_HD_FULL = 1945,  //硬盘满
    CID_TYPE_HD_FREE = 3945,  //硬盘空闲
    CID_TYPE_HD_ERROR = 1946,  //硬盘异常
    CID_TYPE_HD_RESET = 3946,  //硬盘恢复正常
    CID_TYPE_PIC_SEND_FAILED = 1947,  //图片上传失败
    CID_TYPE_SENDING_EMAIL_FAILED = 1948,  //邮件发送失败
    CID_TYPE_NETWORK_CAMERA_DISCONNECT = 1949,  //IPC断开连接
    CID_TYPE_NETWORK_CAMERA_CONNECT = 3949,  //IPC恢复连接
    CID_TYPE_DUTY_CHECKING = 1960,  //值守查岗
    CID_TYPE_POST_RESPONSE = 1961,  //值守应答
    CID_TYPE_ZONE_BUS_SEARCH = 1970,  //总线搜索
    CID_TYPE_ZONE_BUS_REGIST = 1971,  //总线注册
    CID_TYPE_GUARD_SINGLE_ARM = 1973,  //单防区撤防
    CID_TYPE_GUARD_SINGLE_DISARM = 3973,  //单防区布防
    CID_TYPE_SINGLE_ZONE_ALARM_CLEARED = 1974,  //单防区消警
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_DEL = 1975,  //删除探测器
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_ADD = 3975,  //添加探测器
    CID_TYPE_ZONE_CONSULT = 1976,  //业务咨询
    CID_TYPE_ZONE_CONSULT_STOP = 3976,  //业务咨询结束
    CID_TYPE_EXTEND_MODULE_DEL = 1977,  //删除扩展模块
    CID_TYPE_EXTEND_MODULE_ADD = 3977,  //添加扩展模块
    CID_TYPE_WIRELESS_REPEATER_DEL = 1978,  //删除无线中继器
    CID_TYPE_WIRELESS_REPEATER_ADD = 3978,  //添加无线中继器
    CID_TYPE_WIRELESS_SIREN_DEL = 1979,  //删除无线警号
    CID_TYPE_WIRELESS_SIREN_ADD = 3979  //添加无线警号
  );


type
  NET_DVR_CID_ALARM = record 
    dwSize: DWORD;  
    sCIDCode: array[0..CID_CODE_LEN{4}-1] of BYTE;  //CID事件号
    sCIDDescribe: array[0..NAME_LEN{32}-1] of BYTE;  //CID事件名
    struTriggerTime: NET_DVR_TIME_EX;  //触发报警的时间点
    struUploadTime: NET_DVR_TIME_EX;  //上传报警的时间点
    sCenterAccount: array[0..ACCOUNTNUM_LEN{6}-1] of BYTE;  //中心帐号
    byReportType: BYTE;  //见定义NET_DVR_ALARMHOST_REPORT_TYPE
    byUserType: BYTE;  //用户类型，0-网络用户 1-键盘用户,2-手机用户,3-系统用户
    sUserName: array[0..NAME_LEN{32}-1] of BYTE;  //网络用户用户名
    wKeyUserNo: WORD;  //键盘用户号    0xFFFF表示无效
    byKeypadNo: BYTE;  //键盘号        0xFF表示无效
    bySubSysNo: BYTE;  //子系统号        0xFF表示无效
    wDefenceNo: WORD;  //防区号        0xFFFF表示无效
    byVideoChanNo: BYTE;  //视频通道号   0表示无效，表示设备自带的默认视频通道号
    byDiskNo: BYTE;  //硬盘号        0xFF表示无效
    wModuleAddr: WORD;  //模块地址        0xFFFF表示无效
    byCenterType: BYTE;  //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    byRelativeChannel: BYTE;  //外接的视频通道号，0表示无效，字节表示通道号
    sCenterAccountV40: array[0..ACCOUNTNUM_LEN_32{32}-1] of BYTE;  //中心账号V40,使用此字段时sCenterAccount无效
    byDevSerialNo: array[0..DEV_SERIAL_LEN-1] of BYTE;  //产品序列号
    byRepeaterNo: BYTE;  //中继器号，为0无效
    wRemoteCtrllerUserNo: WORD;  //遥控器用户号，为0无效
    dwIOTChannelNo: DWORD;  //IOT通道号
    standardCIDcode: BYTE;  //标准CID码
    byRes2: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_CID_ALARM = ^NET_DVR_CID_ALARM;

type
  NET_DVR_ALARMHOST_MODULE_CFG = record 
    dwSize: DWORD;  
    byModuleType: BYTE;  //1-防区，2-触发器 3-防区触发器
    byZoneType: BYTE;  //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区，6-单防区触发器，0xff表示该参数无效
    byTriggerType: BYTE;  //触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，0xff表示该参数无效
    byRes1: array[0..1-1] of BYTE;  
    sModelInfo: array[0..MODULE_INFO_LEN-1] of AnsiChar;  //模块信息
    sDeviceVersionInfo: array[0..VERSION_INFO_LEN-1] of AnsiChar;  // 版本信息
    byRes: array[0..188-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_MODULE_CFG = ^NET_DVR_ALARMHOST_MODULE_CFG;


const
  MAX_DECODE_CARD_SUPPORTDISPNUMS = 8;    //每个解码卡最多支持的显示通道数
//  MAX_SUPPORT_RES = 32;    
type
  NET_DVR_DECCARD_ABILITY_V41 = record //高清解码卡能力集
    byCardType: BYTE;  //解码卡类型(0:MD,1:MD+,2:HD)
    byDecNums: BYTE;  //解码通道数
    byDispNums: BYTE;  //显示通道数
    byDecStartIdx: BYTE;  //首个解码通道在所有解码通道中的索引
    byDispStartIdx: BYTE;  //首个显示通道在所有显示通道中的索引
    byRes1: array[0..3-1] of BYTE;  
    dwVgaSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwHdmiSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwDviSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwYpbprSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    byDispFormat: array[0..MAX_DECODE_CARD_SUPPORTDISPNUMS-1] of BYTE;  //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举)
    byWindowMode: array[0..MAX_DECODE_CARD_SUPPORTDISPNUMS-1, 0..12-1] of BYTE;  //支持的窗口模式(比如1,2,4,9,16))
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_DECCARD_ABILITY_V41 = ^NET_DVR_DECCARD_ABILITY_V41;

//  MAX_DECODE_CARD_NUM = 6;    //最多高清解码卡数
type
  NET_DVR_DECODESVR_ABILITY_V41 = record 
    dwSize: DWORD;  // 结构体大小 
    byCardNums: BYTE;  // 解码卡数 
    byStartChan: BYTE;  // 起始通道号 
    byRes1: array[0..2-1] of BYTE;  
    struDecCardAbility: array[0..MAX_DECODE_CARD_NUM-1] of NET_DVR_DECCARD_ABILITY_V41;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DECODESVR_ABILITY_V41 = ^NET_DVR_DECODESVR_ABILITY_V41;

// 流录像状态
type
  NET_DVR_STREAM_RECORD_STATUS = record 
    dwSize: DWORD;  
    byRecord: BYTE;  //(只读)录像类型, 0：不在录像，1：在录像 2-空闲
    //3-无连接 4-无输入视频 5-未加载 6-存档中
    //7-回传中 8-用户名或密码错 9-未验证
    //10-存档中和录像中 11-录像回传中和录像中12-token认证失败
    //13-当前条件不满足录像计划条件 14-通道接入异常（见通道状态） 15-硬盘满
    //16-硬盘错 17-无硬盘
    byOffLineRecord: BYTE;  //断网录像功能 0-关闭 1-开启
    byRes1: array[0..2-1] of BYTE;  //保留字节
    dwRelatedHD: DWORD;  //关联磁盘
    byRes2: array[0..8-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_STREAM_RECORD_STATUS = ^NET_DVR_STREAM_RECORD_STATUS;

const
  CHAN_NO_LEN = 24;    

type
  NET_DVR_DIRECT_CONNECT_CHAN_INFO = record 
    byEnable: BYTE;  //是否启用
    byProType: BYTE;  //协议类型，0-私有协议(default), (需要从设备获取能力)
    byZeroChan: BYTE;  //是否是零通道,0-不是，1-是
    byPriority: BYTE;  //优先级
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码
    byDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备域名
    struIP: NET_DVR_IPADDR;  //IP地址
    wDVRPort: WORD;  //端口号
    byStreamType: BYTE;  //主码流:0; 子码流：1
    byOnline: BYTE;  //只读，0-不在线 1-在线
    dwChannel: DWORD;  //通道号
    byTransProtocol: BYTE;  //协议类型，0-TCP，1-UDP，2-多播
    byLocalBackUp: BYTE;  //本地备份: 0-不启用CVR本地备份，1-启用CVR本地备份--即回放时的流一份在录像卷，一份在存档卷（本地备份）
    wDirectLastTime: WORD;  //导播持续时间
    byChanNo: array[0..CHAN_NO_LEN-1] of BYTE;  //通道编号--用于VAG取流
  end;
  LPNET_DVR_DIRECT_CONNECT_CHAN_INFO = ^NET_DVR_DIRECT_CONNECT_CHAN_INFO;

type
  NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40 = record 
    byEnable: BYTE;  //是否启用
    byProType: BYTE;  //协议类型，0-私有协议(default), 1-松下协议，2-索尼, 3-大华 (需要从设备获取能力)
    byZeroChan: BYTE;  //是否是零通道,0-不是，1-是
    byRes1: BYTE;  //保留字段，置0
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //前端IP或者域名,需要设备 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    wDVRPort: WORD;  //端口号
    byStreamType: BYTE;  //主码流:0; 子码流：1
    byOnline: BYTE;  //只读，0-不在线 1-在线
    dwChannel: DWORD;  //通道号
    byTransProtocol: BYTE;  //传输协议类型，0-TCP，1-UDP 2-多播
    byLocalBackUp: BYTE;  //本地备份，0-不启用CVR本地备份，1-启用CVR本地备份--即录像时的流一份在录像卷，一份在存档卷（本地备份）
    byRes2: array[0..2-1] of BYTE;  //保留字段，置0
    byVAGChanNo: array[0..MAX_VAG_CHANNO_LEN-1] of BYTE;  //协议类型为VAG时，对应的VAG通道编号
    byRes: array[0..340-1] of BYTE;  
  end;
  LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40 = ^NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


type
  NET_DVR_PU_STREAM_URL_CFG = record 
    byEnable: BYTE;  
    byRes: array[0..3-1] of BYTE;  
    byStreamMediaIP: array[0..64-1] of BYTE;  //流媒体IP
    wStreamMediaPort: WORD;  //流媒体端口
    byTransmitType: BYTE;  //流媒体传输协议 0- TCP  1- UDP
    byRes1: array[0..33-1] of BYTE;  
    byDevIP: array[0..64-1] of BYTE;  //设备IP
    wDevPort: WORD;  //设备端口
    byChannel: BYTE;  //通道号
    byTransMode: BYTE;  //传输模式 0-主码流 1- 子码流
    byProType: BYTE;  
    //厂家类型 0-私有 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    byTransProtocol: BYTE;  //传输协议类型0-TCP,  1-UDP,  2-多播方式,  3-RTP
    byRes3: array[0..2-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //设备登陆用户名
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // 设备登陆密码
    byRes2: array[0..28-1] of BYTE;  //预留
  end;
  LPNET_DVR_PU_STREAM_URL_CFG = ^NET_DVR_PU_STREAM_URL_CFG;

type
  NET_DVR_PU_STREAM_URL_CFG_V40 = record 
    byEnable: BYTE;  
    byRes: array[0..3-1] of BYTE;  
    byStreamMediaIP: array[0..64-1] of BYTE;  //流媒体IP
    wStreamMediaPort: WORD;  //流媒体端口
    byTransmitType: BYTE;  //流媒体传输协议 0- TCP  1- UDP
    byRes1: BYTE;  
    byDevIP: array[0..64-1] of BYTE;  //设备IP
    wDevPort: WORD;  //设备端口
    byChannel: BYTE;  //通道号
    byTransMode: BYTE;  //传输模式 0-主码流 1- 子码流
    byProType: BYTE;  
    //厂家类型 0-海康 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    byTransProtocol: BYTE;  //传输协议类型0-TCP,  1-UDP  2-多播方式
    byRes3: array[0..2-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //设备登陆用户名
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // 设备登陆密码
    byRes2: array[0..308-1] of BYTE;  //预留
  end;
  LPNET_DVR_PU_STREAM_URL_CFG_V40 = ^NET_DVR_PU_STREAM_URL_CFG_V40;

type
  NET_DVR_STREAM_URL_V40 = record 
    byEnable: BYTE;  
    byStreamType: BYTE;  //主子码流
    byLocalBackUp: BYTE;  //是否本地备份
    byRes: BYTE;  
    strURL: array[0..URL_LEN_V40-1] of BYTE;  //流媒体URL，可以级联
    dwProtocalType: DWORD;  //IPC协议类型值，可以通过获取IPC协议列表得到
    sUserName: array[0..NAME_LEN-1] of BYTE;  //设备登陆用户名
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // 设备登陆密码
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //流来源IP或者域名,需要解析 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    wIPPort: WORD;  //流来源对应的端口号
    wChanNo: WORD;  //流来源设备IP通道号
    byVAGChanNo: array[0..MAX_VAG_CHANNO_LEN-1] of BYTE;  //流来源通道编号,用于VAG功能
    byRes1: array[0..88-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_URL_V40 = ^NET_DVR_STREAM_URL_V40;

type
  NET_DVR_STREAM_TYPE_UNION = record 
    case Byte of
    0: (struChanInfo: NET_DVR_DIRECT_CONNECT_CHAN_INFO);  //IP通道信息  类型值为0
    1: (struStreamUrl: NET_DVR_PU_STREAM_URL);  //通过流媒体到url取流，类型值为4
    2: (struStreamUrlCfg: NET_DVR_PU_STREAM_URL_CFG);  //通过流媒体到指定布防设备上取流，类型值为6
  end;
  LPNET_DVR_STREAM_TYPE_UNION = ^NET_DVR_STREAM_TYPE_UNION;

type
  NET_DVR_STREAM_TYPE_V40_UNION = record 
    case Byte of
    0: (struChanInfo: NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40);  //IP通道信息，类型值为0
    1: (struPuStreamUrl: NET_DVR_PU_STREAM_URL);  //通过流媒体到url取流，类型值为4
    2: (struStreamUrlCfg: NET_DVR_PU_STREAM_URL_CFG_V40);  //通过流媒体到组合url取流，类型值为6
    3: (struRtspCfg: NET_DVR_RTSP_PROTOCAL_CFG);  //由标准RTSP接入取流 类型值7
    4: (struStreamUrlV40: NET_DVR_STREAM_URL_V40);  //通过流媒体（支持级联方式）向流来源取流，类型值为8
  end;
  LPNET_DVR_STREAM_TYPE_V40_UNION = ^NET_DVR_STREAM_TYPE_V40_UNION;


type
  NET_DVR_STREAM_MODE_TYPE = record 
    byGetStreamType: BYTE;  //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流
    byRes: array[0..3-1] of BYTE;  // 保留字节
    uGetStream: NET_DVR_STREAM_TYPE_UNION;  // 不同取流方式结构体
  end;
  LPNET_DVR_STREAM_MODE_TYPE = ^NET_DVR_STREAM_MODE_TYPE;

// 流来源信息
type
  NET_DVR_STREAM_SRC_INFO = record 
    dwSize: DWORD;  
    struStreamSrcInfo: NET_DVR_STREAM_MODE_TYPE;  
  end;
  LPNET_DVR_STREAM_SRC_INFO = ^NET_DVR_STREAM_SRC_INFO;

type
  NET_DVR_STREAM_SRC_INFO_V40 = record 
    dwSize: DWORD;  
    byGetStreamType: BYTE;  //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流 6-通过流媒体到指定布防设备上取流
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    uGetStream: NET_DVR_STREAM_TYPE_V40_UNION;  // 不同取流方式结构体
    byMonitorName: array[0..128-1] of BYTE;  {布防点名称（支持中文，大小写字母，数字，下划线等非特殊字符，编码格式根据登录返回的byCharEncodeType字段判断，
                                                    目前CVR中英文版本不一样，有不同选择，中文CVR要求布防点名称为gbk，英文版本CVR要求布防点名称为iso8859-1，如“A号楼_布防点1”）}
    byRes: array[0..384-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_STREAM_SRC_INFO_V40 = ^NET_DVR_STREAM_SRC_INFO_V40;


// 流录像信息
type
  NET_DVR_STREAM_RECORD_INFO = record 
    dwSize: DWORD;  
    struRecordInfo: NET_DVR_RECORD_V30;  
  end;
  LPNET_DVR_STREAM_RECORD_INFO = ^NET_DVR_STREAM_RECORD_INFO;

// 按流ID对时间段加锁
type
  NET_DVR_STREAM_TIME_LOCK = record 
    dwSize: DWORD;  // 结构体大小
    strBeginTime: NET_DVR_TIME;  // 开始时间
    strEndTime: NET_DVR_TIME;  // 结束时间
    struStreamInfo: NET_DVR_STREAM_INFO;  // 流信息
    dwRecordType: DWORD;  // 录像类型:  0xffffffff－全部，－定时录像，-移动侦测，－报警触发，-报警触发或移动侦测，-报警触发和移动侦测，-命令触发，-手动录像，-智能录像(同文件查找)
    dwLockDuration: DWORD;  // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    strUnlockTimePoint: NET_DVR_TIME_EX;  // 加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
    byRes: array[0..1-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_TIME_LOCK = ^NET_DVR_STREAM_TIME_LOCK;

//回放抽帧接口 开始抽帧命令 NET_DVR_START_DRAWFRAME，对应的控制结构体
type
  NET_DVR_VOD_DRAWFRAME_PARA = record 
    struTime: NET_DVR_TIME_EX;  
    {
    dwDrawType只有设备支持选择性抽帧时，参数才有效果，抽帧方式有：
    0：只传I帧
    1：丢1/2 P帧（只有svc码流支持）
    2：丢3/4P帧 （只有svc码流支持）
    3：传1/2 I帧(只传I帧，且每2个I帧传一个。)
    4：传1/4 I振(只传I帧，且每4个I帧传一个。)
    5：传1/8 I帧(只传I帧，且每8个I帧传一个。)
    }
    dwDrawType: DWORD;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_VOD_DRAWFRAME_PARA = ^NET_DVR_VOD_DRAWFRAME_PARA;

// 按ID+时间回放结构体
type
  NET_DVR_VOD_PARA = record 
    dwSize: DWORD;  
    struIDInfo: NET_DVR_STREAM_INFO;  
    struBeginTime: NET_DVR_TIME;  
    struEndTime: NET_DVR_TIME;  
    hWnd: HWND;  
    byDrawFrame: BYTE;  //0:不抽帧，1：抽帧
    byVolumeType: BYTE;  //0-普通录像卷  1-存档卷
    byVolumeNum: BYTE;  //卷号，目前指存档卷号
    byStreamType: BYTE;  //码流类型 0-主码流， 1-子码流，2-码流三，3-延时摄影码流
    dwFileIndex: DWORD;  //存档卷上的录像文件索引，搜索存档卷录像时返回的值
    byAudioFile: BYTE;  //音频文件0-否，1-是
    byCourseFile: BYTE;  //课程文件0-否，1-是
    byDownload: BYTE;  //是否下载 0-否，1-是
    byOptimalStreamType: BYTE;  //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    byUseAsyn: BYTE;  //0-使用同步IO，1-使用异步IO
    byRes2: array[0..19-1] of BYTE;  
  end;
  LPNET_DVR_VOD_PARA = ^NET_DVR_VOD_PARA;

type
  NET_DVR_VOD_PARA_V50 = record 
    dwSize: DWORD;  
    struIDInfo: NET_DVR_STREAM_INFO;  
    struBeginTime: NET_DVR_TIME_V50;  
    struEndTime: NET_DVR_TIME_V50;  
    hWnd: HWND;  
    byDrawFrame: BYTE;  //0:不抽帧，1：抽帧
    byVolumeType: BYTE;  //0-普通录像卷  1-存档卷
    byVolumeNum: BYTE;  //卷号，目前指存档卷号
    byStreamType: BYTE;  //码流类型 0-主码流， 1-子码流，2-码流三，3-延时摄影码流
    dwFileIndex: DWORD;  //存档卷上的录像文件索引，搜索存档卷录像时返回的值
    byAudioFile: BYTE;  //回放音频文件，0-不回放音频文件，1-仅回放音频文件
    byCourseFile: BYTE;  //回放课程文件0-否，1-是
    byPlayMode: BYTE;  //播放方式0-正放，1-倒放
    byLinkMode: BYTE;  //连接方式0-TCP，1-AdaptiveUDP
    byDownload: BYTE;  //是否下载 0-否，1-是
    byOptimalStreamType: BYTE;  //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    byDisplayBufNum: BYTE;  //设置播放缓冲帧数，当为0时，默认为3帧，hWnd不为空时有效
    byNPQMode: BYTE;  //NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
    sUserName: array[0..NAME_LEN{32}-1] of BYTE;  //二次认证用户名
    sPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  //二次认证密码
    byRemoteFile: BYTE;  //回放远程文件0-否，1-是
    byUseAsyn: BYTE;  //0-使用同步IO，1-使用异步IO
    byRes2: array[0..201-1] of BYTE;  
    byHls: BYTE;  //HLS回放，0-否，1-是
    pSavedFileName: PAnsiChar;  //下载时，保存的录像文件路径，byDownload为1时有效，长度超过256将会被截断
  end;
  LPNET_DVR_VOD_PARA_V50 = ^NET_DVR_VOD_PARA_V50;

// 手动录像
type
  NET_DVR_MANUAL_RECORD_PARA = record 
    struStreamInfo: NET_DVR_STREAM_INFO;  
    lRecordType: DWORD;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MANUAL_RECORD_PARA = ^NET_DVR_MANUAL_RECORD_PARA;


// CABAC码流压缩性能选项，开启可提高20%，只有模拟通道可以用
type
  NET_DVR_STREAM_CABAC = record 
    dwSize: DWORD;  //结构体大小
    byCabacEnable: BYTE;  //码流压缩性能选项值0 不提升 1 提升
    byRes1: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_STREAM_CABAC = ^NET_DVR_STREAM_CABAC;

const
  MAX_IOSPEED_GROUP_NUM = 4;    //IO测速组个数
  MAX_IOOUT_NUM = 4;    //最大IO输出口个数
  MAX_IOIN_NUM = 8;    //最大IO输入口个数
  MAX_RELAY_NUM = 12;    //继电器控制设备最大数 2013-11-04
  MAX_VEHICLE_TYPE_NUM = 8;    //车辆信息管控最大数2013-11-04
  MAX_IOIN_NUMEX = 10;    //最大IO输入口个数(扩展)
  MAX_ITC_LANE_NUM = 6;    //最大车道个数
  MAX_LANEAREA_NUM = 2;    //单车道最大区域个数
  ITC_MAX_POLYGON_POINT_NUM = 20;    //检测区域最多支持20个点的多边形
  MAX_ITC_SERIALCHECK_NUM = 8;    //串口校验类型个数
  MAX_LIGHT_NUM = 6;    //最大交通灯数
  MAX_VIDEO_INTERVAL_NUM = 2;    //最大抓拍间隔数
  MAX_VIDEO_DETECT_LIGHT_NUM = 12;    //视频检测的最大检测区域
  MAX_CALIB_RECOG_NUM = 2;    //标定区域个数
  MAX_RS485_NUM = 12;    //485口最大支持数
  MAX_MOBILE_POLYGON_NUM = 3;    //移动布防支持最大牌识区域个数
  MAX_MOBILE_DETECTLINE_NUM = 3;    //移动布防支持最大违规检测线个数
  MAX_IOOUT_K_NUM = 8;    //K系列最大IO输出口个数

//IO输出口参数（3.1版本（含）之后）
type
  NET_ITC_IOOUT_PARAM = record 
    dwSize: DWORD;  
    byDefaultStatus: BYTE;  //IO默认状态：0-低电平，1-高电平
    byIOOutStatus: BYTE;  //IO起效时状态：0-低电平，1-高电平，2-脉冲
    byMode: BYTE;  //闪光灯工作方式,按位表示，0-表示工作，1-表示不工作，bit0-视频，bit1-卡口，bit2-违章
    byIOWorkMode: BYTE;  //IO输出口工作模式：0-闪光灯，1-偏振镜,  2-常亮灯
    dwTimeDelay: DWORD;  //IO有效持续时间，单位us
    wAheadTime: WORD;  //输出IO提前时间，单位us
    byFreqMulti: BYTE;  //倍频，数值范围[1,15]
    byDutyRate: BYTE;  //占空比，[0,40%]
    byDetectBrightness: BYTE;  //自动检测亮度使能闪光灯0-不检测；1-检测
    byBrightnessThreld: BYTE;  //使能闪光灯亮度阈值，范围[0,100],高于阈值闪
    byFlashLightEnable: BYTE;  //设置闪光灯时间使能:0-关;1-开
    byStartHour: BYTE;  //开始时间-小时,取值范围0-23
    byStartMinute: BYTE;  //开始时间-分,取值范围0-59
    byEndHour: BYTE;  //结束时间-小时,取值范围0-23
    byEndMinute: BYTE;  //结束时间-分,取值范围0-59
    byAutoPlateBrightness: BYTE;  // 车牌亮度自动使能闪光灯 0-不启用 1-启用
    byIncrBrightEnable: BYTE;  //是否启用增亮模式（常亮灯模式下）
    byIncrBrightPercent: BYTE;  //增量百分比，0~100%（启用增亮模式下生效）
    wIncrBrightTime: WORD;  //增亮时间,单位为毫秒（启用增亮模式下生效）
    byBrightness: BYTE;  //亮度值；0~100（常亮灯模式下）
    byEnvironBright: BYTE;  //环境照度值；0~100（闪光灯模式下生效，该参数只读）环境照度值代表着闪光灯所处环境的亮度值，客户可以拿该值作为参考，去配置相应的亮度阈值。
    wDelayCaptureTime: WORD;  //延时抓拍时间1~1000ms（启用增亮模式下生效）
  end;
  LPNET_ITC_IOOUT_PARAM = ^NET_ITC_IOOUT_PARAM;

type
  ITC_TRIGGERMODE_TYPE =  
  (  
    ITC_POST_IOSPEED_TYPE = $1,  //IO测速（卡口）
    ITC_POST_SINGLEIO_TYPE = $2,  //单IO触发（卡口）
    ITC_POST_RS485_TYPE = $4,  //RS485车检器触发（卡口）
    ITC_POST_RS485_RADAR_TYPE = $8,  //RS485雷达触发（卡口）
    ITC_POST_VIRTUALCOIL_TYPE = $10,  //虚拟线圈触发（卡口）
    ITC_POST_HVT_TYPE_V50 = $20,  //混行卡口视频触发V50
    ITC_POST_MPR_TYPE = $40,  //多帧识别(卡口)(Ver3.7)
    ITC_POST_PRS_TYPE = $80,  //视频检测触发配置
    ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE = $100,  //IO红绿灯（电警）
    ITC_EPOLICE_RS485_TYPE = $200,  //RS485车检器电警触发（电警）
    ITC_POST_HVT_TYPE = $400,  //混行卡口视频触发（卡口）
    ITC_PE_RS485_TYPE = $10000,  //RS485车检器卡式电警触发（卡式电警）
    ITC_VIDEO_EPOLICE_TYPE = $20000,  //视频电警触发（卡式电警）
    ITC_VIA_VIRTUALCOIL_TYPE = $40000,  //VIA触发配置
    ITC_POST_IMT_TYPE = $80000,  //智慧布防配置
    IPC_POST_HVT_TYPE = $100000,  //IPC支持的HVT
    ITC_POST_MOBILE_TYPE = $200000,  //移动交通触发模式
    ITC_REDLIGHT_PEDESTRIAN_TYPE = $400000,  //行人闯红灯触发
    ITC_NOCOMITY_PEDESTRIAN_TYPE = $800000  //不礼让行人触发
  );

//能力集接口的输出参数，对应pOutBuf参数
type
  NET_ITC_TRIGGERMODE_ABILITY = record 
    dwSize: DWORD;  
    dwTriggerType: DWORD;  //触发类型，按位表示，定义ITC_TRIGGERMODE_ABILITY定义，根据输入的能力类型不同，此处返回的触发类型也不同
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_ITC_TRIGGERMODE_ABILITY = ^NET_ITC_TRIGGERMODE_ABILITY;

type
  NET_ITC_INTERVAL_PARAM = record 
    byIntervalType: BYTE;  //间隔类型（默认按时间），0-时间起效,1-距离起效
    byRes1: array[0..3-1] of BYTE;  
    wInterval: array[0..MAX_INTERVAL_NUM-1] of WORD;  //连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_INTERVAL_PARAM = ^NET_ITC_INTERVAL_PARAM;

//牌识参数
type
  NET_ITC_PLATE_RECOG_PARAM = record 
    byDefaultCHN: array[0..MAX_CHJC_NUM-1] of BYTE;  //设备运行省份的汉字简写
    byEnable: BYTE;  //是否启用该区域牌识，0-否，1-是
    dwRecogMode: DWORD;  
    {识别的类型，
       bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
       bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
       bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
       bit3-农用车识别：0-不采用农用车识别，1-农用车识别；
       bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
       bit5-帧定位或场定位：0-帧定位，1-场定位；
       bit6-帧识别或场识别：0-帧识别，1-场识别；
       bit7-晚上或白天：0-白天，1-晚上
       bit8-摩托车识别：0-不采用摩托车识别，1-摩托车识别;
       bit9-场景模式：0-电警/多帧，1-卡口；
       bit10-微小车牌：0-不启用，1-启用微小车牌识别(像素60～80)
       bit11-安全带检测：0-不启用，1-启用安全带检测
       bit12-民航车牌识别: 0-不启用，1-开启民航车牌识别
       bit13-车牌过渡倾斜处理: 0-不启用，1-开启过渡倾斜处理（PRS）
       bit14-超大车牌识别: 0-不启用，1-开启超大车牌识别（PRS）
       bit15-遮阳板检测：0-不启用，1-启用遮阳板检测
       bit16-黄标车检测：0-不启用，1-启用黄标车检测
       bit17-危险品车辆检测：0-不启用，1-启用危险品车辆检测
       bit18-使馆车牌识别：0-不启用，1-启用使馆车牌识别
       bit19-车辆子品牌识别：0-不启用，1-启用车辆子品牌识别
       bit20-打电话识别：0-不启用，1-启用
       bit21-车窗悬挂物识别：0-不启用，1-启用
    }
    byVehicleLogoRecog: BYTE;  //车标识别 0-不启用，1-启用
   {
       0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，8-贵，9-琼，10-冀，11-豫，
       12-黑，13-鄂，14-湘，15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，22-鲁，
       23-晋，24-陕，25-沪，26-川，27-台，28-津，29-藏，30-港，31-新，32-云，33-浙，
       34-皖，0xff-全部
    }
    byProvince: BYTE;  //省份索引值
    byRegion: BYTE;  // 区域索引值 0-保留，1-欧洲，2-俄语区域, 3-欧洲&俄罗斯(EU&CIS),4-中东(Middle East)
    byCountry: BYTE;  //国家索引，参照枚举COUNTRY_INDEX(不支持“COUNTRY_ALL = 0xff,//ALL 全部”)
    wPlatePixelWidthMin: WORD;  //车牌像素识别宽度最小值（单位是像素）当前推荐范围[130,500]
    wPlatePixelWidthMax: WORD;  //车牌像素识别宽度最大值（单位是像素）当前推荐范围[130,500]
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_ITC_PLATE_RECOG_PARAM = ^NET_ITC_PLATE_RECOG_PARAM;

//多边型结构体
type
  NET_ITC_POLYGON = record 
    dwPointNum: DWORD;  //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域
    struPos: array[0..ITC_MAX_POLYGON_POINT_NUM-1] of NET_VCA_POINT;  //多边形边界点,最多20个
  end;
  LPNET_ITC_POLYGON = ^NET_ITC_POLYGON;

type
  NET_ITC_PLATE_RECOG_REGION_PARAM = record 
    byMode: BYTE;  //区域类型，0-矩形，1-多边形
    byRes1: array[0..3-1] of BYTE;  
    uRegion: record 
      case Byte of
      0: (struRect: NET_VCA_RECT);  //矩形区域
      1: (struPolygon: NET_ITC_POLYGON);  //多边形区域
    end;  
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_ITC_PLATE_RECOG_REGION_PARAM = ^NET_ITC_PLATE_RECOG_REGION_PARAM;

//单组IO测速参数
type
  NET_ITC_SINGLE_IOSPEED_PARAM = record 
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byTrigCoil1: BYTE;  //第一线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    byCoil1IOStatus: BYTE;  //第一线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    byTrigCoil2: BYTE;  //第二线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    byCoil2IOStatus: BYTE;  //第二线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    byRelatedDriveWay: BYTE;  //关联的车道号
    byTimeOut: BYTE;  //超时时间（默认10），单位s
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    dwDistance: DWORD;  //线圈距离（默认1000）,单位：厘米
    byCapSpeed: BYTE;  //起拍速度（默认30），单位km/h
    bySpeedLimit: BYTE;  //限速值（默认60），单位km/h
    bySpeedCapEn: BYTE;  //是否启用超速抓拍，0-否，1-是
    bySnapTimes1: BYTE;  //线圈1抓拍次数（默认不抓拍），0-不抓拍，非0-连拍次数，最大5次
    bySnapTimes2: BYTE;  //线圈2抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5次
    byBigCarSpeedLimit: BYTE;  //大车车速限制值
    byBigCarSignSpeed: BYTE;  //标志限速(大车)，单位km/h(3.7Ver)
    byIntervalType: BYTE;  //间隔类型（默认按时间），0-时间起效,1-距离起效
    wInterval1: array[0..MAX_INTERVAL_NUM-1] of WORD;  //线圈1连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    wInterval2: array[0..MAX_INTERVAL_NUM-1] of WORD;  //线圈2连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byLaneType: BYTE;  //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    byCarSignSpeed: BYTE;  //标志限速，单位km/h(3.7Ver)
    byUseageType: BYTE;  //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //牌识参数(可用牌识区域1个，保留一个)
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byLowSpeedLimit: BYTE;  //小车限底速值，单位km/h
    byBigCarLowSpeedLimit: BYTE;  //大车限底速值，单位km/h
    byLowSpeedCapEn: BYTE;  //是否启用低速抓拍，0-否，1-是
    byEmergencyCapEn: BYTE;  //是否启用应急车道抓拍，0-否，1-是
    byRes: array[0..27-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_IOSPEED_PARAM = ^NET_ITC_SINGLE_IOSPEED_PARAM;

//卡口IO测速参数
type
  NET_ITC_POST_IOSPEED_PARAM = record 
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struSingleIOSpeed: array[0..MAX_IOSPEED_GROUP_NUM-1] of NET_ITC_SINGLE_IOSPEED_PARAM;  //单个IO测速组参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_POST_IOSPEED_PARAM = ^NET_ITC_POST_IOSPEED_PARAM;

//单IO参数
type
  NET_ITC_SINGLEIO_PARAM = record 
    byDefaultStatus: BYTE;  //IO触发默认状态：0-低电平，1-高电平
    byRelatedDriveWay: BYTE;  //关联的车道号
    bySnapTimes: BYTE;  //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口，可以同时关联多个
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byEnable: BYTE;  //单IO使能标志0-不启用，1-启用 (Remark:在能力返回支持 bySupport&0x20，表示是否支持单IO触发界面IO使能配置 时生效)
    byUseageType: BYTE;  //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    byEmergencyCapEn: BYTE;  //是否启用应急车道抓拍，0-否，1-是
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //牌识参数
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_ITC_SINGLEIO_PARAM = ^NET_ITC_SINGLEIO_PARAM;

//单IO触发参数
type
  NET_ITC_POST_SINGLEIO_PARAM = record 
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struSingleIO: array[0..MAX_IOIN_NUMEX-1] of NET_ITC_SINGLEIO_PARAM;  //单个IO触发参数
  end;
  LPNET_ITC_POST_SINGLEIO_PARAM = ^NET_ITC_POST_SINGLEIO_PARAM;

type
  NET_ITC_LANE_PARAM = record 
    byEnable: BYTE;  //是否启用该车道，0-不启用，1-启用
    byRelatedDriveWay: BYTE;  //关联的车道号
    wDistance: WORD;  //线圈距离，计算速度
    wTrigDelayTime: WORD;  //触发延迟时间（默认200），单位：毫秒
    byTrigDelayDistance: BYTE;  //触发延迟距离（默认0），单位：分米
    bySpeedCapEn: BYTE;  //是否启用超速抓拍，0-否，1-是
    bySignSpeed: BYTE;  //标志限速，单位km/h
    bySpeedLimit: BYTE;  //限速值，单位km/h
    bySnapTimes: BYTE;  //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    byOverlayDriveWay: BYTE;  //OSD叠加的车道号
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口，可以同时关联多个
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byCartSignSpeed: BYTE;  //标志限速(大车)，单位km/h
    byCartSpeedLimit: BYTE;  //限速值（大车），单位km/h
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //车道牌识参数
    byLaneType: BYTE;  //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    byUseageType: BYTE;  //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byLowSpeedLimit: BYTE;  //小车限底速值，单位km/h
    byBigCarLowSpeedLimit: BYTE;  //大车限底速值，单位km/h
    byLowSpeedCapEn: BYTE;  //是否启用低速抓拍，0-否，1-是
    byEmergencyCapEn: BYTE;  //是否启用应急车道抓拍，0-否，1-是
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_ITC_LANE_PARAM = ^NET_ITC_LANE_PARAM;

//卡口RS485车检器触发参数
type
  NET_ITC_POST_RS485_PARAM = record 
    byRelatedLaneNum: BYTE;  //关联的车道个数
    byTriggerSpareMode: BYTE;  //触发备用模式，0-默认，1-卡口虚拟线圈模式,2-卡口混合车道模式
    byFaultToleranceTime: BYTE;  //容错时间(单位:分钟)，用于检测车检器是否正常的最大时间
    byRes1: BYTE;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struLane: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_LANE_PARAM;  //关联的车道参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_POST_RS485_PARAM = ^NET_ITC_POST_RS485_PARAM;

type
  NET_ITC_RADAR_PARAM = record 
    byRadarType: BYTE;  //雷达类型，0-无雷达,1-安道雷雷达，2-奥利维亚，3-川速微波4,雷达接IO扩展盒(此参数在卡口虚拟线圈、混行卡口界面中使用，卡口RS485雷达不使用),0xff-其它类型
    byLevelAngle: BYTE;  //与水平线所成角度,默认为25°(0到90度)
    wRadarSensitivity: WORD;  //雷达灵敏度
    wRadarSpeedValidTime: WORD;  //雷达速度有效时间(0~2000] ,0表示不支持
    byRes1: array[0..2-1] of BYTE;  
    fLineCorrectParam: FLOAT;  //线性矫正参数[0.0~2.0]
    iConstCorrectParam: INT;  //常量矫正参数[-100~100]
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_RADAR_PARAM = ^NET_ITC_RADAR_PARAM;

type
  NET_ITC_RS485_ACCESS_INFO_COND = record //条件结构
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwTriggerModeType: DWORD;  
    byAssociateRS485No: BYTE;  //关联的RS485号 1～5 (唯一值)
    //    BYTE  byModeType; //0～预留，1～雷达，2～车检器，3～信号灯检测器
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_ITC_RS485_ACCESS_INFO_COND = ^NET_ITC_RS485_ACCESS_INFO_COND;

type
  NET_ITC_RADAR_INFO_PARAM = record 
    struRadarParam: NET_ITC_RADAR_PARAM;  //24
    byAssociateLaneNo: BYTE;  //关联的车道号1～99 (这个值可以在不同RS485口重复)
    byRes: array[0..103-1] of BYTE;  
  end;
  LPNET_ITC_RADAR_INFO_PARAM = ^NET_ITC_RADAR_INFO_PARAM;

type
  NET_ITC_ACCESS_DEVINFO_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..128-1] of BYTE);  
    1: (struRadarInfoParam: NET_ITC_RADAR_INFO_PARAM);  //雷达参数配置
  end;
  LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION = ^NET_ITC_ACCESS_DEVINFO_PARAM_UNION;

type
  NET_ITC_RS485_ACCESS_CFG = record //144  配置结构
    dwSize: DWORD;  
    byModeType: BYTE;  //0～预留，bit1～雷达，bit2～车检器，bit3～信号灯检测器
    byRes: array[0..3-1] of BYTE;  
    uITCAccessDevinfoParam: NET_ITC_ACCESS_DEVINFO_PARAM_UNION;  //64
    byRes1: array[0..12-1] of BYTE;  
  end;
  LPNET_ITC_RS485_ACCESS_CFG = ^NET_ITC_RS485_ACCESS_CFG;

//2013-07-09 雷达关联车道扩展
type
  NET_ITC_RS485_ACCESS_INFO = record 
    dwSize: DWORD;  
    struRadar: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_RADAR_PARAM;  //多车道雷达信息
    //根据能力集开发显示，不支持的默认为0，不显示  （有几个车道支持几个）
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_ITC_RS485_ACCESS_INFO = ^NET_ITC_RS485_ACCESS_INFO;


//卡口RS485雷达触发参数
type
  NET_ITC_POST_RS485_RADAR_PARAM = record 
    byRelatedLaneNum: BYTE;  //关联的车道个数
    byRes1: array[0..3-1] of BYTE;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struLane: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_LANE_PARAM;  //关联的车道参数
    struRadar: NET_ITC_RADAR_PARAM;  //雷达参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_POST_RS485_RADAR_PARAM = ^NET_ITC_POST_RS485_RADAR_PARAM;

type
  NET_ITC_VTLANE_PARAM = record 
    byRelatedDriveWay: BYTE;  //关联的车道号
    bySpeedCapEn: BYTE;  //是否启用超速抓拍，0-否，1-是
    bySignSpeed: BYTE;  //标志限速，单位km/h
    bySpeedLimit: BYTE;  //限速值，单位km/h
    bySnapTimes: BYTE;  //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    byBigCarSignSpeed: BYTE;  ///*大车标志限速，单位km/h}
    byBigCarSpeedLimit: BYTE;  //大车限速值，单位km/h
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口，可以同时关联多个
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byLowSpeedLimit: BYTE;  //限低速，单位km/h
    byBigCarLowSpeedLimit: BYTE;  //大车限低速，单位km/h
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //车道牌识参数
    struLine: NET_VCA_LINE;  //车道线
  end;
  LPNET_ITC_VTLANE_PARAM = ^NET_ITC_VTLANE_PARAM;

type
  NET_ITC_VTCOIL_INFO = record 
    struLaneRect: NET_VCA_RECT;  //虚拟线圈区域
    byTrigFlag: BYTE;  //触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
    byTrigSensitive: BYTE;  //触发灵敏度，1-100
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byLaneType: BYTE;  //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    byEnableRadar: BYTE;  //是否启用雷达测速，0-否，1-是
    struLane: NET_ITC_VTLANE_PARAM;  //关联的车道参数
    //车道用途类型，详见ITC_LANE_USEAGE_TYPE，使用1和8两种类型(3.7Ver)
    byUseageType: BYTE;  
    //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
    byCarDriveDirect: BYTE;  
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_ITC_VTCOIL_INFO = ^NET_ITC_VTCOIL_INFO;

//卡口虚拟线圈触发参数
type
  NET_ITC_POST_VTCOIL_PARAM = record 
    byRelatedLaneNum: BYTE;  //关联的车道个数
    byIsDisplay: BYTE;  //视频中是否显示虚拟线圈，0-不显示，1-显示
    byLoopPos: BYTE;  //晚间触发线圈的偏向（默认10）
    byPolarLenType: BYTE;  //偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。
    byDayAuxLightMode: BYTE;  //白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明
    byVideoLaneNO: BYTE;  //视频参考亮度的参考车道号
    byVideoLowTh: BYTE;  //视频参考亮度低阈值初始化值（默认40）
    byVideoHighTh: BYTE;  //视频参考亮度高阈值初始化值（默认55）
    byRecordMode: BYTE;  //录像标志：0-不录像，1-录像
    bySnapMode: BYTE;  //抓拍模式：0-频闪模式；1-爆闪模式
    //测速方式：0-不测速，0x1-雷达测速，0x2-视频测速
    bySpeedDetector: BYTE;  
    byRes2: BYTE;  
    wResolutionX: WORD;  // 设备当前分辨率宽
    wResolutionY: WORD;  // 设备当前分辨率高
    dwDayInitExp: DWORD;  //视频白天曝光时间的初始值2000
    dwDayMaxExp: DWORD;  //视频白天曝光时间的最大值20000
    dwNightExp: DWORD;  //晚间视频曝光时间的设置值3000
    dwSnapExp: DWORD;  //抓拍曝光时间
    byDayInitGain: BYTE;  //视频白天增益的初始值200
    byDayMaxGain: BYTE;  //视频白天增益的最大值400
    byNightGain: BYTE;  //晚间视频增益
    bySnapGain: BYTE;  //抓拍增益
    dwSceneMode: DWORD;  //场景模式， 详见SCENE_MODE
    struGeogLocation: NET_DVR_GEOGLOCATION;  //地址位置(默认浙江)
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struVtCoil: array[0..MAX_VL_NUM-1] of NET_ITC_VTCOIL_INFO;  //虚拟线圈参数
    struRadar: NET_ITC_RADAR_PARAM;  //雷达参数
    struLine: NET_VCA_LINE;  //右车道线
    //违规检测类型，按位表示，详见ITC_VIOLATION_DETECT_TYPE，0-不启用，1-启用(3.7Ver)
    dwVioDetectType: DWORD;  
    byDebugMode: BYTE;  //调试模式，0-不启用，1-启用
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_ITC_POST_VTCOIL_PARAM = ^NET_ITC_POST_VTCOIL_PARAM;

//单组IO红绿灯参数
type
  NET_ITC_SINGLE_IOTL_PARAM = record 
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byLightIO: BYTE;  //红绿灯IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    byTrafficLight: BYTE;  //红绿灯有效状态0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    byTrigIO: BYTE;  //触发的IO号，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    byTrigIOStatus: BYTE;  //触发IO口的状态（默认0），0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    byRelatedDriveWay: BYTE;  //关联的车道号
    byRecordEnable: BYTE;  //闯红灯周期录像标志，0-不录像，1-录像
    byRecordType: BYTE;  //闯红灯录像类型，0-预录，1-延时录像
    byPreRecordTime: BYTE;  //闯红灯录像片段预录时间（默认0），单位：秒
    byRecordDelayTime: BYTE;  //闯红灯录像片段延时时间（默认0），单位：秒
    byRecordTimeOut: BYTE;  //闯红灯周期录像超时时间（秒）
    byRedSnapTimes: BYTE;  //红灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    byGreenSnapTimes: BYTE;  //绿灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    byRes1: BYTE;  
    byIntervalType: BYTE;  //间隔类型（默认按时间），0-时间起效,1-距离起效
    wRedInterval: array[0..MAX_INTERVAL_NUM-1] of WORD;  //红灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    wGreenInterval: array[0..MAX_INTERVAL_NUM-1] of WORD;  //绿灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口，可以同时关联多个
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byRes2: array[0..3-1] of BYTE;  
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //牌识区域参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_IOTL_PARAM = ^NET_ITC_SINGLE_IOTL_PARAM;

//电警IO红绿灯参数
type
  NET_ITC_EPOLICE_IOTL_PARAM = record 
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struSingleIOTL: array[0..MAX_IOSPEED_GROUP_NUM-1] of NET_ITC_SINGLE_IOTL_PARAM;  //单组IO红绿灯参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_EPOLICE_IOTL_PARAM = ^NET_ITC_EPOLICE_IOTL_PARAM;

type
  ITC_SERIAL_PROTOCOL =  
  (  
    ITC_PROTOCOL_UNKNOW = 0,  //未知
    ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1,  //单线圈车检器协议模式1（显示为：单_进1_出1_延1_1），到达、离开、离开延时抓拍，离开牌识，上传3张车辆图片和车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2,  //双线圈车检器协议模式1（显示为：双_进1_出1_出2_1），到达1、离开1、离开2抓拍，离开1牌识，上传3张车辆图片和车牌结果（默认）
    ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3,  //双线圈车检器协议模式2（显示为：双_出1_出2_延2_1），离开1、离开2、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4,  //双线圈车检器协议模式3（显示为：双_进2_出1_延2_1），进入2、离开1、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5,  //双线圈车检器协议模式4（显示为：双/三_进2_出2_延2_1），到达2、离开2、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6,  //双线圈车检器协议模式5（显示为：双/三_进2_出2_延2_2），到达2、离开2、离开2延时抓拍，到达2、离开1均牌识，上传3张车辆图片和置信度高的车牌结果（默认）
    ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7,  //双线圈车检器协议模式6（显示为：双/三_进1_出2_延2_2），到达1、离开2、离开2延时抓拍，到达1、离开1均牌识，上传3张车辆图片和置信度高的车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8,  //双线圈车检器协议模式7（显示为：双_进1_出1_延2_1），到达1、离开1、离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，闯红灯到达1、离开1、离开2延时）和车牌结果
    ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9,  //双线圈车检器协议模式8（显示为：双_进1_出1_延2_2），到达1、离开1、离开2延时抓拍，到达1、离开1均牌识，上传车辆图片（卡口离开1，闯红灯到达1、离开1、离开2延时）和置信度高的车牌结果（默认）
    ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10,  //单线圈车检器协议模式2（显示为：单_进1_出1_延1_2），到达、离开、离开延时抓拍，到达、离开均牌识，上传车辆图片（卡口离开，闯红灯到达、离开、离开延时）和置信度高的车牌结果（默认）
    ITC_OTHER_PROTOCOL = $ff  //其它车检器协议(用于老demo参数配置，3.3之后版本关联的demo和控件均不支持此值)
  );

//正常过车逻辑抓拍类型
type
  ITC_NORMAL_PASS_SERIAL_PROTOCOL =  
  (  
    ITC_NORMAL_PASS_SERIAL_UNKNOW = 0,  //未知
    ITC_NORMAL_PASS_PROTOCOL_MODE1 = 1,  //单线圈，离开抓拍，牌识上传（默认）
    ITC_NORMAL_PASS_PROTOCOL_MODE2 = 2,  //单线圈，到达、离开抓拍，均牌识，仅上传离开车辆图片和置信度高的车牌结果
    ITC_NORMAL_PASS_PROTOCOL_MODE3 = 3,  //双线圈，离开1抓拍，牌识上传（默认）
    ITC_NORMAL_PASS_PROTOCOL_MODE4 = 4,  //双线圈，到达1、离开1抓拍，均牌识，仅上传离开1车辆图片和置信度高的车牌结果
    ITC_NORMAL_PASS_PROTOCOL_MODE5 = 5  //双线圈，到达2、离开1抓拍，均牌识，仅上传离开1车辆图片和置信度高的车牌结果
  );

//逆行违规逻辑抓拍类型
type
  ITC_INVERSE_SERIAL_PROTOCOL =  
  (  
    ITC_INVERSE_SERIAL_UNKNOW = 0,  //未知
    ITC_INVERSE_PROTOCOL_MODE1 = 1,  //不抓拍
    ITC_INVERSE_PROTOCOL_MODE2 = 2,  //到达1连抓2张、离开2抓拍，到达1两张均牌识，上传3张车辆图片和置信度高的车牌结果
    ITC_INVERSE_PROTOCOL_MODE3 = 3  //到达1、离开2抓拍，到达1牌识，上传2张车辆图片和车牌结果
  );

//超速违规逻辑抓拍类型
type
  ITC_SPEED_SERIAL_PROTOCOL =  
  (  
    ITC_SPEED_SERIAL_UNKNOW = 0,  //未知
    ITC_SPEED_PROTOCOL_MODE1 = 1,  //不抓拍
    ITC_SPEED_PROTOCOL_MODE2 = 2,  //双/三线圈，离开1，离开2，离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，超速离开1、离开2、离开2延时）和车牌结果
    ITC_SPEED_PROTOCOL_MODE3 = 3  //双/三线圈，离开1，离开2，离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，超速离开1、离开2）和车牌结果
  );

//车检器参数
type
  NET_ITC_SERIAL_INFO = record 
    bySerialProtocol: BYTE;  //车检器协议类型，详见ITC_SERIAL_PROTOCOL
    byIntervalType: BYTE;  //间隔类型（默认按时间），0-时间起效,1-距离起效
    wInterval: WORD;  //连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    byNormalPassProtocol: BYTE;  //正常过车抓拍协议类型，详见ITC_NORMAL_PASS_SERIAL_PROTOCOL
    byInverseProtocol: BYTE;  //逆行抓拍协议类型，详见ITC_INVERSE_SERIAL_PROTOCOL
    bySpeedProtocol: BYTE;  //超速抓拍协议类型，详见ITC_SPEED_SERIAL_PROTOCOL
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_ITC_SERIAL_INFO = ^NET_ITC_SERIAL_INFO;

type
  NET_ITC_EPOLICE_LANE_PARAM = record 
    byEnable: BYTE;  //是否启用该车道，0-不启用，1-启用
    byRelatedDriveWay: BYTE;  //关联的车道号
    wDistance: WORD;  //线圈距离，单位厘米
    byRecordEnable: BYTE;  //闯红灯周期录像标志，0-不录像，1-录像
    byRecordType: BYTE;  //闯红灯录像类型，0-预录，1-延时录像
    byPreRecordTime: BYTE;  //闯红灯录像片段预录时间（默认0），单位：秒
    byRecordDelayTime: BYTE;  //闯红灯录像片段延时时间（默认0），单位：秒
    byRecordTimeOut: BYTE;  //闯红灯周期录像超时时间（秒）
    bySignSpeed: BYTE;  //标志限速(卡式电警模式有效)，单位km/h
    bySpeedLimit: BYTE;  //限速值(卡式电警模式有效)，单位km/h
    byOverlayDriveWay: BYTE;  //OSD叠加的车道号
    struSerialInfo: NET_ITC_SERIAL_INFO;  //车检器参数
    byRelatedIOOut: array[0..MAX_IOOUT_NUM-1] of BYTE;  //关联的IO输出口，可以同时关联多个
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    bySerialType: BYTE;  //车检器类型，0-私有车检器，1-私有OEM车检器，2-其他车检器
    byRelatedIOOutEx: BYTE;  //第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    bySnapPicPreRecord: BYTE;  //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    struPlateRecog: array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM;  //车道牌识参数
    byBigCarSignSpeed: BYTE;  ///*大车标志限速，单位km/h}
    byBigCarSpeedLimit: BYTE;  //大车限速值，单位km/h
    byRedTrafficLightChan: BYTE;  //红灯通道号：1～16（红绿灯检测器）
    byYellowTrafficLightChan: BYTE;  //黄灯通道号：1～16（红绿灯检测器）
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byRes3: array[0..11-1] of BYTE;  
  end;
  LPNET_ITC_EPOLICE_LANE_PARAM = ^NET_ITC_EPOLICE_LANE_PARAM;

//电警/卡式电警RS485车检器触发参数
type
  NET_ITC_EPOLICE_RS485_PARAM = record 
    byRelatedLaneNum: BYTE;  //关联的车道个数
    byTrafficLightSignalSrc: BYTE;  //交通灯信号来源 0～车检器 1～红绿灯检测器
    byRes1: array[0..2-1] of BYTE;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struLane: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_EPOLICE_LANE_PARAM;  //关联的车道参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_EPOLICE_RS485_PARAM = ^NET_ITC_EPOLICE_RS485_PARAM;

//车道属性参数结构
type
  NET_ITC_LANE_LOGIC_PARAM = record 
    byUseageType: BYTE;  //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    byDirectionType: BYTE;  //车道方向类型，详见ITC_LANE_DIRECTION_TYPE
    byCarDriveDirect: BYTE;  //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT
    byRes: array[0..33-1] of BYTE;  //保留
  end;
  LPNET_ITC_LANE_LOGIC_PARAM = ^NET_ITC_LANE_LOGIC_PARAM;

//视频电警线结构
type
  NET_ITC_LINE = record 
    struLine: NET_VCA_LINE;  //线参数
    byLineType: BYTE;  //线类型，详见ITC_LINE_TYPE
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_ITC_LINE = ^NET_ITC_LINE;

type
  NET_ITC_SNAPMODE_PARAM = record 
    byVehicleCapMode: BYTE;  //机动车抓拍模式，0-频闪模式；1-爆闪模式
    byNoVehicleCapMode: BYTE;  //非机动车抓拍模式，0-频闪模式；1-爆闪模式
    byPasserCapMode: BYTE;  //行人抓拍模式，0-频闪模式；1-爆闪模式
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_ITC_SNAPMODE_PARAM = ^NET_ITC_SNAPMODE_PARAM;

//size = 128
type
  NET_ITC_HVT_EC_PARAM = record 
    dwCapShutter: DWORD;  //抓拍快门0~65535
    wCapGain: WORD;  //抓拍增益0～100
    byRes: array[0..2-1] of BYTE;  
    dwDayTimeVideoShutter: DWORD;  //白天曝光时间最大值
    wDayTimeVideoGain: WORD;  //白天增益最大值
    wNightVideoGain: WORD;  //晚上增益最大值
    wNightVideoShutter: DWORD;  //晚上曝光时间最大值
    byRes1: array[0..108-1] of BYTE;  
  end;
  LPNET_ITC_HVT_EC_PARAM = ^NET_ITC_HVT_EC_PARAM;

type
  NET_ITC_LANE_HVT_PARAM = record 
    byLaneNO: BYTE;  //关联的车道号 1~255（用于叠加和上传）
    bySignSpeed: BYTE;  //标志限速，单位km/h 0～255  70
    bySpeedLimit: BYTE;  //限速值，单位km/h 0～255    80 实际起效
    byBigCarSignSpeed: BYTE;  ///*大车标志限速，单位km/h}
    byBigCarSpeedLimit: BYTE;  //大车限速值，单位km/h
    bySpeedCapEn: BYTE;  //是否启用超速抓拍，0-否，1-是
    byCaptureCount: BYTE;  //抓拍张数1～5(正常)
    byRelatedIOOut: BYTE;  //关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byEnableRadar: BYTE;  //是否启用雷达测速，0-否，1-是
    byChangeLaneEnable: BYTE;  //违章变道抓拍使能，0-关闭，1-开启
    byChangeLaneCapNo: BYTE;  //违章变道抓拍张数2-3
    dwCapTarget: DWORD;  //抓拍类型 bit0 表示机动车 bit1 表示非机动车 bit2 表示行人 0～表示不选择 1～表示选择
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数
    byRes3: array[0..24-1] of BYTE;  
    struLane: NET_ITC_LANE_LOGIC_PARAM;  //车道属性，用byUseageType和byCarDriveDirect
    struLeftLaneLine: NET_ITC_LINE;  //左车道线，线类型为虚线、实线、单黄线和双黄线
    struRightLaneLine: NET_ITC_LINE;  //右车道线，线类型为虚线、实线、单黄线和双黄线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域参数
    struTraceArea: NET_ITC_POLYGON;  //视频触发焦点区域
    struForwardTrigLine: NET_VCA_LINE;  //正向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存。（一般配置为正向车辆的最佳触发位置）
    struBackwardTrigLine: NET_VCA_LINE;  //背向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存（一般配置为背向车辆的最佳触发位置）
    struLeftTrigLine: NET_VCA_LINE;  //左边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从左边进入车辆的最佳触发位置）
    struRightTrigLine: NET_VCA_LINE;  //右边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从右边进入车辆的最佳触发位置）
    byRes4: array[0..60-1] of BYTE;  
  end;
  LPNET_ITC_LANE_HVT_PARAM = ^NET_ITC_LANE_HVT_PARAM;

type
  NET_ITC_POST_HVT_PARAM = record 
    byLaneNum: BYTE;  //识别的车道个数，1-6
    bySceneMode: BYTE;  //0-未知1-城区道路；2-小区出入口
    byRoadExpBright: BYTE;  //路面期望亮度（视频曝光参数调整的依据之一。在无机动车时，依据此亮度期望值，调整视频曝光参数）
    byPlateExpBright: BYTE;  //车牌期望亮度（视频曝光参数调整的依据之一。在有机动车通过并识别到车牌时，依据此亮度期望值，对视频曝光参数调整）
    struDetectArea: NET_ITC_POLYGON;  //视频检测区域
    struCapMode: NET_ITC_SNAPMODE_PARAM;  //抓拍模式
    struEcParam: NET_ITC_HVT_EC_PARAM;  //曝光控制参数
    struLaneParam: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_LANE_HVT_PARAM;  //单车道属性
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struGeogLocation: NET_DVR_GEOGLOCATION;  //地址位置（默认浙江）
    byRes: array[0..324-1] of BYTE;  
  end;
  LPNET_ITC_POST_HVT_PARAM = ^NET_ITC_POST_HVT_PARAM;

//************************MPR触发模式 begin 2013-12-07***************
type
  NET_ITC_LANE_MPR_PARAM = record 
    byLaneNO: BYTE;  
    uTssParamInfo: record 
      case Byte of
      0: (uLen: array[0..4-1] of BYTE);  
      1: (struIO: record
        byIONo: BYTE;  //IO号[1, byIoInNum+1] 最小从1开始，最大值根据接口能力返回NET_DVR_SNAP_ABILITY的字段byIoInNum
        byTriggerType: BYTE;  //0-下降沿，1-上升沿
        byRes1: array[0..2-1] of BYTE;  
      end);  //IO模式下生效
      2: (struRS485: record
        byRelateChan: BYTE;  //关联车检器通道号[1,16]
        byRes2: array[0..3-1] of BYTE;  
      end);  
    end;  
    byCarDriveDirect: BYTE;  //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    byRes: array[0..58-1] of BYTE;  
    struLaneLine: NET_ITC_LINE;  //车道线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPEtypedef struct tagNET_ITS_PICTURE_INFO
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byRes1: array[0..255-1] of BYTE;  
  end;
  LPNET_ITC_LANE_MPR_PARAM = ^NET_ITC_LANE_MPR_PARAM;

type
  NET_ITC_POST_MPR_PARAM = record 
    byEnable: BYTE;  
    byLaneNum: BYTE;  
    bySourceType: BYTE;  //0-MPR触发（视频触发）,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    byPicUploadType: BYTE;  //图片上传类型，0~全部上传，1-正向上传，2-背向上传
    byRoadType: BYTE;  //模式选择 0-出入口，1-城市道路，2-自定义，3-报警输入，4-卡口, 5-治安布防(该模式下可以检测车辆比较混乱且没有车道线的场景)
    byRes2: BYTE;  
    wCustomDelayTime: WORD;  //自定义抓拍延时时间（在byRoadType为 "自定义"的时候生效），范围在[0,15000]ms
    byRes: array[0..56-1] of BYTE;  
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最左边车道的左边界线）
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数  40
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_ITC_LANE_MPR_PARAM;  
    szSceneName: array[0..NAME_LEN{32}-1] of AnsiChar;  //场景名称
    struSnapLine: NET_VCA_LINE;  //抓拍线，在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
    byRes1: array[0..392-1] of BYTE;  
  end;
  LPNET_ITC_POST_MPR_PARAM = ^NET_ITC_POST_MPR_PARAM;
//************************MPR触发模式 end 2013-12-07***************

type
  NET_DVR_VIA_LANE_PARAM = record 
    byLaneNO: BYTE;  //关联车道号
    byRes: array[0..63-1] of BYTE;  //保留
    struLogicParam: NET_ITC_LANE_LOGIC_PARAM;  //车道属性参数
    struLaneLine: NET_ITC_LINE;  //车道线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    byRes1: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIA_LANE_PARAM = ^NET_DVR_VIA_LANE_PARAM;

type
  NET_DVR_VIA_VTCOIL_PARAM = record 
    byEnable: BYTE;  //使能 0-不开启 1-开启
    byLaneNum: BYTE;  //车道数
    byRes: array[0..62-1] of BYTE;  //保留
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最左边车道的左边界线）
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_DVR_VIA_LANE_PARAM;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    byRes1: array[0..624-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIA_VTCOIL_PARAM = ^NET_DVR_VIA_VTCOIL_PARAM;

//配置条件接口
type
  NET_DVR_TRIGGER_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    dwTriggerMode: DWORD;  //触发方式，参考 ITC_TRIGGERMODE_TYPE
    byDetSceneID: BYTE;  //检测场景号[1,4], IPC默认是0
    byRes: array[0..63-1] of BYTE;  //保留留
  end;
  LPNET_DVR_TRIGGER_COND = ^NET_DVR_TRIGGER_COND;

type
  NET_ITC_LANE_IMT_PARAM = record 
    byLaneNO: BYTE;  //叠加车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byRes: array[0..146-1] of BYTE;  
    struLaneLine: NET_ITC_LINE;  //车道线
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_ITC_LANE_IMT_PARAM = ^NET_ITC_LANE_IMT_PARAM;

type
  NET_ITC_POST_IMT_PARAM = record 
    byEnable: BYTE;  
    byLaneNum: BYTE;  
    bySnapMode: BYTE;  //抓拍类型；0~机动车，1~机非人
    byRes: array[0..61-1] of BYTE;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最右边车道的边界线）
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_ITC_LANE_IMT_PARAM;  
    byRes1: array[0..1584-1] of BYTE;  
  end;
  LPNET_ITC_POST_IMT_PARAM = ^NET_ITC_POST_IMT_PARAM;

type
  NET_ITC_LANE_PRS_PARAM = record 
    byLaneNO: BYTE;  
    uTssParamInfo: record 
      case Byte of
      0: (uLen: array[0..4-1] of BYTE);  
      1: (struIO: record
        byIONo: BYTE;  //IO号[1,4]
        byTriggerType: BYTE;  //0-下降沿，1-上升沿
        byRes1: array[0..2-1] of BYTE;  
      end);  //IO模式下生效
      2: (struRS485: record
        byRelateChan: BYTE;  //关联车检器通道号[1,16]
        byRes2: array[0..3-1] of BYTE;  
      end);  
    end;  
    byRes: array[0..59-1] of BYTE;  
    struLaneLine: NET_ITC_LINE;  //车道线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byRes2: array[0..3-1] of BYTE;  
    struTrigLine: NET_ITC_LINE;  //触发线
    byRes1: array[0..228-1] of BYTE;  
  end;
  LPNET_ITC_LANE_PRS_PARAM = ^NET_ITC_LANE_PRS_PARAM;


type
  NET_ITC_POST_PRS_PARAM = record 
    byEnable: BYTE;  
    byLaneNum: BYTE;  
    bySourceType: BYTE;  //0-视频检测,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    bySnapMode: BYTE;  //0-全景图，1-全景图+特写
    byCapMode: BYTE;  //bySourceType为0视频检测时使用，0-频闪模式；1-爆闪模式
    byNoPlatCarCap: BYTE;  //是否启用无车牌抓拍 0-不启用 1-启用
    bySceneMode: BYTE;  //场景模式:0-普通出入口场景、1-收费站模式场景(车辆停留时间较长)、2-地下停车场出入口场景(白天黑夜均较暗)
    byRes: array[0..57-1] of BYTE;  
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最左边车道的左边界线）
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数  40
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_ITC_LANE_PRS_PARAM;  
    byRes1: array[0..440-1] of BYTE;  
  end;
  LPNET_ITC_POST_PRS_PARAM = ^NET_ITC_POST_PRS_PARAM;

type
  NET_IPC_LANE_HVT_PARAM = record 
    byLaneNO: BYTE;  
    byCarDriveDirect: BYTE;  //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    byRes: array[0..62-1] of BYTE;  
    struLaneLine: NET_ITC_LINE;  //车道线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_IPC_LANE_HVT_PARAM = ^NET_IPC_LANE_HVT_PARAM;

type
  NET_ITC_PARKING_DETECTION = record 
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byRes: BYTE;  //保留字节
    wDuration: WORD;  //检测时间间隔，单位：s
    wAlarmIntervalTime: WORD;  //上传时间间隔，单位：s
    byRes1: array[0..58-1] of BYTE;  //保留字节
  end;
  LPNET_ITC_PARKING_DETECTION = ^NET_ITC_PARKING_DETECTION;

type
  NET_IPC_POST_HVT_PARAM = record 
    byEnable: BYTE;  
    byLaneNum: BYTE;  
    byEnhancedMode: BYTE;  //增强模式，0-不启用，1-启用
    byPicRecognition: BYTE;  //车辆报警图片二次识别，0-不启用，1-启用
    byRes: array[0..60-1] of BYTE;  
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最左边车道的左边界线）
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数  40
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_IPC_LANE_HVT_PARAM;  
    szSceneName: array[0..NAME_LEN{32}-1] of AnsiChar;  //场景名称
    struSnapLine: NET_VCA_LINE;  //抓拍线，抓在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
    struParkingDetection: NET_ITC_PARKING_DETECTION;  //停车检测参数
    byRes1: array[0..328-1] of BYTE;  
  end;
  LPNET_IPC_POST_HVT_PARAM = ^NET_IPC_POST_HVT_PARAM;

//抓拍机4.0新增
type
  NET_ITC_LANE_HVT_PARAM_V50 = record 
    byLaneNO: BYTE;  //关联的车道号1～255(用于叠加和上传)
    byFlashMode: BYTE;  //闪光灯闪烁模式，0-同时闪，1-轮流闪
    bySignSpeed: BYTE;  //小车标志限高速，单位km/h
    bySpeedLimit: BYTE;  //小车限高速值，单位km/h
    bySignLowSpeed: BYTE;  //小车标志限底速，单位km/h
    byLowSpeedLimit: BYTE;  //小车限底速值，单位km/h
    byBigCarSignSpeed: BYTE;  //大车标志限高速，单位km/h（新交规）
    byBigCarSpeedLimit: BYTE;  //大车限高速值，单位km/h（新交规）
    byBigCarSignLowSpeed: BYTE;  //大车标志限底速，单位km/h
    byBigCarLowSpeedLimit: BYTE;  //大车限底速值，单位km/h
    bySnapTimes: BYTE;  //卡口抓拍张数，1~3
    byDriveLineSnapTime: BYTE;  // 压线抓拍张数 1~3
    byHighSpeedSnapTime: BYTE;  // 超高速抓拍张数1~3
    byLowSpeedSnapTime: BYTE;  // 超低速抓拍张数1~3
    byBanSnapTime: BYTE;  // 违反禁令抓拍张数  1~3
    byReverseSnapTime: BYTE;  //逆行抓拍张数  1~3
    byRelatedDriveWay: BYTE;  //关联车道号，用于匹配车检器
    byLaneType: BYTE;  //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号byRelatedDriveWay对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byRes1: array[0..27-1] of BYTE;  
    byChangeLaneEnable: BYTE;  //违章变道抓拍使能，0-关闭，1-开启
    byChangeLaneCapNo: BYTE;  //违章变道抓拍张数2-3
    //目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    //类型, 按位表示,0-不启用,1-启用参考 ITC_VIOLATION_DETECT_TYPE
    dwVioDetectType: DWORD;  
    dwRelatedIOOut: DWORD;  //关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
    struTrigLine: NET_ITC_LINE;  //触发线，目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    struLineLeft: NET_ITC_LINE;  //左车道线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    struLane: NET_ITC_LANE_LOGIC_PARAM;  //车道属性，用byUseageType和byCarDriveDirect
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数（20byte）
    byRes2: array[0..280-1] of BYTE;  
  end;
  LPNET_ITC_LANE_HVT_PARAM_V50 = ^NET_ITC_LANE_HVT_PARAM_V50;

type
  NET_ITC_POST_HVT_PARAM_V50 = record 
    byLaneNum: BYTE;  //识别的车道个数，1-6
    byCapType: BYTE;  //抓拍类型，0-机、非、人（默认），1-机动车
    byCapMode: BYTE;  //抓拍方式，0-视频抽帧，1-打断抓拍，2-混合模式，
    bySecneMode: BYTE;  //场景模式，0-城区道路（默认），1-小区出入口，2-高速公路
    bySpeedMode: BYTE;  //测速模式，0-无测速，1-雷达测速，2-视频测速
    byLineRuleEffect: BYTE;  //触发规则线有效性,每一位代表一条触发线,0-无效;1-有效。bit0-左触发线;bit1-右触发线;bit2-视频检测区域
    byRes1: array[0..78-1] of BYTE;  
    struLeftTrigLine: NET_ITC_LINE;  //左触发线(一条垂直线)
    struRigtTrigLine: NET_ITC_LINE;  //右触发线(一条垂直线)
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最右边车道的右车道线）
    struDetectArea: NET_ITC_POLYGON;  //视频检测区域
    struGeogLocation: NET_DVR_GEOGLOCATION;  //地理位置（默认浙江省）计算时区
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_ITC_LANE_HVT_PARAM_V50;  //单车道属性
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    byRes2: array[0..260-1] of BYTE;  
  end;
  LPNET_ITC_POST_HVT_PARAM_V50 = ^NET_ITC_POST_HVT_PARAM_V50;


//车道参数
type
  NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM = record 
    byRelatedDriveWay: BYTE;  //关联的车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byPedestriansNum: BYTE;  //行人数量阈值：范围1-100，默认值1
    byVehicleSpeed: BYTE;  //车辆速度阈值：范围0-100，默认值0
    dwVehicleInterval: DWORD;  //跟车检测阈值：范围0-65536，默认值0
    byPedesDetRule: BYTE;  //行人检测规则；代表行人检测区域中行人行驶方向； 0~向左， 1~向右。
    byRes: array[0..3-1] of BYTE;  
    struLaneLine: NET_ITC_LINE;  //车道线
    struStopLine: NET_ITC_LINE;  //停止线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域
    byRes1: array[0..280-1] of BYTE;  
  end;
  LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM = ^NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;

//不礼让行人参数
type
  NET_ITC_NOCOMITY_PEDESTRIAN_PARAM = record 
    byEnable: BYTE;  //使能
    byLaneNum: BYTE;  // 关联车道总数：范围1-3，默认值3
    byRes: array[0..74-1] of BYTE;  
    struLaneBoundaryLine: NET_ITC_LINE;  //车道右边界线
    struTriggerLine: NET_ITC_LINE;  //不礼让行人触发线
    struPedesDetRecog: NET_ITC_POLYGON;  //行人检测区域
    struLaneParam: array[0..MAX_ITC_LANE_NUM{6}-1] of NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;  //车道参数
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    byRes1: array[0..400-1] of BYTE;  
  end;
  LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM = ^NET_ITC_NOCOMITY_PEDESTRIAN_PARAM;

//单个IO接入信号灯参数
type
  NET_ITC_SINGLE_IO_LIGHT_PARAM = record 
    byLightType: BYTE;  //交通灯导向类型,0-左转灯,1-直行灯,2-右转灯
    byRelatedIO: BYTE;  //关联的IO口号
    byRedLightState: BYTE;  //红灯电平状态，0-高电平红灯，1-低电平红灯
    byRes: array[0..17-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_IO_LIGHT_PARAM = ^NET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO接入信号灯参数
type
  NET_ITC_IO_LIGHT_PARAM = record 
    struIOLight: array[0..MAX_LIGHT_NUM-1] of NET_ITC_SINGLE_IO_LIGHT_PARAM;  //单个IO接入信号灯参数
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_IO_LIGHT_PARAM = ^NET_ITC_IO_LIGHT_PARAM;

//单个485接入信号灯参数
type
  NET_ITC_SINGLE_RS485_LIGHT_PARAM = record 
    byLightType: BYTE;  //交通灯导向类型，0-左转灯，1-直行灯，2-右转灯
    byRelatedLightChan: BYTE;  //关联的红绿灯检测器通道号
    byInputLight: BYTE;  //接入的信号灯类型，0-接红灯，1-接绿灯
    byRelatedYLightChan: BYTE;  //关联的黄灯检测器通道号
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_RS485_LIGHT_PARAM = ^NET_ITC_SINGLE_RS485_LIGHT_PARAM;

//485接入信号灯参数
type
  NET_ITC_RS485_LIGHT_PARAM = record 
    struRS485Light: array[0..MAX_LIGHT_NUM-1] of NET_ITC_SINGLE_RS485_LIGHT_PARAM;  //单个485接入信号灯参数
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_RS485_LIGHT_PARAM = ^NET_ITC_RS485_LIGHT_PARAM;

type
  NET_POS_PARAM = record 
    wLeft: WORD;  
    wTop: WORD;  
    wRight: WORD;  
    wBottom: WORD;  
  end;
  LPNET_POS_PARAM = ^NET_POS_PARAM;

//单组视频检测交通信号灯参数结构
type
  NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM = record 
    byLightNum: BYTE;  //交通灯个数
    byStraightLight: BYTE;  //是否有直行标志灯，0-否 ，1-是
    byLeftLight: BYTE;  //是否有左转标志灯，0-否，1-是
    byRightLight: BYTE;  //是否有右转标志灯，0-否，1-是
    byRedLight: BYTE;  //是否有红灯，0-否，1-是
    byGreenLight: BYTE;  //是否有绿灯，0-否，1-是
    byYellowLight: BYTE;  //是否有黄灯，0-否，1-是
    byYellowLightTime: BYTE;  //取值范围（0～10s）（ITC3.7Ver）
    struLightRect: NET_POS_PARAM;  //交通灯区域
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM = ^NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//视频检测交通信号灯参数结构(最大可有12个区域检测，488字节)
type
  NET_ITC_VIDEO_DETECT_LIGHT_PARAM = record 
    struTrafficLight: array[0..MAX_VIDEO_DETECT_LIGHT_NUM-1] of NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;  //单个视频检测信号灯参数
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM = ^NET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//交通信号灯接入参数
type
  NET_ITC_LIGHT_ACCESSPARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..122-1] of DWORD);  
    1: (struIOLight: NET_ITC_IO_LIGHT_PARAM);  //IO接入信号灯参数
    2: (struRS485Light: NET_ITC_RS485_LIGHT_PARAM);  //485接入信号灯参数
    3: (struVideoDelectLight: NET_ITC_VIDEO_DETECT_LIGHT_PARAM);  //视频检测信号灯参数
  end;
  LPNET_ITC_LIGHT_ACCESSPARAM_UNION = ^NET_ITC_LIGHT_ACCESSPARAM_UNION;

//交通信号灯参数结构
type
  NET_ITC_TRAFFIC_LIGHT_PARAM = record 
    bySource: BYTE;  //交通信号灯接入源，0-IO接入，1-RS485接入
    byRes1: array[0..3-1] of BYTE;  
    struLightAccess: NET_ITC_LIGHT_ACCESSPARAM_UNION;  //信号灯接入参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_TRAFFIC_LIGHT_PARAM = ^NET_ITC_TRAFFIC_LIGHT_PARAM;

//违规检测线参数结构
type
  NET_ITC_VIOLATION_DETECT_LINE = record 
    struLaneLine: NET_ITC_LINE;  //车道线参数
    struStopLine: NET_ITC_LINE;  //停止线参数
    struRedLightLine: NET_ITC_LINE;  //闯红灯触发线参数
    struCancelLine: NET_ITC_LINE;  //直行触发位置取消线
    struWaitLine: NET_ITC_LINE;  //待行区停止线参数
    struRes: array[0..8-1] of NET_ITC_LINE;  
  end;
  LPNET_ITC_VIOLATION_DETECT_LINE = ^NET_ITC_VIOLATION_DETECT_LINE;

//行人闯红灯参数
type
  NET_ITC_REDLIGHT_PEDESTRIAN_PARAM = record 
    byEnable: BYTE;  //使能
    bySnapNumTimes: BYTE;  //抓拍张数：1-3，默认3张
    byPedesDir: BYTE;  //行人方向：0~正向，1~背向，2~双向
    byDelayTime: BYTE;  //延时时间1-5s
    byStackTargetEnble: BYTE;  //叠加目标框（即抓拍第一张图片上框住闯红灯的行人），0~不叠加，1~叠加
    byCalibRecogCtrl: BYTE;  //标定区域控制；0~移除标定区域，1~添加标定区域
    byRes1: array[0..2-1] of BYTE;  
    struTrafficLight: NET_ITC_TRAFFIC_LIGHT_PARAM;  //交通信号灯参数
    struStopLine: NET_ITC_LINE;  //停止线
    struCalibRecog: array[0..MAX_CALIB_RECOG_NUM{2}-1] of NET_ITC_POLYGON;  //标定区域
    byRes: array[0..440-1] of BYTE;  
  end;
  LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM = ^NET_ITC_REDLIGHT_PEDESTRIAN_PARAM;

type
  NET_ITC_POST_MOBILE_PARAM = record 
    byEnable: BYTE;  
    bySceneMode: BYTE;  //场景模式 0-高速公路 1-城市道路
    {抓拍类型
    bit0-卡口,bit1-大车占道,bit2-压硬路肩
    }
    wExpressWayCapType: WORD;  //高速公路
    {抓拍类型
    bit0-卡口,bit1-机占非,bit2-占用专用车道
    }
    wUrbanRoadCapType: WORD;  //城市道路
    byCapNum: BYTE;  //抓拍张数 [2,3]
    byRecordEnable: BYTE;  //违章录像使能 0-关闭，1-开启
    dwPreRecordTime: DWORD;  //录像预录时间(s)
    dwOverRecordTime: DWORD;  //录像超时时间(s)
    struLane: NET_ITC_LANE_LOGIC_PARAM;  //车道属性
    struPolygon: array[0..MAX_MOBILE_POLYGON_NUM{3}-1] of NET_ITC_POLYGON;  //牌识区域参数
    struLine: array[0..MAX_MOBILE_DETECTLINE_NUM{3}-1] of NET_ITC_VIOLATION_DETECT_LINE;  //违规检测线
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最右边车道的右车道线）
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数（20byte）
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_ITC_POST_MOBILE_PARAM = ^NET_ITC_POST_MOBILE_PARAM;

type
  NET_ITC_TRIGGER_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..1070-1] of DWORD);  //参数
    1: (struIOSpeed: NET_ITC_POST_IOSPEED_PARAM);  //（卡口）IO测速参数
    2: (struSingleIO: NET_ITC_POST_SINGLEIO_PARAM);  //（卡口）单IO参数
    3: (struPostRs485: NET_ITC_POST_RS485_PARAM);  //（卡口）RS485车检器参数
    4: (struPostRadar: NET_ITC_POST_RS485_RADAR_PARAM);  //（卡口）RS485雷达参数
    5: (struVtCoil: NET_ITC_POST_VTCOIL_PARAM);  //（卡口）虚拟线圈参数
    6: (struHvt: NET_ITC_POST_HVT_PARAM);  //（卡口）混行卡口参数
    7: (struIOTL: NET_ITC_EPOLICE_IOTL_PARAM);  //（电警）IO红绿灯参数
    8: (struEpoliceRs485: NET_ITC_EPOLICE_RS485_PARAM);  //（电警）RS485车检器触发参数
    9: (struPERs485: NET_ITC_EPOLICE_RS485_PARAM);  //（卡式电警）RS485车检器触发参数
    10: (struPostMpr: NET_ITC_POST_MPR_PARAM);  //多帧检测触发（MPR）
    11: (struViaVtCoil: NET_DVR_VIA_VTCOIL_PARAM);  //(VIA)视频检测参数
    12: (struPostImt: NET_ITC_POST_IMT_PARAM);  //智慧布防触发
    13: (struPostPrs: NET_ITC_POST_PRS_PARAM);  //视频检测触发
    14: (struIpcHvt: NET_IPC_POST_HVT_PARAM);  //(IPC) 混行卡口参数
    15: (struHvtV50: NET_ITC_POST_HVT_PARAM_V50);  //（卡口）混行卡口参数V50
    16: (struPostMobile: NET_ITC_POST_MOBILE_PARAM);  // 移动交通触发模式
    17: (struNoComityPed: NET_ITC_NOCOMITY_PEDESTRIAN_PARAM);  //不礼让行人参数
    18: (struRedLightPed: NET_ITC_REDLIGHT_PEDESTRIAN_PARAM);  //行人闯红灯参数
  end;
  LPNET_ITC_TRIGGER_PARAM_UNION = ^NET_ITC_TRIGGER_PARAM_UNION;

//单个触发参数结构
type
  NET_ITC_SINGLE_TRIGGERCFG = record 
    byEnable: BYTE;  //是否启用该触发模式，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    dwTriggerType: DWORD;  //触发类型，详见ITC_TRIGGERMODE_TYPE
    uTriggerParam: NET_ITC_TRIGGER_PARAM_UNION;  //触发参数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_ITC_SINGLE_TRIGGERCFG = ^NET_ITC_SINGLE_TRIGGERCFG;

//触发参数结构
type
  NET_ITC_TRIGGERCFG = record 
    dwSize: DWORD;  //结构长度
    struTriggerParam: NET_ITC_SINGLE_TRIGGERCFG;  //单个触发参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_TRIGGERCFG = ^NET_ITC_TRIGGERCFG;


//违规检测类型宏定义
type
  ITC_VIOLATION_DETECT_TYPE =  
  (  
    ITC_VIOLATION_POST = $01,  //卡口抓拍
    ITC_VIOLATION_DRIVELINE = $02,  //压车道线抓拍
    ITC_VIOLATION_REVERSE = $04,  //逆行抓拍
    ITC_VIOLATION_REDLIGHT = $08,  //闯红灯抓拍
    ITC_VIOLATION_DIRECTION = $10,  //不按导向行驶抓拍
    ITC_VIOLATION_INTERSECTION_CONGEST = $20,  //路口滞留抓拍
    ITC_VIOLATION_NONDRIVEWAY = $40,  //机占非抓拍
    ITC_VIOLATION_CHANGELANE = $80,  //违法变道
    ITC_VIOLATION_BAN = $100,  //违法禁令
    ITC_VIOLATION_INTERSECTION_PARK = $200,  //红灯越线
    ITC_VIOLATION_GREEN_PARK = $400,  //绿灯停车
    ITC_VIOLATION_HIGH_SPEED = $800,  //超速
    ITC_VIOLATION_LOW_SPEED = $1000,  //低速
    ITC_VIOLATION_EMERGENCY = $2000,  //占用应急车道
    ITC_VIOLATION_TURN_AROUND = $8000,  //违法掉头
    ITC_VIOLATION_CONGESTION = $10000  //拥堵
  );


//违规检测参数结构
type
  NET_ITC_VIOLATION_DETECT_PARAM = record 
    dwVioDetectType: DWORD;  //违规检测类型, 按位表示, 详见ITC_VIOLATION_DETECT_TYPE ,0-不启用,1-启用
    byDriveLineSnapTimes: BYTE;  //压车道线抓拍张数,2-3
    byReverseSnapTimes: BYTE;  //逆行抓拍,2-3
    wStayTime: WORD;  //机占非停留时间（该时间后抓拍），单位s
    byNonDriveSnapTimes: BYTE;  //机占非抓拍张数2-3
    byChangeLaneTimes: BYTE;  //违法变道抓拍张数 2-3
    bybanTimes: BYTE;  //违法禁令抓拍张数2-3
    byDriveLineSnapSen: BYTE;  // 压线灵敏度(0~100)(3.7Ver)
    wSnapPosFixPixel: WORD;  //第2,3张抓拍位置最小偏移(违反信号灯时起效)（单位：像素） 命名需改进
    bySpeedTimes: BYTE;  //违法超速抓拍张数2-3(3.8Ver)
    byTurnAroundEnable: BYTE;  //违章掉头使能 0~关闭 1~开启
    byThirdPlateRecogTime: BYTE;  //第三张牌识时间 0~180s
    byPostSnapTimes: BYTE;  //卡口抓拍张数,1-2张
    byRes1: array[0..18-1] of BYTE;  
    wStopLineDis: WORD;  //电警第2张违规图片与停止线的最短距离，[0,300]单位(像素)
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_ITC_VIOLATION_DETECT_PARAM = ^NET_ITC_VIOLATION_DETECT_PARAM;

//关联车道方向类型定义
type
  ITC_RELA_LANE_DIRECTION_TYPE =  
  (  
    ITC_RELA_LANE_DIRECTION_UNKNOW = 0,  //其它
    ITC_RELA_LANE_EAST_WEST = 1,  //从东向西
    ITC_RELA_LANE_WEST_EAST = 2,  //从西向东
    ITC_RELA_LANE_SOUTH_NORTH = 3,  //从南向北
    ITC_RELA_LANE_NORTH_SOUTH = 4,  //从北向南
    ITC_RELA_LANE_EASTSOUTH_WESTNORTH = 5,  //从东南向西北
    ITC_RELA_LANE_WESTNORTH_EASTSOUTH = 6,  //从西北向东南
    ITC_RELA_LANE_EASTNORTH_WESTSOUTH = 7,  //从东北向西南
    ITC_RELA_LANE_WESTSOUTH_EASTNORTH = 8  //从西南向东北
  );


//车道用途类型定义
type
  ITC_LANE_USEAGE_TYPE =  
  (  
    ITC_LANE_USEAGE_UNKNOW = 0,  //未知
    ITC_LANE_CARRIAGEWAY = 1,  //正常车道
    ITC_LANE_BUS = 2,  //公交车专用道
    ITC_LANE_FAST = 3,  //快车道
    ITC_LANE_SLOW = 4,  //慢车道
    ITC_LANE_MOTOR = 5,  //摩托车道
    ITC_LANE_NONMOTOR = 6,  //非机动车道
    ITC_LANE_REVERSE_LANE = 7,  //反向车道
    ITC_LANE_BAN_TRUCKS = 8,  // 禁止货车车道
    ITC_LANE_MIX = 9,  //混合车道
    ITC_LANE_EMERGENCY = 10,  //应急车道
    ITC_LANE_BAN_LEFT = 11,  // 禁左车道
    ITC_LANE_BAN_RIGHT = 12  // 禁右车道
  );

//车道方向类型定义
type
  ITC_LANE_DIRECTION_TYPE =  
  (  
    ITC_LANE_DIRECTION_UNKNOW = 0,  //未知
    ITC_LANE_LEFT = 1,  //左转
    ITC_LANE_STRAIGHT = 2,  //直行
    ITC_LANE_LEFT_STRAIGHT = 3,  //左转+直行
    ITC_LANE_RIGHT = 4,  //右转
    ITC_LANE_LEFT_RIGHT = 5,  //左转+右转
    ITC_LANE_RIGHT_STRAIGHT = 6,  //右转+直行
    ITC_LANE_LEFT_RIGHT_STRAIGHT = 7,  //左转+右转+直行
    ITC_LANE_LEFT_WAIT = 9,  //左转待行
    ITC_LANE_STRAIGHT_WAIT = 10,  //直行待行
    ITC_LANE_FORWARD = 11,  //正向行驶
    ITC_LANE_BACKWARD = 12,  //背向行驶
    ITC_LANE_BOTHWAY = 13,  //双向行驶
    ITC_LANE_STRAIGHT_WAIT_RIGHT = 14  //直行待行 + 右转
  );

//车辆行驶方向类型定义
type
  ITC_LANE_CAR_DRIVE_DIRECT =  
  (  
    ITC_LANE_DRIVE_UNKNOW = 0,  //未知
    ITC_LANE_DRIVE_UP_TO_DOWN = 1,  //从上往下行驶(下行)
    ITC_LANE_DRIVE_DOWN_TO_UP = 2  //从下往上行驶(上行)
  );

//线类型定义
type
  ITC_LINE_TYPE =  
  (  
    ITC_LINT_UNKNOW = 0,  //未知
    ITC_LINE_WHITE = 1,  //车道间的白实线
    ITC_LINE_STOP = 2,  //车道停止线
    ITC_LINE_SINGLE_YELLOW = 3,  //单黄线
    ITC_LINE_DOUBLE_YELLOW = 4,  //双黄线
    ITC_LINE_GUARD_RAIL = 5,  //车道线上有护栏
    ITC_LINE_NO_CROSS = 6,  //车辆无法跨越的车道线
    ITC_LINE_DOTTED = 7  //虚线
  );


//单个车道视频电警触发参数结构
type
  NET_ITC_LANE_VIDEO_EPOLICE_PARAM = record 
    byLaneNO: BYTE;  //关联的车道号
    bySensitivity: BYTE;  //线圈灵敏度，[1,100]
    byEnableRadar: BYTE;  //启用雷达测试0-不启用，1-启用
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    struLane: NET_ITC_LANE_LOGIC_PARAM;  //车道参数
    struVioDetect: NET_ITC_VIOLATION_DETECT_PARAM;  //违规检测参数
    struLine: NET_ITC_VIOLATION_DETECT_LINE;  //违规检测线
    struPlateRecog: NET_ITC_POLYGON;  //牌识区域参数
    byRecordEnable: BYTE;  //闯红灯周期录像标志，0-不录像，1-录像
    byRecordType: BYTE;  //闯红灯录像类型，0-预录，1-延时录像
    byPreRecordTime: BYTE;  //闯红灯录像片段预录时间（默认0），单位：秒
    byRecordDelayTime: BYTE;  //闯红灯录像片段延时时间（默认0），单位：秒
    byRecordTimeOut: BYTE;  //闯红灯周期录像超时时间（秒）
    byCarSpeedLimit: BYTE;  //车速限制值，单位km/h
    byCarSignSpeed: BYTE;  //标志限速，单位km/h
    bySnapPicPreRecord: BYTE;  //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    struInterval: NET_ITC_INTERVAL_PARAM;  //抓拍间隔参数（20byte）
    byRes: array[0..36-1] of BYTE;  
  end;
  LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM = ^NET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//视频电警触发参数结构
type
  NET_ITC_VIDEO_EPOLICE_PARAM = record 
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byLaneNum: BYTE;  //识别的车道个数
    byLogicJudge: BYTE;  //闯红灯违规判断逻辑，设置值为：0-按方向，1-按车道
    byRes1: BYTE;  
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;  //牌识参数
    struTrafficLight: NET_ITC_TRAFFIC_LIGHT_PARAM;  //交通信号灯参数
    struLaneParam: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_LANE_VIDEO_EPOLICE_PARAM;  //单车道参数
    struLaneBoundaryLine: NET_ITC_LINE;  //车道边界线（最右边车道的边界线）
    struLeftLine: NET_ITC_LINE;  //左转弯分界线
    struRightLine: NET_ITC_LINE;  //右转弯分界线
    struTopZebraLine: NET_ITC_LINE;  //上部斑马线
    struBotZebraLine: NET_ITC_LINE;  //下部斑马线
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_VIDEO_EPOLICE_PARAM = ^NET_ITC_VIDEO_EPOLICE_PARAM;

type
  NET_ITC_VIDEO_TRIGGER_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..1150-1] of DWORD);  
    1: (struVideoEP: NET_ITC_VIDEO_EPOLICE_PARAM);  //视频电警参数
  end;
  LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION = ^NET_ITC_VIDEO_TRIGGER_PARAM_UNION;

type
  NET_ITC_VIDEO_TRIGGER_PARAM = record 
    dwSize: DWORD;  
    dwMode: DWORD;  //触发模式，详见ITC_TRIGGERMODE_TYPE
    uVideoTrigger: NET_ITC_VIDEO_TRIGGER_PARAM_UNION;  //触发模式参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_VIDEO_TRIGGER_PARAM = ^NET_ITC_VIDEO_TRIGGER_PARAM;

type
  NET_DVR_STATUS_DETECTCFG = record 
    dwSize: DWORD;  //结构长度
    byEnableTrigIODetect: BYTE;  //开启触发IO状态检测，1-是，0-否
    byEnableFlashOutDetect: BYTE;  //开启同步输出状态检测，1-是，0-否
    byEnableRS485Detect: BYTE;  //开启RS485接收状态检测，1-是，0-否
    byEnableTrafficLightDetect: BYTE;  //开启交通灯状态检测，1-是，0-否
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_STATUS_DETECTCFG = ^NET_DVR_STATUS_DETECTCFG;

type
  ITC_STATUS_DETECT_TYPE =  
  (  
    ITC_STATUS_DETECT_NULL = 0,  //未知
    ITC_STATUS_DETECT_TRIGGERIO,  //触发IO
    ITC_STATUS_DETECT_FLASHOUT,  //同步输出
    ITC_STATUS_DETECT_RS485,  //RS485
    ITC_STATUS_DETECT_TRIGGERTYPE,  //触发类型（保留）
    ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //交通灯（区分颜色）
    ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //交通灯（区分转向）
  );

type
  NET_ITC_TRIGGERIO_INFO = record 
    byTriggerIOIndex: array[0..MAX_IOIN_NUM-1] of BYTE;  //触发IO号
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_ITC_TRIGGERIO_INFO = ^NET_ITC_TRIGGERIO_INFO;

type
  NET_ITC_FLASHOUT_INFO = record 
    byFlashOutIndex: array[0..MAX_IOOUT_K_NUM-1] of BYTE;  //同步输出号
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_ITC_FLASHOUT_INFO = ^NET_ITC_FLASHOUT_INFO;

type
  NET_ITC_SERIAL_CHECKINFO = record 
    bySerialIndex: array[0..MAX_ITC_SERIALCHECK_NUM-1] of BYTE;  //485串口校验结果，0-无效,1-有效, bySerialIndex[0]表示正确的头, bySerialIndex[1]表示正确的尾
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_ITC_SERIAL_CHECKINFO = ^NET_ITC_SERIAL_CHECKINFO;

type
  NET_ITC_TRIGGERTYPE_INFO = record 
    byTrigTypeIndex: BYTE;  //触发类型值
    byRes: array[0..47-1] of BYTE;  
  end;
  LPNET_ITC_TRIGGERTYPE_INFO = ^NET_ITC_TRIGGERTYPE_INFO;

//视频电警
type
  NET_ITC_TRAFFIC_LIGHT_COLOR = record 
    byLeftLight: BYTE;  //左转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    byRightLight: BYTE;  //右转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    byStraightLight: BYTE;  //直行灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    byRes: array[0..45-1] of BYTE;  
  end;
  LPNET_ITC_TRAFFIC_LIGHT_COLOR = ^NET_ITC_TRAFFIC_LIGHT_COLOR;

//非视频电警
type
  NET_ITC_TRAFFIC_LIGHT_TURN = record 
    byLightType: array[0..MAX_ITC_LANE_NUM-1] of BYTE;  // 0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    byRes: array[0..42-1] of BYTE;  
  end;
  LPNET_ITC_TRAFFIC_LIGHT_TURN = ^NET_ITC_TRAFFIC_LIGHT_TURN;

type
  NET_ITC_STATUS_UNION = record 
    case Byte of
    0: (uLen: array[0..48-1] of BYTE);  //参数
    1: (struTrigIO: NET_ITC_TRIGGERIO_INFO);  //触发IO口号
    2: (struFlashOut: NET_ITC_FLASHOUT_INFO);  //同步输出
    3: (struSerial: NET_ITC_SERIAL_CHECKINFO);  //串口
    4: (struTrigType: NET_ITC_TRIGGERTYPE_INFO);  //触发类型（保留）
    5: (struTrafficLightColor: NET_ITC_TRAFFIC_LIGHT_COLOR);  //交通灯（区分颜色）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    6: (struTrafficLightTurn: NET_ITC_TRAFFIC_LIGHT_TURN);  //交通灯（区分转向）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
  end;
  LPNET_ITC_STATUS_UNION = ^NET_ITC_STATUS_UNION;

type
  NET_ITC_STATUS_DETECT_RESULT = record 
    dwStatusType: ITC_STATUS_DETECT_TYPE;  //状态检测类型，详见ITC_STATUS_DETECT_TYPE
    uStatusParam: NET_ITC_STATUS_UNION;  //状态检测结果
    dwHoldTime: DWORD;  //灯亮持续时间（保留），单位：ms
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITC_STATUS_DETECT_RESULT = ^NET_ITC_STATUS_DETECT_RESULT;

type
  NET_DVR_SETUPALARM_PARAM = record 
    dwSize: DWORD;  
    byLevel: BYTE;  //布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
    byAlarmInfoType: BYTE;  //上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
    byRetAlarmTypeV40: BYTE;  //0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
    byRetDevInfoVersion: BYTE;  //CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
    byRetVQDAlarmType: BYTE;  //VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
    //1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
    byFaceAlarmDetection: BYTE;  
    //Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
    //Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
    //Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标）
    bySupport: BYTE;  
    //断网续传类型
    //bit0-车牌检测（IPC） （0-不续传，1-续传）
    //bit1-客流统计（IPC）  （0-不续传，1-续传）
    //bit2-热度图统计（IPC） （0-不续传，1-续传）
    //bit3-人脸抓拍（IPC） （0-不续传，1-续传）
    //bit4-人脸对比（IPC） （0-不续传，1-续传）
    byBrokenNetHttp: BYTE;  
    wTaskNo: WORD;  //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    byDeployType: BYTE;  //布防类型：0-客户端布防，1-实时布防
    bySubScription: BYTE;  //订阅，按位表示，未开启订阅不上报  //占位
    //Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
    byRes1: array[0..2-1] of BYTE;  
    byAlarmTypeURL: BYTE;  //bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
    //bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
    //bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
    //bit3 - 异常行为检测(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
    byCustomCtrl: BYTE;  //Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
  end;
  LPNET_DVR_SETUPALARM_PARAM = ^NET_DVR_SETUPALARM_PARAM;

type
  NET_DVR_SETUPALARM_PARAM_V50 = record 
    dwSize: DWORD;  
    byLevel: BYTE;  //布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
    byAlarmInfoType: BYTE;  //上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
    byRetAlarmTypeV40: BYTE;  //0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
    byRetDevInfoVersion: BYTE;  //CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
    byRetVQDAlarmType: BYTE;  //VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
    //1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
    byFaceAlarmDetection: BYTE;  
    //Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
    //Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
    //Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标）
    bySupport: BYTE;  
    //断网续传类型
    //bit0-车牌检测（IPC） （0-不续传，1-续传）
    //bit1-客流统计（IPC）  （0-不续传，1-续传）
    //bit2-热度图统计（IPC） （0-不续传，1-续传）
    //bit3-人脸抓拍（IPC） （0-不续传，1-续传）
    //bit4-人脸对比（IPC） （0-不续传，1-续传）
    //bit5-JSON报警透传（IPC） （0-不续传，1-续传）
    //bit6-热度图按人员停留时间统计数据上传事件（0-不续传，1-续传）
    //bit7-热度图按人数统计数据上传事件的确认机制（0-不续传，1-续传）
    byBrokenNetHttp: BYTE;  
    wTaskNo: WORD;  //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    byDeployType: BYTE;  //布防类型：0-客户端布防，1-实时布防
    bySubScription: BYTE;  //订阅，按位表示，未开启订阅不上报  //占位Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
    //断网续传响应类型V60版本
    //bit0-AID事件(COMM_ALARM_AID_V41) （0-不续传，1-续传）
    //bit1-TFS事件（COMM_ALARM_TFS）  （0-不续传，1-续传）
    //bit2-TPS统计过车事件（COMM_ALARM_TPS_STATISTICS）  （0-不续传，1-续传）
    //bit3-异常行为检测(COMM_ALARM_RULE)  （0-不续传，1-续传）
    byBrokenNetHttpV60: BYTE;  
    byRes1: BYTE;  
    byAlarmTypeURL: BYTE;  //bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
    //bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
    //bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
    //bit3 - 异常行为检测(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
    byCustomCtrl: BYTE;  //Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
    byRes4: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SETUPALARM_PARAM_V50 = ^NET_DVR_SETUPALARM_PARAM_V50;

type
  NET_ITC_VIDEO_TRIGGER_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwTriggerMode: DWORD;  //视频触发模式类型，详见ITC_TRIGGERMODE_TYPE
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_ITC_VIDEO_TRIGGER_COND = ^NET_ITC_VIDEO_TRIGGER_COND;

//条件结构
type
  NET_ITC_FTP_TYPE_COND = record 
    dwChannel: DWORD;  //通道号
    byWorkMode: BYTE;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_ITC_FTP_TYPE_COND = ^NET_ITC_FTP_TYPE_COND;

//配置结构
type
  NET_ITC_FTP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启动ftp上传功能，0-否，1-是
    byAddressType: BYTE;  //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    wFTPPort: WORD;  //端口
    unionServer: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //服务器地址，域名
        byRes1: array[0..80-1] of BYTE;  
      end);  
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  {IP地址}//IPv4 IPv6地址, 144字节
      end);  
    end;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64
    szUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    szPassWORD: array[0..PASSWD_LEN-1] of BYTE;  //密码
    byRes4: BYTE;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
    byDirLevel: BYTE;  {0 = 不使用目录结构，直接保存在根目录,
                                                                1 = 使用1级目录,2=使用2级目录,
                                 3 = 使用3级目录,4=使用4级目录}
    byIsFilterCarPic: BYTE;  //车牌小图是否上传，0-上传,1-不上传
    byUploadDataType: BYTE;  //0-全部，1-卡口，2-违章 (单FTP时默认选择全部，双FTP时支持卡口，违章的选择)
    struPicNameRule: NET_DVR_PICTURE_NAME;  // 图片命名规则 
    byTopDirMode: BYTE;  {一级目录, 0x1 = 使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用显示点,0x5=使用时间(年月),
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义}
    bySubDirMode: BYTE;  {二级目录, 0x1 =使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用显示点,0x5=使用时间(年月),
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义}
    byThreeDirMode: BYTE;  {三级目录, 0x1 = 使用设备名,
                                                                                                            0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                            0x4=使用显示点,0x5=使用时间(年月),
                                                                                                            0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义}
    byFourDirMode: BYTE;  {四级目录, 0x1 =使用设备名,
                                                                                                           0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                           0x4=使用显示点,0x5=使用时间(年月),
                                                                                                           0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义}
                                                                        //图片命名自定义 当PICNAME_ITEM_CUSTOM 时 生效
    szPicNameCustom: array[0..MAX_CUSTOMDIR_LEN-1] of BYTE;  // (3.7Ver 生效)
    szTopCustomDir: array[0..MAX_CUSTOMDIR_LEN-1] of BYTE;  //自定义一级目录
    szSubCustomDir: array[0..MAX_CUSTOMDIR_LEN-1] of BYTE;  //自定义二级目录
    szThreeCustomDir: array[0..MAX_CUSTOMDIR_LEN-1] of BYTE;  //自定义三级目录
    szFourCustomDir: array[0..MAX_CUSTOMDIR_LEN-1] of BYTE;  //自定义四级目录
    byRes3: array[0..900-1] of BYTE;  //满足12级扩展预留 支持透传
  end;
  LPNET_ITC_FTP_CFG = ^NET_ITC_FTP_CFG;

type
  NET_DVR_LATITUDE_PARAM = record 
    byDegree: BYTE;  //度[0,179]
    byMinute: BYTE;  //分[0,59]
    bySec: BYTE;  //秒[0,59]
    byRes: BYTE;  
  end;
  LPNET_DVR_LATITUDE_PARAM = ^NET_DVR_LATITUDE_PARAM;

type
  NET_DVR_LONGITUDE_PARAM = record 
    byDegree: BYTE;  //度[0,179]
    byMinute: BYTE;  //分[0,59]
    bySec: BYTE;  //秒[0,59]
    byRes: BYTE;  
  end;
  LPNET_DVR_LONGITUDE_PARAM = ^NET_DVR_LONGITUDE_PARAM;

type
  NET_DVR_GPS_DATACFG = record 
    dwSize: DWORD;  
    byGpsDataMode: BYTE;  //GPS数据获取 0-自动，1-手动
    byLongitudeType: BYTE;  //经度 0-东经，1-西经
    byLatitudeType: BYTE;  //纬度 0-南纬，1-北纬
    byRes: BYTE;  
    struLatitude: NET_DVR_LATITUDE_PARAM;  //纬度
    struLongitude: NET_DVR_LONGITUDE_PARAM;  //经度
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_GPS_DATACFG = ^NET_DVR_GPS_DATACFG;

type
  VCA_DATABASE_TYPE =  
  (  
    DATABASE_NULL = 0,  //未知
    DATABASE_SNAP,  //抓拍数据库
    DATABASE_FACE  //人脸数据库
  );

type
  NET_VCA_DATABASE_PARAM = record 
    dwSize: DWORD;  
    dwDataBaseID: DWORD;  //数据库ID（设备生成，添加时无效，修改和删除时有效）
    dwDataBaseType: DWORD;  //数据库类型，见VCA_DATABASE_TYPE
    byDataBaseName: array[0..NAME_LEN-1] of BYTE;  //数据库名称
    byAttribute: array[0..64-1] of BYTE;  //数据库属性
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_VCA_DATABASE_PARAM = ^NET_VCA_DATABASE_PARAM;

type
  NET_VCA_FIND_DATABASE_COND = record 
    dwDataBaseType: DWORD;  //数据库类型，详见VCA_DATABASE_TYPE
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_VCA_FIND_DATABASE_COND = ^NET_VCA_FIND_DATABASE_COND;

type
  NET_VCA_DELETE_DATABASE_COND = record 
    dwSize: DWORD;  
    dwDataBaseType: DWORD;  //数据库类型，见VCA_DATABASE_TYPE
    dwDataBaseID: DWORD;  //数据库ID
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_VCA_DELETE_DATABASE_COND = ^NET_VCA_DELETE_DATABASE_COND;

type
  NET_VCA_INQUIRE_SNAPDB_COND = record 
    dwChannel: DWORD;  //通道号
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
    bySex: BYTE;  //性别：0-不启用，1-男，2-女
    byRes1: array[0..3-1] of BYTE;  //保留
    byStartBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //起始出生年月，如：201106
    byEndBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //截止出生年月，如201106
    byAttribute1: array[0..NAME_LEN-1] of BYTE;  //属性1
    byAttribute2: array[0..NAME_LEN-1] of BYTE;  //属性2
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_VCA_INQUIRE_SNAPDB_COND = ^NET_VCA_INQUIRE_SNAPDB_COND;

type
  NET_VCA_INQUIRE_SNAPRECORD_RESULT = record 
    dwSize: DWORD;  //结构体大小
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    struSnapTime: NET_DVR_TIME;  //抓拍时间
    bySex: BYTE;  //性别：0-不启用，1-男，2-女
    byRes1: array[0..3-1] of BYTE;  //保留
    byStartBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //起始出生年月，如：201106
    byEndBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //截止出生年月，如201106
    byAttribute1: array[0..NAME_LEN-1] of BYTE;  //属性1
    byAttribute2: array[0..NAME_LEN-1] of BYTE;  //属性2
    dwFacePicID: DWORD;  //人脸图ID
    dwFacePicLen: DWORD;  //人脸图数据长度
    byRes: array[0..80-1] of BYTE;  //保留
    pFacePic: PBYTE;  //人脸图数据
  end;
  LPNET_VCA_INQUIRE_SNAPRECORD_RESULT = ^NET_VCA_INQUIRE_SNAPRECORD_RESULT;

type
  NET_VCA_DELETE_SNAPRECORD_COND_UNION = record 
    case Byte of
    0: (struAttribute: NET_VCA_INQUIRE_SNAPDB_COND);  //人员信息（批量删除）
    1: (dwRecordID: DWORD);  //记录ID（单条删除）
  end;
  LPNET_VCA_DELETE_SNAPRECORD_COND_UNION = ^NET_VCA_DELETE_SNAPRECORD_COND_UNION;

type
  VCA_DELETE_RECORD_TYPE =  
  (  
    DELETE_RECORD_SINGLE = 0,  //单条删除
    DELETE_RECORD_BATCH  //批量删除
  );

type
  NET_VCA_DELETE_SNAPRECORD_COND = record 
    dwDeleteType: VCA_DELETE_RECORD_TYPE;  //删除记录类型
    uDeleteCond: NET_VCA_DELETE_SNAPRECORD_COND_UNION;  //删除参数
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_VCA_DELETE_SNAPRECORD_COND = ^NET_VCA_DELETE_SNAPRECORD_COND;

type
  VCA_SEARCH_DATABASE_TYPE =  
  (  
    VCA_NORMAL_SEARCH_DATABASE = $00000000,  //普通检索
    VCA_ADVANCE_SEARCH_DATABASE = $00000001  //高级检索
  );

type
  NET_VCA_ADVANCE_SEARCH_DATABASE_COND = record 
    dwDataBaseType: DWORD;  //数据库类型，详见VCA_DATABASE_TYPE
    dwDataBaseID: DWORD;  //数据库ID
    dwFacePicID: DWORD;  //人脸图片ID
    byRes: array[0..36-1] of BYTE;  
  end;
  LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND = ^NET_VCA_ADVANCE_SEARCH_DATABASE_COND;

type
  NET_VCA_SEARCH_DATABASE_COND_UNION = record 
    case Byte of
    0: (uLen: array[0..25-1] of DWORD);  
    1: (struNormalFind: NET_VCA_REGISTER_PIC);  //普通检索
    2: (struAdvanceFind: NET_VCA_ADVANCE_SEARCH_DATABASE_COND);  //高级检索
  end;
  LPNET_VCA_SEARCH_DATABASE_COND_UNION = ^NET_VCA_SEARCH_DATABASE_COND_UNION;

type
  NET_VCA_SEARCH_DATABASE_PARAM = record 
    dwSearchType: DWORD;  //检索类型，详见VCA_SEARCH_DATABASE_TYPE
    uSearchCond: NET_VCA_SEARCH_DATABASE_COND_UNION;  //检索参数
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_VCA_SEARCH_DATABASE_PARAM = ^NET_VCA_SEARCH_DATABASE_PARAM;

type
  NET_VCA_SEARCH_SNAPDB_COND = record 
    dwChannel: DWORD;  //通道
    dwDataBaseID: DWORD;  //数据库ID
    struStartTime: NET_DVR_TIME;  //开始时间
    struStopTime: NET_DVR_TIME;  //结束时间
    bySex: BYTE;  //性别：0-不启用，1-男，2-女
    byRes1: array[0..3-1] of BYTE;  //保留
    byStartBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //起始出生年月，如：201106
    byEndBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //截止出生年月，如201106
    byAttribute1: array[0..NAME_LEN-1] of BYTE;  //属性1
    byAttribute2: array[0..NAME_LEN-1] of BYTE;  //属性2
    struSearchParam: NET_VCA_SEARCH_DATABASE_PARAM;  //检索参数
    dwMaxSearchNum: DWORD;  //最大检索条数
    wThreshold: WORD;  //阈值，0-100
    byRes: array[0..78-1] of BYTE;  //保留
  end;
  LPNET_VCA_SEARCH_SNAPDB_COND = ^NET_VCA_SEARCH_SNAPDB_COND;

type
  NET_VCA_SEARCH_SNAPRECORD_RESULT = record 
    dwSize: DWORD;  //结构体大小
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    struSnapTime: NET_DVR_TIME;  //抓拍时间
    bySex: BYTE;  //性别：0-不启用，1-男，2-女
    byRes1: array[0..3-1] of BYTE;  //保留
    byStartBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //起始出生年月，如：201106
    byEndBirthDate: array[0..MAX_HUMAN_BIRTHDATE_LEN-1] of BYTE;  //截止出生年月，如201106
    byAttribute1: array[0..NAME_LEN-1] of BYTE;  //属性1
    byAttribute2: array[0..NAME_LEN-1] of BYTE;  //属性2
    fSimilarity: FLOAT;  //相似度，[0.001,1]
    dwFacePicID: DWORD;  //人脸图ID
    dwFacePicLen: DWORD;  //人脸图数据长度
    byRes: array[0..80-1] of BYTE;  //保留
    pFacePic: PBYTE;  //人脸图数据
  end;
  LPNET_VCA_SEARCH_SNAPRECORD_RESULT = ^NET_VCA_SEARCH_SNAPRECORD_RESULT;

type
  NET_VCA_DATARECORD_INFO = record 
    dwSize: DWORD;  //结构体大小
    dwRecordID: DWORD;  //记录ID，添加时无效，修改时有效
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    struRegisterPic: NET_VCA_REGISTER_PIC;  //人员图片信息
    byRemark1: array[0..NAME_LEN-1] of BYTE;  //备注信息1
    byRemark2: array[0..64-1] of BYTE;  //备注信息2
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_VCA_DATARECORD_INFO = ^NET_VCA_DATARECORD_INFO;

type
  NET_VCA_FAST_DATARECORD_INFO = record 
    dwSize: DWORD;  //结构体大小
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    byRemark1: array[0..NAME_LEN-1] of BYTE;  //备注信息1
    byRemark2: array[0..64-1] of BYTE;  //备注信息2
    dwImageLen: DWORD;  //图像数据长度
    byRes: array[0..80-1] of BYTE;  //保留
    pImage: PBYTE;  //图像数据
  end;
  LPNET_VCA_FAST_DATARECORD_INFO = ^NET_VCA_FAST_DATARECORD_INFO;

type
  NET_VCA_INQUIRE_DATARECORD_RESULT = record 
    dwSize: DWORD;  //结构体大小
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    byRemark1: array[0..NAME_LEN-1] of BYTE;  //备注信息1
    byRemark2: array[0..64-1] of BYTE;  //备注信息2
    dwFacePicID: DWORD;  //人脸图ID
    dwFacePicLen: DWORD;  //人脸图数据长度
    byRes: array[0..80-1] of BYTE;  //保留
    pFacePic: PBYTE;  //人脸图数据
  end;
  LPNET_VCA_INQUIRE_DATARECORD_RESULT = ^NET_VCA_INQUIRE_DATARECORD_RESULT;

type
  NET_VCA_SEARCH_DATARECORD_RESULT = record 
    dwSize: DWORD;  //结构体大小
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    struAttribute: NET_VCA_HUMAN_ATTRIBUTE;  //人员信息
    byRemark1: array[0..NAME_LEN-1] of BYTE;  //备注信息1
    byRemark2: array[0..64-1] of BYTE;  //备注信息2
    fSimilarity: FLOAT;  //相似度，[0.001,1]
    dwFacePicID: DWORD;  //人脸图ID
    dwFacePicLen: DWORD;  //人脸图数据长度
    byRes: array[0..80-1] of BYTE;  //保留
    pFacePic: PBYTE;  //人脸图数据
  end;
  LPNET_VCA_SEARCH_DATARECORD_RESULT = ^NET_VCA_SEARCH_DATARECORD_RESULT;

type
  NET_VCA_DATARECORD_COND = record 
    dwDataBaseID: DWORD;  //数据库ID
    struAttribute: NET_VCA_HUMANATTRIBUTE_COND;  //人员信息
    byRes: array[0..80-1] of BYTE;  //保留
  end;
  LPNET_VCA_DATARECORD_COND = ^NET_VCA_DATARECORD_COND;

type
  NET_VCA_DELETE_RECORD_COND_UNION = record 
    case Byte of
    0: (struAttribute: NET_VCA_HUMANATTRIBUTE_COND);  //人员信息（批量删除）
    1: (dwRecordID: DWORD);  //记录ID（单条删除）
  end;
  LPNET_VCA_DELETE_RECORD_COND_UNION = ^NET_VCA_DELETE_RECORD_COND_UNION;

type
  NET_VCA_DELETE_RECORD_COND = record 
    dwDeleteType: VCA_DELETE_RECORD_TYPE;  //删除记录类型
    uDeleteCond: NET_VCA_DELETE_RECORD_COND_UNION;  //删除参数
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_VCA_DELETE_RECORD_COND = ^NET_VCA_DELETE_RECORD_COND;

type
  NET_VCA_SEARCH_FACEDB_COND = record 
    dwDataBaseID: DWORD;  //数据库ID
    struAttribute: NET_VCA_HUMANATTRIBUTE_COND;  //人员信息
    struSearchParam: NET_VCA_SEARCH_DATABASE_PARAM;  //检索参数
    dwMaxSearchNum: DWORD;  //最大检索条数
    wThreshold: WORD;  //阈值，0-100
    byRes: array[0..78-1] of BYTE;  //保留
  end;
  LPNET_VCA_SEARCH_FACEDB_COND = ^NET_VCA_SEARCH_FACEDB_COND;

type
  NET_VCA_FIND_MATCHPIC_COND = record 
    dwSize: DWORD;  
    dwDataBaseType: DWORD;  //数据库类型，见VCA_DATABASE_TYPE
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_VCA_FIND_MATCHPIC_COND = ^NET_VCA_FIND_MATCHPIC_COND;

type
  NET_VCA_FIND_MATCHPIC_RESULT = record 
    dwSize: DWORD;  
    dwDataBaseType: DWORD;  //数据库类型，见VCA_DATABASE_TYPE
    dwDataBaseID: DWORD;  //数据库ID
    dwRecordID: DWORD;  //记录ID
    dwPicLen: DWORD;  //图片长度
    byRes: array[0..64-1] of BYTE;  //保留
    pPicBuffer: PBYTE;  //图片数据指针
  end;
  LPNET_VCA_FIND_MATCHPIC_RESULT = ^NET_VCA_FIND_MATCHPIC_RESULT;

type
  NET_DVR_REMOTECONTROL_ALARM_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    wDealyTime: WORD;  //延迟时间，单位s
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROL_ALARM_PARAM = ^NET_DVR_REMOTECONTROL_ALARM_PARAM;

type
  NET_DVR_REMOTECONTROL_STUDY_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROL_STUDY_PARAM = ^NET_DVR_REMOTECONTROL_STUDY_PARAM;

type
  NET_DVR_WIRELESS_ALARM_STUDY_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byIndex: BYTE;  //无线报警序号，1-8
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM = ^NET_DVR_WIRELESS_ALARM_STUDY_PARAM;

const
  MAX_AUX_ALARM_NUM = 8;    //最大辅助报警个数
  MAX_WIRELESS_ALARM_NUM = 8;    //最大无线报警个数
type
  IPC_AUX_ALARM_TYPE =  
  (  
    IPC_AUXALARM_UNKNOW = 0,  //未知
    IPC_AUXALARM_PIR = 1,  //PIR报警
    IPC_AUXALARM_WIRELESS = 2,  //无线报警
    IPC_AUXALARM_CALLHELP = 3  //呼救报警
  );

type
  NET_IPC_AUDIO_LIMIT_ALARM_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    dwDecibelLimit: DWORD;  //分贝告警阀值
    struHandleException: NET_DVR_HANDLEEXCEPTION_V30;  //异常处理方式
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_IPC_AUDIO_LIMIT_ALARM_CFG = ^NET_IPC_AUDIO_LIMIT_ALARM_CFG;

type
  NET_IPC_BUTTON_DOWN_ALARM_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V30;  //异常处理方式
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_IPC_BUTTON_DOWN_ALARM_CFG = ^NET_IPC_BUTTON_DOWN_ALARM_CFG;

type
  NET_IPC_PIR_ALARMCFG = record 
    byAlarmName: array[0..NAME_LEN-1] of BYTE;  // 报警名称 
    byAlarmHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byRes1: array[0..3-1] of BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_IPC_PIR_ALARMCFG = ^NET_IPC_PIR_ALARMCFG;

type
  NET_IPC_PIR_ALARMCFG_EX = record 
    byAlarmName: array[0..NAME_LEN-1] of BYTE;  // 报警名称 
    byAlarmHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byRes1: array[0..3-1] of BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    byRes: array[0..1464-1] of BYTE;  
  end;
  LPNET_IPC_PIR_ALARMCFG_EX = ^NET_IPC_PIR_ALARMCFG_EX;

//呼救报警
type
  NET_IPC_CALLHELP_ALARMCFG = record 
    byAlarmHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byRes1: array[0..3-1] of BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_IPC_CALLHELP_ALARMCFG = ^NET_IPC_CALLHELP_ALARMCFG;

type
  NET_IPC_SINGLE_WIRELESS_ALARMCFG = record 
    byAlarmName: array[0..NAME_LEN-1] of BYTE;  // 报警名称 
    byAlarmHandle: BYTE;  // 是否处理 0-不处理 1-处理
    byID: BYTE;  //无线报警ID，1-8
    byRes1: array[0..2-1] of BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;  // 处理方式 
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of BYTE;  //报警触发的录象通道,为1表示触发该通道
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_IPC_SINGLE_WIRELESS_ALARMCFG = ^NET_IPC_SINGLE_WIRELESS_ALARMCFG;

type
  NET_IPC_WIRELESS_ALARMCFG = record 
    struWirelessAlarm: array[0..MAX_WIRELESS_ALARM_NUM-1] of NET_IPC_SINGLE_WIRELESS_ALARMCFG;  //单个无线报警参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_IPC_WIRELESS_ALARMCFG = ^NET_IPC_WIRELESS_ALARMCFG;

type
  NET_IPC_AUX_ALARMCFG_UNION = record 
    case Byte of
    0: (uLen: array[0..472-1] of DWORD);  
    1: (struPIRAlarm: NET_IPC_PIR_ALARMCFG_EX);  //PIR报警参数
    2: (struWirelessAlarm: NET_IPC_WIRELESS_ALARMCFG);  //无线报警参数
    3: (struCallHelpAlarm: NET_IPC_CALLHELP_ALARMCFG);  //呼救报警参数
  end;
  LPNET_IPC_AUX_ALARMCFG_UNION = ^NET_IPC_AUX_ALARMCFG_UNION;

type
  NET_IPC_SINGLE_AUX_ALARMCFG = record 
    byAlarmType: BYTE;  //报警器类型，详见IPC_AUX_ALARM_TYPE
    byRes1: array[0..3-1] of BYTE;  
    uAlarm: NET_IPC_AUX_ALARMCFG_UNION;  //报警参数
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_IPC_SINGLE_AUX_ALARMCFG = ^NET_IPC_SINGLE_AUX_ALARMCFG;

type
  NET_IPC_AUX_ALARMCFG = record 
    dwSize: DWORD;  
    struAlarm: array[0..MAX_AUX_ALARM_NUM-1] of NET_IPC_SINGLE_AUX_ALARMCFG;  //报警参数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_IPC_AUX_ALARMCFG = ^NET_IPC_AUX_ALARMCFG;

type
  NET_IPC_AUXALARM_UPLOAD_UNION = record 
    case Byte of
    0: (uLen: array[0..66-1] of DWORD);  
    1: (struPIRAlarm: NET_IPC_PIR_ALARMCFG);  //PIR报警参数
    2: (struWirelessAlarm: NET_IPC_SINGLE_WIRELESS_ALARMCFG);  //无线报警参数
    3: (struCallHelpAlarm: NET_IPC_CALLHELP_ALARMCFG);  //呼救报警参数
  end;
  LPNET_IPC_AUXALARM_UPLOAD_UNION = ^NET_IPC_AUXALARM_UPLOAD_UNION;

type
  NET_IPC_AUXALARM_RESULT = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byAlarmType: BYTE;  //报警器类型，详见IPC_AUX_ALARM_TYPE
    byRes1: array[0..3-1] of BYTE;  
    struAuxAlarm: NET_IPC_AUXALARM_UPLOAD_UNION;  //报警结果参数
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_IPC_AUXALARM_RESULT = ^NET_IPC_AUXALARM_RESULT;

type
  NET_DVR_PREVIEW_DISPLAYCFG = record 
    dwSize: DWORD;  // 结构体大小
    byCorrectMode: BYTE;  //校正模式，0-软件校正，1-芯片校正
    byMountType: BYTE;  //安装类型，0-吸顶，1-桌面，2-墙面
    {
    0-模式1：鱼眼+全景+3PTZ (与原有非实时模式一致)；
    1-模式2：鱼眼+4PTZ(与原有实时模式一致)；
    2-模式3：鱼眼(主)+鱼眼(子)+3PTZ；
    3-模式4：全景展开(主码流+子码流)；
    4-模式5：4PTZ；
    5-模式6：鱼眼；
    6-模式7: 经纬度全景展开模式；
    7-模式8: 4PTZ融合模式；
    }
    byRealTimeOutput: BYTE;  //实时输出，0 -不启用，1- 启用
    byRes: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEW_DISPLAYCFG = ^NET_DVR_PREVIEW_DISPLAYCFG;

type
  NET_DVR_REMOTECONTROL_PTZ_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwPTZCommand: DWORD;  //PTZ控制命令
    struVcaPoint: NET_VCA_POINT;  //预览界面点坐标
    dwSpeed: DWORD;  //控制的速度，取值范围[0,7]
    dwStop: DWORD;  //停止动作或开始动作：0-开始；1-停止
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROL_PTZ_PARAM = ^NET_DVR_REMOTECONTROL_PTZ_PARAM;

type
  NET_DVR_PRESET_POINT_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwPTZPresetCmd: DWORD;  //预置点控制命令
    struVcaPoint: NET_VCA_POINT;  //预览界面点坐标
    dwPresetIndex: DWORD;  //预置点的序号（从1开始），最多支持255个预置点
    wZoomCoordinate: WORD;  ///<预置点窗口Zoom值
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_PRESET_POINT_PARAM = ^NET_DVR_PRESET_POINT_PARAM;

type
  NET_DVR_PTZ_CRUISE_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwPTZCruiseCmd: DWORD;  //巡航控制命令
    struVcaPoint: NET_VCA_POINT;  //预览界面点坐标
    wCruiseRoute: WORD;  //巡航路径，最多支持32条路径（序号从1开始）
    wCruisePoint: WORD;  //巡航点，最多支持32个点（序号从1开始）
    wInput: WORD;  //不同巡航命令时的值不同，预置点(最大255)、时间(最大255)、速度(最大40)
    wZoomCoordinate: WORD;  ///<预置点窗口Zoom值
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_CRUISE_PARAM = ^NET_DVR_PTZ_CRUISE_PARAM;

type
  NET_DVR_WPS_PARAM = record 
    dwSize: DWORD;  
    byEnableWps: BYTE;  //启用WPS，0-否，1-是
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_WPS_PARAM = ^NET_DVR_WPS_PARAM;

type
  NET_DVR_PIN_PARAM = record 
    dwSize: DWORD;  
    byPIN: array[0..8-1] of BYTE;  //PIN码
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PIN_PARAM = ^NET_DVR_PIN_PARAM;

type
  NET_DVR_WPS_CONNECT_PARAM = record 
    dwSize: DWORD;  
    byConnectType: BYTE;  //WPS连接方式，0-PBC,1-AP PIN
    byRes1: array[0..3-1] of BYTE;  
    byPIN: array[0..8-1] of BYTE;  //PIN码(WPS连接方式为AP PIN时有效)
    byEssid: array[0..IW_ESSID_MAX_SIZE-1] of BYTE;  //essid(WPS连接方式为AP PIN时有效)
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WPS_CONNECT_PARAM = ^NET_DVR_WPS_CONNECT_PARAM;

type
  NET_DVR_DECODER_JOINT_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    byJointed: BYTE;  //  0 没有关联 1 已经关联
    byRes1: array[0..3-1] of BYTE;  // 保留字节
    struIP: NET_DVR_IPADDR;  // 被关联解码器的IP地址
    wPort: WORD;  // 被关联解码器的端口号
    wChannel: WORD;  // 被关联解码器的解码通道号
    sDeviceName: array[0..NAME_LEN-1] of BYTE;  //被关联解码器的设备名称
    sChanName: array[0..NAME_LEN-1] of BYTE;  //被关联解码器的解码通道名称
    byRes2: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DECODER_JOINT_PARAM = ^NET_DVR_DECODER_JOINT_PARAM;

type
  NET_DVR_PIC_VIEW_PARAM = record 
    dwSize: DWORD;  
    struCuIp: NET_DVR_IPADDR;  //CU端IP地址
    wPort: WORD;  //CU端口
    bySourceIndex: BYTE;  //信号源通道号
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_PIC_VIEW_PARAM = ^NET_DVR_PIC_VIEW_PARAM;

const
  DVCS_DEVICEID_LEN = 16;    
//2012-03-13图片回显注册消息回调
type
  NET_DVR_PICVIEW_CALLBACKPARAM = record 
    dwUserID: DWORD;  
    sDeviceID: array[0..DVCS_DEVICEID_LEN-1] of BYTE;  
    nPicViewHandle: LONG;  //回显句柄
    wSignalIndex: WORD;  //信号源索引
    wHeadLen: WORD;  //文件头长度 私有的码流文件头都是40
    byHeadBuf: array[0..100-1] of BYTE;  //文件头
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PICVIEW_CALLBACKPARAM = ^NET_DVR_PICVIEW_CALLBACKPARAM;

const
  DEVICEID_LEN = 32;    

type
  NET_DVR_DEVICEID_INFO = record 
    dwSize: DWORD;  
    dwDeviceIndex: DWORD;  //设备序号
    byWallNo: BYTE;  //墙号，从1开始
    byRes1: array[0..27-1] of BYTE;  
    dwChan: DWORD;  //通道号
    dwInputSignalIndex: DWORD;  //信号源索引，集中式大屏控制器使用
    byRes2: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_DEVICEID_INFO = ^NET_DVR_DEVICEID_INFO;


type
  NET_DVR_SINGLE_NETPARAM = record 
    dwSize: DWORD;  
    byUseDhcp: BYTE;  //是否启用DHCP 0xff-无效 0-不启用 1-启用
    byRes1: array[0..3-1] of BYTE;  
    struDevIP: NET_DVR_IPADDR;  // 设备IP地址
    struSubnetMask: NET_DVR_IPADDR;  // 设备子网掩码
    struGateway: NET_DVR_IPADDR;  // 设备网关
    wDevPort: WORD;  // 设备端口号
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  // MAC 地址(只能获取)
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_NETPARAM = ^NET_DVR_SINGLE_NETPARAM;

type
  NET_DVR_CHAN_INFO = record 
    dwSize: DWORD;  
    byValid: BYTE;  //0-无效 1-有效
    byRes1: array[0..3-1] of BYTE;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  //通道名称
    struVideoColor: NET_DVR_COLOR;  //信号源颜色
    wResolutionX: WORD;  //当前分辨率---宽
    wResolutionY: WORD;  //当前分辨率---高
    byRes2: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_CHAN_INFO = ^NET_DVR_CHAN_INFO;

//编码子设备信息
type
  NET_DVR_CODEDEV_INFO = record 
    struChanInfo: array[0..MAX_CHANNUM{16}-1] of NET_DVR_CHAN_INFO;  //设备通道信息
  end;
  LPNET_DVR_CODEDEV_INFO = ^NET_DVR_CODEDEV_INFO;

//解码子设备信息
type
  NET_DVR_DECODEDEV_INFO = record 
    byRes: array[0..1408-1] of BYTE;  
  end;
  LPNET_DVR_DECODEDEV_INFO = ^NET_DVR_DECODEDEV_INFO;

//网络信号源信息
type
  NET_DVR_NETSIGNAL_INFO = record 
    dwSize: DWORD;  
    byDevName: array[0..NAME_LEN{32}-1] of BYTE;  //网络信号源名称
    struPuStream: NET_DVR_PU_STREAM_CFG;  
    byValid: BYTE;  //是否有效，0-无效，删除时设为0  1-有效，添加和修改时设为1/
    byRes1: array[0..3-1] of BYTE;  //保留
    sGroupName: array[0..NAME_LEN{32}-1] of BYTE;  //网络信号源所在组的组名，网络信号源根据这个组名来分类
    wResolutionX: WORD;  //当前分辨率---宽
    wResolutionY: WORD;  //当前分辨率---高
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_NETSIGNAL_INFO = ^NET_DVR_NETSIGNAL_INFO;

type
  NET_DVR_NETSIGNALDEV_INFO = record 
    struDevInfo: NET_DVR_NETSIGNAL_INFO;  
    byRes1: array[0..816-1] of BYTE;  
  end;
  LPNET_DVR_NETSIGNALDEV_INFO = ^NET_DVR_NETSIGNALDEV_INFO;

type
  NET_DVR_DIFFDEV_INFO = record 
    case Byte of
    0: (struCodeDevInfo: NET_DVR_CODEDEV_INFO);  //编码设备信息
    1: (struDecodeDevInfo: NET_DVR_DECODEDEV_INFO);  //解码设备信息
    2: (struNetSignalInfo: NET_DVR_NETSIGNALDEV_INFO);  //网络信号源信息
  end;
  LPNET_DVR_DIFFDEV_INFO = ^NET_DVR_DIFFDEV_INFO;

//注册设备信息
type
  NET_DVCS_DEVICE_TYPE =  
  (  
    NET_DVR_BNC_PROC = 1,  // BNC处理器 
    NET_DVR_RGB_PROC,  // RGB处理器 
    NET_DVR_STP_PROC,  // 转码处理器 
    NET_DVR_DISP_PROC,  // 显示处理器 
    NET_DVR_NETSIGNAL,  //网络信号源
    NET_DVR_SDI_PROC,  //SDI处理器
    NET_DVR_BIW_PROC,  //8路BNC处理器
    NET_DVR_DON_PROC,  //显示处理器
    NET_DVR_TVI_PROC,  //TVI处理器
    NET_DVR_DI2_PROC,  //2路DVI输入处理器
    NET_DVR_DO2_PROC,  //2路DVI输出设备
    NET_DVR_UHDI_PROC,  //DP/HDMI 1路4K超高清输入设备
    NET_DVR_YI2_PROC,  //两路YPbPr输入板
    NET_DVR_HI2_PROC,  // HDMI输入节点(2路)
    NET_DVR_VI2_PROC,  // VGA输入节点(2路)
    NET_DVR_SI2_PROC,  // SDI输入节点(2路)
    NET_DVR_HO2_PROC,  // HDMI输出节点(2路)
    NET_DVR_S24G_PROC,  // C20N专用千兆交换机(24路)
    NET_DVR_S24X_PROC  // C20N专用万兆交换机(24路)
  );

type
  NET_DVR_SINGLE_DEV_INFO = record 
    dwSize: DWORD;  
    dwSoftVersion: DWORD;  //设备软件版本号(只能获取) 最高8位为主版本号，次高8位为次版本号，低16位为修复版本号
    dwSoftwareBuildDate: DWORD;  //版本编译日期Build, 0xYYYYMMDD
    byUseInSys: BYTE;  //是否在系统中使用
    byDevStatus: BYTE;  //设备当前状态，0-下线，1-上线(只能获取)
    byDeviceType: BYTE;  //设备类型(只能获取)  见DEVICE_TYPE
    byRes1: array[0..17-1] of BYTE;  
    sDevName: array[0..NAME_LEN-1] of BYTE;  //设备名称
    struEtherNet: array[0..MAX_ETHERNET-1] of NET_DVR_SINGLE_NETPARAM;  //设备网络参数
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //设备序列号
    struSubDevInfo: NET_DVR_DIFFDEV_INFO;  //设备信息
    dwDeviceIndex: DWORD;  //设备序号，相对于C20N或Y10等设备的全局编号
    dwSubBoardNo: DWORD;  //分布式设备所属的子板编号，相对于C20N或Y10等设备的全局编号，从1开始，为0时该字段无效，子板编号默认为1
    bySubSysNo: BYTE;  //分布式设备所属的子板上的子系统编号，相对于子板全局，从1开始，为0时该字段无效，子系统号默认为1
    byRes3: array[0..3-1] of BYTE;  
    wStartAudioTalkChanNo: WORD;  //分布式设备上语音对讲的起始通道号
    wAudioTalkChanNum: WORD;  //分布式设备上语音对讲通道号的数量
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_DEV_INFO = ^NET_DVR_SINGLE_DEV_INFO;

type
  NET_DVR_DEVLIST = record 
    dwSize: DWORD;  
    dwDevNums: DWORD;  //设备返回的分布式子设备数量
    pBuffer: PBYTE;  
    byRes1: array[0..3-1] of BYTE;  
    dwBufLen: DWORD;  //所分配指针长度，输入参数
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DEVLIST = ^NET_DVR_DEVLIST;

type
  NET_DVR_DEV_BASE_INFO = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否在系统中使用
    byDeviceType: BYTE;  //设备类型(只能获取)
    byRes1: array[0..2-1] of BYTE;  
    sDevName: array[0..NAME_LEN-1] of BYTE;  //设备名称
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_DEV_BASE_INFO = ^NET_DVR_DEV_BASE_INFO;

//网络配置信息
type
  NET_DVR_NETPARAM = record 
    dwSize: DWORD;  
    struEtherNet: array[0..MAX_ETHERNET-1] of NET_DVR_SINGLE_NETPARAM;  //以太网口
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_NETPARAM = ^NET_DVR_NETPARAM;

// 绑定屏幕和设备关系(16个字节)
type
  NET_DVR_DISP_SCREEN = record 
    dwSize: DWORD;  
    wScreenID: WORD;  // 屏幕ID号, ID号从1开始
    byWallNo: BYTE;  // 电视墙号
    byRes1: BYTE;  // 保留1
    dwDeviceIndex: DWORD;  // 输出设备序号
    byRes2: array[0..16-1] of BYTE;  // 保留2
  end;
  LPNET_DVR_DISP_SCREEN = ^NET_DVR_DISP_SCREEN;

// 屏幕控制
type
  NET_DVR_TEXTSHOW = record 
    dwSize: DWORD;  
    byShowText: BYTE;  //是否显示文字，1-显示文字，0-不显示文字
    byRes: array[0..35-1] of BYTE;  
  end;
  LPNET_DVR_TEXTSHOW = ^NET_DVR_TEXTSHOW;

type
  NET_DVR_SCREENLIST = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙号，从1开始
    byRes: array[0..11-1] of BYTE;  
    dwScreenNums: DWORD;  //设备返回的映射显示屏数量
    pBuffer: PBYTE;  
    dwBufLen: DWORD;  //所分配指针长度，输入参数
  end;
  LPNET_DVR_SCREENLIST = ^NET_DVR_SCREENLIST;

type
  NET_DVR_OPERATE_DEVICE = record 
    dwSize: DWORD;  
    dwSubCommand: DWORD;  //设置设备的命令，1-设备开始升级，2-停止升级
    dwDeviceIndex: DWORD;  //设备序号
    byRes: array[0..44-1] of BYTE;  
  end;
  LPNET_DVR_OPERATE_DEVICE = ^NET_DVR_OPERATE_DEVICE;

//设备升级
type
  NET_DVR_UPGRADE_STATE = record 
    dwProgress: DWORD;  // 0-100
    byState: BYTE;  //升级进度：1-升级完成 2-正在升级 3-升级失败
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_UPGRADE_STATE = ^NET_DVR_UPGRADE_STATE;
type
  DVCS_UPGRADESTATE_CB = procedure(nUpgradeHandle: LONG; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;

type
  PIC_PREVIEW_DATATYPE =  
  (  
    NET_DVR_DATA_BMP = 0,  
    NET_DVR_START_CALLBACK,  
    NET_DVR_STREAM_SYSHEAD,  
    NET_DVR_STREAM_DATA  
  );

type
  NET_DVR_START_PIC_VIEW_INFO = record 
    dwSize: DWORD;  
    dwSignalIndex: DWORD;  //信号源序号，该参数用于大屏控制器，其他设备该值设为0
    dwDeviceIndex: DWORD;  //设备序号
    byRes1: array[0..12-1] of BYTE;  
    byChanIndex: BYTE;  //通道号
    byRes2: array[0..3-1] of BYTE;  
    //视频综合平台回显参数
    dwScreenNum: DWORD;  //大屏序号：从零开始
    dwLayer: DWORD;  //图层号：从零开始
    dwResolution: DWORD;  //回显分辨率,1-QCIF,2-CIF,3-D1
    byFrame: BYTE;  //帧率，单位：帧/秒
    bySupportStreamView: BYTE;  //客户端是否支持码流回显，0-不支持，1-支持
    byRes3: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_START_PIC_VIEW_INFO = ^NET_DVR_START_PIC_VIEW_INFO;

type
  NET_DVR_DVCS_STATE_ALARM = record 
    dwSize: DWORD;  
    byAlarmType: BYTE;  // 报警类型,1-设备上线，2-设备离线 3-服务器上线 4-服务器离线 5-管理员登陆 6-预案开始,7-预案结束，8-分辨率变化，9-图像切割失败，10-设备资源不足，11-温度异常  12-窗口大小与信号源分辨率不符合}
    byDeviceType: BYTE;  // 设备类型 见定义NET_DVCS_DEVICE_TYPE }
    byWallNo: BYTE;  // 墙号，从1开始， 0表示无效
    byDeviceChanIndex: BYTE;  // 设备通道号，0表示无效，其他值表示通道号
    dwDeviceIndex: DWORD;  // 设备序号， 0表示无效
    wResolutionX: WORD;  // 分辨率-宽  0表示无效
    wResolutionY: WORD;  // 分辨率-高  0表示无效
    wTemperature: WORD;  // 设备温度 单位：摄氏度, 0表示无效
    byRes: array[0..86-1] of BYTE;  
  end;
  LPNET_DVR_DVCS_STATE_ALARM = ^NET_DVR_DVCS_STATE_ALARM;

type
  NET_DVR_PIC_ADJUST = record 
    dwSize: DWORD;  
    bySubCommand: BYTE;  //见宏定义DECODEPIC_LEFTADJUST等
    byScale: BYTE;  //调整的量值
    byPictureProportion: BYTE;  //图像缩放比例 0-无效 1-4:3, 2-16:9
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_PIC_ADJUST = ^NET_DVR_PIC_ADJUST;

type
  NET_DVR_PICTURE_PARAM = record 
    dwSize: DWORD;  
    byControlCommand: BYTE;  //切换命令，1-显示，2-隐藏，3-全部删除（针对GIF图片    ）
    byUseType: BYTE;  //图片类型，1-OSD 2-底图，3-GIF
    byWallNo: BYTE;  //电视墙墙号，从1开始
    byPictureNo: BYTE;  //图片序号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PICTURE_PARAM = ^NET_DVR_PICTURE_PARAM;

// 76SP设备POE通道添加方式配置
type
  NET_DVR_POE_CHANNEL_ADD_MODE = record 
    dwSize: DWORD;  //结构体大小
    byAddMode: BYTE;  //添加方式 0: 即插即用 1: 手动添加
    byRes1: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_POE_CHANNEL_ADD_MODE = ^NET_DVR_POE_CHANNEL_ADD_MODE;

const
  MAX_ESATA_NUM = 16;    
  MAX_MINISAS_NUM = 96;    

type
  NET_DVR_ESATA_MINISAS_USAGE = record 
    dwSize: DWORD;  
    byESATAUsage: array[0..MAX_ESATA_NUM-1] of BYTE;  // 数组索引表示第几个eSATA，0：默认备份 1：默认录像
    byMiniSASUsage: array[0..MAX_MINISAS_NUM-1] of BYTE;  // 数组索引表示第几个miniSAS，0：默认备份 1：默认录像
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ESATA_MINISAS_USAGE = ^NET_DVR_ESATA_MINISAS_USAGE;

const
  MAX_DISK_NUM = 128;    

type
  NET_DVR_BACKUP_LOG_PARAM = record 
    dwSize: DWORD;  
    byDiskDesc: array[0..DESC_LEN_32-1] of BYTE;  //备份磁盘描述
    byHardDisk: array[0..MAX_DISK_NUM-1] of BYTE;  //需备份的硬盘号，备份几个取前几个
    byBackupHardDiskNum: BYTE;  //需备份的硬盘个数
    byContinue: BYTE;  //是否继续备份，0-不继续，1-继续
    byAllLogBackUp: BYTE;  //是否全部备份，0-按磁盘号备份，1-备份所有日志，当为1时，需备份的磁盘号和硬盘个数无效
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_BACKUP_LOG_PARAM = ^NET_DVR_BACKUP_LOG_PARAM;

type
  NET_DVR_DIGITAL_CHANNEL_STATE = record 
    dwSize: DWORD;  
    byDigitalAudioChanTalkState: array[0..MAX_CHANNUM_V30-1] of BYTE;  //表示数字语音通道的对讲状态 0-未使用，1-使用中, 0xff无效
    byDigitalChanState: array[0..MAX_CHANNUM_V30-1] of BYTE;  {数字通道的连接状态 byDigitalChanErrState[0]
                                               表示第一个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效}
    byDigitalAudioChanTalkStateEx: array[0..MAX_CHANNUM_V30*3-1] of BYTE;  //表示数字语音通道的对讲状态，从第MAX_CHANNUM_V30+1 到第MAX_CHANNUM_V30*4个， 0-未使用，1-使用中, 0xff无效
    byDigitalChanStateEx: array[0..MAX_CHANNUM_V30*3-1] of BYTE;  //数字通道的连接状态 byDigitalChanErrStateEx[0]表示第从第MAX_CHANNUM_V30+1个个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效
    byAnalogChanState: array[0..MAX_ANALOG_CHANNUM-1] of BYTE;  //表示模拟通道是否启用,0-禁用,1-启用
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DIGITAL_CHANNEL_STATE = ^NET_DVR_DIGITAL_CHANNEL_STATE;

//数字通道状态
type
  NET_SDK_DIGITAL_CHANNEL_STATUS =  
  (  
    NET_SDK_DC_STATUS_CONNECTED = 1,  //已连接
    NET_SDK_DC_STATUS_CONNECTING,  //正在连接
    NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,  //超过系统带宽
    NET_SDK_DC_STATUS_DOMAIN_ERROR,  //域名错误
    NET_SDK_DC_STATUS_CHANNEL_ERROR,  //通道号错误
    NET_SDK_DC_STATUS_ACCOUNT_ERROR,  //用户名或密码错误
    NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,  //流类型不支持
    NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,  //和设备IP地址冲突
    NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,  //和IPC IP地址冲突
    NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,  //网络不可达
    NET_SDK_DC_STATUS_IPC_NOT_EXIST,  //IP通道未接入
    NET_SDK_DC_STATUS_IPC_EXCEPTION,  //IP通道异常
    NET_SDK_DC_STATUS_OTHER_ERROR,  //其他错误
    NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,  //IPC分辨率不支持
    NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,  //IPC语言与NVR语言不匹配
    NET_SDK_DC_STATUS_USER_LOCKED = 16,  //用户被锁定
    NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,  //设备未激活
    NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,  //用户不存在
    NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,  //IP通道对应设备未注册(GB28181协议接入)
    NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20,  //POE通道检测中
    NET_SDK_DC_STATUS_RESOURCE_EXCEED = 21,  // IPC分辨率，码率超过限制
    NET_SDK_DC_STATUS_NEED_TO_REPAIR = 22,  // 子码流断连，需要重连
    NET_SDK_DC_STATUS_ACTIVATING = 23,  // IPC正在激活 
    NET_SDK_DC_STATUS_TOKEN_AUTHENTCATE_FAILED = 24  // token认证失败 
  );

//************************************ITS***************************
const
  VERSION_LEN = 32;    //版本长度
  MAX_OVERLAP_ITEM_NUM = 50;    //最大字符叠加种数
  ITS_MAX_DEVICE_NUM = 32;    //最大设备个数

//终端基本信息
type
  NET_ITS_BASEINFO = record 
    dwSize: DWORD;  
    byMainVer: array[0..VERSION_LEN-1] of BYTE;  // 算法主流程版本
    byMprVer: array[0..VERSION_LEN-1] of BYTE;  // 多帧识别库版本
    byBvtVer: array[0..VERSION_LEN-1] of BYTE;  // 背向视频库版本
    byLptVer: array[0..VERSION_LEN-1] of BYTE;  // 视频库版本
    byTvdVer: array[0..VERSION_LEN-1] of BYTE;  // 违章检测库版本
    byTldVer: array[0..VERSION_LEN-1] of BYTE;  // 信号灯检测库版本
    byRes: array[0..252-1] of BYTE;  // 预留字段
  end;
  LPNET_ITS_BASEINFO = ^NET_ITS_BASEINFO;

//图片合成参数
type
  NET_ITS_IMGMERGE_CFG = record 
    dwSize: DWORD;  
    byIsMerge: BYTE;  //是否需要合成（0：不合成；1：合成）
    byCloseupProportion: BYTE;  //特写图比例 1-原始分辨率大小，2-宽高为原始分辨率两倍，以此类推(1～8)
    byRes1: array[0..2-1] of BYTE;  
    dwOneMergeType: DWORD;  //抓拍单张图合成方式（可能会截取特写图）
    //**********************************************************************
    // 201 两张图片上下排列合成,合成后图片宽为单张图的1倍,高为2倍         
    // 202 两张图片左右排列合成,合成后图片宽为单张图的2倍,高为1倍         
    // 203 上下合成，特写在最上边.                                          
    // 204 上下合成，特写在最下边.                                        
    // 205 左右合成，特写在最右边。                                       
    // 206 左右合成，特写在最左边                                         
    // 207 品字合成，特写图在上边                                         
    // 208 倒品字合成，特写图在下边                                       
    // 209 唱字形，左边1张为特写                                          
    // 210 反唱字形，右边1张为特写                                        
    // 301 三张图片上下排列合成,合成后图片宽为单张图的1倍,高为3倍         
    // 302 三张图片左右排列合成,合成后图片宽为单张图的3倍,高为1倍          
    { 303 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的2倍,高为2倍                      }
    { 304 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的1倍,高为1倍                      }
    { 305 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;合成后图片宽为单张图的2倍,高为2倍                      }
    { 306 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      }
    // 307 三张图片"品"字型排列合成                                          
    // 308 三张图片倒"品"字型排列合成                                      
    { 309 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的2倍,高为2倍                          }
    { 310 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的1倍,高为1倍                          }
    { 311 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;合成后图片宽为单张图的2倍,高为2倍                          }
    { 312 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      }

    { 313 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         }
    { 314 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         }
    { 315 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         }
    { 316 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         }
    { 317 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         }
    { 318 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         }
    { 319 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         }
    { 320 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         }
    //**********************************************************************
    dwTwoMergeType: DWORD;  //抓拍两张图合成方式
    dwThreeMergeType: DWORD;  //抓拍三张图合成方式
    dwJpegQuality: DWORD;  //压缩质量（0~100）
    dwCloseupIndex: DWORD;  //特写图抓拍第几张
    dwMerageMaxSize: DWORD;  //合成图片大小的上限,300-10240(单位KB)
    wCloseupDeviation: WORD;  // 特写图偏移量(50~图片高度)，单位:像素
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_ITS_IMGMERGE_CFG = ^NET_ITS_IMGMERGE_CFG;

//交通数据主机
type
  NET_ITS_TRAFFIC_DATA_HOST = record 
    struHostAddr: NET_DVR_IPADDR;  // 远程主机IP
    wHostPort: WORD;  // 远程主机Port
    byRes1: array[0..2-1] of BYTE;  
    dwDataType: DWORD;  // 上传远程主机的数据类型（定义见下），按位表示
    bySuspendUpload: BYTE;  // 是否暂停数据上传：0-正常上传；1-暂停上传
    byUploadStrategy: BYTE;  // 上传策略：0-最新数据优先上传；1-按照通行时间上传
    wUploadInterval: WORD;  // 上传间隔时间（ms，1~2000），该参数只对历史数据有效
    dwUploadTimeOut: DWORD;  //上传超时时间
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_ITS_TRAFFIC_DATA_HOST = ^NET_ITS_TRAFFIC_DATA_HOST;

//数据上传参数
type
  NET_ITS_UPLOAD_CFG = record 
    dwSize: DWORD;  
    struRemoteDataHost1: NET_ITS_TRAFFIC_DATA_HOST;  //接收交通数据主机1
    struRemoteDataHost2: NET_ITS_TRAFFIC_DATA_HOST;  //接收交通数据主机2
  end;
  LPNET_ITS_UPLOAD_CFG = ^NET_ITS_UPLOAD_CFG;

type
  NET_DVR_SYSTEM_TIME = record 
    wYear: WORD;  //年
    wMonth: WORD;  //月
    wDay: WORD;  //日
    wHour: WORD;  //时
    wMinute: WORD;  //分
    wSecond: WORD;  //秒
    wMilliSec: WORD;  //毫秒
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_SYSTEM_TIME = ^NET_DVR_SYSTEM_TIME;

//交通数据主机状态信息
type
  NET_ITS_TRAFFIC_DATA_INFO = record 
    dwDataQuantity: DWORD;  //数据总量
    dwDataRsendQuantity: DWORD;  //未发送数量（需要上传交通数据主机的）
    struStartTime: NET_DVR_SYSTEM_TIME;  //未发送数据的最早时间
    struEndTime: NET_DVR_SYSTEM_TIME;  //未发送数据的最晚时间
    struDataHost: NET_DVR_IPADDR;  //接收交通数据主机
  end;
  LPNET_ITS_TRAFFIC_DATA_INFO = ^NET_ITS_TRAFFIC_DATA_INFO;

//终端工作状态
type
  NET_ITS_WORKSTATE = record 
    dwSize: DWORD;  
    byDevName: array[0..NAME_LEN-1] of BYTE;  // 设备名称
    dwRunTime: DWORD;  // 系统运行时间，单位s
    struTrafficDataInfo: array[0..2-1] of NET_ITS_TRAFFIC_DATA_INFO;  //支持两台主机（数据上传配置的主机）
    dwMemoryUsage: DWORD;  // 内存占用率（如果内存占用率为30%，此处填30）
    dwCpuUsage: DWORD;  // cpu占用率（如果cpu占用率为30%，此处填30）
    dwDevTemperature: DWORD;  // 本机温度
    dwDeviceStatic: DWORD;  // 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    struHardDiskStatic: array[0..MAX_DISKNUM_V30-1] of NET_DVR_DISKSTATE;  //硬盘状态
    struChanStatic: array[0..MAX_CHANNUM_V30-1] of NET_DVR_CHANNELSTATE_V30;  //通道的状态
    byAlarmInStatic: array[0..MAX_ALARMIN_V30-1] of BYTE;  //报警输入口的状态,0-没有报警,1-有报警
    byAlarmOutStatic: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //报警输出端口的状态,0-没有输出,1-有报警输出
    dwLocalDisplay: DWORD;  //本地显示状态,0-正常,1-不正常
    byAudioInChanStatus: array[0..8-1] of BYTE;  //表示语音通道的状态 0-未使用，1-使用中，数组0表示第1个语音通道
    byRes: array[0..36-1] of BYTE;  //保留
  end;
  LPNET_ITS_WORKSTATE = ^NET_ITS_WORKSTATE;

//出入口交通配置获取参数
type
  NET_ITS_ECT_WORKSTATE_COMMAND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_ITS_ECT_WORKSTATE_COMMAND = ^NET_ITS_ECT_WORKSTATE_COMMAND;

type
  NET_ITS_ECTWORKSTATE = record 
    dwSize: DWORD;  
    byDevName: array[0..NAME_LEN-1] of BYTE;  // 设备名称
    dwRunTime: DWORD;  // 系统运行时间，单位s
    struTrafficDataInfo: array[0..2-1] of NET_ITS_TRAFFIC_DATA_INFO;  //支持两台主机（数据上传配置的主机）
    dwMemoryUsage: DWORD;  // 内存占用率（如果内存占用率为30%，此处填30）
    dwCpuUsage: DWORD;  // cpu占用率（如果cpu占用率为30%，此处填30）
    dwDevTemperature: DWORD;  // 本机温度
    dwDeviceStatic: DWORD;  // 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    struHardDiskStatic: array[0..MAX_DISKNUM_V30-1] of NET_DVR_DISKSTATE;  //硬盘状态
    byAlarmInStatic: array[0..MAX_ALARMIN_V30-1] of BYTE;  //报警输入口的状态,0-没有报警,1-有报警
    byAlarmOutStatic: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //报警输出端口的状态,0-没有输出,1-有报警输出
    dwLocalDisplay: DWORD;  //本地显示状态,0-正常,1-不正常
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_ITS_ECTWORKSTATE = ^NET_ITS_ECTWORKSTATE;

// 图片信息（后续会加入码流）
type
  NET_ITS_PICTURE_INFO = record 
    dwDataLen: DWORD;  //媒体数据长度
    // 0:车牌图;1:车辆图;2:合成图; 3:特写图;4:二直图;5:码流;6:人脸子图(主驾驶);7:人脸子图(副驾驶)成图;8-非机动车;9-行人;10-称重原始裸数据;11-目标图;12-主驾驶室图 ;13-副驾驶室图;14-人脸图抠小图
    //15 - 自定义图片(用户自己上传进行违法检测的图片)
    byType: BYTE;  
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    byDataType: BYTE;  
    byCloseUpType: BYTE;  //特写图类型，0-保留,1-非机动车,2-行人
    byPicRecogMode: BYTE;  //图片背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
    dwRedLightTime: DWORD;  //经过的红灯时间  （s）
    byAbsTime: array[0..32-1] of BYTE;  //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    struPlateRect: NET_VCA_RECT;  //车牌位置,当byType为8-非机动车;9-行人时，表示人体坐标
    struPlateRecgRect: NET_VCA_RECT;  //牌识区域坐标，当图片类型为12-主驾驶室图13-副驾驶室图是，该坐标为驾驶员坐标
    pBuffer: PBYTE;  //数据指针
    dwUTCTime: DWORD;  //UTC时间定义
    byCompatibleAblity: BYTE;  //兼容能力字段 0表示无效，1表示有效; bit0-表示dwUTCTime字段有效
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byRes2: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_ITS_PICTURE_INFO = ^NET_ITS_PICTURE_INFO;


type
  NET_ITS_ILLEGAL_INFO = record 
    byIllegalInfo: array[0..MAX_ILLEGAL_LEN{64}-1] of BYTE;  // 违章类型信息（字符格式）
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_ITS_ILLEGAL_INFO = ^NET_ITS_ILLEGAL_INFO;


// 检测结果
type
  NET_ITS_PLATE_RESULT = record 
    dwSize: DWORD;  //结构长度
    dwMatchNo: DWORD;  //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    byGroupNum: BYTE;  //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    byPicNo: BYTE;  //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    bySecondCam: BYTE;  //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    byFeaturePicNo: BYTE;  //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    byDriveChan: BYTE;  //触发车道号
    byVehicleType: BYTE;  //车辆类型，参考VTR_RESULT
    byDetSceneID: BYTE;  //检测场景号[1,4], IPC默认是0
    //车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    //该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
    byVehicleAttribute: BYTE;  
    wIllegalType: WORD;  //违章类型采用国标定义
    byIllegalSubType: array[0..8-1] of BYTE;  //违章子类型
    byPostPicNo: BYTE;  //违章时取第几张图片作为卡口图,0xff-表示不取
    //通道号(有效，报警通道号和所在设备上传报警通道号一致，在后端和所接入的 通道号一致)
    byChanIndex: BYTE;  
    wSpeedLimit: WORD;  //限速上限（超速时有效）
    byChanIndexEx: BYTE;  //byChanIndexEx*256+byChanIndex表示真实通道号。
    {车辆方位布防标志,0~为普通车牌识别报警,
    1~为车辆位置布防触发报警(即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)。
    2~为车辆智能布防触发报警(包含多预置点及GPS车辆布防)(即通过PUT /ISAPI/Traffic/channels/<ID>/vehicleMonitor/<taskID>/startTask触发,
    但在unarmedVehicleDetectionEnable（非目标车辆检测使能）为true时，只上报车辆检测报警，无车辆智能布防报警，因此该字段取值为0，而不是2)。
    3~为手动车辆布防触发报警(/ISAPI/Traffic/channels/<ID>/manualVehicleMonitor?format=json)
    4~为日常布防(复用车辆检测配置)可通过车辆检测能力中区分是否支持日常车辆布防,
        (即通过/ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities中isSupportDailyVehicleMonitor判断,日常车辆布防时,设备不仅会上报ANPR报警还会实时上报vehicleMonitor车辆布防报警)
        若不返回该字段则代表为普通车辆检测
    }
    byVehiclePositionControl: BYTE;  
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byDeviceID: array[0..48-1] of BYTE;  //设备编号
    byDir: BYTE;  //显示方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    byDetectType: BYTE;  //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byCarDirectionType: BYTE;  //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    dwCustomIllegalType: DWORD;  //违章类型定义(用户自定义)
    {为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
      为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码}
    pIllegalInfoBuf: PBYTE;  //违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO
    byIllegalFromatType: BYTE;  //违章信息格式类型； 0~数字格式， 1~字符格式
    byPendant: BYTE;  // 0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
    byDataAnalysis: BYTE;  //0-数据未分析, 1-数据已分析
    byYellowLabelCar: BYTE;  //0-表示未知, 1-非黄标车,2-黄标车
    byDangerousVehicles: BYTE;  //0-表示未知, 1-非危险品车,2-危险品车
    //以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
    byPilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byCopilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byPilotSunVisor: BYTE;  //0-表示未知,1-不打开遮阳板,2-打开遮阳板
    byCopilotSunVisor: BYTE;  //0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    byPilotCall: BYTE;  // 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据名单匹配后，是否开闸成功的标志)；当byAlarmDataType为0-实时数据时 0-未开闸 1-开闸
    byBarrierGateCtrlType: BYTE;  
    byAlarmDataType: BYTE;  //0-实时数据，1-历史数据
    struSnapFirstPicTime: NET_DVR_TIME_V30;  //端点时间(ms)（抓拍第一张图片的时间）
    dwIllegalTime: DWORD;  //违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    dwPicNum: DWORD;  //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
    struPicInfo: array[0..6-1] of NET_ITS_PICTURE_INFO;  //图片信息,单张回调，最多6张图，由序号区分
  end;
  LPNET_ITS_PLATE_RESULT = ^NET_ITS_PLATE_RESULT;

//出入口车辆抓拍数据上传
type
  NET_ITS_GATE_VEHICLE = record 
    dwSize: DWORD;  //结构长度
    dwMatchNo: DWORD;  //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码 默认0
    byGroupNum: BYTE;  //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）默认 1 抓拍类型下图片数据 控制后续接收延时操作
    byPicNo: BYTE;  //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成。
    //接收超时不足图片组数量时，根据需要保留或删除）
    bySecondCam: BYTE;  //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）标示前后相机抓拍图片
    byRes: BYTE;  //标记为预留
    wLaneid: WORD;  //车道号1～32（索引车道号，可以跳跃）
    byCamLaneId: BYTE;  //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    byRes1: BYTE;  //保留
    byAlarmReason: array[0..MAX_ALARMREASON_LEN-1] of BYTE;  //自定义报警类型 默认为中文
    wBackList: WORD;  //标记为是否报警数据 0 表示为正常过车数据 1 表示禁止名单
    wSpeedLimit: WORD;  //限速上限（超速时有效）km/h
    dwChanIndex: DWORD;  //通道号
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息  含速度
    byMonitoringSiteID: array[0..MAX_ID_LEN-1] of BYTE;  //显示点编号
    byDeviceID: array[0..MAX_ID_LEN-1] of BYTE;  //设备编号
    byDir: BYTE;  //显示方向，0-其它 1 入场，2 出场
    byDetectType: BYTE;  //检测方式, 0-其他 1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    byRes2: array[0..2-1] of BYTE;  
    byCardNo: array[0..MAX_ID_LEN-1] of BYTE;  // 卡号
    dwPicNum: DWORD;  //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
    struPicInfo: array[0..4-1] of NET_ITS_PICTURE_INFO;  //图片信息,单张回调，最多4张图，由序号区分
    //2013-11-19 出入口车辆抓拍数据上传（监听方式）新增参数
    bySwipeTime: array[0..MAX_TIME_LEN-1] of BYTE;  //增加刷卡时间  时间格式为yyyymmddhh24missfff
    byRes3: array[0..224-1] of BYTE;  
  end;
  LPNET_ITS_GATE_VEHICLE = ^NET_ITS_GATE_VEHICLE;

//出入口人脸识别
type
  NET_ITS_GATE_FACE = record 
    dwSize: DWORD;  //结构体长度
    byGroupNum: BYTE;  //图片组数量（一个行人相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    byPicNo: BYTE;  //连拍的图片序号（接收到图片组数量后，表示接收完成。
    //接收超时不足图片组数量时，根据需要保留或删除）
    byFeaturePicNo: BYTE;  //连抓时取第几张图作为特写图,0xff-表示不取
    byRes: BYTE;  //保留
    wLaneid: WORD;  //车道号1～32（索引车道号，可以跳跃）
    byCamLaneId: BYTE;  //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    byDir: BYTE;  //显示方向，0-其他 1 入场， 2 出场
    dwChanIndex: DWORD;  //通道号
    byMonitoringSiteID: array[0..MAX_ID_LEN-1] of BYTE;  //显示点编号
    byDeviceID: array[0..MAX_ID_LEN-1] of BYTE;  //设备编号
    struFaceInfo: NET_VCA_FACESNAP_RESULT;  //人脸抓拍数据
    byRes2: array[0..256-1] of BYTE;  //预留
  end;
  LPNET_ITS_GATE_FACE = ^NET_ITS_GATE_FACE;

//停车场数据上传
type
  NET_ITS_PARK_VEHICLE = record 
    dwSize: DWORD;  //结构长度
    byGroupNum: BYTE;  //图片组数量（单次轮询抓拍的图片数量）
    byPicNo: BYTE;  //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成
    //接收超时不足图片组数量时，根据需要保留或删除）
    byLocationNum: BYTE;  //单张图片所管理的车位数
    byParkError: BYTE;  //停车异常，0-正常 1 异常
    byParkingNo: array[0..MAX_PARKNO_LEN-1] of BYTE;  //车位编号
    byLocationStatus: BYTE;  //车位车辆状态，0-无车，1有车
    bylogicalLaneNum: BYTE;  //逻辑车位号，0-3，一个相机最大能管4个车位 （0代表最左边，3代表最右边）
    wUpLoadType: WORD;  //第零位表示：0~轮巡上传、1~变化上传
    byRes1: array[0..4-1] of BYTE;  //保留字节
    dwChanIndex: DWORD;  //通道号数字通道
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    byMonitoringSiteID: array[0..MAX_ID_LEN-1] of BYTE;  //显示点编号
    byDeviceID: array[0..MAX_ID_LEN-1] of BYTE;  //设备编号
    dwPicNum: DWORD;  //图片数量（与picGroupNum不同，代表本条信息附带的图片数量
    //，图片信息由struVehicleInfoEx定义
    struPicInfo: array[0..2-1] of NET_ITS_PICTURE_INFO;  //图片信息,单张回调，最多2张图，由序号区分
    byRes2: array[0..256-1] of BYTE;  
  end;
  LPNET_ITS_PARK_VEHICLE = ^NET_ITS_PARK_VEHICLE;

//交通取证报警
type
  NET_DVR_TFS_ALARM = record 
    dwSize: DWORD;  //结构体大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    dwIllegalType: DWORD;  //违章类型，采用国标定义，当dwIllegalType值为0xffffffff时使用byIllegalCode
    dwIllegalDuration: DWORD;  //违法持续时间（单位：秒） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    byMonitoringSiteID: array[0..MONITORSITE_ID_LEN-1] of BYTE;  //显示点编号（路口编号、内部编号）
    byDeviceID: array[0..DEVICE_ID_LEN-1] of BYTE;  //设备编号
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    struSceneInfo: NET_DVR_SCENE_INFO;  //场景信息
    struBeginRecTime: NET_DVR_TIME_EX;  //录像开始时间
    struEndRecTime: NET_DVR_TIME_EX;  //录像结束时间
    struAIDInfo: NET_DVR_AID_INFO;  //交通事件信息
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    dwPicNum: DWORD;  //图片数量
    struPicInfo: array[0..8-1] of NET_ITS_PICTURE_INFO;  //图片信息，最多8张
    bySpecificVehicleType: BYTE;  //具体车辆种类  参考识别结果类型VTR_RESULT
    byLaneNo: BYTE;  //关联车道号
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    struTime: NET_DVR_TIME_V30;  //手动定位，当前时间。
    dwSerialNo: DWORD;  //序号；
    byVehicleAttribute: BYTE;  //车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    byPilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byCopilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byPilotSunVisor: BYTE;  //0-表示未知,1-不打开遮阳板,2-打开遮阳板
    byCopilotSunVisor: BYTE;  //0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    byPilotCall: BYTE;  // 0-表示未知, 1-不打电话,2-打电话
    byRes2: array[0..2-1] of BYTE;  //保留
    byIllegalCode: array[0..ILLEGAL_LEN{32}-1] of BYTE;  //违法代码扩展，当dwIllegalType值为0xffffffff；使用这个值
    wCountry: WORD;  // 国家索引值,参照枚举COUNTRY_INDEX
    byRegion: BYTE;  //区域索引值,0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
    byCrossLine: BYTE;  //是否压线停车（侧方停车），0-表示未知，1-不压线，2-压线
    byParkingSerialNO: array[0..SERIAL_NO_LEN{16}-1] of BYTE;  //泊车位编号
    byCrossSpaces: BYTE;  //是否跨泊车位停车（侧方停车），0-表示未知，1-未跨泊车位停车，2-跨泊车位停车
    byAngledParking: BYTE;  //是否倾斜停车（侧方停车）, 0-表示未知，1-未倾斜停车，2-倾斜停车
    byAlarmValidity: BYTE;  //报警置信度，可以输出驶入驶出的置信度，范围0-100；置信度越高，事件真实性越高
    byDoorsStatus: BYTE;  //车门状态 0-车门关闭 1-车门开启
    dwXmlLen: DWORD;  //XML报警信息长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
{$ELSE}
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    byRes3: array[0..4-1] of BYTE;  
{$ENDIF}
    byVehicleHeadTailStatus: BYTE;  //车头车尾状态 0-保留 1-车头 2-车尾
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不重传数据，1-重传数据
    byRes: array[0..30-1] of BYTE;  //保留
  end;
  LPNET_DVR_TFS_ALARM = ^NET_DVR_TFS_ALARM;

type
  NET_DVR_SOFTWARE_SERVICE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byThirdStreamEnabled: BYTE;  //是否开启三码流配置：0-否，1-是
    bySubStreamEnabled: BYTE;  //是否开启子码流配置：0-否，1-是
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_SOFTWARE_SERVICE_CFG = ^NET_DVR_SOFTWARE_SERVICE_CFG;

type
  NET_ITS_ECT_BLOCKLIST = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    bylogicalLaneNo: BYTE;  //逻辑车道号
    byRes1: array[0..3-1] of BYTE;  
    byLaneName: array[0..NAME_LEN-1] of BYTE;  //车道名称 32
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    byRes2: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_ITS_ECT_BLOCKLIST = ^NET_ITS_ECT_BLOCKLIST;

//IPC通道参数配置
type
  NET_ITS_IPC_CHAN_CFG = record 
    dwSize: DWORD;  
    byCameraType: BYTE;  //相机种类，0-布防用相机；1-线圈触发相机；2-视频分析用相机,3-一体机
    byRes1: array[0..3-1] of BYTE;  //保留
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byDeviceID: array[0..48-1] of BYTE;  //设备编号
    byDirectionNo: BYTE;  //显示方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
    byMonitorInfo: array[0..48-1] of BYTE;  //显示点信息描述
    byRes2: array[0..15-1] of BYTE;  //保留
  end;
  LPNET_ITS_IPC_CHAN_CFG = ^NET_ITS_IPC_CHAN_CFG;

//单个设备信息
type
  NET_ITS_SINGLE_DEVICE_INFO = record 
    dwDeviceType: DWORD;  //设备类型：0-终端，1-相机，2-补光灯，3-车检器，4-线圈1，5-线圈2，6-线圈3，7-红绿灯检测器，8-机柜，
    //9-雷达，10-道闸，11-出入口控制机(票箱)，12-LED显示屏，13-远距离读卡器，14-近距离读卡器，15-红外扫描枪，
    //16-票据打印机，17-节点管理器(诱导服务器相关) , 18-机柜检测仪
    dwDirID: DWORD;  //方向编号
    dwLaneID: DWORD;  //车道编号
    dwDeviceState: DWORD;  //设备状态  0正常 非0 异常（参考设备异常代码表）
    byDeviceName: array[0..32-1] of BYTE;  //设备名称
    byDeviceID: array[0..48-1] of BYTE;  //设备编号，一般用序列号，车检器用地址
    struTriggerTime: NET_DVR_TIME_V30;  //触发时间
    byRelateChan: BYTE;  //关联通道号（传感器是1~8  AC端子1~4  AC插座1~2）
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_ITS_SINGLE_DEVICE_INFO = ^NET_ITS_SINGLE_DEVICE_INFO;

//路口信息
type
  NET_ITS_ROADINFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号,0xffffffff表示终端，其它表示对应的相机
    byTriggerMode: BYTE;  //  0:线圈触发;  1:视频触发
    byRes1: array[0..3-1] of BYTE;  
    dwDeviceNum: DWORD;  //实际设备个数
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byRoadInfo: array[0..48-1] of BYTE;  //显示点信息
    struSingleDevice: array[0..ITS_MAX_DEVICE_NUM-1] of NET_ITS_SINGLE_DEVICE_INFO;  
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_ITS_ROADINFO = ^NET_ITS_ROADINFO;

//单个车道路况信息
type
  NET_ITS_TRAFFIC_DRIVE_CHAN = record 
    byDriveChan: BYTE;  //车道号
    byRes1: array[0..3-1] of BYTE;  // 预留
    wCarFlux: WORD;  //汽车流量数
    wPasserbyFlux: WORD;  //行人流量数
    wShayFlux: WORD;  //二轮车流量数
    fAverOccpancy: FLOAT;  //平均车道占有率百分比
    wAverSpeed: WORD;  //平均车速(km/h)
    wAverCarDis: WORD;  //平均车距(单位待定)
    byRes2: array[0..16-1] of BYTE;  // 预留
  end;
  LPNET_ITS_TRAFFIC_DRIVE_CHAN = ^NET_ITS_TRAFFIC_DRIVE_CHAN;

type
  NET_ITS_TRAFFIC_COLLECT = record 
    dwSize: DWORD;  //结构大小
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byDeviceID: array[0..48-1] of BYTE;  //设备编号
    byLaneNum: BYTE;  //车道总数
    byDir: BYTE;  //显示方向
    byDetectType: BYTE;  //检测方式1-地感线圈、2-视频触发、3、多帧识别、4雷达触发
    byRes1: BYTE;  //预留
    dwChannel: DWORD;  //通道号
    struStartTime: NET_DVR_SYSTEM_TIME;  //统计开始时间
    dwSamplePeriod: DWORD;  //统计时间,单位秒
    struDriveChan: array[0..6-1] of NET_ITS_TRAFFIC_DRIVE_CHAN;  //交通流量数据,每个相机支持6个车道
    byRes2: array[0..24-1] of BYTE;  //预留
  end;
  LPNET_ITS_TRAFFIC_COLLECT = ^NET_ITS_TRAFFIC_COLLECT;

type
  NET_ITS_OVERLAPCFG_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwConfigMode: DWORD;  //配置模式，0-终端，1-前端(直连前端或终端接前端)
    byPicModeType: BYTE;  //0-表示小图(独立图)，1-表示大图(合成图)
                        {
                        0表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
                        1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    }
    byRelateType: BYTE;  
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAPCFG_COND = ^NET_ITS_OVERLAPCFG_COND;

type
  ITS_OVERLAP_ITEM_TYPE =  
  (  
    OVERLAP_ITEM_NULL = 0,  //0-未知
    OVERLAP_ITEM_SITE,  //1-地点
    OVERLAP_ITEM_ROADNUM,  //2-路口编号
    OVERLAP_ITEM_INSTRUMENTNUM,  //3-设备编号
    OVERLAP_ITEM_DIRECTION,  //4-方向编号
    OVERLAP_ITEM_DIRECTIONDESC,  //5-方向
    OVERLAP_ITEM_LANENUM,  //6-车道号
    OVERLAP_ITEM_LANEDES,  //7-车道
    OVERLAP_ITEM_CAPTIME,  //8-抓拍时间(不带毫秒)
    OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-抓拍时间(带毫秒)
    OVERLAP_ITEM_PLATENUM,  //10-车牌号
    OVERLAP_ITEM_CARCOLOR,  //11-车身颜色
    OVERLAP_ITEM_CARTYPE,  //12-车辆类型
    OVERLAP_ITEM_CARBRAND,  //13-车辆品牌
    OVERLAP_ITEM_CARSPEED,  //14-车辆速度
    OVERLAP_ITEM_SPEEDLIMIT,  //15-限速标志
    OVERLAP_ITEM_CARLENGTH,  //16-车辆长度1~99m
    OVERLAP_ITEM_ILLEGALNUM,  //17-违法代码(违法代码叠加应该没用的，应该直接叠加违法信息，比如正常、低速、超速、逆行、闯红灯、占道、压黄线等)
    OVERLAP_ITEM_MONITOR_INFO,  //18-显示点信息
    OVERLAP_ITEM_ILLEGALDES,  //19-违法行为
    OVERLAP_ITEM_OVERSPEED_PERCENT,  //20-超速比
    OVERLAP_ITEM_RED_STARTTIME,  //21-红灯开始时间
    OVERLAP_ITEM_RED_STOPTIME,  //22-红灯结束时间
    OVERLAP_ITEM_RED_DURATION,  //23-红灯已亮时间
    OVERLAP_ITEM_SECUNITY_CODE,  //24-防伪码
    OVERLAP_ITEM_CAP_CODE,  //25-抓拍编号
    OVERLAP_ITEM_SEATBELT,  //26-安全带
    OVERLAP_ITEM_MONITOR_ID,  //27-显示点编号
    OVERLAP_ITEM_SUN_VISOR,  //28-遮阳板
    OVERLAP_ITEM_LANE_DIRECTION,  //29-车道行驶方向
    OVERLAP_ITEM_LICENSE_PLATE_COLOR,  // 30-车牌颜色
    OVERLAP_ITEM_SCENE_NUMBER,  //31-场景编号
    OVERLAP_ITEM_SCENE_NAME,  //32-场景名称
    OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-黄标车
    OVERLAP_ITEM_DANGEROUS_CAR,  //34-危险品车
    OVERLAP_ITEM_CAR_SUBBRAND,  //35-车辆子品牌
    OVERLAP_ITEM_CAR_DIRECTION,  //36-车辆方向
    OVERLAP_ITEM_PENDANT,  //37-车窗悬挂物
    OVERLAP_ITEM_CALL,  //38-打电话
    OVERLAP_ITEM_CAR_VALIDITY,  //39-置信度
    OVERLAP_ITEM_CAR_COUNTRY,  //40-国家
    OVERLAP_ITEM_CAR_PLATE_TYPE,  //41-车牌类型，参考车牌类型枚举
    OVERLAP_ITEM_CAR_PLATE_SIZE,  //42-车牌尺寸
    OVERLAP_ITEM_CAR_PLATE_COLOR,  //43-车牌颜色
    OVERLAP_ITEM_CAR_PLATE_CATEGORY,  //44-车牌附加信息
    OVERLAP_ITEM_ACCIDENT,  //45-交通事故
    OVERLAP_ITEM_SMOKING,  //46-吸烟
    OVERLAP_ITEM_HELMET,  //47-戴头盔
    OVERLAP_ITEM_MANNED,  //48-载人
    OVERLAP_ITEM_HUMAN,  //49-人体属性
    OVERLAP_ITEM_PLAYMOBILEPHONE,  //50-玩手机
    OVERLAP_ITEM_ADR  //51- ADR车牌： 欧洲国家车辆有的会挂双牌，需要显示第二个车牌号，用ADR车牌叠加项表示
  );

//字符叠加每一条信息结构体
type
  NET_ITS_OVERLAP_SINGLE_ITEM_PARAM = record 
    byRes1: array[0..2-1] of BYTE;  // 保留
    byItemType: BYTE;  //类型，详见OVERLAP_ITEM_TYPE
    byChangeLineNum: BYTE;  //叠加项后的换行数[0-10](默认0)
    bySpaceNum: BYTE;  //叠加项后的空格数[0-255](默认0)
    byRes2: array[0..2-1] of BYTE;  
    byEnablePos: BYTE;  //是否启用坐标显示
    wStartPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM = ^NET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

type
  NET_ITS_OVERLAP_ITEM_PARAM = record 
    struSingleItem: array[0..MAX_OVERLAP_ITEM_NUM-1] of NET_ITS_OVERLAP_SINGLE_ITEM_PARAM;  //单条字符参数
    dwLinePercent: DWORD;  //叠加行百分比(0-100),(默认100)
    dwItemsStlye: DWORD;  //叠加方式：0-横排,1-竖排(默认横排)
    wStartPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    wCharStyle: WORD;  //字体类型,0-宋体1-魏体(默认)
    wCharSize: WORD;  //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    wCharInterval: WORD;  //字符间距，[0～16]，可设单位：像素(默认)
    byRes1: array[0..2-1] of BYTE;  
    dwForeClorRGB: DWORD;  //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    dwBackClorRGB: DWORD;  //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    byColorAdapt: BYTE;  //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    byParamFillZeroEnble: BYTE;  
    byPlateLeftCornerEnable: BYTE;  // 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    byRes2: BYTE;  
    wStartSPicPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartSPicPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    byOsdLocate: BYTE;  
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_ITEM_PARAM = ^NET_ITS_OVERLAP_ITEM_PARAM;

//叠加项具体信息
type
  NET_ITS_OVERLAP_INFO_PARAM = record 
    bySite: array[0..128-1] of BYTE;  //地点描述
    byRoadNum: array[0..32-1] of BYTE;  //路口编号
    byInstrumentNum: array[0..32-1] of BYTE;  //设备编号
    byDirection: array[0..32-1] of BYTE;  //方向编号
    byDirectionDesc: array[0..32-1] of BYTE;  //方向描述
    byLaneDes: array[0..32-1] of BYTE;  //车道描述
    byRes1: array[0..32-1] of BYTE;  //保留
    byMonitoringSite1: array[0..44-1] of BYTE;  //显示点1信息
    byMonitoringSite2: array[0..32-1] of BYTE;  //显示点2信息
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_ITS_OVERLAP_INFO_PARAM = ^NET_ITS_OVERLAP_INFO_PARAM;

type
  NET_ITS_OVERLAP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    struOverLapItem: NET_ITS_OVERLAP_ITEM_PARAM;  //字符串参数
    struOverLapInfo: NET_ITS_OVERLAP_INFO_PARAM;  //字符串内容信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_CFG = ^NET_ITS_OVERLAP_CFG;

//字符叠加每一条信息结构体
type
  NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 = record 
    byRes1: array[0..2-1] of BYTE;  // 保留
    byItemType: BYTE;  //类型，详见OVERLAP_ITEM_TYPE
    byChangeLineNum: BYTE;  //叠加项后的换行数[0-10](默认0)
    bySpaceNum: BYTE;  //叠加项后的空格数[0-255](默认0)
    byRes2: array[0..2-1] of BYTE;  
    byEnablePos: BYTE;  //是否启用坐标显示
    wStartPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    //自定义类型；与byItemType参数对应。可将byItemType参数类型自定义名称。若自定义内容为空，便默认以byItemType参数中的类型命名。
    byItemTypeCustom: array[0..32-1] of BYTE;  
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 = ^NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

type
  NET_ITS_OVERLAP_ITEM_PARAM_V50 = record 
    struSingleItem: array[0..MAX_OVERLAP_ITEM_NUM-1] of NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;  //单条字符参数
    dwLinePercent: DWORD;  //叠加行百分比(0-100),(默认100)
    dwItemsStlye: DWORD;  //叠加方式：0-横排,1-竖排(默认横排)
    wStartPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    wCharStyle: WORD;  //字体类型,0-宋体1-魏体(默认)
    wCharSize: WORD;  //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    wCharInterval: WORD;  //字符间距，[0～16]，可设单位：像素(默认)
    byRes1: array[0..2-1] of BYTE;  
    dwForeClorRGB: DWORD;  //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    dwBackClorRGB: DWORD;  //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    byColorAdapt: BYTE;  //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    byParamFillZeroEnble: BYTE;  
    byPlateLeftCornerEnable: BYTE;  // 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    byRes2: BYTE;  
    wStartSPicPosTop: WORD;  //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    wStartSPicPosLeft: WORD;  //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    byOsdLocate: BYTE;  
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_ITEM_PARAM_V50 = ^NET_ITS_OVERLAP_ITEM_PARAM_V50;

type
  NET_ITS_OVERLAP_CFG_V50 = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    struOverLapItemV50: NET_ITS_OVERLAP_ITEM_PARAM_V50;  //字符串参数
    struOverLapInfo: NET_ITS_OVERLAP_INFO_PARAM;  //字符串内容信息
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_ITS_OVERLAP_CFG_V50 = ^NET_ITS_OVERLAP_CFG_V50;

const
  MAX_PTZCRUISE_POINT_NUM = 32;    //最大支持32个巡航点


//预置点信息
type
  NET_DVR_PRESET_INFO = record 
    dwSize: DWORD;  
    dwPresetNum: DWORD;  //预置点个数
    dwGroupNum: DWORD;  //组数
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PRESET_INFO = ^NET_DVR_PRESET_INFO;

//输入参数
type
  NET_DVR_PRESET_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwGroupNO: DWORD;  //组号
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PRESET_COND = ^NET_DVR_PRESET_COND;

//输出参数
type
  NET_DVR_PRESETCFG = record 
    dwSize: DWORD;  
    dwPresetIndex: DWORD;  //预置点序号
    struVcaPoint: NET_VCA_POINT;  //预置点坐标
    wZoomCoordinate: WORD;  ///<预置点窗口Zoom值
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_PRESETCFG = ^NET_DVR_PRESETCFG;

//获取巡航路径的数目
type
  NET_DVR_PTZCRUISE_INFO = record 
    dwSize: DWORD;  
    dwPtzCruiseNum: DWORD;  //路径个数
    dwGroupNum: DWORD;  //组数
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PTZCRUISE_INFO = ^NET_DVR_PTZCRUISE_INFO;

//输入参数：
type
  NET_DVR_PTZCRUISE_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    dwGroupNO: DWORD;  //组号
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_PTZCRUISE_COND = ^NET_DVR_PTZCRUISE_COND;

//输出参数
type
  NET_DVR_PTZCRUISE_POINTCFG = record 
    dwSize: DWORD;  
    dwPresetIndex: DWORD;  //预置点序号
    struVcaPoint: NET_VCA_POINT;  //预置点坐标
    byDwell: BYTE;  //停留时间
    bySpeed: BYTE;  //速度
    wZoomCoordinate: WORD;  ///<预置点窗口Zoom值
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_PTZCRUISE_POINTCFG = ^NET_DVR_PTZCRUISE_POINTCFG;

type
  NET_DVR_PTZCRUISECFG = record 
    dwSize: DWORD;  
    dwCruiseRoute: DWORD;  //巡航路径序号
    struCruisePoint: array[0..MAX_PTZCRUISE_POINT_NUM-1] of NET_DVR_PTZCRUISE_POINTCFG;  //最大支持32个巡航点
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PTZCRUISECFG = ^NET_DVR_PTZCRUISECFG;

//模式结构
type
  NET_DVR_MOTION_TRACK_CFG = record 
    dwSize: DWORD;  
    byEnableTrack: BYTE;  //启用，0-否，1-是
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_MOTION_TRACK_CFG = ^NET_DVR_MOTION_TRACK_CFG;

//一天的定时计划
type
  NET_DVR_DAY_SCHEDULE = record 
    byWorkMode: BYTE;  //0-全天开，1-全天关，2-定时
    byRes1: array[0..3-1] of BYTE;  
    struTime: array[0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_SCHEDTIME;  //时间段
    byRes2: array[0..8-1] of BYTE;  //保留
  end;
  LPNET_DVR_DAY_SCHEDULE = ^NET_DVR_DAY_SCHEDULE;

//定时智能参数结构
type
  NET_DVR_SCHEDULE_AUTO_TRACK_CFG = record 
    dwSize: DWORD;  //结构长度
    byEnableTrack: BYTE;  //启用：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struSchedule: array[0..MAX_DAYS{7}-1] of NET_DVR_DAY_SCHEDULE;  //定时智能时间段，不在这8个时间段内的时间，默认定时智能关闭
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG = ^NET_DVR_SCHEDULE_AUTO_TRACK_CFG;

type
  NET_DVR_I_FRAME = record 
    dwSize: DWORD;  //结构长度
    sStreamID: array[0..STREAM_ID_LEN{32}-1] of BYTE;  //流ID
    dwChan: DWORD;  //被控通道号
    byStreamType: BYTE;  //0-主码流，1-子码流，2-码流3，3-码流4，4-码流5
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_I_FRAME = ^NET_DVR_I_FRAME;

type
  NET_DVR_REBOOT_TIME = record 
    byDate: BYTE;  //星期几，1-7代表星期一到星期日
    byHour: BYTE;  //时
    byMinute: BYTE;  //分
    byRes1: BYTE;  
    byRebootMode: BYTE;  //0-按周重启，1-按月重启（此参数只能获取，不能设置）
    byDisabled: BYTE;  // 0-启用 1-禁用
    byRes: array[0..10-1] of BYTE;  //保留
  end;
  LPNET_DVR_REBOOT_TIME = ^NET_DVR_REBOOT_TIME;

type
  NET_DVR_AUTO_REBOOT_CFG = record 
    dwSize: DWORD;  
    struRebootTime: NET_DVR_REBOOT_TIME;  
  end;
  LPNET_DVR_AUTO_REBOOT_CFG = ^NET_DVR_AUTO_REBOOT_CFG;

const
  NET_DVR_GPS_FINDING = 0;    //正在查找
  NET_DVR_GPS_RECV = 1;    //接收数据
  NET_DVR_GPS_OVER = 2;    //查找结束
  NET_DVR_GPS_EXCEPTION = 3;    //接收异常
type
  NET_DVR_MENU_OUTPUT_MODE = record 
    dwSize: DWORD;  
    byMenuOutputMode: BYTE;  //非同源设备：0-Auto 1-主CVBS 2-HDMI 3-VGA 同源设备：0-Auto 1-主CVBS 2-HDMI/VGA
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_MENU_OUTPUT_MODE = ^NET_DVR_MENU_OUTPUT_MODE;

type
  NET_DVR_MB_IPADDR = record 
    struIP: NET_DVR_IPADDR;  //IP地址
    wPort: WORD;  //端口号
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_MB_IPADDR = ^NET_DVR_MB_IPADDR;

type
  NET_DVR_MB_WVSPARA = record 
    struWVSAddr: NET_DVR_MB_IPADDR;  
    byPuid: array[0..NAME_LEN-1] of BYTE;  //设备id
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_MB_WVSPARA = ^NET_DVR_MB_WVSPARA;

type
  NET_DVR_MB_EHOMEPARA = record 
    struEHomeAddr: NET_DVR_MB_IPADDR;  
    byPuid: array[0..NAME_LEN-1] of BYTE;  //设备id
  end;
  LPNET_DVR_MB_EHOMEPARA = ^NET_DVR_MB_EHOMEPARA;

type
  NET_DVR_MB_PLATFORMPARA = record 
    dwSize: DWORD;  
    byNetEnvironment: BYTE;  //网络环境,0-wireless,1-3G,2-wLan,3-lan
    byCurPlatForm: BYTE;  //< 当前平台0 - WVS, 1 - E家, 2 - 推模式 
    byRes1: array[0..2-1] of BYTE;  
    struWVSPara: NET_DVR_MB_WVSPARA;  //车载平台(平台登入)
    struMbEHpara: NET_DVR_MB_EHOMEPARA;  //E家平台车载平台不设置设备登入密码 
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MB_PLATFORMPARA = ^NET_DVR_MB_PLATFORMPARA;

type
  NET_DVR_MB_GPS_STATUS = record 
    byGPSModule: BYTE;  //gps模块, 0: 不存在, 1: 正常
    byPositionStatus: BYTE;  //gps定位状态, 0: 定位失败, 1: 定位成功
    bySignalStrength: BYTE;  //信号强度, 0: 弱, 1: 正常, 2: 强
    byres: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_MB_GPS_STATUS = ^NET_DVR_MB_GPS_STATUS;

type
  NET_DVR_MB_GSENSOR_STATUS = record 
    byGsensorModule: BYTE;  //g-sensor模块, 0: not exist, 1: 内置, 2: 外置
    byCurAccX: array[0..10-1] of BYTE;  //当前X轴加速度
    byCurAccY: array[0..10-1] of BYTE;  //当前Y轴加速度
    byCurAccZ: array[0..10-1] of BYTE;  //当前Z轴加速度
    byRefAccX: array[0..10-1] of BYTE;  // X轴加速度标定值
    byRefAccY: array[0..10-1] of BYTE;  // Y轴加速度标定值
    byRefAccZ: array[0..10-1] of BYTE;  // Z轴加速度标定值
    byres: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_MB_GSENSOR_STATUS = ^NET_DVR_MB_GSENSOR_STATUS;

const
  IP_ADDR_LEN = 16;    
//  IW_ESSID_MAX_SIZE = 32;    

type
  NET_DVR_MB_WIFI_STATUS = record 
    byEnableWiFi: BYTE;  // 无线, 0 关, 1 开 
    byWiFiConnectStatus: BYTE;  // WIFI状态, 0: 连接失败, 1: 连接成功 2: 无模块
    bySignalStrength: BYTE;  // 信号强度, 0 弱, 1 正常, 2 强 
    byIPaddress: array[0..IP_ADDR_LEN-1] of BYTE;  //WIFI 设备 ip
    byEssid: array[0..IW_ESSID_MAX_SIZE-1] of BYTE;  //无线接入点essid
    byres: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_MB_WIFI_STATUS = ^NET_DVR_MB_WIFI_STATUS;

type
  NET_DVR_MB_PLATFORM_STATUS = record 
    byCurPlat: BYTE;  //当前平台, 0: wvs, 1: ivms, 2: 推模式(net_3g_sdk)
    byLoginStatus: BYTE;  //login 状态, 0: login failed, 1: login success
    byExceptionInfo: BYTE;  //异常信息
    {
    WVS :exception info:
    0: 连接服务器失败
    1: 注册中
    2: 用户名密码错误
    3: 注册超时
    4: 心跳超时
    5: 注册成功
    iVMS :exception info:
    0未注册
    1注册中
    2注册连接出错
    3注册超时
    4长时间没有心跳，连接中断
    5重新注册
    6 CMS中注册设备数量已经超过限定的台数
    7 CMS中注册通道数量已经超过限定通道数
    8设备在WEB管理中心中没有配置
    9CMS和WEB管理中心通信失败
    10登录未知错误
    11注册成功
    推模式 :exception info:
    0未注册
    1: 注册中
    2: 重复注册
    3: 注册连接失败
    4: 服务器IP变化
    5: 注册成功
    6: 用户注销
    7: 心跳超时
    }
    byres: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_MB_PLATFORM_STATUS = ^NET_DVR_MB_PLATFORM_STATUS;


type
  NET_DVR_MB_MOBILEDEV_STATUS = record 
    dwSize: DWORD;  //结构大小
    mobileStatus: record 
      case Byte of
      0: (struGPSStatus: NET_DVR_MB_GPS_STATUS);  
      1: (struGSensorStatus: NET_DVR_MB_GSENSOR_STATUS);  
      2: (struWiFiStatus: NET_DVR_MB_WIFI_STATUS);  
      3: (struPlatformStatus: NET_DVR_MB_PLATFORM_STATUS);  
    end;  
  end;
  LPNET_DVR_MB_MOBILEDEV_STATUS = ^NET_DVR_MB_MOBILEDEV_STATUS;

const
  NET_DVR_GPS_STATUS = 0;    
  NET_DVR_GSENSOR_STATUS = 1;    
  NET_DVR_WIFI_STATUS = 2;    
  NET_DVR_PLATFORM_STATUS = 3;    

//GPS点信息结构
type
  NET_DVR_GPS_INFO = record 

    // 经纬度为S*100 
    byDirection: array[0..2-1] of BYTE;  //direction[0]0or1(东经/西经), direction[1]:0or1(北纬/南纬)  
    bySvs: BYTE;  // satellite vehicles(初值0)：有效定位星数 
    byLocateMode: BYTE;  // 定位模式(初值0)：仅NMEA0183 3.00版本输出，0=自主定位，1=差分，2=估算，3=数据无效 
    wHDOP: WORD;  // 水平精度因子，度量GPS精确度，0.5-99.9，6以内定位精度高，20以上需丢弃，这里存储的是乘以10以后的整数 
    wHeight: WORD;  // 高度 
    dwLatitude: DWORD;  //纬度latitude = 实际度*3600*100+实际分*60*100+实际秒*100 
    dwLongitude: DWORD;  //经度longitude =实际度*3600*100+实际分*60*100+实际秒*100 
    dwVehicleSpeed: DWORD;  // mobile speed =实际速度*100000 实际单位kph
    dwVehicleDirection: DWORD;  // mobile direction= 实际方向*100，实际数值是方向角，正北为0度，顺时针 
    byRes: array[0..8-1] of BYTE;  // 保留
  end;
  LPNET_DVR_GPS_INFO = ^NET_DVR_GPS_INFO;//32字节

//GPS状态上传
type
  NET_DVR_GPS_STATUS_ALARM = record 
    dwSize: DWORD;  
    struGPSTime: NET_DVR_TIME_V30;  //GPS 采样时间，采用本地时间
    struGPSInfo: NET_DVR_GPS_INFO;  //GPS坐标点
    byRetransFlag: BYTE;  //0-本条 GPS 为实时包；1-本条 GPS 为重传包
    byNeedsResponse: BYTE;  //回应标记，0：不需回应包，1：需回应包
    byType: BYTE;  //上报类型 0-无人机
    byBatteryRemaining: BYTE;  //剩余电量：-1--100; -1表示出错
    iRollAngle: INT;  //俯仰角度,范围-pi - +pi,实际值*100
    iPitchAngle: INT;  //机头朝向角度,范围-pi - +pi,实际值*100
    wRelativeHeight: WORD;  //相对高度，单位：厘米
    wVerticalSpeed: WORD;  //垂直速度，单位：厘米/小时
    byRes2: array[0..160-1] of BYTE;  //保留
  end;
  LPNET_DVR_GPS_STATUS_ALARM = ^NET_DVR_GPS_STATUS_ALARM;

//GPS关联时间
type
  NET_DVR_GPS_DATA = record 
    struGPSInfo: NET_DVR_GPS_INFO;  //GPS坐标点
    struTime: NET_DVR_TIME;  //GPS坐标对应的时间点，UTC时间
    byRes: array[0..12-1] of BYTE;  // 保留
  end;
  LPNET_DVR_GPS_DATA = ^NET_DVR_GPS_DATA;

//GPS查找条件结构
type
  NET_DVR_GET_GPS_DATA_PARAM = record 
    dwCmdType: DWORD;  //0-按时间段查找GPS数据,1-按时间点查找GPS数据
    GpsDataParam: record 
      case Byte of
      0: (TimeSeg: record
        struBeginTime: NET_DVR_TIME;  //GPS数据查找起始时间
        struEndTime: NET_DVR_TIME;  //GPS数据查找结束时间
        dwInterval: DWORD;  //GPS点时间间隔，单位秒
        byRes: array[0..76-1] of BYTE;  // 保留
      end);  
      1: (TimePoint: record
        struTimePoint: NET_DVR_TIME;  //GPS数据查找起始时间单位秒
        byRes: array[0..104-1] of BYTE;  // 保留
      end);  
    end;  
  end;
  LPNET_DVR_GET_GPS_DATA_PARAM = ^NET_DVR_GET_GPS_DATA_PARAM;

const
  NET_SDK_MAX_CARD_LEN = 32;    //最大卡号长度

//标签信息上传
type
  NET_DVR_TAG_INFO_ALARM = record 
    dwSize: DWORD;  
    byCardNo: array[0..NET_SDK_MAX_CARD_LEN{32}-1] of BYTE;  //卡号
    iRssi: INT;  //接收信号强度,范围-100 - +100
    byIndexCode: array[0..64-1] of BYTE;  //平台index code,相当于设备编号
    struAcquisitionTime: NET_DVR_TIME_V30;  //获取时间
    byRFIDInfo: array[0..32-1] of BYTE;  //卡片ID
    byRFIDInfoLen: BYTE;  //卡片ID长度
    byVoltageLow: BYTE;  //1表示低电压，0表示正常
    byAlarmFlag: BYTE;  //(通知平台服务器)是否需要报警，1需要，0不需要
    byDirection: BYTE;  //0表示忽略,1表示入,2表示出,3-255保留
    byRes: array[0..48-1] of BYTE;  //保留
  end;
  LPNET_DVR_TAG_INFO_ALARM = ^NET_DVR_TAG_INFO_ALARM;


type
  NET_DVR_SDKLOCAL_CFG = record 
    byEnableAbilityParse: BYTE;  //使用能力集解析库,0-不使用,1-使用,默认不使用
    byVoiceComMode: BYTE;  //对讲模式，0-使用对讲库（默认），1-使用windows api模式
    byLoginWithSimXml: BYTE;  //登录时使用模拟能力,0-不使用,1-使用,默认不使用
    byCompatibleType: BYTE;  
    byRes: array[0..380-1] of BYTE;  
    byProtectKey: array[0..128-1] of BYTE;  //默认设置为0
  end;
  LPNET_DVR_SDKLOCAL_CFG = ^NET_DVR_SDKLOCAL_CFG;

type
  NET_DVR_LOCAL_ABILITY_PARSE_CFG = record 
    byEnableAbilityParse: BYTE;  //使用能力集解析库,0-不使用,1-使用,默认不使用
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_ABILITY_PARSE_CFG = ^NET_DVR_LOCAL_ABILITY_PARSE_CFG;

type
  NET_DVR_LOCAL_TALK_MODE_CFG = record 
    byTalkMode: BYTE;  //对讲模式，0-使用对讲库（默认），1-使用windows api模式
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_TALK_MODE_CFG = ^NET_DVR_LOCAL_TALK_MODE_CFG;


type
  NET_DVR_LOCAL_PROTECT_KEY_CFG = record 
    byProtectKey: array[0..128-1] of BYTE;  //默认设置为0
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_PROTECT_KEY_CFG = ^NET_DVR_LOCAL_PROTECT_KEY_CFG;

type
  NET_DVR_SIMXML_LOGIN = record 
    byLoginWithSimXml: BYTE;  //登录时使用模拟能力校正结构体能力字段,0-不使用,1-使用
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_SIMXML_LOGIN = ^NET_DVR_SIMXML_LOGIN;

//报警回调配置参数
type
  NET_DVR_MESSAGE_CALLBACK_PARAM_V51 = record 
{控制JSON透传报警（即COMM_VCA_ALARM）的JSON格式。
    0~新JSON格式，参考4.1.4;
    1~旧JSON格式，参考4.1.5
    }
    byVcaAlarmJsonType: BYTE;  
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_MESSAGE_CALLBACK_PARAM_V51 = ^NET_DVR_MESSAGE_CALLBACK_PARAM_V51;

type
  NET_SDK_LOCAL_CFG_TYPE =  
  (  
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,  //本地TCP端口绑定配置，对应结构体NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,  //本地UDP端口绑定配置，对应结构体NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,  //内存池本地配置，对应结构体NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,  //按模块配置超时时间，对应结构体NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,  //是否使用能力集解析库，对应结构体NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,  //对讲模式，对应结构体NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,  //密钥设置，对应结构体NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,  //用于测试版本头的设备端兼容情NET_DVR_LOCAL_MEM_POOL_CFG况, 只有在设置参数时才起作用。
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,  //rtsp参数配置，对于结构体NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,  //在登录时使用模拟能力补充support字段, 对应结构NET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,  //心跳交互间隔时间
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,  //SDK本次安全配置，
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,  //配置萤石云通信库地址，
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,  //13.配置字符编码相关处理回调
    NET_SDK_LOCAL_CFG_TYPE_PROXYS,  //设置获取代
    NET_DVR_LOCAL_CFG_TYPE_LOG,  //日志参数配置  NET_DVR_LOCAL_LOG_CFG
    NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK,  //码流回调参数配置 NET_DVR_LOCAL_STREAM_CALLBACK_CFG
    NET_DVR_LOCAL_CFG_TYPE_GENERAL,  //通用参数配置 NET_DVR_LOCAL_GENERAL_CFG
    NET_DVR_LOCAL_CFG_TYPE_PTZ,  //PTZ是否接收设备返回配置
    NET_DVR_LOCAL_CFG_MESSAGE_CALLBACK_V51,  //报警V51回调相关本地配置,对应结构体为NET_DVR_MESSAGE_CALLBACK_PARAM_V51 。(仅对NET_DVR_SetDVRMessageCallBack_V51以上版本有效)
    NET_SDK_LOCAL_CFG_CERTIFICATION,  //配置和证书相关的参数，对应结构体结构体NET_DVR_LOCAL_CERTIFICATION
    NET_SDK_LOCAL_CFG_PORT_MULTIPLEX,  //端口复用，对应结构体NET_DVR_LOCAL_PORT_MULTI_CFG
    NET_SDK_LOCAL_CFG_ASYNC,  //异步配置，对应结构体NET_DVR_LOCAL_ASYNC_CFG
    NET_SDK_P2P_LOGIN_2C,  
    NET_SDK_P2P_LOGIN_2B,  
    NET_SDK_P2P_LOGOUT,  
    NET_SDK_AUDIOCAST_CFG  //配置广播采样率 ,对应结构体NET_LOCAL_AUDIOCAST_CFG
  );

type
  NET_SDK_EXCEPTION_CALLBACK_TYPE =  
  (  
    NET_SDK_EXCEPTION_CALLBACK_BY_POOL = 0,  //通过线程池异常回调
    NET_SDK_EXCEPTION_CALLBACK_DIRECTLY = 1  //直接异常回调给上层
  );

type
  NET_DVR_LOCAL_GENERAL_CFG = record 
    byExceptionCbDirectly: BYTE;  //0-通过线程池异常回调，1-直接异常回调给上层
    byNotSplitRecordFile: BYTE;  //回放和预览中保存到本地录像文件不切片 0-默认切片，1-不切片
    byResumeUpgradeEnable: BYTE;  //断网续传升级使能，0-关闭（默认），1-开启
    byAlarmJsonPictureSeparate: BYTE;  //控制JSON透传报警数据和图片是否分离，0-不分离，1-分离（分离后走COMM_ISAPI_ALARM回调返回）
    byRes: array[0..4-1] of BYTE;  //保留
    i64FileSize: UINT64;  //单位：Byte
    dwResumeUpgradeTimeout: DWORD;  //断网续传重连超时时间，单位毫秒
    byAlarmReconnectMode: BYTE;  //0-独立线程重连（默认） 1-线程池重连
    byStdXmlBufferSize: BYTE;  //设置ISAPI透传接收缓冲区大小，1-1M 其他-默认
    byMultiplexing: BYTE;  //0-普通链接（非TLS链接）关闭多路复用，1-普通链接（非TLS链接）开启多路复用
    byFastUpgrade: BYTE;  //0-正常升级，1-快速升级
    byAlarmPrealloc: BYTE;  //0-不预分配。其他值为预分配大小，最大64，单位兆
    byRes1: array[0..231-1] of BYTE;  //预留
  end;
  LPNET_DVR_LOCAL_GENERAL_CFG = ^NET_DVR_LOCAL_GENERAL_CFG;

type
  NET_SDK_P2P_SERVER_2C = record 
    byPlatformType: BYTE;  //0-国内 1-国外 2-test2
    byRes1: array[0..3-1] of BYTE;  
    pAppID: PAnsiChar;  //APP ID
    pAuthAddr: PAnsiChar;  //认证服务器IP地址
    pPlatformAddr: PAnsiChar;  //平台服务IP地址
    pUserName: PAnsiChar;  //账号
    pPassword: PAnsiChar;  //密码
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_P2P_SERVER_2C = ^NET_SDK_P2P_SERVER_2C;

type
  NET_SDK_P2P_SERVER_2B = record 
    byPlatformType: BYTE;  //0-国内 1-国外 2-test2
    byRes1: array[0..3-1] of BYTE;  
    pAppID: PAnsiChar;  //APP ID
    pAuthAddr: PAnsiChar;  //认证服务器IP地址
    pPlatformAddr: PAnsiChar;  //平台服务IP地址
    pToken: PAnsiChar;  //Token
    byRes: array[0..44-1] of BYTE;  
  end;
  LPNET_DVR_P2P_SERVER_2B = ^NET_SDK_P2P_SERVER_2B;

type
  NET_DVR_LOCAL_ASYNC_CFG = record 
    bEnable: BOOL;  //异步配置使能，true-开启
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_ASYNC_CFG = ^NET_DVR_LOCAL_ASYNC_CFG;

type
  NET_DVR_LOCAL_STREAM_CALLBACK_CFG = record 
    byPlayBackEndFlag: BYTE;  //0-不回调回放结束标记，1-回调回放结束标记
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG = ^NET_DVR_LOCAL_STREAM_CALLBACK_CFG;

type
  LOGCALLBACK = procedure(pContent: PAnsiChar; dwInputLen: DWord; wLogLevel: INT; pData: PVOID); stdcall;

type
  NET_DVR_LOCAL_LOG_CFG = record 
    wSDKLogNum: WORD;  
    fnCB: LOGCALLBACK;  //日志回调
    pUserData: PVOID;  //用户指针
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    byRes: array[0..238-1] of BYTE;  //保留
{$ELSE}
    byRes: array[0..246-1] of BYTE;  //保留
{$ENDIF}
  end;
  LPNET_DVR_LOCAL_LOG_CFG = ^NET_DVR_LOCAL_LOG_CFG;

type
  CHAR_ENCODE_CONVERT = function(pInput: PAnsiChar; dwInputLen: DWORD; dwInEncodeType: DWORD; pOutput: PAnsiChar; dwOutputLen: DWORD; dwOutEncodeType: DWORD): INT; stdcall;

type
  NET_DVR_LOCAL_BYTE_ENCODE_CONVERT = record 
    fnCharConvertCallBack: CHAR_ENCODE_CONVERT;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT = ^NET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

type
  NET_DVR_LOCAL_SECURITY = record 
    bySecurityLevel: BYTE;  //私有协议通信模式， //0-兼容模式（默认），允许所有的SDK登录协议通过，1-安全模式（MD5）, 允许RSA和MD5登录，开启校验2-安全模式（RSA）RSA登录，开启校验
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_SECURITY = ^NET_DVR_LOCAL_SECURITY;

type
  NET_DVR_LOCAL_CHECK_DEV = record 
    dwCheckOnlineTimeout: DWORD;  //巡检时间间隔，单位ms  最小值为30s，最大值120s。为0时，表示用默认值(120s)
    dwCheckOnlineNetFailMax: DWORD;  //由于网络原因失败的最大累加次数；超过该值SDK才回调用户异常，为0时，表示使用默认值1
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_CHECK_DEV = ^NET_DVR_LOCAL_CHECK_DEV;

type
  NET_DVR_LOCAL_PTZ_CFG = record 
    byWithoutRecv: BYTE;  //0-接收设备返回，1-不接收设备返回
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_PTZ_CFG = ^NET_DVR_LOCAL_PTZ_CFG;

type
  NET_DVR_LOCAL_CFG_VERSION = record 
    byVersion: BYTE;  //版本信息
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_CFG_VERSION = ^NET_DVR_LOCAL_CFG_VERSION;

type
  NET_DVR_LOCAL_TCP_PORT_BIND_CFG = record 
    wLocalBindTcpMinPort: WORD;  //本地绑定Tcp最小端口
    wLocalBindTcpMaxPort: WORD;  //本地绑定Tcp最大端口
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG = ^NET_DVR_LOCAL_TCP_PORT_BIND_CFG;


type
  NET_DVR_LOCAL_UDP_PORT_BIND_CFG = record 
    wLocalBindUdpMinPort: WORD;  //本地绑定Udp最小端口
    wLocalBindUdpMaxPort: WORD;  //本地绑定Udp最大端口
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG = ^NET_DVR_LOCAL_UDP_PORT_BIND_CFG;


type
  NET_DVR_LOCAL_MEM_POOL_CFG = record 
    dwAlarmMaxBlockNum: DWORD;  //报警模块内存池最多向系统申请的内存块（block）个数，每个block为64MB, 超过这个上限则不向系统申请，0表示无上限
    dwAlarmReleaseInterval: DWORD;  //报警模块空闲内存释放的间隔，单位秒，为0表示不释放
    dwObjectReleaseInterval: DWORD;  //对象申请模块空闲内存释放的间隔，单位秒，为0表示不释放
    byRes: array[0..508-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_MEM_POOL_CFG = ^NET_DVR_LOCAL_MEM_POOL_CFG;

type
  NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG = record 
    dwPreviewTime: DWORD;  //预览模块超时时间
    dwAlarmTime: DWORD;  //报警模块超时时间
    dwVodTime: DWORD;  //回放模块超时时间
    dwElse: DWORD;  //其他模块
    byRes: array[0..512-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG = ^NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

const
  MAX_CERTIFICATE_ISSUER_LEN = 64;    //证书颁发者长度
  MAX_CERTIFICATE_VALIDITY_LEN = 128;    //证书有效时间长度
  MAX_CERTIFICATE_SUBJECT_LEN = 64;    //证书持有者长度
type
  NET_DVR_CETTIFICATE_INFO = record 
    dwSize: DWORD;  
    szIssuer: array[0..MAX_CERTIFICATE_ISSUER_LEN-1] of AnsiChar;  //证书颁发者
    szSubject: array[0..MAX_CERTIFICATE_SUBJECT_LEN-1] of AnsiChar;  //证书持有者
    struStartTime: NET_DVR_TIME;  
    struEndTime: NET_DVR_TIME;  
    byRes1: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_CETTIFICATE_INFO = ^NET_DVR_CETTIFICATE_INFO;

type
  fnCertVerifyResultCallBack = function(uiResult: DWORD; lpCertificateInfo: LPNET_DVR_CETTIFICATE_INFO; pUserData: PAnsiChar): BOOL; stdcall;

const
  MAX_FILE_PATH_LEN = 256;    //文件路径长度
type
  NET_DVR_LOCAL_CERTIFICATION = record 
    szLoadPath: array[0..MAX_FILE_PATH_LEN-1] of AnsiChar;  
    fnCB: fnCertVerifyResultCallBack;  
    pUserData: PVOID;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_CERTIFICATION = ^NET_DVR_LOCAL_CERTIFICATION;

type
  NET_DVR_LOCAL_PORT_MULTI_CFG = record 
    bEnable: BOOL;  //端口复用使能，true-开启
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_PORT_MULTI_CFG = ^NET_DVR_LOCAL_PORT_MULTI_CFG;

type
  NET_DVR_RTSP_PARAMS_CFG = record 
    dwMaxBuffRoomNum: DWORD;  //rtp over udp排序开辟的最大缓冲区个数，0为无效，使用默认值20
    //一个缓冲区开辟内存为10K多一点，缓冲区个数越多，处理乱序的能力则越强，流畅性越好，延时也越大
    byUseSort: BYTE;  //是否开启rtp over udp排序， 0-不开启  1-开启
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_RTSP_PARAMS_CFG = ^NET_DVR_RTSP_PARAMS_CFG;

type
  NET_DVR_OPTICAL_CHANNEL_BIND = record 
    wChannelIndex: WORD;  //光口号(0-7)
    wSubChannel: WORD;  //光口子通道号，取值范围从能力集获取
    byBind: BYTE;  //0-不绑定或清除绑定，1-绑定
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_CHANNEL_BIND = ^NET_DVR_OPTICAL_CHANNEL_BIND;

type
  NET_DVR_OPTICAL_CHANNEL_CFG = record 
    dwSize: DWORD;  
    struBindVideo: NET_DVR_OPTICAL_CHANNEL_BIND;  //视频绑定
    struBindAudio: NET_DVR_OPTICAL_CHANNEL_BIND;  //音频绑定
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_OPTICAL_CHANNEL_CFG = ^NET_DVR_OPTICAL_CHANNEL_CFG;

type
  NET_DVR_OPTICAL_INFO = record 
    dwSize: DWORD;  
    bySlotNum: BYTE;  //编码子系统槽位号
    byChannel: BYTE;  //编码通道号
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_INFO = ^NET_DVR_OPTICAL_INFO;

//音频切换
type
  NET_DVR_AUDIO_SURCHAN_CFG = record 
    dwSize: DWORD;  
    byStatus: BYTE;  //音频是否开启，1-开，0-关
    byRes1: array[0..3-1] of BYTE;  
    //以下参数当byStatus == 1时有效
    dwSubWinNum: DWORD;  //关联的子窗口号
    dwSurChanNum: DWORD;  //布防通道号  
    struIpaddr: NET_DVR_IPADDR;  //布防通道地址 
    wPort: WORD;  //布防通道端口 
    byRes2: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_SURCHAN_CFG = ^NET_DVR_AUDIO_SURCHAN_CFG;

//端口聚合
const
  MAX_ETHERNET_PORT_NUM = 8;    //每条链路最大端口数
type
  NET_DVR_ETHERNET_CHANNEL_INFO = record 
    dwSize: DWORD;  
    byConverge: array[0..MAX_ETHERNET_PORT_NUM-1] of BYTE;  
    //byConverge[i] = j表示将第i个端口加入到第j条链路，j的取值为1-8,j=0表示移除
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ETHERNET_CHANNEL_INFO = ^NET_DVR_ETHERNET_CHANNEL_INFO;

//畅显
type
  NET_DVR_SPARTAN_INFO = record 
    dwSize: DWORD;  
    bySpartanStatus: BYTE;  //0-畅显关，1-畅显开
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_SPARTAN_INFO = ^NET_DVR_SPARTAN_INFO;

type
  NET_DVR_IPADDR_FILTERCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //启用IP地址过滤，0-否，1-是
    byFilterType: BYTE;  //过滤类型，0-禁用，1-允许
    byRes: array[0..18-1] of BYTE;  
    byIPAddr: array[0..1024-1] of BYTE;  //IP地址信息，格式192.168.1.2;192.168.1.3
  end;
  LPNET_DVR_IPADDR_FILTERCFG = ^NET_DVR_IPADDR_FILTERCFG;

type
  NET_DVR_LOGO_OVERLAYCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    dwCoordinateX: DWORD;  //图片显示区域X坐标
    dwCoordinateY: DWORD;  //图片显示区域Y坐标
    wPicWidth: WORD;  //图片宽
    wPicHeight: WORD;  //图片高
    byLogoName: array[0..16-1] of BYTE;  //Logo名称
  end;
  LPNET_DVR_LOGO_OVERLAYCFG = ^NET_DVR_LOGO_OVERLAYCFG;


type
  NET_DVR_INVALID_DISK_PARAM = record 
    struStructHead: NET_DVR_STRUCTHEAD;  
    dwDiskNo: DWORD;  // 磁盘号
    byDelAll: BYTE;  // 0-删除dwDiskNo  1-删除全部无效磁盘
    byres: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_INVALID_DISK_PARAM = ^NET_DVR_INVALID_DISK_PARAM;


type
  NET_DVR_MOUNT_DISK_PARAM = record 
    struStructHead: NET_DVR_STRUCTHEAD;  
    dwDiskNo: DWORD;  // 磁盘号
    byres: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MOUNT_DISK_PARAM = ^NET_DVR_MOUNT_DISK_PARAM;

// 长连接回调类型
type
  NET_SDK_CALLBACK_TYPE =  
  (  
    NET_SDK_CALLBACK_TYPE_STATUS = 0,  // 回调状态值
    NET_SDK_CALLBACK_TYPE_PROGRESS,  // 回调进度值
    NET_SDK_CALLBACK_TYPE_DATA  // 回调数据内容
  );


// 回调类型为NET_SDK_CALLBACK_TYPE_STATUS时的状态值
type
  NET_SDK_CALLBACK_STATUS_NORMAL =  
  (  
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,  // 成功
    NET_SDK_CALLBACK_STATUS_PROCESSING,  // 处理中
    NET_SDK_CALLBACK_STATUS_FAILED,  // 失败
    NET_SDK_CALLBACK_STATUS_EXCEPTION,  // 异常
    NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,  //（IPC配置文件导入）语言不匹配
    NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,  //（IPC配置文件导入）设备类型不匹配
    NET_DVR_CALLBACK_STATUS_SEND_WAIT  // 发送等待
  );


//一键配置通用状态
const
  NET_SDK_OKC_STATUS_SUCCESS = 1000;    //一键配置成功
  NET_SDK_OKC_STATUS_FAILED = 1002;    //一键配置失败

//一键配置CVR状态
const
  NET_SDK_OKC_STATUS_START_CONFIG = 1003;    //开始配置
  NET_SDK_OKC_CHECK_HD = 1004;    //检测磁盘
  NET_SDK_OKC_INIT_HD = 1005;    //初始化磁盘
  NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK = 1006;    //创建阵列或者单盘模式
  NET_SDK_OKC_INIT_CVR_SERVICE = 1007;    //初始化CVR服务
  NET_SDK_OKC_CREATE_RECORD_VOLUME = 1008;    //创建录像卷

//以下为一键配置失败的状态码――part1
const
  NET_SDK_OKC_ERR_LOAD_CONF_FAILED = 1009;    //加载配置文件失败
  NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE = 1010;    //不支持此种类型的raid
  NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT = 1011;    //系统已经存在raid或存储池
  NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED = 1012;    //获取磁盘信息失败
  NET_SDK_OKC_ERR_CHECK_DISK_FAILED = 1013;    //检测磁盘失败
  NET_SDK_OKC_ERR_INIT_DISK_FAILED = 1014;    //初始化磁盘失败
  NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL = 1015;    //磁盘总容量不足
  NET_SDK_OKC_ERR_BOTH_SV_NS = 1016;    //同时存在SV盘和NS盘
  NET_SDK_OKC_ERR_CREATE_RAID_FAILED = 1017;    //创建raid失败
  NET_SDK_OKC_ERR_GET_RAID_FAILED = 1018;    //获取raid失败
  NET_SDK_OKC_ERR_CREATE_SPARE_FAILED = 1019;    //创建热备盘失败
  NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED = 1020;    //创建存储池失败
  NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED = 1021;    //获取存储池信息失败
  NET_SDK_OKC_ERR_CREATE_LUN_FAILED = 1022;    //创建lun卷失败
  NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED = 1023;    //获取lun信息失败
  NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED = 1024;    //创建预留卷失败
  NET_SDK_OKC_ERR_GET_BACKUP_FAILED = 1025;    //获取预留卷失败
  NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED = 1026;    //创建私有卷失败
  NET_SDK_OKC_ERR_CREATE_RV_FAILED = 1027;    //创建录像卷失败
  NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED = 1028;    //创建存档卷失败
  NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED = 1029;    //开启CVR服务失败

//一键配置SAN状态
const
  NET_SDK_OKC_CREATING_ARRAY = 1030;    //创建阵列阶段
  NET_SDK_OKC_CREATING_STORAGE_POOL = 1031;    //创建存储池阶段
  NET_SDK_OKC_CREATING_LUN_VOL = 1032;    //创建逻辑卷阶段
  NET_SDK_OKC_CREATING_ISCSI = 1033;    //创建ISCSI阶段
  NET_SDK_OKC_ERR_HOT_SPARE_CONFICT = 1034;    //已存在热备盘
  NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT = 1035;    //已存在存储池
  NET_SDK_OKC_ERR_RAID_CONFLICT = 1036;    //系统已经存在阵列
  NET_SDK_OKC_ERR_OPEN_ISCSI_FAILED = 1037;    //开启ISCSI失败
  NET_SDK_OKC_ERR_DEVICE_NOSUPPORT_SAN = 1038;    //设备不支持san

//以下为一键配置失败的状态码――part2
const
  NET_SDK_OKC_ERR_SAPRE_NUM_EXCEED = 1101;    //热备盘个数过多
  NET_SDK_OKC_ERR_CREATE_PIC_VOLUME_FAILED = 1102;    //创建图片卷失败

type
  NET_SDK_GET_NEXT_STATUS =  
  (  
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,  // 成功读取到数据，客户端处理完本次数据后需要再次调用NET_DVR_RemoteConfigGetNext获取下一条数据
    NET_SDK_GET_NETX_STATUS_NEED_WAIT,  // 需等待设备发送数据，继续调用NET_DVR_RemoteConfigGetNext函数
    NET_SDK_GET_NEXT_STATUS_FINISH,  // 数据全部取完，此时客户端可调用NET_DVR_StopRemoteConfig结束长连接
    NET_SDK_GET_NEXT_STATUS_FAILED  // 出现异常，客户端可调用NET_DVR_StopRemoteConfig结束长连接
  );

// 用户调用SendwithRecv接口时，接口返回的状态
type
  NET_SDK_SENDWITHRECV_STATUS =  
  (  
    NET_SDK_CONFIG_STATUS_SUCCESS = 1000,  // 成功读取到数据，客户端处理完本次数据后需要再次调用NET_DVR_SendWithRecvRemoteConfig获取下一条数据
    NET_SDK_CONFIG_STATUS_NEEDWAIT,  // 配置等待，客户端可重新NET_DVR_SendWithRecvRemoteConfig
    NET_SDK_CONFIG_STATUS_FINISH,  // 数据全部取完，此时客户端可调用NET_DVR_StopRemoteConfig结束
    NET_SDK_CONFIG_STATUS_FAILED,  // 配置失败，客户端可重新NET_DVR_SendWithRecvRemoteConfig下发下一条
    NET_SDK_CONFIG_STATUS_EXCEPTION  // 配置异常，此时客户端可调用NET_DVR_StopRemoteConfig结束
  );

//导入配置文件错误码
type
  NET_SDK_IPC_CFG_FILE_ERR_CODE =  
  (  
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,  // 没出错 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,  // 通道ID非法 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,  // 通道ID重复 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,  // 通道IP或域名非法 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,  // 通道IP或域名重复 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL,  // 通道IP与本地IP冲突 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,  // 协议错误 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,  // 管理端口错误 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,  // 设备通道号错误 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,  // 用户名含非法字符 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,  // 密码含非法字符 
    NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID  //传输协议错误
  );

//IPC升级错误码
type
  NET_SDK_UPGRADE_IPC_ERR_CODE =  
  (  
    NET_SDK_UPGRADE_IPC_INVALID = 0,  //无效通道或未选择该通道升级
    NET_SDK_UPGRADE_IPC_SUCCESS,  //升级成功
    NET_SDK_UPGRADE_IPC_OFFLINE,  //IPC不在线
    NET_SDK_UPGRADE_IPC_NOT_SUPPORT,  //IPC不支持升级命令
    NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,  //语言不匹配
    NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,  //写flsh失败
    NET_SDK_UPGRADE_IPC_OTHER_ERROR  //其他错误
  );

type
  NET_SDK_REMOTE_CONFIG_STATUS =  
  (  
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,  //录播主机一键发布成功
    NET_SDK_REMOTE_CONFIG_STATUS_FAILED,  //录播主机一键发布失败
    NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING  //录播主机一键发布正在获取
  );

const
  MAX_CODE_CARD_SUPPORTDISPNUMS = 8;    //每个编码卡最多支持的显示通道数
//  MAX_SUPPORT_RES = 32;    

{$WARN BOUNDS_ERROR OFF}
type
  BOARD_TYPE =  
  (  
    DS4004HC_BOARD = 2,  //4004HC
    DS4008HC_BOARD = 3,  //4008HC
    DS4016HC_BOARD = 4,  //4016HC
    DS4001HF_BOARD = 5,  //4001HF
    DS4004HF_BOARD = 6,  //4004HF
    DS4002MD_BOARD = 7,  //4002MD
    DS4004MD_BOARD = 8,  //4004MD
    DS4016HCS_BOARD = 9,  //4016HCS
    DS4004HC_PLUS_BOARD = 13,  //4004HC+
    DS4008HC_PLUS_BOARD = 14,  //4008HC+
    DS4016HC_PLUS_BOARD = 15,  //4016HC+
    DS4008HF_BOARD = 16,  //4008HF
    DS4008MD_BOARD = 17,  //4008MD
    DS4008HS_BOARD = 18,  //4008HS
    DS4016HS_BOARD = 19,  //4016HS

    DS4108HCV_BOARD = 20,  //4108HCV
    DS4116HCV_BOARD = 21,  //4116HCV
    DS5016HC_BOARD = 22,  //5016HC

    DS4208HFV_BOARD = 23,  //4208HFV
    DS4216HC_BOARD = 24,  //4216HC
    DS4216HFV_BOARD = 25,  //4216HFV

    DS5008HF_BOARD = 26,  //5008HF
    DS5116HF_BOARD = 27,  //5116HF

    DS5216HC_BOARD = 28,  //5216HC
    DS5208HF_BOARD = 29,  //5208HF
    DS5216HF_BOARD = 30,  //5216HF

    DS4101HD_BOARD = 31,  //4101HD
    DS4102HD_BOARD = 32,  //4102HD
    DS4104HD_BOARD = 33,  //4104HD

    DS4002MD_PLUS_BOARD = 34,  //4002MD+
    DS4004MD_PLUS_BOARD = 35,  //4004MD+

    DS4204HFV_BOARD = 36,  //4204HFV
    DS4308HCV_BOARD = 37,  //4308HCV
    DS4308HFV_BOARD = 38,  //4308HFV
    DS4316HCV_BOARD = 39,  //4316HCV
    DS4316HFV_BOARD = 40,  //4316HFV
    DS4304HD_BOARD = 41,  //4304HD
    DS4304HFH_BOARD = 42,  //4304HFH
    DS4304HFV_BOARD = 43,  //4304HFV
    DS4302HFH_BOARD = 44,  //4302HFH
    DS5316HF_BOARD = 45,  //5316HF
    DS4308HW_BOARD = 46,  //4308HW
    DS4316HW_BOARD = 47,  //4316HW
    DS4308MD_BOARD = 48,  //4308MD
    UNKNOWN_BOARD_TYPE = $ffffffff  
  );
{$WARN BOUNDS_ERROR ON}

type
  NET_DVR_CODECARD_ABILITY = record //高清编码卡能力集
    byCardType: BYTE;  //编码卡类型(按BOARD_TYPE中的枚举)
    byCodeNums: BYTE;  //编码通道数
    byDispNums: BYTE;  //显示通道数
    byCodeStartIdx: BYTE;  //首个编码通道在所有编码通道中的索引
    byDispStartIdx: BYTE;  //首个显示通道在所有显示通道中的索引
    byRes1: array[0..3-1] of BYTE;  
    dwVgaSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwHdmiSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwDviSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    dwYpbprSupportResolution: array[0..MAX_SUPPORT_RES{32}-1] of DWORD;  //支持的分辨率
    byDispFormat: array[0..MAX_CODE_CARD_SUPPORTDISPNUMS-1] of BYTE;  //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举)
    byWindowMode: array[0..MAX_CODE_CARD_SUPPORTDISPNUMS-1, 0..12-1] of BYTE;  //支持的窗口模式(比如1,2,4,9,16))
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_CODECARD_ABILITY = ^NET_DVR_CODECARD_ABILITY;

const
  MAX_CODE_CARD_NUM = 8;    //最多高清编码卡数
type
  NET_DVR_CODESVR_ABILITY = record 
    dwSize: DWORD;  // 结构体大小 
    byCardNums: BYTE;  // 编码卡数 
    byStartChan: BYTE;  // 起始通道号 
    byRes1: array[0..2-1] of BYTE;  
    struCodeCardAbility: array[0..MAX_CODE_CARD_NUM-1] of NET_DVR_CODECARD_ABILITY;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CODESVR_ABILITY = ^NET_DVR_CODESVR_ABILITY;

type
  NET_DVR_CODER_SERVER_OUTPUT_CFG = record 
    dwSize: DWORD;  
    byDispChanType: BYTE;  {显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI}//此参数只能获取
    byVedioFormat: BYTE;  //1:NTSC,2:PAL，0-NULL
    byRes1: array[0..2-1] of BYTE;  
    dwResolution: DWORD;  //分辨率
    dwWindowMode: DWORD;  //画面模式，支持模式从能力集获取
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CODER_SERVER_OUTPUT_CFG = ^NET_DVR_CODER_SERVER_OUTPUT_CFG;

type
  NET_DVR_DISPLAY_START_INFO = record 
    dwSize: DWORD;  
    dwDisplayChan: DWORD;  //显示通道号
    dwCodeChan: DWORD;  //编码通道号
    dwWinNum: DWORD;  //窗口号，从1起
    byEnableAudio: BYTE;  //开启音频，0-关，1-开
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAY_START_INFO = ^NET_DVR_DISPLAY_START_INFO;

type
  NET_DVR_CODER_WINDOW_INFO = record 
    dwSize: DWORD;  
    dwDisplayChan: DWORD;  //显示通道号
    dwWinNum: DWORD;  //窗口号，从1开始
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_CODER_WINDOW_INFO = ^NET_DVR_CODER_WINDOW_INFO;

type
  NET_DVR_WINDOW_STATUS = record 
    dwSize: DWORD;  //结构大小
    dwCodeChan: DWORD;  //编码通道号
    byDisplay: BYTE;  //是否输出，0-否，1-是
    byAudio: BYTE;  //音频是否开启,0-否，1-是
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_WINDOW_STATUS = ^NET_DVR_WINDOW_STATUS;

type
  NET_DVR_RECORD_LOCK_PERCENTAGE = record 
    dwSize: DWORD;  //结构体大小
    byPercentage: BYTE;  //百分比，取值范围[0,100]
    byRes: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_LOCK_PERCENTAGE = ^NET_DVR_RECORD_LOCK_PERCENTAGE;

type
  NET_DVR_UPDATE_RECORD_INFO = record 
    dwSize: DWORD;  //结构体大小
    struStreasmInfo: NET_DVR_STREAM_INFO;  //流ID
    dwBeginTime: DWORD;  //录像总的开始时间
    dwEndTime: DWORD;  //录像总的结束时间
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_UPDATE_RECORD_INFO = ^NET_DVR_UPDATE_RECORD_INFO;

type
  NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA = record 
    struStreamInfo: NET_DVR_STREAM_INFO;  
    dwCmdType: DWORD;  //外部触发类型
    dwRecordTimeLen: DWORD;  //录像持续时间，单位：秒
    byEventID: array[0..MAX_EVENTID_LEN-1] of BYTE;  //事件ID，作为附加信息
    dwLockDuration: DWORD;  //锁定持续时间，单位：秒，0xffffffff- 永久锁定，0- 不锁
    byBackUp: BYTE;  //是否存档，0-不存档，1-存档
    byPreRecord: BYTE;  //是否预录，0-不预录，1-预录
    byRes: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA = ^NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

type
  NET_DVR_LOCK_FILE_BY_NAME_PARA = record 
    byFileName: array[0..NAME_LEN-1] of BYTE;  // 录像文件名，老协议只传32个文件名
    dwLockDuration: DWORD;  // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_LOCK_FILE_BY_NAME_PARA = ^NET_DVR_LOCK_FILE_BY_NAME_PARA;


type
  NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  
    dwStreamType: DWORD;  //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……（自定义码流类型需通过GET /ISAPI/Streaming/channels/<ID>/customStream获取当前通道已经添加的所有自定义码流ID。自定义码流为6~10，其索引值就是6~10）
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND = ^NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


type
  NET_DVR_MULTI_STREAM_COMPRESSIONCFG = record 
    dwSize: DWORD;  
    dwStreamType: DWORD;  //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    struStreamPara: NET_DVR_COMPRESSION_INFO_V30;  //码流压缩参数
    dwResolution: DWORD;  //当分辨率索引小于255时和byResolution保持一致，大于255时以该字段返回索引值判断。
    byRes: array[0..76-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG = ^NET_DVR_MULTI_STREAM_COMPRESSIONCFG;

type
  NET_DVR_PUSHALARMINFO_V40 = record 
    dwAlarmType: DWORD;  //0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 
    uAlarmInfo: record 
      case Byte of
      0: (byRes: array[0..300-1] of BYTE);  
      1: (struIOAlarm: record
        dwAlarmInputNumber: DWORD;  //按位,第0位对应第0个输入端口,dwAlarmType为0时需要设置
        byAlarmOutputNumber: array[0..MAX_ALARMOUT_V30-1] of BYTE;  //按位,第0位对应第0个输出端口, 
        byAlarmRelateChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //按位,第0位对应第0个通道
        byRes1: array[0..97-1] of BYTE;  
        byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
        byRes2: array[0..7-1] of BYTE;  
      end);  
      2: (struStreamIDorChannel: record
        byStreamID: array[0..STREAM_ID_LEN-1] of BYTE;  // ID信息
        byRes1: array[0..132-1] of BYTE;  
        byChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  //按位,0x2表示第1通道，第1位对应第1个通道(从通道1开始)，dwAlarmType为2或3, 6，9，10时需要设置, 
        byRes2: array[0..33-1] of BYTE;  
        byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
        byRes3: array[0..7-1] of BYTE;  
      end);  
      3: (struDiskAlarm: record
        byRes1: array[0..228-1] of BYTE;  
        byDiskNumber: array[0..MAX_DISKNUM_V30-1] of BYTE;  //按位,第0位对应第0个硬盘,dwAlarmType为1,4,5时需要设置
        byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备的ID串
        byRes2: array[0..7-1] of BYTE;  
      end);  
    end;  
  end;
  LPNET_DVR_PUSHALARMINFO_V40 = ^NET_DVR_PUSHALARMINFO_V40;

type
  NET_DVR_RECORD_PACK = record 
    struStruceHead: NET_DVR_STRUCTHEAD;  
    dwPackageInterval: DWORD;  // 打包时间间隔 ，时间单位：分钟
    byRes: array[0..32-1] of BYTE;  // 保留
  end;
  LPNET_DVR_RECORD_PACK = ^NET_DVR_RECORD_PACK;

const
  NET_DVR_FIND_NAS_DIRECTORY = 6161;    //查找NAS目录
  NET_DVR_NAS_FINDING = 0;    //正在查找
  NET_DVR_NAS_RECV = 1;    //接收数据
  NET_DVR_NAS_OVER = 2;    //查找结束
  NET_DVR_NAS_EXCEPTION = 3;    //接收异常
type
  NET_DVR_NET_DISK_SERACH_PARAM = record 
    struIP: NET_DVR_IPADDR;  // IP地址
    wPort: WORD;  // IP端口
    byRes: array[0..10-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_NET_DISK_SERACH_PARAM = ^NET_DVR_NET_DISK_SERACH_PARAM;


type
  NET_DVR_NET_DISK_SERACH_RET = record 
    byDirectory: array[0..128-1] of BYTE;  // 返回的文件目录
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_NET_DISK_SERACH_RET = ^NET_DVR_NET_DISK_SERACH_RET;

type
  NET_DVR_WD1_CFG = record 
    struStruceHead: NET_DVR_STRUCTHEAD;  
    byWD1Enable: BYTE;  //WD1使能开关 0 关闭 1 开启
    byRes: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_WD1_CFG = ^NET_DVR_WD1_CFG;

type
  NET_DVR_FTPCFG_V40 = record 
    struStruceHead: NET_DVR_STRUCTHEAD;  
    byEnableFTP: BYTE;  //是否启动ftp上传功能，0-否，1-是
    byProtocolType: BYTE;  //协议类型 0-FTP，1-SFTP
    wFTPPort: WORD;  //端口
    unionServer: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..64-1] of BYTE;  //服务器地址，可以使IPv4 IPv6或是域名
        byRes1: array[0..80-1] of BYTE;  
      end);  
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  //IP地址:IPv4 IPv6地址, 144字节
      end);  
    end;  //使用联合体结构，防止既是IP地址又是域名的情况
    szUserName: array[0..32-1] of BYTE;  //用户名
    szPassWORD: array[0..16-1] of BYTE;  //密码
    szTopCustomDir: array[0..64-1] of BYTE;  //自定义一级目录
    szSubCustomDir: array[0..64-1] of BYTE;  //自定义二级目录
    byDirLevel: BYTE;  //0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录
    byTopDirMode: BYTE;  { 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                0x4=使用显示点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,0x8=方向,0x9=地点}
    bySubDirMode: BYTE;  {二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,0x9 = 车位编号}
    byType: BYTE;  // 0-主服务器，1-备服务器
    byEnableAnony: BYTE;  //启用匿名 0-否 1是
    byAddresType: BYTE;  //0 使用IPV4、IPV6  1- 使用域名
    byFTPPicType: BYTE;  //0-保留，1-停车场抓拍图片命名规则
    byPicArchivingInterval: BYTE;  //图片归档间隔[1~30],0表示关闭
    struPicNameRule: NET_DVR_PICTURE_NAME_EX;  { 图片命名规则:
    byFTPPicType ==1的时候,自数组内的命名规则是停车场抓拍图片命名规则}
    byPicNameRuleType: BYTE;  //图片命令规则类型；0~默认类型，1~图片前缀名定义(启用struPicNameRule中的byPicNamePrefix字段)
    byRes: array[0..203-1] of BYTE;  //保留
  end;
  LPNET_DVR_FTPCFG_V40 = ^NET_DVR_FTPCFG_V40;

type
  NET_DVR_FTP_TYPE = record 
    byType: BYTE;  // 0-主服务器，1-备服务器
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_FTP_TYPE = ^NET_DVR_FTP_TYPE;

//FTP服务器测试参数结构体
type
  NET_DVR_FTP_SERVER_TEST_PARA = record 
    dwSize: DWORD;  
    byEnableFTP: BYTE;  //是否启动ftp上传功能，0-否，1-是
    byProtocolType: BYTE;  //协议类型 0-FTP，1-SFTP
    wFTPPort: WORD;  //端口
    unionServer: record 
      case Byte of
      0: (byRes: array[0..144-1] of BYTE);  
      1: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //服务器地址，可以使IPv4 IPv6或是域名
        byRes1: array[0..80-1] of BYTE;  
      end);  
      2: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  //IP地址:IPv4 IPv6地址, 144字节
      end);  
    end;  //使用联合体结构，防止既是IP地址又是域名的情况

    szUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    szPassWORD: array[0..PASSWD_LEN-1] of BYTE;  //密码
    szTopCustomDir: array[0..MAX_CUSTOM_DIR-1] of BYTE;  //自定义一级目录
    szSubCustomDir: array[0..MAX_CUSTOM_DIR-1] of BYTE;  //自定义二级目录
    byDirLevel: BYTE;  //0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录
    byTopDirMode: BYTE;  { 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                                    0x4=使用显示点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,
                                    0x8=方向,0x9=地点}
    bySubDirMode: BYTE;  {二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                                    0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,
                                    0x9 = 车位编号}
    byType: BYTE;  // 0-主服务器，1-备服务器
    byEnableAnony: BYTE;  //启用匿名 0-否 1是
    byAddresType: BYTE;  //0 使用IPV4、IPV6  1- 使用域名

    byRes2: array[0..198-1] of BYTE;  
  end;
  LPNET_DVR_FTP_SERVER_TEST_PARA = ^NET_DVR_FTP_SERVER_TEST_PARA;

const
  NET_SDK_ACCESS_KEY_LEN = 64;    //访问密码长度
  NET_SDK_SECRET_KEY_LEN = 64;    //加密密码长度

//服务器测试结构体
type
  NET_DVR_SERVER_TEST_PARA = record 
    dwSize: DWORD;  
    unionServerPara: record 
      case Byte of
      0: (byRes: array[0..740-1] of BYTE);  
      1: (struNtpPara: record
        struNtpPara: NET_DVR_NTPPARA;  //NTP服务器测试参数80字节
        byRes1: array[0..660-1] of BYTE;  
      end);  
      2: (struNasPara: record
        struNasPara: NET_DVR_SINGLE_NET_DISK_INFO_V40;  //NAS服务器测试参数480字节
        byRes1: array[0..260-1] of BYTE;  
      end);  
      3: (struFtpPara: record
        struFtpPara: NET_DVR_FTP_SERVER_TEST_PARA;  //FTP服务器测试参数528字节
        byRes1: array[0..212-1] of BYTE;  
      end);  
      4: (struEmailPara: record
        struEmailPara: NET_DVR_EMAILCFG_V30;  //Email服务器测试参数660字节
        byRes1: array[0..80-1] of BYTE;  
      end);  
      5: (struIpPara: record
        struIp: NET_DVR_IPADDR;  //IP冲突测试参数24字节
        byRes1: array[0..716-1] of BYTE;  
      end);  
      6: (struCloudStoragePara: record
        struIPAdder: NET_DVR_IPADDR;  
        wPort: WORD;  //端口号
        byRes2: array[0..2-1] of BYTE;  
        szUser: array[0..CLOUD_NAME_LEN{48}-1] of AnsiChar;  //用户名
        szPassword: array[0..CLOUD_PASSWD_LEN{48}-1] of AnsiChar;  // 密码
        struPoolInfo: array[0..16-1] of NET_DVR_POOLPARAM;  // 数组0表示卡口图片数据池，数组1表示违章图片数据池，数组2表示车辆侦测数据池（IPC/D）
        byProtocolType: BYTE;  //云存储协议版本，0- 1.0版本，1- 2.0版本
        byRes3: array[0..3-1] of BYTE;  
        szAccessKey: array[0..NET_SDK_ACCESS_KEY_LEN{64}-1] of AnsiChar;  //访问密码
        szSecretKey: array[0..NET_SDK_SECRET_KEY_LEN{64}-1] of AnsiChar;  //加密密码
        byRes1: array[0..354-1] of BYTE;  
      end);  
      7: (struPhoneNumPara: record
        byPhoneNum: array[0..MAX_PHONE_NUM{32}-1] of BYTE;  
        byRes1: array[0..708-1] of BYTE;  
      end);  //短信测试
    end;  
    byRes2: array[0..800-1] of BYTE;  
  end;
  LPNET_DVR_SERVER_TEST_PARA = ^NET_DVR_SERVER_TEST_PARA;

type
  NET_DVR_GOP_INFO = record //获取GOP索引信息结构体,建立连接时使用
    dwSize: DWORD;  //结构体大小
    lChannel: LONG;  //通道号
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    byRes: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_GOP_INFO = ^NET_DVR_GOP_INFO;

type
  NET_DVR_GOP_INFO_RET = record 
    struGopTime: NET_DVR_TIME_V30;  //Gop信息时间点
    dwDuration: DWORD;  //信息持续时间
    dwDataSize: DWORD;  //指针pBuf大小
    byRes: array[0..128-1] of BYTE;  
    pBuf: PAnsiChar;  //Gop信息块
  end;
  LPNET_DVR_GOP_INFO_RET = ^NET_DVR_GOP_INFO_RET;

type
  NET_DVR_GOP_INFO_PASSBACK = record //智能数据信息回填
    dwSize: DWORD;  //结构体大小
    struTime: NET_DVR_TIME_V30;  //开始时间,当数据类型为智能元数据时，表示的开始时间，当为缩略图时，表示的是图片时间
    dwDuration: DWORD;  //信息持续时间，仅当数据类型为智能元数据时有效
    dwMetaDataSize: DWORD;  //数据源的大小
    dwPicDataSize: DWORD;  //图片数据大小
    pMetaDataBuffer: PAnsiChar;  //智能元数据缓冲区
    pPicDataBuf: PAnsiChar;  //图片缓冲区
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_GOP_INFO_PASSBACK = ^NET_DVR_GOP_INFO_PASSBACK;

type
  NET_DVR_SINGLEWALLPARAM = record 
    dwSize: DWORD;  
    byEnable: BYTE;  
    byRes1: array[0..3-1] of BYTE;  
    dwWallNum: DWORD;  //电视墙输出号
    //坐标须为基准坐标的整数倍（128×128），宽度和高度值不用设置，即为基准值
    struRectCfg: NET_DVR_RECTCFG;  
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_SINGLEWALLPARAM = ^NET_DVR_SINGLEWALLPARAM;

//窗口信息
type
  NET_DVR_WALLWINCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  
    byRes1: array[0..7-1] of BYTE;  
    dwWinNum: DWORD;  //窗口号
    dwLayerIndex: DWORD;  //窗口相对应的图层号
    struWinPosition: NET_DVR_RECTCFG;  //目的窗口(相对显示墙)
    dwDeviceIndex: DWORD;  //分布式大屏控制器设备序号
    wInputIndex: WORD;  //输入信号源
    byRes2: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_WALLWINCFG = ^NET_DVR_WALLWINCFG;

type
  NET_DVR_WALL_INDEX = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙序号，从1开始
    bySceneNo: BYTE;  //场景序号
    byRes1: array[0..2-1] of BYTE;  
    dwDeviceID: DWORD;  //分布式子设备ID
    dwWindowNo: DWORD;  //窗口序号/信号源序号
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WALL_INDEX = ^NET_DVR_WALL_INDEX;

type
  NET_DVR_WALLWINPARAM = record 
    dwSize: DWORD;  
    byTransparency: BYTE;  //使能透明度，0-关，非0-开
    byWinMode: BYTE;  //窗口分屏模式，能力集获取
    byEnableSpartan: BYTE;  //畅显使能，0-关，1-开
    byDecResource: BYTE;  //为窗口分配的解码资源，1-D1,2-720P,3-1080P
    byWndShowMode: BYTE;  //窗口显示模式，0-此字段不用，1-子窗口模式，2-子窗口全屏模式
    byEnabledFeature: BYTE;  //是否启用场景特写，0-不启用，!0-启用
    byFeatureMode: BYTE;  //特写模式，启用场景特写时有效，0-无效，1-“1+5”模式
    byRes1: BYTE;  
    dwAmplifyingSubWndNo: DWORD;  //全屏子窗口号（1字节墙号+1字节子窗口号+2字节窗口号）
                                                                  //当byWndShowMode为2时有效，表示当前全屏显示的子窗口
    byWndTopKeep: BYTE;  //窗口置顶保持，0-不保持，1-保持
    byWndOpenKeep: BYTE;  //窗口打开保持，0-不保持，1-保持
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_WALLWINPARAM = ^NET_DVR_WALLWINPARAM;

type
  NET_DVR_WALLSCENECFG = record 
    dwSize: DWORD;  
    sSceneName: array[0..NAME_LEN-1] of BYTE;  //场景名称
    byEnable: BYTE;  //场景是否有效，0-无效，1-有效
    bySceneIndex: BYTE;  //场景号，只能获取。获取所有场景时使用该参数
    byRes: array[0..78-1] of BYTE;  
  end;
  LPNET_DVR_WALLSCENECFG = ^NET_DVR_WALLSCENECFG;

type
  NET_DVR_WALLWIN_INFO = record 
    dwSize: DWORD;  
    dwWinNum: DWORD;  //窗口号
    dwSubWinNum: DWORD;  //子窗口号
    dwWallNo: DWORD;  //墙号
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_WALLWIN_INFO = ^NET_DVR_WALLWIN_INFO;

type
  NET_DVR_WALL_WIN_STATUS = record 
    dwSize: DWORD;  
    byDecodeStatus: BYTE;  //当前解码状态:0:未启动,1 :已启动
    byStreamType: BYTE;  //码流类型
    byPacketType: BYTE;  //打包方式
    byFpsDecV: BYTE;  //视频解码帧率
    byFpsDecA: BYTE;  //音频解码帧率
    byRes1: array[0..7-1] of BYTE;  
    dwDecodedV: DWORD;  //解码的视频帧
    dwDecodedA: DWORD;  //解码的音频帧
    wImgW: WORD;  //当前码流源的图像大小
    wImgH: WORD;  
    byStreamMode: BYTE;  //码流源(此参数对视频综合平台有效)：1-网络，2-综合平台内部编码子系统，3-屏幕服务器，0xff-无效
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_WALL_WIN_STATUS = ^NET_DVR_WALL_WIN_STATUS;

type
  NET_DVR_WININDEX_INFO = record 
    dwWinIndex: DWORD;  //窗口号
    dwSubWinIndex: DWORD;  //子窗口号
    byType: BYTE;  //资源类型，1-解码，2-回显
    byWallNo: BYTE;  //墙号
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_WININDEX_INFO = ^NET_DVR_WININDEX_INFO;

type
  NET_DVR_ASSOCIATEDDEV_CHAN_INFO = record 
    dwSize: DWORD;  
    sAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //ip地址，或是域名
    wDVRPort: WORD;  // 端口号 
    wChannel: WORD;  // 通道号 
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 布防主机登陆帐号 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 布防主机密码 
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO = ^NET_DVR_ASSOCIATEDDEV_CHAN_INFO;

type
  NET_DVR_WALLOUTPUTPARAM = record 
    dwSize: DWORD;  
    dwResolution: DWORD;  //分辨率
    struRes: NET_DVR_VIDEOEFFECT;  
    byVideoFormat: BYTE;  //视频制式，见VIDEO_STANDARD
    byDisplayMode: BYTE;  //输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，0xff-无效
    byBackgroundColor: BYTE;  //背景色，0-无效，不支持背景色，1-红，2-绿，3-蓝，4-黄，5-紫，6-青，7-黑，8-白，0xff-自定义
    byUseEDIDResolution: BYTE;  //是否使用EDID分辨率，0-不使用，1-使用
    wLEDWidth: WORD;  //LED屏输出分辨率宽
    wLEDHeight: WORD;  //LED屏输出分辨率高
    struBackColor: NET_DVR_RGB_COLOR;  //背景色，byBackgroundColor为0xff时有效
    byLinkStatus: BYTE;  //输出口连接状态，0-无效,1-接入显示器,2-未接入显示器
    byRes2: array[0..51-1] of BYTE;  
  end;
  LPNET_DVR_WALLOUTPUTPARAM = ^NET_DVR_WALLOUTPUTPARAM;

//  MAX_UNITEDMATRIX_NUM = 8;    //级联中最多视频综合平台数量

type
  NET_DVR_SUBMATRIXSYSTEMINFO = record 

    //平台号，0表示无此平台
    dwSequence: DWORD;  
    sAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //ip地址，或是域名
    wSubMatrixPort: WORD;  //子系统端口号
    byRes1: array[0..6-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //密码 
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_SUBMATRIXSYSTEMINFO = ^NET_DVR_SUBMATRIXSYSTEMINFO;

type
  NET_DVR_UNITEDMATRIXSYSTEMINFO = record 
    dwSize: DWORD;  
    //视频综合平台信息
    struMatrixInfo: array[0..MAX_UNITEDMATRIX_NUM-1] of NET_DVR_SUBMATRIXSYSTEMINFO;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_UNITEDMATRIXSYSTEMINFO = ^NET_DVR_UNITEDMATRIXSYSTEMINFO;

type
  NET_DVR_SUBSTREAM_SWITCH_CFG = record 
    byAutoSwitchEnable: BYTE;  //子码流自动切换，0 - 不启用，1 - 启用
    byRes1: array[0..3-1] of BYTE;  
    wSubWndWidth: WORD;  //子窗口宽度设定值，byAutoSwitchEnable为1时有效
    wSubWndHeight: WORD;  //子窗口高度设定值，byAutoSwitchEnable为1时有效
  end;
  LPNET_DVR_SUBSTREAM_SWITCH_CFG = ^NET_DVR_SUBSTREAM_SWITCH_CFG;

type
  NET_DVR_WALL_CFG = record 
    dwSize: DWORD;  
    byTransparency: BYTE;  //透明度,0-100,0为不透明
    byWinStaticMode: BYTE;  //窗口解码停止显示模式，1-清屏(之前的清屏后是黑色)，2-显示最后一帧图像
    byStreamFailedMode: BYTE;  //取流失败显示模式，1-“无网络视频信号”，2-显示最后一帧图像，3-连接异常，4-清屏
    byEnabledOverlayLogo: BYTE;  //解码能力不足时是否叠加LOGO以提示用户，0-不叠加，!0-叠加
    struSubStreamSwitch: NET_DVR_SUBSTREAM_SWITCH_CFG;  //子码流切换
    byLEDShowMode: BYTE;  //LED窗口显示模式，0-普通模式，1-平铺模式
    byLowLatencyMode: BYTE;  //低延时模式，0-普通模式，1-低延时模式
    byRes: array[0..50-1] of BYTE;  
  end;
  LPNET_DVR_WALL_CFG = ^NET_DVR_WALL_CFG;

type
  NET_DVR_LEDDISPLAYINFO = record 
    dwSize: DWORD;  
    byAddressType: BYTE;  //0-实际ipv4 ipv6地址 1-域名
    byRes1: array[0..3-1] of BYTE;  
    // 控制unionServer是使用实际地址还是域名
    unionServer: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //服务器地址，域名
        byRes1: array[0..80-1] of BYTE;  
      end);  
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  {IP地址}//IPv4 IPv6地址, 144字节
      end);  
    end;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64
    szDisplayInfo: array[0..MAX_LEDDISPLAYINFO_LEN{1024}-1] of AnsiChar;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LEDDISPLAYINFO = ^NET_DVR_LEDDISPLAYINFO;


type
  NET_DVR_LOW_LIGHT_CFG = record 
    dwSize: DWORD;  
    byLowLightLimt: BYTE;  // 低照度电子快门: 0-关，1-开 
    byLowLightLimtLevel: BYTE;  
    {球机0-关，1-慢快门*2，2-慢快门*3，3-慢快门*4，4-慢快门*6，5-慢快门*8，6-慢快门*12，7-慢快门*16，
    8-慢快门*24，9-慢快门*32，10-慢快门*48，11-慢快门*64，12-慢快门*96，13-慢快门*128，14-慢快门*256，
    15-慢快门*512, 16-慢快门*1.25, 17-慢快门*1.5 }
    byRes: array[0..66-1] of BYTE;  
  end;
  LPNET_DVR_LOW_LIGHT_CFG = ^NET_DVR_LOW_LIGHT_CFG;

type
  NET_DVR_FOCUSMODE_CFG = record 
    dwSize: DWORD;  
    byFocusMode: BYTE;  // 聚焦模式，0-自动，1-手动，2-半自动 
    byAutoFocusMode: BYTE;  // 自动聚焦模式，0-关，1-模式A，2-模式B，3-模式AB，4-模式C 自动聚焦模式，需要在聚焦模式为自动时才显示
    wMinFocusDistance: WORD;  // 最小聚焦距离，单位CM,  0-自动，0xffff-无穷远 
    byZoomSpeedLevel: BYTE;  // 变倍速度，为实际取值，1-3 
    byFocusSpeedLevel: BYTE;  // 聚焦速度，为实际取值，1-3 
    byOpticalZoom: BYTE;  // 光学变倍，0-255 
    byDigtitalZoom: BYTE;  // 数字变倍，0-255 
    fOpticalZoomLevel: FLOAT;  // 光学变倍(倍率值) [1,32], 最小间隔0.5 ，内部设备交互的时候*1000 
    dwFocusPos: DWORD;  // dwFocusPos 是focus值（聚焦值），范围为[0x1000,0xC000]，这个值是sony坐标值，使用这个值是为了对外统一，保证不同的镜头对外focus值都转换在这个范围内 (手动聚焦模式下下应用)
    byFocusDefinitionDisplay: BYTE;  // 聚焦清晰度显示，0~不显示，1~显示, 开启会在码流上显示当前镜头目标的清晰度值，用于帮助客户调焦使相机抓拍能够达到最清晰的效果，该清晰度越大代表着越清晰，清晰度范围为：0~100.0000
    byFocusSensitivity: BYTE;  //聚焦灵敏度，范围[0,2]，聚焦模式为自动、半自动时生效
    byRes1: array[0..2-1] of BYTE;  
    dwRelativeFocusPos: DWORD;  //相对focus值，其低16位表示聚焦值，0~4000；高16位代表当前聚焦值获取时的温度值
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_FOCUSMODE_CFG = ^NET_DVR_FOCUSMODE_CFG;

type
  NET_DVR_INFRARE_CFG = record 
    dwSize: DWORD;  
    byIrControlMode: BYTE;  // 红外球机配置-控制模式：0-自动，1-手动 
    byIrBrightness: BYTE;  // 红外球机配置-红外亮度：0-100 
    byIrSensitivity: BYTE;  // 红外球机配置-红外灯灵敏度：0-100 
    byIrTrigMode: BYTE;  // 触发模式 0-机芯触发，1-光敏触发 自动模式下生效
    byIrBrightnessLimit: BYTE;  // 亮度限制 如果此值为80，表示的意义是当前红外灯的亮度为原先根据自动策略计算出的亮度值×80% 自动模式下生效
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_INFRARE_CFG = ^NET_DVR_INFRARE_CFG;

type
  NET_DVR_AEMODECFG = record 
    dwSize: DWORD;  
    iIrisSet: INT;  // 光圈，为实际取值*100的值，0-关 
    iGainSet: INT;  // 快球增益，曝光补偿，为实际取值*100的值，有可能是负值 
    iGainLimit: INT;  // 增益限制，曝光补偿，为实际取值*100的值，有可能是负值 
    iExposureCompensate: INT;  // 曝光补偿，为实际取值*100的值，比如1050代表10.5dB, -750代表-7.5dB 
    byExposureModeSet: BYTE;  // 球机的曝光模式,0-手动模式，1-自动曝光，2-光圈优先，3-快门优先，4-增益优先 
    byShutterSet: BYTE;  { 快门，0-关，1-自动x1，2-自动x2，3-自动x4，4-自动x8，5-自动x16，6-自动x32，7-自动x64，8-自动x128，9-1/1，10-1/2，
    11-1/3，12-1/4，13-1/6，14-1/8，15-1/12，16-1/15，17-1/25，18-1/30，19-1/50，20-1/60，21-1/75，
    22-1/90，23-1/100，24-1/120，25-1/125，26-1/150，27-1/180，28-1/200，29-1/215，30-1/250，31-1/300，
    32-1/350，33-1/425，34-1/500，35-1/600，36-1/725，37-1/1000，38-1/1250，39-1500,40-1/1750，41-1/2000，
    42-1/2500，43-3000,44-1/3500，45-1/4000，46-1/6000，47-1/10000，48-1/30000，49-1/100000,50-1/175，
    51-1/195，52-1/225，53-1/230 }
    byImageStabilizeLevel: BYTE;  // 防抖动等级: 0-3 
    byCameraIrCorrect: BYTE;  // 红外校正: 0-自动，1-开，2,关 
    byHighSensitivity: BYTE;  // 高灵敏度设置: 0-关，1-开 
    byInitializeLens: BYTE;  // 初始化镜头: 0-关，1-开 
    byChromaSuppress: BYTE;  // 色彩抑制 :0-255
    byMaxShutterSet: BYTE;  //最大快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    byMinShutterSet: BYTE;  //最小快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    byMaxIrisSet: BYTE;  //最大光圈限制值(自动曝光、快门优先模式) [0,100] ;
    byMinIrisSet: BYTE;  //最小光圈限制值(自动曝光、快门优先模式) [0,100] ;
    byExposureLevel: BYTE;  //曝光等级（曝光模式为自动、光圈优先、快门优先情况有效），等级1-5 默认4，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为曝光等级为1
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_AEMODECFG = ^NET_DVR_AEMODECFG;

type
  NET_DVR_FLASH_CFG = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    dwInNumbers: DWORD;  //进入人数
    dwOutNumbers: DWORD;  //离开人数
    dwStartTime: DWORD;  //开始时间秒数
    dwEndTime: DWORD;  //结束时间秒数
    dwEhomeFlag: DWORD;  //
    dwAlarmFlag: DWORD;  //
    byRes: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_FLASH_CFG = ^NET_DVR_FLASH_CFG;

type
  NET_DVR_EXTERNAL_MATRIX_CFG = record 
    dwSize: DWORD;  
    byValid: BYTE;  // 有效时为设置，无效时为删除
    byRes1: array[0..3-1] of BYTE;  
    sMatrixName: array[0..NAME_LEN{32}-1] of BYTE;  // 矩阵的名称
    dwMatrixID: DWORD;  // 矩阵的ID号，只能获取
    wMatrixInputChanNum: WORD;  // 矩阵的输入通道数目
    wMatrixOutputChanNum: WORD;  // 矩阵的输出通道数目
    wMatrixOutputChanRef: array[0..MAX_CAM_COUNT-1] of WORD;  //// 设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
    //元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
    byMatrixChanType: BYTE;  // 矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
    byMatrixProtocol: BYTE;  // 矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
    byMatrixType: BYTE;  //1-模拟矩阵，2-数字矩阵
    byRes2: BYTE;  
    struMatrixUnion: NET_MATRIX_UNION;  
    byRes3: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_MATRIX_CFG = ^NET_DVR_EXTERNAL_MATRIX_CFG;

type
  NET_DVR_EXTERNAL_MATRIX_CFG_V50 = record 
    dwSize: DWORD;  
    byValid: BYTE;  // 有效时为设置，无效时为删除
    byRes1: array[0..3-1] of BYTE;  
    sMatrixName: array[0..NAME_LEN{32}-1] of BYTE;  // 矩阵的名称
    dwMatrixID: DWORD;  // 矩阵的ID号，只能获取
    wMatrixInputChanNum: WORD;  // 矩阵的输入通道数目
    wMatrixOutputChanNum: WORD;  // 矩阵的输出通道数目
    wMatrixOutputChanRef: array[0..MAX_CAM_COUNT_V50-1] of WORD;  //// 设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
    //元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
    byMatrixChanType: BYTE;  // 矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
    byMatrixProtocol: BYTE;  // 矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
    byMatrixType: BYTE;  //1-模拟矩阵，2-数字矩阵
    byRes2: BYTE;  
    struMatrixUnion: NET_MATRIX_UNION;  
    byRes3: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_MATRIX_CFG_V50 = ^NET_DVR_EXTERNAL_MATRIX_CFG_V50;


const
  MAX_INPUTNUMS = 1024;    
  MAX_OUTPUTNUMS = 256;    
type
  NET_DVR_ASSOCIATE_INPUT_PARAM = record 
    byEnable: BYTE;  
    byRes1: array[0..3-1] of BYTE;  
    dwDeviceIndex: DWORD;  //分布式大屏控制器设备序号
    wInputIndex: WORD;  //输入信号源
    byRes2: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_ASSOCIATE_INPUT_PARAM = ^NET_DVR_ASSOCIATE_INPUT_PARAM;

type
  NET_DVR_ASSOCIATE_OUTPUT_PARAM = record 
    byEnable: BYTE;  
    byWallNo: BYTE;  //墙号，从1开始
    byRes1: array[0..2-1] of BYTE;  
    dwOutputIndex: DWORD;  //输出显示屏的序号
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_ASSOCIATE_OUTPUT_PARAM = ^NET_DVR_ASSOCIATE_OUTPUT_PARAM;

type
  NET_DVR_VCS_USER_INFO = record 
    dwSize: DWORD;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名，最大16字节
    sPassWord: array[0..PASSWD_LEN-1] of BYTE;  // 密码
    struUserIP: NET_DVR_IPADDR;  // 用户IP地址(为0时表示允许任何地址)
    byMacAddr: array[0..MACADDR_LEN-1] of BYTE;  // 物理地址
    byPriority: BYTE;  // 优先级，1-管理员，2-操作员 ，管理员具有任何权限，操作员没有"管理用户"的权限
    byRes1: BYTE;  
    dwRight: DWORD;  //远程操作权限，按位表示，0-不支持，1-支持，各32位代表的权限类型
    //bit0-获取设置基本参数
    //bit1-显示屏管理
    //bit2-窗口管理
    //bit3-信号源管理
    //bit4-布局管理
    //bit5-预案管理
    //bit6-底图管理
    //bit7-OSD管理
    //bit8-回显权限
    //bit9-报警布防
    //bit10-远程升级
    //bit11-恢复默认设置
    //bit12-导入导出配置配置文件
    //bit13-日志查询
    //bit14-远程重启
    //bit15-屏幕区域管理
    struInputParam: array[0..MAX_INPUTNUMS{1024}-1] of NET_DVR_ASSOCIATE_INPUT_PARAM;  
    struOutputParam: array[0..MAX_OUTPUTNUMS{256}-1] of NET_DVR_ASSOCIATE_OUTPUT_PARAM;  
    struManageRegion: NET_DVR_RECTCFG_EX;  //屏幕管理区域
    byWallNo: BYTE;  //开启屏幕管理区域的墙号，对只支持单墙的设备，此字段无效
    byRes2: array[0..3-1] of BYTE;  
    sLoginPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  // 登陆密码
    byRes: array[0..88-1] of BYTE;  end;
  LPNET_DVR_VCS_USER_INFO = ^NET_DVR_VCS_USER_INFO;

type
  NET_DVR_STREAM_MEDIA_SERVER_CFG_V41 = record 
    byValid: BYTE;  //是否启用，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //IP或者域名
    wDevPort: WORD;  //流媒体服务器端口
    byTransmitType: BYTE;  //传输协议类型 0-TCP，1-UDP
    byRes2: array[0..69-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41 = ^NET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

//设备通道信息
type
  NET_DVR_DEV_CHAN_INFO_V41 = record 
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备域名
    wDVRPort: WORD;  //端口号
    byChannel: BYTE;  //通道号
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    byDeviceType: BYTE;  //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    byDispChan: BYTE;  //显示通道号,智能配置使用
    bySubDispChan: BYTE;  //显示通道子通道号，智能配置时使用
    byResolution: BYTE;  //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    byUseZeroChan: BYTE;  //是否使用零通道，0-否，1-是
    byRes: BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //布防主机登陆帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //布防主机密码
  end;
  LPNET_DVR_DEV_CHAN_INFO_V41 = ^NET_DVR_DEV_CHAN_INFO_V41;

type
  NET_DVR_DEV_CHAN_INFO_EX = record 
    byChanType: BYTE;  //通道类型，0-普通通道,1-零通道,2-流ID，3-本地输入源，4-虚拟屏服务器通道，5-拼接通道，6-屏幕服务器，7-分布式网络源，8-多相机融合通道，9-网络输入源
    byStreamId: array[0..STREAM_ID_LEN-1] of BYTE;  //流ID，当byChanType=2、9时，该字段用于指定流或者网络ipc的ID号
    byRes1: array[0..3-1] of BYTE;  
    dwChannel: DWORD;  //通道号，通道类型为普通通道，零通道，本地输入源，虚拟屏服务器通道，拼接通道，屏幕服务器，分布式网络源时填此字段
    byRes2: array[0..24-1] of BYTE;  
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备域名
    wDVRPort: WORD;  //端口号
    byChannel: BYTE;  //通道号,dwChannel不为0时此字段无效
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    byDeviceType: BYTE;  //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    byDispChan: BYTE;  //显示通道号,智能配置使用
    bySubDispChan: BYTE;  //显示通道子通道号，智能配置时使用
    byResolution: BYTE;  //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    byRes: array[0..2-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  //布防主机登陆帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //布防主机密码
  end;
  LPNET_DVR_DEV_CHAN_INFO_EX = ^NET_DVR_DEV_CHAN_INFO_EX;

type
  NET_DVR_STREAM_MEDIA_SERVER = record 
    byValid: BYTE;  //是否启用，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //IP或者域名
    wDevPort: WORD;  //流媒体服务器端口
    byTransmitType: BYTE;  //传输协议类型 0-TCP，1-UDP
    byRes2: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_STREAM_MEDIA_SERVER = ^NET_DVR_STREAM_MEDIA_SERVER;

type
  NET_DVR_DEV_DDNS_INFO = record 
    byDevAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //域名(IPServer或hiDDNS时可填序列号或者别名)
    byTransProtocol: BYTE;  //传输协议类型0-TCP，1-UDP, 2-MCAST
    byTransMode: BYTE;  //传输码流模式 0－主码流 1－子码流
    byDdnsType: BYTE;  //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
    byRes1: BYTE;  
    byDdnsAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //DDNS服务器地址
    wDdnsPort: WORD;  //DDNS服务器端口号
    byChanType: BYTE;  //0-普通通道,1-零通道,2-流ID
    byFactoryType: BYTE;  //前端设备厂家类型,通过接口获取
    dwChannel: DWORD;  //通道号
    byStreamId: array[0..STREAM_ID_LEN-1] of BYTE;  //流ID
    sUserName: array[0..NAME_LEN-1] of BYTE;  //布防主机登陆帐号
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //布防主机密码
    wDevPort: WORD;  //前端设备通信端口
    byRes2: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_DEV_DDNS_INFO = ^NET_DVR_DEV_DDNS_INFO;

type
  NET_DVR_DEC_STREAM_DEV_EX = record 
    struStreamMediaSvrCfg: NET_DVR_STREAM_MEDIA_SERVER;  
    struDevChanInfo: NET_DVR_DEV_CHAN_INFO_EX;  
  end;
  LPNET_DVR_DEC_STREAM_DEV_EX = ^NET_DVR_DEC_STREAM_DEV_EX;


//DDNS方式取流
type
  NET_DVR_DEC_DDNS_DEV = record 
    struDdnsInfo: NET_DVR_DEV_DDNS_INFO;  
    struMediaServer: NET_DVR_STREAM_MEDIA_SERVER;  
  end;
  LPNET_DVR_DEC_DDNS_DEV = ^NET_DVR_DEC_DDNS_DEV;

type
  NET_DVR_DEC_STREAM_MODE = record 
    case Byte of
    0: (struDecStreamDev: NET_DVR_DEC_STREAM_DEV_EX);  
    1: (struUrlInfo: NET_DVR_PU_STREAM_URL);  
    2: (struDdnsDecInfo: NET_DVR_DEC_DDNS_DEV);  
    3: (byRes: array[0..300-1] of BYTE);  
  end;
  LPNET_DVR_DEC_STREAM_MODE = ^NET_DVR_DEC_STREAM_MODE;

type
  NET_DVR_PU_STREAM_CFG_V41 = record 
    dwSize: DWORD;  
    byStreamMode: BYTE;  //取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
    byStreamEncrypt: BYTE;  //是否进行码流加密处理,0-不支持,1-支持
    byRes1: array[0..2-1] of BYTE;  
    uDecStreamMode: NET_DVR_DEC_STREAM_MODE;  //取流信息
    dwDecDelayTime: DWORD;  //解码延时时间，单位：毫秒
    sStreamPassword: array[0..STREAM_PASSWD_LEN-1] of BYTE;  //码流加密密码,需敏感信息加密
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_PU_STREAM_CFG_V41 = ^NET_DVR_PU_STREAM_CFG_V41;

type
  NET_DVR_MATRIX_CHAN_INFO_V41 = record 
    byEnable: BYTE;  //是否启用，0-否，1-是
    byStreamMode: BYTE;  //取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
    byRes: array[0..2-1] of BYTE;  
    uDecStreamMode: NET_DVR_DEC_STREAM_MODE;  //取流信息
  end;
  LPNET_DVR_MATRIX_CHAN_INFO_V41 = ^NET_DVR_MATRIX_CHAN_INFO_V41;

type
  NET_DVR_MATRIX_LOOP_DECINFO_V41 = record 
    dwSize: DWORD;  
    dwPoolTime: DWORD;  //轮巡间隔
    struchanConInfo: array[0..MAX_CYCLE_CHAN_V30-1] of NET_DVR_MATRIX_CHAN_INFO_V41;  
    byStreamEncrypt: BYTE;  //是否进行码流加密处理,0-不支持,1-支持
    byRes: array[0..3-1] of BYTE;  
    sStreamPassword: array[0..STREAM_PASSWD_LEN-1] of BYTE;  //码流加密密码,需敏感信息加密
  end;
  LPNET_DVR_MATRIX_LOOP_DECINFO_V41 = ^NET_DVR_MATRIX_LOOP_DECINFO_V41;

type
  NET_DVR_MATRIX_DEC_CHAN_INFO_V41 = record 
    dwSize: DWORD;  
    byStreamMode: BYTE;  //取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流
    byRes1: array[0..3-1] of BYTE;  
    uDecStreamMode: NET_DVR_DEC_STREAM_MODE;  //取流信息
    dwPlayMode: DWORD;  // 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 
    StartTime: NET_DVR_TIME;  // 按时间回放开始时间 
    StopTime: NET_DVR_TIME;  // 按时间回放停止时间 
    sFileName: array[0..128-1] of BYTE;  // 按文件回放文件名 
    dwGetStreamMode: DWORD;  //取流模式:1-主动，2-被动
    struPassiveMode: NET_DVR_MATRIX_PASSIVEMODE;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 = ^NET_DVR_MATRIX_DEC_CHAN_INFO_V41;

type
  NET_DVR_IP_ADDRESS = record 
    byDevAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备IP地址
    wDevPort: WORD;  //设备端口
    byres: array[0..134-1] of BYTE;  
  end;
  LPNET_DVR_IP_ADDRESS = ^NET_DVR_IP_ADDRESS;

type
  NET_DVR_DDNS_ADDRESS = record 
    byDevAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //DDNS域名
    byDevDdns: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备地址
    byDdnsType: BYTE;  //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，//3- NO-IP, 4- hiDDNS
    byRes1: array[0..3-1] of BYTE;  
    wDevPort: WORD;  //设备端口
    wDdnsPort: WORD;  //域名服务器端口
    byres: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DDNS_ADDRESS = ^NET_DVR_DDNS_ADDRESS;

type
  NET_DVR_PLAY_BACK_BY_TIME = record 
    StartTime: NET_DVR_TIME;  
    StopTime: NET_DVR_TIME;  
  end;
  LPNET_DVR_PLAY_BACK_BY_TIME = ^NET_DVR_PLAY_BACK_BY_TIME;

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX = record 
    dwSize: DWORD;  
    dwDecChannel: DWORD;  //解码通道号
    byAddressType: BYTE;  //设备地址类型，0-IP，1-DDNS
    byChannelType: BYTE;  //通道类型，0-普通通道，1-零通道，2-流ID
    byres: array[0..2-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwChannel: DWORD;  // 设备通道号 
    byStreamId: array[0..STREAM_ID_LEN-1] of BYTE;  //流ID,此参数在通道类型为流ID时有效
    dwPlayMode: DWORD;  // 0－按文件 1－按时间
    unionAddr: record 
      case Byte of
      0: (byRes: array[0..200-1] of BYTE);  
      1: (struIpAddr: NET_DVR_IP_ADDRESS);  
      2: (struDdnsAddr: NET_DVR_DDNS_ADDRESS);  
    end;  

    unionPlayBackInfo: record 
      case Byte of
      0: (byRes: array[0..128-1] of BYTE);  
      1: (struPlayBackByTime: NET_DVR_PLAY_BACK_BY_TIME);  //按时间回放时文件信息
      2: (sFileName: array[0..128-1] of AnsiChar);  //按文件名回放时文件信息
    end;  
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_V50 = record 
    dwSize: DWORD;  
    dwDecChannel: DWORD;  //解码通道号
    byAddressType: BYTE;  //设备地址类型，0-IP，1-DDNS，2-URL
    byChannelType: BYTE;  //通道类型，0-普通通道，1-零通道，2-流ID
    byStreamEncrypt: BYTE;  //是否进行码流加密处理,0-不支持,1-支持
    byRes1: array[0..1-1] of BYTE;  
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 用户名 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 密码 
    dwChannel: DWORD;  // 设备通道号 
    byStreamId: array[0..STREAM_ID_LEN-1] of BYTE;  //流ID,此参数在通道类型为流ID时有效
    dwPlayMode: DWORD;  // 0－按文件 1－按时间
    unionAddr: record 
      case Byte of
      0: (byRes: array[0..200-1] of BYTE);  
      1: (struIpAddr: NET_DVR_IP_ADDRESS);  //IP地址，byAddressType为0时有效
      2: (struDdnsAddr: NET_DVR_DDNS_ADDRESS);  //DDNS地址，byAddressType为1时有效
    end;  
    unionPlayBackInfo: record 
      case Byte of
      0: (byRes: array[0..128-1] of BYTE);  
      1: (struPlayBackByTime: NET_DVR_PLAY_BACK_BY_TIME);  //按时间回放时文件信息
      2: (sFileName: array[0..128-1] of BYTE);  //按文件名回放时文件信息
    end;  
    struURL: NET_DVR_PU_STREAM_URL;  //取流URL，byAddressType为2时有效
    sStreamPassword: array[0..STREAM_PASSWD_LEN-1] of BYTE;  //码流加密密码,需敏感信息加密
    byRes2: array[0..116-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50 = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_V50;

type
  NET_DVR_DISPLAY_EFFECT_CFG = record 
    dwSize: DWORD;  
    struColor: NET_DVR_COLOR;  //显示相关参数/
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAY_EFFECT_CFG = ^NET_DVR_DISPLAY_EFFECT_CFG;

//获取干线状态
type
  NET_DVR_TRUNK_USE_STATE = record 
    dwSize: DWORD;  
    dwTrunkID: DWORD;  //干线ID
    wReserveUserID: WORD;  //预留的用户ID： 1~256 ，0表示释放预留
    byStatus: BYTE;  //1-空闲，2-占用，3-复用 }
    byRes1: BYTE;  
    byUserId: array[0..256-1] of BYTE;  //数组下标表示用户ID号，数组元素的值表示是否使用干线。如：byUserID[0] 的值为1，表示用户ID为0的用户正在使用，byUserID[0] 的值为0表示用户ID为0的用户没有使用这条干线
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_TRUNK_USE_STATE = ^NET_DVR_TRUNK_USE_STATE;


//PTZ控制参数
type
  NET_DVR_PTZ_CTRL_INFO = record 
    dwSize: DWORD;  
    dwCtrlDelayTime: DWORD;  //PTZ控制持续时间，指PTZ控制后在dwCtrlDelayTime时间内，其他同级别或低级别用户对其操作无效。单位：秒
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_CTRL_INFO = ^NET_DVR_PTZ_CTRL_INFO;

//显示路径
const
  MAX_MATRIX_CASCADE = 32;    
type
  NET_DVR_MATRIX_ROUTE_INFO = record 
    dwSize: DWORD;  
    dwCamNo: DWORD;  
    dwMonNo: DWORD;  
    dwSubWin: DWORD;  
    dwUserId: DWORD;  
    dwTrunkId: array[0..MAX_MATRIX_CASCADE{32}-1] of DWORD;  //trunkId成员对应级联级数从1到32，从CAM端开始，trunkId[0]表示第一级级联，trunkId[1]表示第二级级联, trunkId[i] = 0 表示无干线
    byRes: array[0..64-1] of BYTE;  // 预留 
  end;
  LPNET_DVR_MATRIX_ROUTE_INFO = ^NET_DVR_MATRIX_ROUTE_INFO;


//获取PTZ状态
type
  NET_DVR_PTZ_STATUS = record 
    dwSize: DWORD;  
    dwUserID: DWORD;  //1~256，0 表示无用户
    dwStatus: DWORD;  // PTZ控制状态0-停止、1-运行
    dwRestTime: DWORD;  //剩余时间
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_STATUS = ^NET_DVR_PTZ_STATUS;

type
  NET_DVR_SAFETYCABIN_WORK_MODE = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //工作模式，0-无人门常开，1-无人门常锁
    byFaintToUnlock: BYTE;  //晕倒报警一定时间后外部可以开锁：0-否，1-是
    byOvertimeToUnlock: BYTE;  //使用超时后外部按钮是否可以开锁：0-否，1-是
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_SAFETYCABIN_WORK_MODE = ^NET_DVR_SAFETYCABIN_WORK_MODE;

type
  NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG = record 
    dwSize: DWORD;  
    bySensorType: BYTE;  //传感器类型，0-红外对射型，1-幕帘传感器
    bySensitivity: BYTE;  //传感器敏感度，范围：0-100%
    byDevUseTimeout: BYTE;  //防护舱使用超时时间，单位：分,范围：5-30，默认超时15min,超时后通过布防通道上传报警
    byRes1: BYTE;  
    wCurtainDelayTime: WORD;  //幕帘传感器探测延时时间，单位：秒，范围：0-10
    wCurtainResponseTime: WORD;  //幕帘人状态变化控制器响应时间，单位：秒，范围：0-300
    wFaintToEmergencyTime: WORD;  //晕倒告警生效时间，单位：秒，范围：10-300
    byFollowDetectorSensitivity: BYTE;  //尾随检测灵敏度，范围：0-100%
    byManyPersonSensitivity: BYTE;  //多人检测灵敏度，范围：0-100%
    byRes2: array[0..28-1] of BYTE;  //保留
  end;
  LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG = ^NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;

type
  NET_DVR_ETHERNET_IPV6_COND = record 
    dwSize: DWORD;  
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //网卡的物理地址
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_ETHERNET_IPV6_COND = ^NET_DVR_ETHERNET_IPV6_COND;

type
  NET_DVR_ETHERNET_IPV6_CFG = record 
    dwSize: DWORD;  
    byState: BYTE;  //IPv6状态，0-路由分配，1-自动设置
    byRes1: array[0..3-1] of BYTE;  
    byIPv6: array[0..MAX_IPV6_LEN-1] of BYTE;  //IPv6地址
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_ETHERNET_IPV6_CFG = ^NET_DVR_ETHERNET_IPV6_CFG;

type
  NET_DVR_DAYTIME = record 
    byHour: BYTE;  //0~24
    byMinute: BYTE;  //0~60
    bySecond: BYTE;  //0~60
    byRes: BYTE;  
    wMilliSecond: WORD;  //0~1000
    byRes1: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_DAYTIME = ^NET_DVR_DAYTIME;

type
  NET_DVR_SCHEDULE_DAYTIME = record 
    struStartTime: NET_DVR_DAYTIME;  //开始时间
    struStopTime: NET_DVR_DAYTIME;  //结束时间
  end;
  LPNET_DVR_SCHEDULE_DAYTIME = ^NET_DVR_SCHEDULE_DAYTIME;

type
  NET_DVR_DNMODE = record 
    byObjectSize: BYTE;  //占比参数(0~100)
    byMotionSensitive: BYTE;  //移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_DNMODE = ^NET_DVR_DNMODE;

type
  NET_DVR_MOTION_MULTI_AREAPARAM = record 
    byAreaNo: BYTE;  //区域编号(IPC- 1~8)
    byRes: array[0..3-1] of BYTE;  
    struRect: NET_VCA_RECT;  //单个区域的坐标信息(矩形) size = 16;
    struDayNightDisable: NET_DVR_DNMODE;  //关闭模式
    struDayModeParam: NET_DVR_DNMODE;  //白天模式
    struNightModeParam: NET_DVR_DNMODE;  //夜晚模式
    byRes1: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_MOTION_MULTI_AREAPARAM = ^NET_DVR_MOTION_MULTI_AREAPARAM;

type
  NET_DVR_MOTION_MULTI_AREA = record 
    byDayNightCtrl: BYTE;  //日夜控制 0~关闭,1~自动切换,2~定时切换(默认关闭)
    byAllMotionSensitive: BYTE;  //移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭，全部区域的灵敏度范围
    byRes: array[0..2-1] of BYTE;  //
    struScheduleTime: NET_DVR_SCHEDULE_DAYTIME;  //切换时间  16
    struMotionMultiAreaParam: array[0..MAX_MULTI_AREA_NUM-1] of NET_DVR_MOTION_MULTI_AREAPARAM;  //最大支持24个区域
    byRes1: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_MOTION_MULTI_AREA = ^NET_DVR_MOTION_MULTI_AREA;//1328

type
  NET_DVR_MOTION_SINGLE_AREA = record 
    byMotionScope: array[0..64-1, 0..96-1] of BYTE;  //侦测区域,0-96位,表示64行,共有96*64个小宏块,目前有效的是22*18,为1表示是移动侦测区域,0-表示不是
    byMotionSensitive: BYTE;  //移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_MOTION_SINGLE_AREA = ^NET_DVR_MOTION_SINGLE_AREA;

type
  NET_DVR_MOTION_MODE_PARAM = record 
    struMotionSingleArea: NET_DVR_MOTION_SINGLE_AREA;  //普通模式下的单区域设
    struMotionMultiArea: NET_DVR_MOTION_MULTI_AREA;  //专家模式下的多区域设置
  end;
  LPNET_DVR_MOTION_MODE_PARAM = ^NET_DVR_MOTION_MODE_PARAM;

type
  NET_DVR_MOTION_V40 = record 
    struMotionMode: NET_DVR_MOTION_MODE_PARAM;  //(5.1.0新增)
    byEnableHandleMotion: BYTE;  // 是否处理移动侦测 0－否 1－是
    byEnableDisplay: BYTE;  //启用移动侦测高亮显示，0-否，1-是
    byConfigurationMode: BYTE;  //0~普通,1~专家(5.1.0新增)
    byKeyingEnable: BYTE;  //启用键控移动侦测 0-不启用，1-启用
    // 异常处理方式 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x1000: 抓图上传到云
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40-1] of DWORD;  //实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    //触发的录像通道
    dwMaxRecordChanNum: DWORD;  //设备支持的最大关联录像通道数-只读
    dwRelRecordChan: array[0..MAX_CHANNUM_V40-1] of DWORD;  // 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwRelRecordChan -1有效，如果中间遇到0xffffffff,则后续无效
    byDiscardFalseAlarm: BYTE;  //启用去误报 0-无效，1-不启用，2-启用
    byRes: array[0..127-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_MOTION_V40 = ^NET_DVR_MOTION_V40;

type
  NET_DVR_HIDEALARM_V40 = record 
    dwEnableHideAlarm: DWORD;  // 是否启动遮挡报警，0-否，1-低灵敏度，2-中灵敏度，3-高灵敏度
    wHideAlarmAreaTopLeftX: WORD;  // 遮挡区域的x坐标 
    wHideAlarmAreaTopLeftY: WORD;  // 遮挡区域的y坐标 
    wHideAlarmAreaWidth: WORD;  // 遮挡区域的宽 
    wHideAlarmAreaHeight: WORD;  //遮挡区域的高
    // 信号丢失触发报警输出 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x1000:抓图上传到云
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40-1] of DWORD;  //触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_HIDEALARM_V40 = ^NET_DVR_HIDEALARM_V40;//遮挡报警

type
  NET_DVR_VILOST_V40 = record 
    dwEnableVILostAlarm: DWORD;  // 是否启动信号丢失报警 ,0-否,1-是
    // 信号丢失触发报警输出 
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    //0x1000:抓图上传到云
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40-1] of DWORD;  //触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    byVILostAlarmThreshold: BYTE;  //信号丢失报警阈值，当值低于阈值，认为信号丢失，取值0-99
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_VILOST_V40 = ^NET_DVR_VILOST_V40;//信号丢失报警

type
  NET_DVR_VICOLOR = record 
    struColor: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_COLOR;  //图象参数(第一个有效，其他三个保留)
    struHandleTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //处理时间段(保留)
  end;
  LPNET_DVR_VICOLOR = ^NET_DVR_VICOLOR;

type
  NET_DVR_PICCFG_V40 = record 
    dwSize: DWORD;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  
    dwVideoFormat: DWORD;  // 只读 视频制式 1-NTSC 2-PAL  
    struViColor: NET_DVR_VICOLOR;  //    图像参数按时间段设置
    //显示通道名
    dwShowChanName: DWORD;  // 预览的图象上是否显示通道名称,0-不显示,1-显示
    wShowNameTopLeftX: WORD;  // 通道名称显示位置的x坐标 
    wShowNameTopLeftY: WORD;  // 通道名称显示位置的y坐标 
    //隐私遮挡
    dwEnableHide: DWORD;  // 是否启动遮挡 ,0-否,1-是
    struShelter: array[0..MAX_SHELTERNUM-1] of NET_DVR_SHELTER;  
    //OSD
    dwShowOsd: DWORD;  // 预览的图象上是否显示OSD,0-不显示,1-显示
    wOSDTopLeftX: WORD;  // OSD的x坐标 
    wOSDTopLeftY: WORD;  // OSD的y坐标 
    byOSDType: BYTE;  // OSD类型(主要是年月日格式) 
    // 0: XXXX-XX-XX 年月日 
    // 1: XX-XX-XXXX 月日年 
    // 2: XXXX年XX月XX日 
    // 3: XX月XX日XXXX年 
    // 4: XX-XX-XXXX 日月年
    // 5: XX日XX月XXXX年 
    //6: xx/xx/xxxx(月/日/年) 
    //7: xxxx/xx/xx(年/月/日) 
    //8: xx/xx/xxxx(日/月/年)
    byDispWeek: BYTE;  // 是否显示星期 
    byOSDAttrib: BYTE;  // OSD属性:透明，闪烁 
    // 0: 不显示OSD 
    // 1: 透明，闪烁 
    // 2: 透明，不闪烁 
    // 3: 不透明，闪烁 
    // 4: 不透明，不闪烁 
    byHourOSDType: BYTE;  // OSD小时制:0-24小时制,1-12小时制 
    byFontSize: BYTE;  //16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 7-80*80(中)/40*80(英) 8-112*112(中)/56*112(英) 0xff-自适应(adaptive)
    byOSDColorType: BYTE;  //0-默认（黑白）；1-自定义；2-勾边
    {当对齐方式选择国标模式时，可以分别对右下角、左下角两个区域做字符叠加。
    右下角区域：
    共支持6行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V30/ NET_DVR_GET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第0至第5个下标的值。叠加字符的方式为从下到上的方式。
    左下角区域：
    共支持2行字符叠加，可以通过NET_DVR_SET_SHOWSTRING_V3/ NET_DVR_GET_SHOWSTRING_V30字符叠加接口，对应NET_DVR_SHOWSTRINGINFO结构体数组中的第6和第7个下标的值。叠加字符的方式为从下到上的方式。
    }
    byAlignment: BYTE;  //对齐方式 0-自适应，1-右对齐, 2-左对齐，3-国标模式，4-全部右对齐(包含叠加字符、时间以及标题等所有OSD字符)，5-全部左对齐(包含叠加字符、时间以及标题等所有OSD字符)
    byOSDMilliSecondEnable: BYTE;  //视频叠加时间支持毫秒；0~不叠加, 1-叠加
    struVILost: NET_DVR_VILOST_V40;  //视频信号丢失报警（支持组）
    struAULost: NET_DVR_VILOST_V40;  //音频信号丢失报警（支持组）
    struMotion: NET_DVR_MOTION_V40;  //移动侦测报警（支持组）
    struHideAlarm: NET_DVR_HIDEALARM_V40;  //遮挡报警（支持组）
    struOsdColor: NET_DVR_RGB_COLOR;  //OSD颜色
    dwBoundary: DWORD;  //边界值，左对齐，右对齐以及国标模式的边界值，0-表示默认值，单位：像素;在国标模式下，单位修改为字符个数（范围是，0,1,2）
    struOsdBkColor: NET_DVR_RGB_COLOR;  //自定义OSD背景色
    byOSDBkColorMode: BYTE;  //OSD背景色模式，0-默认，1-自定义OSD背景色
    byUpDownBoundary: BYTE;  //上下最小边界值选项，单位为字符个数（范围是，0,1,2）,国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
    byLeftRightBoundary: BYTE;  //左右最小边界值选项，单位为字符个数（范围是，0,1,2）, 国标模式下无效。byAlignment=3该字段无效，通过dwBoundary进行边界配置，.byAlignment不等于3的情况下， byUpDownBoundary/byLeftRightBoundary配置成功后，dwBoundary值将不生效
    byAngleEnabled: BYTE;  //OSD是否叠加俯仰角信息,0~不叠加, 1-叠加
    wTiltAngleTopLeftX: WORD;  // 俯仰角信息显示位置的x坐标 
    wTiltAngleTopLeftY: WORD;  // 俯仰角信息显示位置的y坐标 
    byRes: array[0..108-1] of BYTE;  
  end;
  LPNET_DVR_PICCFG_V40 = ^NET_DVR_PICCFG_V40;

type
  NET_DVR_ISP_CAMERAPARAMCFG = record //
    dwSize: DWORD;  
    byWorkType: BYTE;  // 0-自适应, 1-定时模式
    byRes: array[0..3-1] of BYTE;  
    //定时模式参数
    struDayNightScheduleTime: NET_DVR_SCHEDULE_DAYTIME;  //日夜定时切换模式(白天时间)
    struSelfAdaptiveParam: NET_DVR_CAMERAPARAMCFG_EX;  //自适应参数
    struDayIspAdvanceParam: NET_DVR_CAMERAPARAMCFG_EX;  //白天参数
    struNightIspAdvanceParam: NET_DVR_CAMERAPARAMCFG_EX;  //夜晚参数
    byRes1: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_ISP_CAMERAPARAMCFG = ^NET_DVR_ISP_CAMERAPARAMCFG;

type
  NET_DVR_DEVSERVER_CFG = record 
    dwSize: DWORD;  
    byIrLampServer: BYTE;  //红外灯设置 0～禁用，1～启用
    bytelnetServer: BYTE;  //telnet设置 0～禁用，1～启用
    byABFServer: BYTE;  //ABF设置 0～启用，1～禁用
    byEnableLEDStatus: BYTE;  //状态指示灯控制 0～禁用，1～启用
    byEnableAutoDefog: BYTE;  //自动除雾控制 0～启用，1～禁用
    byEnableSupplementLight: BYTE;  //补光灯控制0-启用，1-禁用
    byEnableDeicing: BYTE;  //除冰功能 0-关闭，1-开启
    byEnableVisibleMovementPower: BYTE;  // 可见光机芯电源开关 0-关闭，1-开启
    byEnableThermalMovementPower: BYTE;  // 热成像机芯电源开关 0-关闭，1-开启
    byEnablePtzPower: BYTE;  // 云台电源开关 0-关闭，1-开启
    byPowerSavingControl: BYTE;  // 低功耗策略 0-保留 1-休眠模式 2-低功耗模式 低功耗模式下 可见光机芯电源、热成像机芯电源、云台电源控制生效
    byCaptureWithSupplimentLightEnabled: BYTE;  //启用抓拍补光使能 0-关闭，1-开启
    byRes: array[0..244-1] of BYTE;  
  end;
  LPNET_DVR_DEVSERVER_CFG = ^NET_DVR_DEVSERVER_CFG;

type
  NET_DVR_GBT28181_ACCESS_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //28181协议使能 0-关闭 1-开启
    byTransProtocol: BYTE;  //传输协议:0-UDP、1-TCP、默认0-UDP
    wLocalSipPort: WORD;  //1024-65535(IPC设备端)
    szServerID: array[0..MAX_SERVERID_LEN-1] of AnsiChar;  //服务器ID：64字节字符串，仅限数字
    szServerDomain: array[0..MAX_SIPSERVER_ADDRESS_LEN-1] of AnsiChar;  // 服务器域
    szSipServerAddress: array[0..MAX_SIPSERVER_ADDRESS_LEN-1] of AnsiChar;  // SIP服务器地址支持域名和IP地址
    wServerSipPort: WORD;  //服务器SIP端口：1024-65535
    byProtocolVersion: BYTE;  //协议版本 0-GB/T28181-2011(仅支持UDP),1-GB/T28181-2015(支持TCP,UDP),2-GB/T28181-2016
    byTCPConnectMod: BYTE;  //TCP连接模式，使用TCP传输协议时有效，0-无效，1-主动模式，2-被动模式
    szSipUserName: array[0..MAX_SERVERNAME_LEN-1] of AnsiChar;  //SIP用户名称：64字节字符串(第三方SIP终端请求IPC服务时使用)
    szSipAuthenticateID: array[0..MAX_AUTHENTICATEID_LEN-1] of AnsiChar;  //SIP用户认证ID：64字节字符串
    szSipAuthenticatePasswd: array[0..MAX_AUTHENTICATEPASSWD_LEN-1] of AnsiChar;  //SIP用户认证密码：32字节字符串(IPC设备注册到SIP服务器时使用)
    dwRegisterValid: DWORD;  //注册有效期：单位秒，默认3600；
    byHeartbeatInterval: BYTE;  //心跳间隔：单位秒，默认10秒；
    byMaxHeartbeatTimeOut: BYTE;  //最大心跳超时次数：默认3次；
    byStreamType: BYTE;  // 取流类型0～主码流，1～子码流，2～3码流
    byDeviceStatus: BYTE;  //设备是否在线状态，0-保留，1-在线，2-离线
    dwRegisterInterval: DWORD;  //注册间隔:注册失败后再次注册的时间间隔,范围60-600s，默认60s
    dwAutoAllocChannelID: DWORD;  //是否自动分配通道ID,按位表示，0为手动配置，1为自动分配，bit1-自动分配编码通道ID,bit2-自动分配报警输入通道,bit3-自动分配解码通道ID
    szDeviceDomain: array[0..MAX_SIPSERVER_ADDRESS_LEN-1] of AnsiChar;  // 设备域
    byRes4: array[0..116-1] of BYTE;  
  end;
  LPNET_DVR_GBT28181_ACCESS_CFG = ^NET_DVR_GBT28181_ACCESS_CFG;

//GBT28181协议的设备编码通道配置
type
  NET_DVR_GBT28181_CHANINFO_CFG = record 
    dwSize: DWORD;  
    szVideoChannelNumID: array[0..MAX_COMPRESSIONID_LEN-1] of AnsiChar;  //设备视频通道编码ID：64字节字符串，仅限数字
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_GBT28181_CHANINFO_CFG = ^NET_DVR_GBT28181_CHANINFO_CFG;

//GBT28181协议的报警输入通道配置 条件结构
type
  NET_DVR_ALARMIN_INFO = record 
    struStreamInfo: NET_DVR_STREAM_INFO;  
    dwAlarmInChannel: DWORD;  //报警输入通道号
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARMIN_INFO = ^NET_DVR_ALARMIN_INFO;

//GBT28181协议的报警输入通道配置 配置结构
type
  NET_DVR_GBT28181_ALARMINCFG = record 
    dwSize: DWORD;  
    szAlarmInNumID: array[0..MAX_COMPRESSIONID_LEN-1] of AnsiChar;  //设备报警输入编码ID（每一路报警输入不同）：20字节字符串，仅限数字
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_GBT28181_ALARMINCFG = ^NET_DVR_GBT28181_ALARMINCFG;

type
  NET_DVR_CAMERA_SETUPCFG = record 
    dwSize: DWORD;  
    wSetupHeight: WORD;  //架设高度[0,20]，单位：米
    byLensType: BYTE;  //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    bySetupHeightUnit: BYTE;  // 架设高度单位0～M,1~CM
    dwSceneDis: DWORD;  //图像下边缘位置与相机之间的水平距离，单位：厘米
    fPitchAngle: FLOAT;  //相机俯仰角度[-180°, 180°],
    fInclineAngle: FLOAT;  //相机倾斜角度[-180°,180°]
    fRotateAngle: FLOAT;  //相机旋转角度[-180°,180°]
    wVideoDetCoefficient: WORD;  //视频测试系数[0,300](3.6新增)
    byErectMethod: BYTE;  //架设方式0-正装，1-侧装(3.6新增)
    byCameraViewAngle: BYTE;  //摄像机安装视野角度(0-垂直，1-倾斜，默认0-垂直)
    dwHorizontalDistance: DWORD;  //摄像机与出入口水平距离：范围1-1000，默认30，单位cm，注意摄像机角度为倾斜时该项有效
    byDetailLensType: BYTE;  //范围1-100，默认28，单位0.1mm
    byRes: array[0..3-1] of BYTE;  
    fHorFieldAngle: FLOAT;  //相机水平视场角角度[0°, 360°]（抓拍机）
    fVerFieldAngle: FLOAT;  //相机垂直视场角角度[0°, 360°]（抓拍机）,鹰眼范围-90°-90°
    fLableSetupHeight: FLOAT;  //标签到架设相机的高度[0,100]，单位：米
    fMaxViewRadius: FLOAT;  //最大可视半径,0~10000.00米，默认5000米.
    byRes1: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_CAMERA_SETUPCFG = ^NET_DVR_CAMERA_SETUPCFG;

//起止日期段参数结构体
type
  NET_DVR_SCHEDDATE = record 
    byStartMonth: BYTE;  //起始（月）
    byStartDay: BYTE;  //起始（日）
    byStopMonth: BYTE;  //结束（月）
    byStopDay: BYTE;  //结束（日）
  end;
  LPNET_DVR_SCHEDDATE = ^NET_DVR_SCHEDDATE;

//时控输出参数
type
  NET_DVR_OUTPUT_SCHEDULE = record 
    struTime: NET_DVR_SCHEDTIME;  //时间段
    byState: BYTE;  //0C关闭, 1C开启
    byRes: array[0..11-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTPUT_SCHEDULE = ^NET_DVR_OUTPUT_SCHEDULE;

//单条时控输出规则参数
type
  NET_DVR_ONE_OUTPUT_SCHEDULE_RULE = record 
    byEnable: BYTE;  //是否启用规则,0-否,1-是
    byRes1: array[0..3-1] of BYTE;  //保留
    struDate: NET_DVR_SCHEDDATE;  //日期区段
    struOutputSchedule: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_OUTPUT_SCHEDULE;  //最多支持8个时间段的时控输出
    byRes2: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE = ^NET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

//时控输出规则参数
type
  NET_DVR_OUTPUT_SCHEDULE_RULECFG = record 
    dwSize: DWORD;  //结构体大小
    struOutputRule: array[0..MAX_RULE_NUM-1] of NET_DVR_ONE_OUTPUT_SCHEDULE_RULE;  //最多支持8个日期区段的规则配置
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTPUT_SCHEDULE_RULECFG = ^NET_DVR_OUTPUT_SCHEDULE_RULECFG;

//交通统计报警参数
type
  NET_DVR_TPS_ALARMCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用交通统计报警上传
    byRes1: array[0..3-1] of BYTE;  //
    dwInterval: DWORD;  //统计间隔时间（单位：分钟）
    byRes: array[0..248-1] of BYTE;  
  end;
  LPNET_DVR_TPS_ALARMCFG = ^NET_DVR_TPS_ALARMCFG;

type
  NET_DVR_DOWNLOAD_ALARM_RECORD_COND = record 
    dwSize: DWORD;  
    wAlarmRecordID: WORD;  //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    byRes: array[0..130-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND = ^NET_DVR_DOWNLOAD_ALARM_RECORD_COND;

type
  NET_DVR_CABINET_AlARM_PARAMCFG = record 
    sCabinetName: array[0..NAME_LEN-1] of AnsiChar;  
    byAssociateIO: BYTE;  //1-4，0xff， 其中1-4表示具体的IO通道号，0xff表示不启用
    byCabinetState: BYTE;  //0~低电平,1~高电平
    byAlarmIntervalTime: BYTE;  //取值范围1-60，单位：秒
    byRes1: array[0..25-1] of BYTE;  
  end;
  LPNET_DVR_CABINET_AlARM_PARAMCFG = ^NET_DVR_CABINET_AlARM_PARAMCFG;

type
  NET_DVR_CABINET_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //0~不启用，1～启用
    byRes: array[0..3-1] of BYTE;  
    struCabinetCfg: array[0..MAX_CABINET_COUNT-1] of NET_DVR_CABINET_AlARM_PARAMCFG;  
    byRes1: array[0..84-1] of BYTE;  
  end;
  LPNET_DVR_CABINET_CFG = ^NET_DVR_CABINET_CFG;

type
  NET_ITS_GATE_LANE_CFG = record 
    byGateSiteID: array[0..MAX_ID_LEN-1] of BYTE;  //出入口编号
    byGateInfo: array[0..MAX_ID_LEN-1] of BYTE;  //出入口信息描述
    byLaneName: array[0..NAME_LEN-1] of BYTE;  //车道名称
    byValid: BYTE;  //是否启用 0 表示未启用，1表示启用
    byCamLaneId: BYTE;  //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    wLaneid: WORD;  //车道号1～32（索引车道号，可以跳跃 逻辑车道）
    byRelativeIoNum: BYTE;  //逻辑车道号关联的输出口编号
    byDirection: BYTE;  //方向编号;  0 -其他 1 入场  2 出场 3 双向
    byLprMode: BYTE;  //牌识放行配置0 全部进1 除禁止名单进2 允许名单进
    byCardMode: BYTE;  //卡片放行配置0 全部进1 除禁止名单进2 允许名单进
    byGateLaneMode: BYTE;  //出入口放行配置模式 0-全部进 1-只有牌识匹配放行2 只有刷卡匹配放//行 3-牌识或卡片有一个匹配则放行 4-牌识且卡片同时匹配则放行 5-全不进
    //2013-11-19 新增参数
    byCharge: BYTE;  //是否收费 0-不收费，1-收费
    byChargeMode: BYTE;  //收费类型 0-车牌收费，1-卡号收费
    byRes1: BYTE;  
    byLedRelativeIndex: array[0..MAX_INDEX_LED-1] of BYTE;  //LED 索引 (1~255) 紧凑排列，0表示无效，不解析后面的数据
    byGateRelativeIndex: BYTE;  //出入口控制机相对索引
    byFarRrRelativeIndex: BYTE;  // 远距离读卡器相对索引
    byRes: array[0..82-1] of BYTE;  //预留
  end;
  LPNET_ITS_GATE_LANE_CFG = ^NET_ITS_GATE_LANE_CFG;

type
  NET_ITS_IPC_CHAN_LANE_CFG = record 
    dwSize: DWORD;  
    byIpcType: BYTE;  //0-无，1-车牌抓拍，2-人脸抓拍，3-视频安防相机
    byRes: array[0..135-1] of BYTE;  
    struGateLane: array[0..4-1] of NET_ITS_GATE_LANE_CFG;  //车道配置结构体
  end;
  LPNET_ITS_IPC_CHAN_LANE_CFG = ^NET_ITS_IPC_CHAN_LANE_CFG;

//设备远程控制
type
  NET_ITS_REMOTE_COMMAND = record 
    wLaneid: WORD;  //车道号1～32（索引车道号，可以跳跃）
    byCamLaneId: BYTE;  //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    byRes: BYTE;  //预留
    dwCode: DWORD;  //命令码 0x0 开闸 0x1 关闸，其它待扩展
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_ITS_REMOTE_COMMAND = ^NET_ITS_REMOTE_COMMAND;

type
  NET_ITS_REMOTE_CONTROL = record 
    dwSize: DWORD;  
    struRemoteCommand: NET_ITS_REMOTE_COMMAND;  //远程命令结构
  end;
  LPNET_ITS_REMOTE_CONTROL = ^NET_ITS_REMOTE_CONTROL;

//长连接获取通道状态
type
  NET_ITS_ECT_CHANNELSTATE = record 
    dwSize: DWORD;  
    byRecordStatic: BYTE;  //通道是否在录像,0-不录像,1-录像
    bySignalStatic: BYTE;  //连接的信号状态,0-正常,1-信号丢失
    byHardwareStatic: BYTE;  //通道硬件状态,0-正常,1-异常,例如DSP死掉
    byChannelArmState: BYTE;  //接入IPC的布防状态
    dwChannel: DWORD;  //通道号
    dwBitRate: DWORD;  //实际码率
    dwLinkNum: DWORD;  //客户端连接的个数
    struClientIP: array[0..MAX_LINK-1] of NET_DVR_IPADDR;  //客户端的IP地址
    dwIPLinkNum: DWORD;  //如果该通道为IP接入，那么表示IP接入当前的连接数
    byExceedMaxLink: BYTE;  // 是否超出了128路连接数 0 - 未超出, 1-超出
    byRes: array[0..139-1] of BYTE;  // 保留字节
  end;
  LPNET_ITS_ECT_CHANNELSTATE = ^NET_ITS_ECT_CHANNELSTATE;

//外接灯
type
  NET_DVR_PARK_EXTERNAL_SUBINFO = record 
    byEnable: BYTE;  //0 ～ 不开启 1 ～ 开启
    byFlicker: BYTE;  //0 ～ 不闪烁 1 ～ 闪烁
    byIOState: BYTE;  //0 ～ 低电平 1 ～ 高电平 (外置灯起效)
    byLampColor: BYTE;  // 0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 (内置灯起效)
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_PARK_EXTERNAL_SUBINFO = ^NET_DVR_PARK_EXTERNAL_SUBINFO;

type
  NET_DVR_PARK_INLAY_SUBINFO = record 
    byEnable: BYTE;  //0～不开启 1 ～开启
    byFlicker: BYTE;  //0～不闪烁 1 ～闪烁
    byLampColor: BYTE;  //0-灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)
    byRes: array[0..21-1] of BYTE;  
  end;
  LPNET_DVR_PARK_INLAY_SUBINFO = ^NET_DVR_PARK_INLAY_SUBINFO;

type
  NET_DVR_PARKINFO = record 
    struNormalParkIOState: NET_DVR_PARK_EXTERNAL_SUBINFO;  //有车io电平状态
    struNormalNoParkIOState: NET_DVR_PARK_EXTERNAL_SUBINFO;  //无车io电平状态
    struSpecialParkIOState: NET_DVR_PARK_EXTERNAL_SUBINFO;  //特殊车位有车io电平状态
    struSpecialNoParkIOState: NET_DVR_PARK_EXTERNAL_SUBINFO;  //特殊车位无车io电平状态
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PARKINFO = ^NET_DVR_PARKINFO;

type
  NET_DVR_EXTERNAL_LAMP_CTRL_MODE = record 
    struParkInfo: array[0..MAX_PARKING_NUM-1] of NET_DVR_PARKINFO;  //外接灯的情况下车位信息，一个通道最大4个车位 (从左到右车位 数组0～3)
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE = ^NET_DVR_EXTERNAL_LAMP_CTRL_MODE;

type
  NET_DVR_INLAY_LAMP_CTRL_MODE = record 
    struLampStateCtrl: array[0..MAX_PARKING_STATUS-1] of NET_DVR_PARK_INLAY_SUBINFO;  
    byRes: array[0..96-1] of BYTE;  
  end;
  LPNET_DVR_INLAY_LAMP_CTRL_MODE = ^NET_DVR_INLAY_LAMP_CTRL_MODE;

type
  NET_DVR_LAMP_INFO = record //8
    byEnable: BYTE;  //0～不开启 1 ～开启
    byFlicker: BYTE;  //0~不闪烁 1 ～闪烁(车位指示灯闪烁)
    byLampColor: BYTE;  //0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (车位指示灯颜色)
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_INFO = ^NET_DVR_LAMP_INFO;

//内置外置灯模式
type
  NET_DVR_PARKLAMP_CTRL_MODE = record //size == 72

    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    struLampInfo: array[0..MAX_PARKING_STATUS{8}-1] of NET_DVR_LAMP_INFO;  
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    byLampType: BYTE;  
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_PARKLAMP_CTRL_MODE = ^NET_DVR_PARKLAMP_CTRL_MODE;

type
  NET_DVR_LAMP_PARAM = record //4
    byEnable: BYTE;  //0～不开启 1 ～开启
    byFlicker: BYTE;  //0~不闪烁 1 ～闪烁
    byLampColor: BYTE;  //0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_PARAM = ^NET_DVR_LAMP_PARAM;

//内置外置灯模式
type
  NET_DVR_EXTERNAL_PARKLAMP = record //size == 56

    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    struLampParam: array[0..MAX_PARKING_STATUS{8}-1] of NET_DVR_LAMP_PARAM;  
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    byLampType: BYTE;  
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_PARKLAMP = ^NET_DVR_EXTERNAL_PARKLAMP;

//内置灯加外置灯模式下 内置灯控制结构子信息 
type
  NET_DVR_BUILTIN_PARKLAMP = record 
    byEnable: BYTE;  //0～不开启 1 ～开启
    byFlicker: BYTE;  //0~不闪烁 1 ～闪烁
    byLampColor: BYTE;  //0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)
    byRes: array[0..5-1] of BYTE;  
  end;
  LPNET_DVR_BUILTIN_PARKLAMP = ^NET_DVR_BUILTIN_PARKLAMP;

// 混合控制模式结构 
type
  NET_DVR_MIXLAMP_CTRL_MODE = record 
    struExternalParkLamp: array[0..MAX_PARKING_NUM{4}-1] of NET_DVR_EXTERNAL_PARKLAMP;  //外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
    struBuiltInParkLamp: array[0..MAX_PARKING_STATUS{8}-1] of NET_DVR_BUILTIN_PARKLAMP;  //内置灯 按照车位状态区分，车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
  end;
  LPNET_DVR_MIXLAMP_CTRL_MODE = ^NET_DVR_MIXLAMP_CTRL_MODE;

// 单控外接灯控制模式结构 
type
  NET_DVR_SINGLELAMP_CTRL_MODE = record //单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
    struExternLampStateCtrl: array[0..MAX_PARKING_STATUS{4}-1] of NET_DVR_PARK_EXTERNAL_SUBINFO;  //外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
    byLampType: BYTE;  // 1-外置灯1，2-外置灯2，3-外置灯3
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_SINGLELAMP_CTRL_MODE = ^NET_DVR_SINGLELAMP_CTRL_MODE;

type
  NET_DVR_LAMP_CTRL_MODE_UNION = record 
    case Byte of
    0: (uLen: array[0..288-1] of BYTE);  
    1: (struInlayLampCtrlMode: NET_DVR_INLAY_LAMP_CTRL_MODE);  //内置灯控制模式结构
    2: (struExternalLampCtrlMode: NET_DVR_EXTERNAL_LAMP_CTRL_MODE);  //外接灯控制模式结构
    3: (struParkLampCtrlMode: array[0..MAX_PARKING_NUM{4}-1] of NET_DVR_PARKLAMP_CTRL_MODE);  //内置外置灯模式，一个通道最大4个车位 (从左到右车位 数组0～3)  当模式为内外置灯的时候生效
    //车位检测相机内外置灯，混合控制模式（区分与上面内外置灯模式，该模式下内置灯不作为外置灯使用（内置外置灯模式下，内置灯作为外置灯使用））；
    //混合控制模式下，内置灯显示当前显示车位状态中，优先级最高的车位状态(压线>特殊车位>有无车状态)关联灯的状态
    4: (struMixLampCtrlMode: NET_DVR_MIXLAMP_CTRL_MODE);  
    //单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
    5: (struSingleExternalLampCtrlMode: NET_DVR_SINGLELAMP_CTRL_MODE);  
  end;
  LPNET_DVR_LAMP_CTRL_MODE_UNION = ^NET_DVR_LAMP_CTRL_MODE_UNION;//灯控制模式联合体

type
  NET_DVR_LAMP_CTRL_INFO = record 
    dwSize: DWORD;  
    byLampCtrlMode: BYTE;  //控灯模式：1代表内置灯,2代表外接灯,3代表内外置灯,4代表混合灯模式（内置灯只做高优先级指示灯),5-代表单外置灯模式
    byCtrlChannelIndex: BYTE;  //交替控制通道号(33~48)
    byRes: array[0..2-1] of BYTE;  
    uLampCtrlMode: NET_DVR_LAMP_CTRL_MODE_UNION;  //灯控制模式联合体
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_CTRL_INFO = ^NET_DVR_LAMP_CTRL_INFO;

//车位属性配置（默认都是normal）
type
  NET_DVR_PARKSPACE_INFO = record 
    byParkSpaceAttribute: BYTE;  //0~普通车位 1～特殊车位
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_PARKSPACE_INFO = ^NET_DVR_PARKSPACE_INFO;

type
  NET_DVR_PARKSPACE_ATTRIBUTE = record 
    dwSize: DWORD;  
    struParkSpaceInfo: array[0..MAX_PARKING_NUM-1] of NET_DVR_PARKSPACE_INFO;  //一个通道最大4个车位 (从左到右车位 数组0～3)
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PARKSPACE_ATTRIBUTE = ^NET_DVR_PARKSPACE_ATTRIBUTE;

//指示灯外控
type
  NET_DVR_LAMP_STATE = record 
    byFlicker: BYTE;  //0~不闪烁 1 ～闪烁
    byParkingIndex: BYTE;  //车位号1～3
    byRes1: array[0..2-1] of BYTE;  
    dwIONo: DWORD;  //1~IO1;2~IO2;4~IO3;
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_STATE = ^NET_DVR_LAMP_STATE;

type
  NET_DVR_LAMP_EXTERNAL_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //外控使能 0～不启用 1～启用
    byRes1: array[0..3-1] of BYTE;  
    struLampStateCtrl: NET_DVR_LAMP_STATE;  //指示灯外控
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_EXTERNAL_CFG = ^NET_DVR_LAMP_EXTERNAL_CFG;

//车位强制抓图 一个通道最多四车位
type
  NET_DVR_COMPEL_CAPTURE = record 
    dwSize: DWORD;  
    byParkIndex: BYTE;  //车位序号从左到右 （0-表示当前有几个车位，就上传几张图片）1,2,3,4
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_COMPEL_CAPTURE = ^NET_DVR_COMPEL_CAPTURE;

//外控报警结构
type
  NET_DVR_EXTERNAL_CONTROL_ALARM = record 
    dwSize: DWORD;  
    dwChannelNo: DWORD;  
    struLampStateCtrl: NET_DVR_LAMP_STATE;  //指示灯外控状态
    struExternalBeginTime: NET_DVR_TIME;  //外控开始时间
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_CONTROL_ALARM = ^NET_DVR_EXTERNAL_CONTROL_ALARM;

// 设备类型 
type
  EXTERNAL_DEVICES_TYPE =  
  (  
    DEVICES_TYPE_RES1 = 0,  //保留1
    DEVICES_TYPE_FAR_SCR = 1,  //远距离读卡器
    DEVICES_TYPE_ENTRANCE_CONTROL = 2,  //出入口控制机
    DEVICES_TYPE_WJ_LED_DEV = 3,  //外接LED
    DEVICES_TYPE_NJ_LED_DEV = 4,  //内接LED
    DEVICES_TYPE_VEH_DETECT_DEV = 5,  //车检器设备
    DEVICES_TYPE_DZ_DEV = 6,  //道闸
    DEVICES_TYPE_PX_SCR_DEV = 7,  //票箱读卡器
    DEVICES_TYPE_KJ_SCR_DEV = 8,  //卡机读卡器
    DEVICES_TYPE_FKJ_DEV = 9,  //发卡机
    DEVICES_TYPE_SKJ_DEV = 10,  //收卡机
    DEVICES_TYPE_HDD_DEV = 11,  //硬盘(裸盘 1G)
    DEVICES_TYPE_DZ_LOCK = 12,  //道闸锁闸状态，0表示未锁闸，1表示锁闸
    DEVICES_TYPE_PAPER_PRINTER = 13,  //纸票打印机
    DEVICES_TYPE_PAPER_SCANNERS = 14,  //纸票扫描仪
    DEVICES_TYPE_IPC_ALARM = 15  //IPC布防状态
  );

// 设备状态 
type
  EXTERNAL_DEVICES_STATUS =  
  (  
    // 通用设备状态码 0~19
    DEVICES_STATUS_NORMAL = 0,  //状态正常
    DEVICES_STATUS_ABNORMAL = 1,  //状态异常

    // 发卡机设备状态码 20~39
    DEVICES_STATUS_TOO_LESS_CARD = 20,  //发卡机少卡
    DEVICES_STATUS_NO_CARD = 21,  //发卡机无卡
    DEVICES_STATUS_SENDCARD_ERROR = 22,  //预发卡错误
    DEVICES_STATUS_CARD_BLOCKED = 23,  //堵卡
    DEVICES_STATUS_CARD_FULL = 24,  //回收仓卡满


    // 道闸设备状态码 40~60
    DEVICES_STATUS_OPENING = 40,  //道闸正在开
    DEVICES_STATUS_CLOSING = 41,  //道闸正在关
    DEVICES_STATUS_OPENED = 42,  //道闸开到位
    DEVICES_STATUS_CLOSED = 43,  //道闸关到位
    DEVICES_STATUS_NOSIGNAL = 44,  //道闸无信号
    DEVICES_STATUS_LOCK = 45,  //锁闸

    // 纸票打印机状态 61~90
    PP_STATUS_OFFLINE = 61,  //脱机
    PP_STATUS_PRINT_HEADER_UP,  // 打印头抬起
    PP_STATUS_FEED_BUTTON_FEEDING,  //正在用进纸键进纸
    PP_STATUS_ONLINE_WAITING,  //联机等待
    PP_STATUS_FEED_BUTTON_ENABLE,  //按键进纸使能为开
    PP_STATUS_JAMR_PAPER_ERROR,  //卡纸错误
    PP_STATUS_CUT_PAPER_ERROR,  //切刀错误
    PP_STATUS_AUTO_FEED_ERROR,  //自动上纸错误
    PP_STATUS_EXIT_RECOVERY_ERROR,  //有可恢复错误
    PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,  //有可自动恢复错误
    PP_STATUS_PULL_PAPER_ERROR,  //拉纸错误
    PP_STATUS_LESS_PAPER,  //纸将尽
    PP_STATUS_NO_PAPER,  //无纸
    PP_STATUS_PRINT_FAIL,  //打印失败
    PP_STATUS_PRINTING  //正在打印
  );

// 外接设备控制类型 
type
  EXTERNAL_DEVICESCTRL_TYPE =  
  (  
    DEVICES_CTRL_RES = 0,  //预留(不去区分具体控制类型)
    DEVICES_CTRL_REMOTE = 1  //遥控器控制，当前仅外设为道闸时支持通过遥控器开闸
  );


type
  NET_DVR_GATE_ALARMINFO = record 
    dwSize: DWORD;  
    //0x1车辆非法侵入报警
    //0x2道闸超时未关报警
    //0x3车辆压线圈超时报警
    //0x4发卡报警（无卡）
    //0x5发卡报警（少卡）
    //0x6发卡报警（发卡异常）
    byAlarmType: BYTE;  
    byExternalDevType: BYTE;  //外接设备类型(EXTERNAL_DEVICES_TYPE)
    byExternalDevStatus: BYTE;  //外接设备类型(EXTERNAL_DEVICES_STATUS)
    byExternalDevCtrlType: BYTE;  //外接设备控制类型(EXTERNAL_DEVICESCTRL_TYPE)
    struAlarmTime: NET_DVR_TIME_V30;  //报警时间
    uAlarmInfo: record 
      case Byte of
      0: (uLen: array[0..128-1] of BYTE);  
      1: (struVehicleInfo: record
        sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
            //车辆类型0-保留 1-固定车，2-临时车，3-预订车，4-联检车，5-授权车
        byVehicleType: BYTE;  
        byRes1: array[0..111-1] of BYTE;  
      end);  //当struAlarmType为(0x1车辆非法侵入报警)
    end;  
    byRes2: array[0..64-1] of BYTE;  //预留
  end;
  LPNET_DVR_GATE_ALARMINFO = ^NET_DVR_GATE_ALARMINFO;

type
  NET_DVR_ALARMWIRELESSINFO = record 
    byDeviceID: array[0..NAME_LEN-1] of BYTE;  //设备ID
    fDataTraffic: FLOAT;  // 已用流量,单位：MB,小数点后两位
    bySignalIntensity: BYTE;  // 信号强度，0~100
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_ALARMWIRELESSINFO = ^NET_DVR_ALARMWIRELESSINFO;

type
  NET_DVR_VOLTAGE = record 
    iPhaseAVol: INT;  //A相电压
    iPhaseBVol: INT;  //B相电压
    iPhaseCVol: INT;  //C相电压
    iAveragePhaseVol: INT;  //相电压平均值
  end;
  LPNET_DVR_VOLTAGE = ^NET_DVR_VOLTAGE;

type
  NET_DVR_LINE_VOLTAGE = record 
    iLineVolAB: INT;  //AB线电压
    iLineVolBC: INT;  //BC线电压
    iLineVolCA: INT;  //CA线电压
    iAverageLineVol: INT;  //线电压平均值
  end;
  LPNET_DVR_LINE_VOLTAGE = ^NET_DVR_LINE_VOLTAGE;


//电流
type
  NET_DVR_CURRENT = record 
    iPhaseACurrent: INT;  //A相电流
    iPhaseBCurrent: INT;  //B相电流
    iPhaseCCurrent: INT;  //C相电流
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_CURRENT = ^NET_DVR_CURRENT;

//功率
type
  NET_DVR_POWER = record 
    iPhaseAPower: INT;  //A相功率
    iPhaseBPower: INT;  //B相功率
    iPhaseCPower: INT;  //C相功率
    iSysTotalPower: INT;  //系统总功率
  end;
  LPNET_DVR_POWER = ^NET_DVR_POWER;

//功率因数
type
  NET_DVR_POWER_FACTOR = record 
    iPhaseAPowerFactor: INT;  //A相功率因数
    iPhaseBPowerFactor: INT;  //B相功率因数
    iPhaseCPowerFactor: INT;  //C相功率因数
    iTotalPowerFactor: INT;  //总功率因数
  end;
  LPNET_DVR_POWER_FACTOR = ^NET_DVR_POWER_FACTOR;

//频率
type
  NET_DVR_FREQUENCY = record 
    iPhaseAFrequency: INT;  //A相频率
    iPhaseBFrequency: INT;  //B相频率
    iPhaseCFrequency: INT;  //C相频率
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_FREQUENCY = ^NET_DVR_FREQUENCY;

//负载率
type
  NET_DVR_LOAD_FACTOR = record 
    iPhaseALoadFactor: INT;  //A相负载率
    iPhaseBLoadFactor: INT;  //B相负载率
    iPhaseCLoadFactor: INT;  //C相负载率
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_LOAD_FACTOR = ^NET_DVR_LOAD_FACTOR;

//UPS状态
type
  NET_DVR_ALARMHOST_UPS_STATE = record 
    struInputVoltage: NET_DVR_VOLTAGE;  //输入电压
    struBypassVoltage: NET_DVR_VOLTAGE;  //旁路电压
    struOutputVoltage: NET_DVR_VOLTAGE;  //输出电压
    iRectifierVol: INT;  //整流器电压
    iInverterVol: INT;  //逆变器电压

    struInputCurrent: NET_DVR_CURRENT;  //输入电流
    struBypassCurrent: NET_DVR_CURRENT;  //旁路电流
    struOutputCurrent: NET_DVR_CURRENT;  //输出电流
    iInverterCurrent: INT;  //逆变器电流

    struInputFrequency: NET_DVR_FREQUENCY;  //输入频率
    struBypassFrequency: NET_DVR_FREQUENCY;  //旁路频率
    struOutputFrequency: NET_DVR_FREQUENCY;  //输出频率
    iInverterFre: INT;  //逆变器频率

    struInputPower: NET_DVR_POWER;  //输入功率
    struBypassPower: NET_DVR_POWER;  //旁路功率
    struOutputPower: NET_DVR_POWER;  //输出功率
    struComplexPower: NET_DVR_POWER;  //复功率

    iNormalPower: INT;  //标称功率
    iPowerFacter: INT;  //功率因数

    struBatteryLoadFactor: NET_DVR_LOAD_FACTOR;  //电池负载率
    iBatteryEstimated: INT;  //电池备份时间(min)
    iBatteryTemperature: INT;  //电池温度
    iBatteryVoltage: INT;  //电池电压


    byRectifierState: BYTE;  //整流器运行状态/*1正常 2异常}
    byInverterState: BYTE;  //逆变器运行状态/*1正常 2异常}
    byChargeState: BYTE;  //充电器运行状态/*1正常 2异常}
    byBatteryState: BYTE;  //电池运行状态/*1正常 2异常}
    byAutoBypassState: BYTE;  //自动旁路状态/*1正常 2异常}
    byRes2: array[0..247-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_UPS_STATE = ^NET_DVR_ALARMHOST_UPS_STATE;

//开关电源状态
type
  NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE = record 
    struACVoltage: NET_DVR_VOLTAGE;  //交流电压
    iDCConvertVoltage: INT;  //DC转换器电压
    struACCurrent: NET_DVR_CURRENT;  //交流电流
    iTotalCurrent: INT;  //负载总电流
    iBattery1Temperature: INT;  //电池1温度
    iBattery2Temperature: INT;  //电池2温度
    iBattery1Current: INT;  //电池1电流
    iBattery2Current: INT;  //电池2电流
    iBattery3Current: INT;  //电池3电流
    iBattery4Current: INT;  //电池4电流
    iBatteryTestVoltage: INT;  //电池测试电压
    iRectifierOutputVoltage: INT;  //整流模块输出电压
    iRectifierOutputCurrent: INT;  //整流模块输出电流
    iDCOutputVoltage: INT;  //直流输出电压
    byRes: array[0..432-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE = ^NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

//气体探测器状态
type
  NET_DVR_ALARMHOST_GAS_DETECTOR_STATE = record 
    iSF6: INT;  //SF6，单位ppm
    iFlow: INT;  //流量，ml/min
    iTemperature: INT;  //温度，单位摄氏度
    iO2: INT;  //氧气，单位%
    iHumidity: INT;  //湿度，单位%
    byRes: array[0..492-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE = ^NET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

//温湿度传感器状态
type
  NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE = record 
    iTemperature: INT;  //温度，单位摄氏度
    iHumidity: INT;  //湿度，单位%
    byRes: array[0..504-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE = ^NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

//空调状态
type
  NET_DVR_ALARMHOST_AIRCONDITION_STATE = record 
    iTemperature: INT;  //温度，单位摄氏度
    iHumidity: INT;  //湿度，单位%
    byRunState: BYTE;  //运行状态 1-正常，2-停机
    byRes: array[0..503-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_AIRCONDITION_STATE = ^NET_DVR_ALARMHOST_AIRCONDITION_STATE;


//电量表状态
type
  NET_DVR_ALARMHOST_ELECTRICITY_STATE = record 
    iDCVoltage: INT;  //直流电压
    iDCCurrent: INT;  //直流电流
    struPhaseVoltage: NET_DVR_VOLTAGE;  //相电压
    struLineVoltage: NET_DVR_LINE_VOLTAGE;  //线电压
    struCurrent: array[0..4-1] of NET_DVR_CURRENT;  //电流，struCurrent[0]表示第1路, 以此类推
    iAverageCurrent: INT;  //平均电流
    iNeutralCurrent: INT;  //中线电流
    struActivePower: array[0..4-1] of NET_DVR_POWER;  //有功功率 struActivePower[0]表示第一路有功功率，以此类推
    struReactivePower: array[0..4-1] of NET_DVR_POWER;  //无功功率 struReactivePower[0]表示第一路无功功率，以此类推
    struApparentPower: array[0..4-1] of NET_DVR_POWER;  //视在功率 struApprentPower[0]表示第一路视在功率，以此类推
    struPowerFactor: array[0..4-1] of NET_DVR_POWER_FACTOR;  //功率因数，struPowerFactor[0]表示第一路功率因数，以此类推
    struFrequency: NET_DVR_FREQUENCY;  //频率
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ELECTRICITY_STATE = ^NET_DVR_ALARMHOST_ELECTRICITY_STATE;

//变电器温显表状态
type
  NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE = record 
    iPhaseATemperature: INT;  //A相温度
    iPhaseBTemperature: INT;  //B相温度
    iPhaseCTemperature: INT;  //C相温度
    iPhaseDTemperature: INT;  //D相温度
    byRes: array[0..496-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE = ^NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;

//水位传感器
type
  NET_DVR_ALARMHOST_WATERLEVEL_SENSOR = record 
    iWaterLevel: LONG;  //水位
    byRes: array[0..508-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR = ^NET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//扬尘噪声传感器
type
  NET_DVR_ALARMHOST_DUSTNOISE_SENSOR = record 
    iDust: LONG;  //扬尘
    iNoise: LONG;  //噪声
    iPM25: LONG;  //PM2.5
    byRes: array[0..500-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR = ^NET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//环境采集仪
type
  NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER = record 
    iAmmoniaNitrogen: LONG;  //氨氮
    iCOD: LONG;  //COD
    iPH: LONG;  //PH
    iOxygen: LONG;  //氧气
    iSulfurDioxide: LONG;  //二氧化硫
    iSoot: LONG;  //烟尘
    iFluoride: LONG;  //氟化物
    iPollutedWater: LONG;  //污水
    iTotalPhosphorus: LONG;  //总磷
    iExhaust: LONG;  //废气
    iNitrogenOxides: LONG;  //氮氧化物
    iFlueGasTemperature: LONG;  //烟气温度
    iFlueGasPressure: LONG;  //烟气压力
    iDustThickness: LONG;  //粉尘浓度
    iAirCleanLevel: LONG;  //空气洁净度等级
    iPm10Thickness: LONG;  //PM10浓度
    byRes: array[0..448-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER = ^NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

//风速传感器状态
type
  NET_DVR_WIND_SPEED_STATE = record 
    iWindSpeed: INT;  //风速
    byRes: array[0..508-1] of BYTE;  
  end;
  LPNET_DVR_WIND_SPEED_STATE = ^NET_DVR_WIND_SPEED_STATE;

//通用扩展输出模块状态（48路，每位表示1路，0表示关，1表示开）
type
  NET_DVR_GENERATE_OUTPUT_STATE = record 
    byOutPutState1: BYTE;  //output1-8
    byOutPutState2: BYTE;  //output9-16
    byOutPutState3: BYTE;  //output17-24
    byOutPutState4: BYTE;  //output25-32
    byOutPutState5: BYTE;  //output33-40
    byOutPutState6: BYTE;  //output41-48
    Res: array[0..506-1] of BYTE;  
  end;
  LPNET_DVR_GENERATE_OUTPUT_STATE = ^NET_DVR_GENERATE_OUTPUT_STATE;

//浸水传感器状态
type
  NET_DVR_SOAK_STATE = record 
    iWaterLogVal: INT;  // 泄露位置，100倍
    iLeakResist1: INT;  //第一路漏水电阻
    iTotolResist1: INT;  //第一路总电阻
    iLeakResist2: INT;  //第二路漏水电阻
    iTotolResist2: INT;  //第二路总电阻
    byWaterLogAlarm: BYTE;  // 泄漏报警1：正常，2：告警
    byLeakAlarm1: BYTE;  //第一路漏水告警1：正常，2：告警
    byFaultAlarm1: BYTE;  //第一路故障告警1：正常，2：告警
    byLeakAlarm2: BYTE;  //第二路漏水告警1：正常，2：告警
    byFaultAlarm2: BYTE;  //第二路故障告警1：正常，2：告警
    byRes: array[0..487-1] of BYTE;  
  end;
  LPNET_DVR_SOAK_STATE = ^NET_DVR_SOAK_STATE;

//太阳能控制器状态
type
  NET_DVR_SOLAR_POWER_STATE = record 
    iChangerVolInput: INT;  //充电设备输入电压
    iChangerCurInput: INT;  //充电设备输入电流
    iChangerPwInput: INT;  //充电设备输入功率
    iChangerVolOutput: INT;  //充电设备输出电压
    iChangerCurOutput: INT;  //充电设备输出电流
    iChangerPwOutput: INT;  //充电设备输出功率
    iDischangerVolOutput: INT;  //放电设备输出电压
    iDischangerCurOutput: INT;  //放电设备输出电流
    iDischangerPwOutput: INT;  //放电设备输出功率
    iDevTemperatrue: INT;  //设备内温度
    byBatteryVolState: BYTE;  //蓄电池电压状态1：正常，2：异常
    byBatteryTmpState: BYTE;  //蓄电池温度状态1：正常，2：异常
    byChangerVolInputState: BYTE;  //充电设备输入电压状态1：正常，2：异常
    byChangerRunState: BYTE;  //充电设备运行状态1：正常，2：待机
    byChangerChgState: BYTE;  //充电设备充电状态1：正常，2：异常
    byBatteryVolFlt: BYTE;  //蓄电池电压故障1：正常，2：告警
    byBatteryTmpFlt: BYTE;  //蓄电池温度异常1：正常，2：告警
    byBatteryResistanceFlt: BYTE;  //蓄电池内阻异常1：正常，2：告警
    byVolRcgFlt: BYTE;  //额定电压识别错误1：正常，2：告警
    byChangerVolInputFlt: BYTE;  //充电设备输入电压异常1：正常，2：告警
    byChangerMosShort: BYTE;  //充电MOS管短路1：正常，2：告警
    byChangerAntiOrMosShort: BYTE;  //充电或防反MOS管短路1：正常，2：告警
    byChangerAntiShort: BYTE;  //防反MOS管短路1：正常，2：告警
    byInputOverCur: BYTE;  //输入过流1：正常，2：告警
    byLoadOverCur: BYTE;  //负载过流1：正常，2：告警
    byLoadShort: BYTE;  //负载短路1：正常，2：告警
    byLoadMosShort: BYTE;  //负载MOS管短路1：正常，2：告警
    byChangerFlt: BYTE;  //充电设备故障1：正常，2：告警
    byRes: array[0..454-1] of BYTE;  
  end;
  LPNET_DVR_SOLAR_POWER_STATE = ^NET_DVR_SOLAR_POWER_STATE;

//SF6报警主机状态
type
  NET_DVR_SF6_ALARMHOST_STATE = record 
    iSf6Thick1: INT;  //第一点SF6浓度
    iO2Thick1: INT;  //第一点氧气浓度
    iTemprature1: INT;  //第一点温度
    iHumidity1: INT;  //第一点湿度
    iSf6Thick2: INT;  //第二点SF6浓度
    iO2Thick2: INT;  //第二点氧气浓度
    iTemprature2: INT;  //第二点温度
    iHumidity2: INT;  //第三点湿度
    iSf6Thick3: INT;  //第三点SF6浓度
    iO2Thick3: INT;  //第三点氧气浓度
    iTemprature3: INT;  //第三点温度
    iHumidity3: INT;  //第三点湿度
    iSf6Thick4: INT;  //第四点SF6浓度
    iO2Thick4: INT;  //第四点氧气浓度
    iTemprature4: INT;  //第四点温度
    iHumidity4: INT;  //第四点湿度
    iSf6Thick5: INT;  //第五点SF6浓度
    iO2Thick5: INT;  //第五点氧气浓度
    iTemprature5: INT;  //第五点温度
    iHumidity5: INT;  //第五点湿度
    iSf6Thick6: INT;  //第六点SF6浓度
    iO2Thick6: INT;  //第六点氧气浓度
    iTemprature6: INT;  //第六点温度
    iHumidity6: INT;  //第六点湿度
    iSf6Thick7: INT;  //第七点SF6浓度
    iO2Thick7: INT;  //第七点氧气浓度
    iTemprature7: INT;  //第七点温度
    iHumidity7: INT;  //第七点湿度
    iSf6Thick8: INT;  //第八点SF6浓度
    iO2Thick8: INT;  //第八点氧气浓度
    iTemprature8: INT;  //第八点温度
    iHumidity8: INT;  //第八点湿度
    iSf6Thick9: INT;  //第九点SF6浓度
    iO2Thick9: INT;  //第九点氧气浓度
    iTemprature9: INT;  //第九点温度
    iHumidity9: INT;  //第九点湿度
    iSf6Thick10: INT;  //第十点SF6浓度
    iO2Thick10: INT;  //第十点氧气浓度
    iTemprature10: INT;  //第十点温度
    iHumidity10: INT;  //第十点湿度
    iSf6Thick11: INT;  //第十一点SF6浓度
    iO2Thick11: INT;  //第十一点氧气浓度
    iTemprature11: INT;  //第十一点温度
    iHumidity11: INT;  //第十一点湿度
    iSf6Thick12: INT;  //第十二点SF6浓度
    iO2Thick12: INT;  //第十二点氧气浓度
    iTemprature12: INT;  //第十二点温度
    iHumidity12: INT;  //第十二点湿度
    byFanState1: BYTE;  //风机状态1 1：运行，2：停止
    byFanState2: BYTE;  //风机状态2 1：运行，2：停止
    byFanState3: BYTE;  //风机状态3 1：运行，2：停止
    byFanState4: BYTE;  //风机状态4 1：运行，2：停止
    byFanState5: BYTE;  //风机状态5 1：运行，2：停止
    byFanState6: BYTE;  //风机状态6 1：运行，2：停止
    byFanState7: BYTE;  //风机状态7 1：运行，2：停止
    byFanState8: BYTE;  //风机状态8 1：运行，2：停止
    byFanState9: BYTE;  //风机状态9 1：运行，2：停止
    byFanState10: BYTE;  //风机状态10 1：运行，2：停止
    byFanState11: BYTE;  //风机状态11 1：运行，2：停止
    byFanState12: BYTE;  //风机状态12 1：运行，2：停止
    byRes: array[0..308-1] of BYTE;  
  end;
  LPNET_DVR_SF6_ALARMHOST_STATE = ^NET_DVR_SF6_ALARMHOST_STATE;

//称重仪状态
type
  NET_DVR_WEIGHT_STATE = record 
    iWeight: INT;  //称重值,1000倍
    byRes: array[0..508-1] of BYTE;  
  end;
  LPNET_DVR_WEIGHT_STATE = ^NET_DVR_WEIGHT_STATE;

//气象采集系统状态
type
  NET_DVR_WEATHER_STATION_STATE = record 
    iAirTemperature: INT;  // 空气温度
    dwAirHumidity: DWORD;  // 空气湿度
    dwWindSpeed: DWORD;  // 风速
    dwWindDirection: DWORD;  // 风向
    dwIlluminationIntensity: DWORD;  // 光照强度
    dwCO2: DWORD;  // co2浓度
    dwPM25: DWORD;  // PM2.5浓度
    dwAirPressure: DWORD;  // 大气压力
    iSoilTemperature: INT;  // 土壤温度
    dwSoilHumidity: DWORD;  // 土壤湿度
    dwRainFall: DWORD;  //降雨量
    byIsRainSnow: BYTE;  // 雨雪情况，1-无雨雪，2-有雨雪
    byRes: array[0..467-1] of BYTE;  
  end;
  LPNET_DVR_WEATHER_STATION_STATE = ^NET_DVR_WEATHER_STATION_STATE;

//水质显示仪状态
type
  NET_DVR_WATER_QLT_STATE = record 
    dwTurbidity: DWORD;  // 浊度值
    dwChlorine: DWORD;  // 余氯值
    dwPH: DWORD;  // PH 值
    byRes: array[0..500-1] of BYTE;  
  end;
  LPNET_DVR_WATER_QLT_STATE = ^NET_DVR_WATER_QLT_STATE;

//燃气显示系统状态
type
  NET_DVR_FUEL_GAS_DETE_STATE = record 
    iNatrualGasThick: INT;  // 天然气浓度
    byRes: array[0..508-1] of BYTE;  
  end;
  LPNET_DVR_FUEL_GAS_DETE_STATE = ^NET_DVR_FUEL_GAS_DETE_STATE;

//消防主机设备
type
  NET_DVR_FIRE_ALARM_STATUS = record 
    byFireAlarm: array[0..MAX_FIRE_ALARM_ZONE-1, 0..MAX_FIRE_ALARM_POINT_ZONE-1] of BYTE;  //火点状态参数位，1-正常，2-告警
    byRes: array[0..128-1] of BYTE;  //保留位
  end;
  LPNET_DVR_FIRE_ALARM_STATUS = ^NET_DVR_FIRE_ALARM_STATUS;

type
  NET_DVR_EXTERNAL_DEVICE_STATE_UNION = record 
    case Byte of
    0: (struUpsState: NET_DVR_ALARMHOST_UPS_STATE);  //UPS状态
    1: (struSwitchPowerState: NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE);  //开关电源状态
    2: (struGasDetectorState: NET_DVR_ALARMHOST_GAS_DETECTOR_STATE);  //气体检测系统状态
    3: (struTempHumiSensorState: NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE);  //温湿度传感器状态
    4: (struAirConditionState: NET_DVR_ALARMHOST_AIRCONDITION_STATE);  //空调状态
    5: (struElectricityState: NET_DVR_ALARMHOST_ELECTRICITY_STATE);  //电量表状态
    6: (struTransformerTempState: NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE);  //变电器状态
    7: (struWaterLevelSensor: NET_DVR_ALARMHOST_WATERLEVEL_SENSOR);  //水位传感器
    8: (struDustNoiseSensor: NET_DVR_ALARMHOST_DUSTNOISE_SENSOR);  //扬尘噪声传感器
    9: (struEnvironmentLogger: NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER);  //环境采集仪
    10: (struWindSpeedState: NET_DVR_WIND_SPEED_STATE);  //风速传感器状态
    11: (struGenerateOutputState: NET_DVR_GENERATE_OUTPUT_STATE);  //通用扩展输出模块状态（48路，每位表示1路）
    12: (struSoakState: NET_DVR_SOAK_STATE);  //浸水传感器状态
    13: (struSolarPowerState: NET_DVR_SOLAR_POWER_STATE);  //太阳能控制器状态
    14: (struSF6AlarmHostState: NET_DVR_SF6_ALARMHOST_STATE);  //SF6报警主机状态
    15: (struWeightState: NET_DVR_WEIGHT_STATE);  //称重仪状态
    16: (struWeatherStationState: NET_DVR_WEATHER_STATION_STATE);  //气象采集系统状态
    17: (struWaterQltState: NET_DVR_WATER_QLT_STATE);  //水质显示仪状态
    18: (struFuelGasDeteState: NET_DVR_FUEL_GAS_DETE_STATE);  //燃气显示系统状态
    19: (struFireAlarmStatus: NET_DVR_FIRE_ALARM_STATUS);  //消防主机设备状态
    20: (byRes: array[0..512-1] of BYTE);  
  end;
  LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION = ^NET_DVR_EXTERNAL_DEVICE_STATE_UNION;

type
  NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE = record 
    dwSize: DWORD;  
    byDevType: BYTE;  //1-UPS，2-开关电源，3-气体检测系统，4-温湿度传感器，5-空调，6-电量表，7-变电器状态, 8-水位传感器、9-扬尘噪声传感器、10-环境采集仪、11-风速传感器状态、12-通用扩展输出模块状态、13-浸水传感器状态、14-太阳能控制器状态、15-SF6报警主机状态、16-称重仪状态、17-气象采集系统状态、18-水质检测仪状态、19-燃气显示系统状态、20-消防主机状态
    byRes1: array[0..3-1] of BYTE;  
    struDevState: NET_DVR_EXTERNAL_DEVICE_STATE_UNION;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE = ^NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;

//通用扩展输出模块控制（48路，每位表示1路）
type
  NET_DVR_GENERATE_OUTPUT_CTRL = record 
    dwSize: DWORD;  
    byOutPutState1: BYTE;  //output1-8
    byOutPutState2: BYTE;  //output9-16
    byOutPutState3: BYTE;  //output17-24
    byOutPutState4: BYTE;  //output25-32
    byOutPutState5: BYTE;  //output33-40
    byOutPutState6: BYTE;  //output41-48
    byOperateType: BYTE;  //操作类型，0-无效，1-开，2-关
    Res: array[0..65-1] of BYTE;  
  end;
  LPNET_DVR_GENERATE_OUTPUT_CTRL = ^NET_DVR_GENERATE_OUTPUT_CTRL;

//UPS报警限值
type
  NET_DVR_ALARMHOST_UPS_LIMIT_VALUE = record 
    iInputVolHigh: INT;  //越限输入电压值(高值)
    iInputVolLow: INT;  //越限输入电压值(低值)
    iInputFreHigh: INT;  //越限输入频率值(高值)
    iInputFreLow: INT;  //越限输入频率值(低值)
    iOutputVolHigh: INT;  //越界输出电压值(高值)
    iOutputVolLow: INT;  //越界输出电压值(低值)
    iBatteryVoltageLow: INT;  //电池低电压限值
    iBatterySurplus: INT;  //电池后备时间低 限值
    iBatteryTemperatureHigh: INT;  //电池温度高限值
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE = ^NET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

//温湿度传感器限值
type
  NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE = record 
    iTemperatureHighLimit: INT;  //温度高限值，单位摄氏度
    iTemperatureLowLimit: INT;  //温度低限值，单位摄氏度
    iHumidityHighLimit: INT;  //湿度高限值，单位%
    iHumidityLowLimit: INT;  //湿度低限值，单位%
    byRes: array[0..84-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE = ^NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

type
  NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION = record 
    case Byte of
    0: (struUpsLimitValue: NET_DVR_ALARMHOST_UPS_LIMIT_VALUE);  
    1: (struTempHumidityLimitValue: NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE);  
  end;
  LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION = ^NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

type
  NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = record 
    dwSize: DWORD;  
    byDevType: BYTE;  //1-UPS，2-温湿度传感器
    byRes1: array[0..3-1] of BYTE;  
    struAlarmValue: NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE = ^NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

const
  ALARMHOST_ALARMOUT_NUM = 64;    //触发器个数
  MAX_OSD_UNIT_LEN = 8;    //OSD单位长度
type
  NET_DVR_ALARMHOST_SENSOR_JOINT_CFG = record 
    dwSize: DWORD;  
    bySensorJointAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM{512}-1] of BYTE;  //模拟量联动触发器，0-不联动，1-联动
    bySensorJointSiren: array[0..ALARMHOST_MAX_SIREN_NUM{8}-1] of BYTE;  //模拟量联动警号
    bySensorAlarmTypeJointAlarmOut: array[0..ALARMHOST_ALARMOUT_NUM{64}-1] of BYTE;  //模拟量按类型联动触发器，该字段是bySensorJointAlarmOut的扩展。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    bySesorAlarmTypeJointSiren: array[0..ALARMHOST_MAX_SIREN_NUM-1] of BYTE;  //模拟量按类型联动警号，该字段是bySensorJointSiren的扩展。数组下标表示警号序号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    byChan: BYTE;  //通道号
    byRes: array[0..55-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG = ^NET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

//UPS报警信息上传
type
  NET_DVR_ALARMHOST_UPS_ALARMINFO = record 
    byAlarmType: BYTE;  //报警类型：1.A相输入电压越限 2.B相输入电压越限 3.C相输入电压越限 4.A相输出电压越限5.B相输出电压越限 6.C相输出电压越限7.A相输入频率越限 8.B相输入频率越限9.C相输入频率越限10.整流器电压越限报警 11.过载报警 12.电池电压低报警 13.电池后备时间超低报警 14.电池温度超高报警 15.逆变器关闭报警 16.自动旁路开报警 17.整流器故障报警 18.逆变器故障报警 19.充电器故障报警    20.电池故障报警     21.自动旁路故障报警 
    byChanNo: BYTE;  //485通道号，从1开始
    bySlotNo: BYTE;  //485虚拟槽位号
    byRes1: BYTE;  //保留
    iAlarmValue: INT;  //报警值
    byRes2: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARMHOST_UPS_ALARMINFO = ^NET_DVR_ALARMHOST_UPS_ALARMINFO;

//开关电源报警上传
type
  NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO = record 
    byAlarmType: BYTE;  //报警类型：1-电池测试失败 2-AC-DC转换器故障，3-输入线/相电压AB/A越限，4-输入线/相电压BC/B越限，5-输入线/相电压CA/C越限，6-输出电流A越限，7-输出电流B越限，8-输出电流C越限，9整流模块故障，10-风扇故障，11-直流电压越限
    byChanNo: BYTE;  //485通道号，从1开始
    bySlotNo: BYTE;  //485虚拟槽位号
    byRes1: BYTE;  
    iAlarmValue: INT;  //报警值
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO = ^NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

//气体检测系统报警
type
  NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO = record 
    byAlarmType: BYTE;  //报警类型：1- SF6气体含量异常，2-氧气含量异常，3-温度值异常，4-湿度值异常，5-流量
    byChanNo: BYTE;  //485通道号，从1开始
    bySlotNo: BYTE;  //485虚拟槽位号
    byRes1: BYTE;  
    iAlarmValue: INT;  //报警值
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO = ^NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;


//温湿度传感器报警
type
  NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO = record 
    byAlarmType: BYTE;  //1-温度异常，2-湿度异常
    byChanNo: BYTE;  //485通道号
    bySlotNo: BYTE;  //485槽位号
    byRes1: BYTE;  
    iAlarmValue: INT;  //报警值
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO = ^NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

type
  NET_DVR_485_DEVICE_ALARM_UNION = record 
    case Byte of
    0: (struUPSAlarm: NET_DVR_ALARMHOST_UPS_ALARMINFO);  //UPS报警
    1: (struSwitchPowerAlarm: NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO);  //开关电源报警
    2: (struGasDetectSystemAlarm: NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO);  //气体检测系统报警
    3: (struTempHumiditySensorAlarm: NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO);  //温湿度传感器报警
    4: (byRes: array[0..72-1] of BYTE);  
  end;
  LPNET_DVR_485_DEVICE_ALARM_UNION = ^NET_DVR_485_DEVICE_ALARM_UNION;

//485外接设备报警信息
type
  NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO = record 
    dwSize: DWORD;  
    byAlarmType: BYTE;  //1-UPS报警，2-开关电源报警，3-气体检测系统报警，4-温湿度传感器报警
    byRes1: array[0..3-1] of BYTE;  
    struAlarmInfo: NET_DVR_485_DEVICE_ALARM_UNION;  
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO = ^NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

type
  NET_DVR_ALARMHOST_RS485_SLOT_CFG = record 
    dwSize: DWORD;  // 结构体大小
    sDeviceName: array[0..NAME_LEN-1] of BYTE;  // 前端设备名称
    wDeviceType: WORD;  // 前端设备类型ALARM_FRONT_DEVICE _TYPE
    wDeviceProtocol: WORD;  // 前端设备协议 通过获取协议列表获取
    wAddress: WORD;  //设备地址
    byChannel: BYTE;  //485通道号
    bySlotChan: BYTE;  //槽位号
    byRes: array[0..60-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMHOST_RS485_SLOT_CFG = ^NET_DVR_ALARMHOST_RS485_SLOT_CFG;

//走廊模式
type
  NET_DVR_CORRIDOR_MODE = record 
    dwSize: DWORD;  
    byEnableCorridorMode: BYTE;  //是否启用走廊模式 0～不启用， 1～启用
    byMirrorMode: BYTE;  //镜像方式，0 关闭;1 左右;2 上下;3 中间
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_CORRIDOR_MODE = ^NET_DVR_CORRIDOR_MODE;

//人脸侦测
type
  NET_DVR_DETECT_FACE = record 
    dwSize: DWORD;  
    byEnableDetectFace: BYTE;  //是否启用 0～不启用， 1～启用
    byDetectSensitive: BYTE;  //灵敏度 10个等级 1～10
    byEnableDisplay: BYTE;  //启用移动侦测高亮显示，0-否，1-是
    byRes: BYTE;  
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V40;  //处理方式
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间 
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道数 实际支持数
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  // 报警触发的录象通道
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    wDuration: WORD;  //报警持续时间 5s 能力集
    byRes1: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_DETECT_FACE = ^NET_DVR_DETECT_FACE;

type
  NET_DVR_MUL_STREAM_CHANNEL_GROUP = record 
    dwSize: DWORD;  // 结构体大小
    dwGroup: DWORD;  //组号
    struMultiStreamCfg: NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;  //多码流配置
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MUL_STREAM_CHANNEL_GROUP = ^NET_DVR_MUL_STREAM_CHANNEL_GROUP;

type
  NET_DVR_CHANNEL_GROUP = record 
    dwSize: DWORD;  // 结构体大小
    dwChannel: DWORD;  //通道号
    dwGroup: DWORD;  //组号
    byID: BYTE;  //设备区域设置ID
    byRes1: array[0..3-1] of BYTE;  
    dwPositionNo: DWORD;  //场景位置索引号,IPC是0，IPD是从1开始
    byRes: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_CHANNEL_GROUP = ^NET_DVR_CHANNEL_GROUP;


type
  NET_DVR_TIME_DETECTION = record 
    struSchedTime: NET_DVR_SCHEDTIME;  //时间
    byDetSceneID: BYTE;  //检测场景号[1,4],IPC默认是0
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_TIME_DETECTION = ^NET_DVR_TIME_DETECTION;

//抓拍触发模式支持关联布防时间段和上传中心条件
type
  NET_DVR_GUARD_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    {
    0表示无效，
    1表示关联 抓拍VIA模式（视频触发抓拍 IPC使用）;
    2 表示关联 抓拍 HVT 模式 （混卡IPC使用）
    }
    byRelateType: BYTE;  
    byGroupNo: BYTE;  //组号
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_GUARD_COND = ^NET_DVR_GUARD_COND;

//抓拍触发模式支持关联布防时间段和上传中心
type
  NET_DVR_GUARD_CFG = record 
    dwSize: DWORD;  
    //布防时间
    struAlarmSched: array[0..MAX_DAYS{7}-1, 0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_TIME_DETECTION;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //本组内实际触发的录象通道数
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  //报警触发的录象通道(0xffff ffff表示后续无效）
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_TIME_DETECTION;  //假日布防时间
    byDirection: BYTE;  //触发方向：0-保留；1-全部；2-正向；3-反向
    byRes: array[0..87-1] of BYTE;  
  end;
  LPNET_DVR_GUARD_CFG = ^NET_DVR_GUARD_CFG;

//抓拍图片参数配置扩展条件结构
type
  NET_DVR_SNAPINFO_COND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  
    {
    0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
    1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    }
    byRelateType: BYTE;  
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_SNAPINFO_COND = ^NET_DVR_SNAPINFO_COND;


//抓拍图片参数配置
type
  NET_DVR_SNAPINFOCFG = record 
    dwSize: DWORD;  
    byCurPicType: BYTE;  //0-表示的图片质量，1-表示图片大小
    byPicQuality: BYTE;  //图片质量[1,100]
    byRes1: array[0..2-1] of BYTE;  
    dwPicSize: DWORD;  //图片大小[64k,2048k]
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SNAPINFOCFG = ^NET_DVR_SNAPINFOCFG;

//ptz方式
type
  PTZ_TRACK_MODE =  
  (  
    PTZ_TRACK_MODE_ALWAYS = 1,  //一直
    PTZ_TRACK_MODE_BYTIME = 2,  //指定时间
    PTZ_TRACK_MODE_NEXT = 3  //下一目标
  );

//ptz参数
type
  NET_DVR_PTZ_TRACK_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byTrackMode: BYTE;  //方式,参考PTZ_TRACK_MODE
    byLinkageTarget: BYTE;  //联动目标0-默认,1-球机1,2-球机2…..依次类推
    byAutoTrackEnable: BYTE;  //使能 0-自动开启，1-自动关闭（枪球设备才支持自动关闭功能，故在此特殊扩展）
    byRes1: BYTE;  //保留
    dwTrackTime: DWORD;  //时间，
    //当模式为PTZ_TRACK_MODE_ALWAYS，此字段无效
    //当模式为PTZ_TRACK MODE_BYTIME时，范围[1,60]，默认10秒
    //当模式为PTZ_TRACK MODE_NEXT时，范围[1,10]，默认2秒
    byRes2: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_PTZ_TRACK_PARAM = ^NET_DVR_PTZ_TRACK_PARAM;

type
  NET_VCA_TRAVERSE_PLANE_DETECTION = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byEnableDualVca: BYTE;  // 启用支持智能后检索 0-不启用，1-启用
    byEnableHumanMisinfoFilter: BYTE;  // 启用人体去误报 0-不启用，1-启用
    byEnableVehicleMisinfoFilter: BYTE;  // 启用车辆去误报 0-不启用，1-启用
    struAlertParam: array[0..MAX_ALERTLINE_NUM-1] of NET_VCA_TRAVERSE_PLANE;  //警戒线参数
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道 数 实际支持的数量
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  //触发录像的通道号
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    byRes2: array[0..100-1] of BYTE;  
  end;
  LPNET_VCA_TRAVERSE_PLANE_DETECTION = ^NET_VCA_TRAVERSE_PLANE_DETECTION;


type
  NET_VCA_FIELDDETECION = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能，是否开启
    byEnableDualVca: BYTE;  // 启用支持智能后检索 0-不启用，1-启用
    byEnableHumanMisinfoFilter: BYTE;  // 启用人体去误报 0-不启用，1-启用
    byEnableVehicleMisinfoFilter: BYTE;  // 启用车辆去误报 0-不启用，1-启用
    struIntrusion: array[0..MAX_INTRUSIONREGION_NUM-1] of NET_VCA_INTRUSION;  //每个区域的参数设置
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道 数 实际支持的数量
    byRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  //触发录像通道
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    byRes2: array[0..100-1] of BYTE;  
  end;
  LPNET_VCA_FIELDDETECION = ^NET_VCA_FIELDDETECION;

type
  NET_DVR_ROI_DETECT_NUM = record 
    dwSize: DWORD;  
    dwGroup: DWORD;  
    dwStreamType: DWORD;  //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    dwRoiFixNum: DWORD;  //固定区域总数，确定后续再次获取的组号
    dwRoiFixID: array[0..MAX_ROIDETECT_NUM-1] of DWORD;  //IPC现在支持4个，球机现在支持24个
    szFixRoiName: array[0..MAX_ROIDETECT_NUM-1, 0..NAME_LEN-1] of BYTE;  //固定ROI区域名称
    dwRoiTrackNum: DWORD;  //自动区域总数，确定后续再次获取的组号
    dwRoiTrackID: array[0..MAX_ROIDETECT_NUM-1] of DWORD;  //IPC现在支持4个，球机现在支持24个
    byRes: array[0..320-1] of BYTE;  
  end;
  LPNET_DVR_ROI_DETECT_NUM = ^NET_DVR_ROI_DETECT_NUM;

type
  DETECT_ROI_TYPE =  
  (  
    DETECT_FIX_ROI = 0,  //检测ROI固定区域
    DETECT_TRACK_ROI = 1  //检测ROI 自动区域
  );
//条件参数
type
  NET_DVR_ROI_DETECT_COND = record 
    dwSize: DWORD;  
    dwRoiID: DWORD;  //区域检测号 一个PTZ支持4个
    struMultiStreamCfg: NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;  //多码流配置
    byRoiDetectType: BYTE;  // DECTECT_ROI_TYPE 的值
    byRoiDetectTrackType: BYTE;  //固定区域时，该字段无效；区域时，1～人脸侦测（IPC）,2～移动物体,3-车牌
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_ROI_DETECT_COND = ^NET_DVR_ROI_DETECT_COND;

//配置参数
//ROI固定区域模式 区域编码功能
type
  NET_DVR_ROI_FIX_RECT_CFG = record 
    byEnableFixRoi: BYTE;  // ROI固定区域模式 是否启用 0～不启用， 1～启用
    byImageQualityLevel: BYTE;  //图像质量提升等级 1～6
    byRes: array[0..2-1] of BYTE;  
    szFixRoiName: array[0..NAME_LEN-1] of BYTE;  
    struRoiRect: NET_VCA_RECT;  //ROI区域
    byRes1: array[0..468-1] of BYTE;  
  end;
  LPNET_DVR_ROI_FIX_RECT_CFG = ^NET_DVR_ROI_FIX_RECT_CFG;

//ROI自动模式 区域编码功能
type
  NET_DVR_ROI_TRACK_RECT_CFG = record 
    byEnableTrackRoi: BYTE;  // ROI自动模式 是否启用 0～不启用， 1～启用
    byImageQualityLevel: BYTE;  //图像质量提升等级 1～6
    byModeType: BYTE;  // 0 ~ 无, 1～人脸模式(移动和静止的物体), 2~移动物体(移动的物体), 3-车牌
    byRes: array[0..509-1] of BYTE;  
  end;
  LPNET_DVR_ROI_TRACK_RECT_CFG = ^NET_DVR_ROI_TRACK_RECT_CFG;

type
  NET_DVR_ROI_DETECT_UNION = record 
    case Byte of
    0: (uLen: array[0..128-1] of DWORD);  
    1: (strRoiFixRectCfg: NET_DVR_ROI_FIX_RECT_CFG);  //固定区域模式
    2: (strRoiTrackRectCfg: NET_DVR_ROI_TRACK_RECT_CFG);  //自动模式
  end;
  LPNET_DVR_ROI_DETECT_UNION = ^NET_DVR_ROI_DETECT_UNION;

type
  NET_DVR_ROI_DETECT_CFG = record 
    dwSize: DWORD;  //560
    dwStreamType: DWORD;  //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    byRoiDetectType: BYTE;  // DECTECT_ROI_TYPE 的值
    byRes: array[0..3-1] of BYTE;  
    uRoiDetectInfo: NET_DVR_ROI_DETECT_UNION;  //ROI检测区域
    byRes1: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_ROI_DETECT_CFG = ^NET_DVR_ROI_DETECT_CFG;

//虚焦侦测
type
  NET_VCA_DEFOCUSPARAM = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    bySensitiveLevel: BYTE;  // 1-100，默认50，灵敏度越高，越容易报警
    byRes1: array[0..2-1] of BYTE;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_VCA_DEFOCUSPARAM = ^NET_VCA_DEFOCUSPARAM;

type
  NET_PTZ_INFO_EX = record 
    fPan: FLOAT;  //P值 精确到小数点后3位 范围[0,360.000]
    fTilt: FLOAT;  //Z值 精确到小数点后3位 范围[-90.000,90.000]
    fVisibleZoom: FLOAT;  //可见光zoom 精确到小数点后1位 不会超过[0，10000.0]
    dwVisibleFocus: DWORD;  //可见光focus[0,65535]
    fThermalZoom: FLOAT;  //热成像zoom 精确到小数点后1位 不会超过[0，10000.0]
    dwThermalFocus: DWORD;  //热成像focus[0,65535]
  end;
  LPNET_PTZ_INFO_EX = ^NET_PTZ_INFO_EX;

//IPC5.1.0
type
  NET_DVR_PRESET_NAME = record 
    dwSize: DWORD;  
    wPresetNum: WORD;  //预置点编号
    byRes1: array[0..2-1] of BYTE;  //字节对齐
    byName: array[0..NAME_LEN-1] of AnsiChar;  
    wPanPos: WORD;  //水平参数 如果获取到的数据大于360默认减去360
    wTiltPos: WORD;  //垂直参数 如果获取到的数据大于360默认减去360
    wZoomPos: WORD;  //变倍参数如果获取到的数据大于360默认减去360
    byRes2: BYTE;  
    byPTZPosExEnable: BYTE;  //是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。1~启用，PTZ坐标值以struPtzPosEx为准
    struPtzPosEx: NET_PTZ_INFO_EX;  // ptz坐标扩展(支持高精度PTZ值)
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PRESET_NAME = ^NET_DVR_PRESET_NAME;

type
  NET_DVR_SCHEDTASK = record 
    struSchedTime: NET_DVR_SCHEDTIME;  //时间
    wAction: WORD;  ///< 定时动作具体动作
    wActionNum: WORD;  ///< 特殊动作子编号，如预置点，巡航，花样，报警输出，日夜切换，
    byres: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_SCHEDTASK = ^NET_DVR_SCHEDTASK;

//定时任务
type
  NET_DVR_TIME_TASK = record 
    dwSize: DWORD;  
    byTaskEnable: BYTE;  ///< 使能 1-开，0-关
    byRes: array[0..3-1] of BYTE;  ///< 字节对齐
    struTask: array[0..MAX_DAYS-1, 0..MAX_SCH_TASKS_NUM-1] of NET_DVR_SCHEDTASK;  ///< 7天，每天10时间段
    dwParkTime: DWORD;  ///< 守望时间 5s-720s
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_TIME_TASK = ^NET_DVR_TIME_TASK;

//条件结构体
type
  NET_DVR_CHANNEL_INDEX = record 
    dwSize: DWORD;  // 结构体大小
    dwChannel: DWORD;  //通道号
    dwIndex: DWORD;  //索引号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CHANNEL_INDEX = ^NET_DVR_CHANNEL_INDEX;

type
  NET_DVR_AUDIO_NAME = record 
    dwSize: DWORD;  // 结构体大小
    cName: array[0..NAME_LEN-1] of AnsiChar;  //名称
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_NAME = ^NET_DVR_AUDIO_NAME;

//登录设备参数
type
  NET_DVR_LOGIN_DEVICE_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byMobileDev: BYTE;  //设备种类, 0- 非移动设备, 1 - 移动设备
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOGIN_DEVICE_PARAM = ^NET_DVR_LOGIN_DEVICE_PARAM;

type
  RECV_DATA_TYPE =  
  (  
    ENUM_RECV_ERRCODE = $0  //返回错误码
  );

//码流输出模式
type
  FISHEYE_STREAM_OUTPUT_MODE =  
  (  
    FISHEYE_STREAM_MODE_FISHEYE = 1,  //鱼眼模式
    FISHEYE_STREAM_MODE_PTZ = 2,  //PTZ模式
    FISHEYE_STREAM_MODE_PANORAMA = 3  //全景模式
  );

//回调数据类型枚举
type
  CALLBACK_TYPE_DATA_ENUM =  
  (  
    ENUM_FISHEYE_STREAM_STATUS = 1,  //鱼眼码流输出状态
    ENUM_FISHEYE_PTZPOS = 2,  //ptz通道当前所处鱼眼模式下的坐标
    ENUM_FISHEYE_REALTIME_OUTPUT = 3  //实时输出模式
  );

//鱼眼码流状态
type
  NET_DVR_FISHEYE_STREAM_STATUS = record 
    dwSize: DWORD;  //结构体大小
    byStreamMode: BYTE;  //码流输出模式，参见FISHEYE_STREAM_OUTPUT_MODE
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_FISHEYE_STREAM_STATUS = ^NET_DVR_FISHEYE_STREAM_STATUS;

//长连接回调数据结构体
type
  NET_DVR_CALLBACK_TYPE_DATA = record 
    dwChannel: DWORD;  //通道号
    dwDataType: DWORD;  //参见CALLBACK_TYPE_DATA_ENUM
    dwDataLen: DWORD;  //数据长度
    pData: PBYTE;  //数据，当dwTypeData为 ENUM_FISHEYE_STREAM_STATUS，其对应为NET_DVR_FISHEYE_STREAM_STATUS
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_CALLBACK_TYPE_DATA = ^NET_DVR_CALLBACK_TYPE_DATA;

//鱼眼ptz拖动参数
type
  NET_DVR_DRAG_POS_PARAM = record 
    dwChannel: DWORD;  //通道号
    dwPtzChannel: DWORD;  //当dwChannel所指通道模式为FISHEYE_STREAM_MODE_FISHEYE（鱼眼模式时），此值为其拖动所联动的ptz通道。当dwChannel通道模式为非鱼眼时，置为0即可
    struToPoint: NET_VCA_POINT;  //拖动画面要跳转到的目标点，目标点位置相对于预览画面的左上角
    struOriPoint: NET_VCA_POINT;  //拖动操作起始点,此点为当次拖动操作开始时，鼠标指针相对于预览画面左上角的位置
    byRes: array[0..56-1] of BYTE;  //保留
  end;
  LPNET_DVR_DRAG_POS_PARAM = ^NET_DVR_DRAG_POS_PARAM;

//平台查询诊断服务器的状态
type
  NET_DVR_QUERY_STATUS = record 
    dwSize: DWORD;  
    byCpuLoad: BYTE;  //CPU资源占用情况, 取值范围：0-100
    byMemLoad: BYTE;  //Memory资源占用情况，取值范围：0-100
    wAbility: WORD;  //诊断服务器能力集，大于0
    wRemainAbility: WORD;  //诊断服务器剩余能力，取值范围：大于 0  剩余布防点的个数
    wTotalPlanNum: WORD;  //最多64个计划>
    wCurPlanNum: WORD;  //当前计划数  最多64个计划>
    byRes: array[0..62-1] of BYTE;  //保留
  end;
  LPNET_DVR_QUERY_STATUS = ^NET_DVR_QUERY_STATUS;

type
  NET_DVR_MONITOR_VQDCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用
    byDevType: BYTE;  //设备类型：0-非云台设备，1-带云台设备
    bySignalPoint: BYTE;  //信号丢失阀值，0-100
    byBlurPoint: BYTE;  //图像模糊阀值，0-100
    byLumaPoint: BYTE;  //图像过亮阀值，0-100
    byChromaPoint: BYTE;  //图像偏色阀值，0-100
    bySnowPoint: BYTE;  //噪声干扰阀值，0-100
    byStreakPoint: BYTE;  //条纹干扰阀值，0-100
    byFreezePoint: BYTE;  //画面冻结阀值，0-100
    byPTZPoint: BYTE;  //云台失控阀值，0-100
    byMonitorDel: BYTE;  //布防点删除 0-不删除， 1-删除
    byContrastThreshold: BYTE;  //对比度异常阈值，0-100
    byMonoThreshold: BYTE;  //黑白图像阈值，0-100
    byShakeThreshold: BYTE;  //视频抖动阈值，0-100
    byFlashThreshold: BYTE;  //视频剧变阈值，0-100
    byCoverThreshold: BYTE;  //视频遮挡阈值，0-100
    bySceneThreshold: BYTE;  //场景变更阈值，0-100
    byDarkThreshold: BYTE;  //图像过暗阈值，0-100
    byRes: array[0..46-1] of BYTE;  
  end;
  LPNET_DVR_MONITOR_VQDCFG = ^NET_DVR_MONITOR_VQDCFG;

//诊断结果
type
  NET_DVR_DIAGNOSIS_UPLOAD = record 
    dwSize: DWORD;  
    sStreamID: array[0..STREAM_ID_LEN-1] of AnsiChar;  ///< 流ID，长度小于32个字节
    sMonitorIP: array[0..64-1] of AnsiChar;  ///< 布防点ip
    dwChanIndex: DWORD;  ///< 布防点通道号
    dwWidth: DWORD;  ///< 图像宽度
    dwHeight: DWORD;  ///< 图像高度
    struCheckTime: NET_DVR_TIME;  ///< 检测时间(合并日期和时间字段)，格式：2012-08-06 13:00:00
    byResult: BYTE;  ///0-未检测 1-正常 2-异常 3-登录失败 4-取流异常
    bySignalResult: BYTE;  ///< 视频丢失检测结果 0-未检测 1-正常 2-异常
    byBlurResult: BYTE;  ///< 图像模糊检测结果，0-未检测 1-正常 2-异常
    byLumaResult: BYTE;  ///< 图像过亮检测结果，0-未检测 1-正常 2-异常
    byChromaResult: BYTE;  ///< 偏色检测结果，0-未检测 1-正常 2-异常
    bySnowResult: BYTE;  ///< 噪声干扰检测结果，0-未检测 1-正常 2-异常
    byStreakResult: BYTE;  ///< 条纹干扰检测结果，0-未检测 1-正常 2-异常
    byFreezeResult: BYTE;  ///< 画面冻结检测结果，0-未检测 1-正常 2-异常
    byPTZResult: BYTE;  ///< 云台检测结果，0-未检测 1-正常 2-异常
    byContrastResult: BYTE;  //对比度异常检测结果，0-未检测，1-正常，2-异常
    byMonoResult: BYTE;  //黑白图像检测结果，0-未检测，1-正常，2-异常
    byShakeResult: BYTE;  //视频抖动检测结果，0-未检测，1-正常，2-异常
    sSNapShotURL: array[0..256-1] of AnsiChar;  ///<图片URL地址
    byFlashResult: BYTE;  //视频剧变检测结果，0-未检测，1-正常，2-异常
    byCoverResult: BYTE;  //视频遮挡检测结果，0-未检测，1-正常，2-异常
    bySceneResult: BYTE;  //场景变更检测结果，0-未检测，1-正常，2-异常
    byDarkResult: BYTE;  //图像过暗检测结果，0-未检测，1-正常，2-异常
    byStreamType: BYTE;  //码流类型，0-无效，1-未知，2-国标类型，3-非国标类型
    byRes2: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_DIAGNOSIS_UPLOAD = ^NET_DVR_DIAGNOSIS_UPLOAD;

type
  NET_DVR_DOWN_LOAD_REQUEST = record ///< 这个数据结构是平台发送到诊断服务器的
    struStreamInfo: NET_DVR_STREAM_INFO;  
    sSnapShotURL: array[0..256-1] of AnsiChar;  ///< 诊断抓图URL，长度小于256个字节
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DOWN_LOAD_REQUEST = ^NET_DVR_DOWN_LOAD_REQUEST;

type
  NET_DVR_VQD_RESULT_INFO = record ///< 这个数据结构是诊断服务器返回给平台的
    dwSize: DWORD;  
    sStreamID: array[0..32-1] of AnsiChar;  ///<流ID(布防点ID)，长度小于32个字节
    dwPicLength: DWORD;  ///图片长度
    byStatus: BYTE;  ///< 设置结果:0-成功,1-数据有误，2-图片不存在，3-获取图片失败
    byRes: array[0..31-1] of BYTE;  
    pSnapShot: PAnsiChar;  ///< 诊断抓图，是一块图片缓存数据(700k)
  end;
  LPNET_DVR_VQD_RESULT_INFO = ^NET_DVR_VQD_RESULT_INFO;

type
  NET_DVR_PLAN_VQD_CFG = record 
    dwSize: DWORD;  
    sPlanID: array[0..PLAN_ID_LEN-1] of BYTE;  ///< 计划id，长度小于32个字节
    struDetectTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  ///< 检测时间
    byPlanMode: BYTE;  ///0:即时计划，1:周期计划
    byRes1: BYTE;  //
    byCheckFlag: BYTE;  ///< 是否检测，0-不检测，1-检测
    bySignal: BYTE;  ///<视频丢失 是否检测，0-不检测，1-检测
    byBlur: BYTE;  ///< 图像模糊 是否检测，0-不检测，1-检测
    byLuma: BYTE;  ///< 图像过亮是否检测，0-不检测，1-检测
    byChroma: BYTE;  ///< 偏色检测 是否检测，0-不检测，1-检测
    bySnow: BYTE;  ///<噪声干扰 是否检测，0-不检测，1-检测
    byStreak: BYTE;  ///<条纹干扰 是否检测，0-不检测，1-检测
    byFreeze: BYTE;  ///<画面冻结是否检测，0-不检测，1-检测
    byPTZ: BYTE;  ///<云台是否检测，0-不检测，1-检测
    byEnablePlanRound: BYTE;  ///计划循环是否开启
    byContrast: BYTE;  //对比度异常是否检测，0-不检测，1-检测
    byMono: BYTE;  //黑白图像是否检测，0-不检测，1-检测
    byShake: BYTE;  //视频抖动是否检测，0-不检测，1-检测
    byFlash: BYTE;  //视频剧变是否检测，0-不检测，1-检测
    byCover: BYTE;  //视频遮挡是否检测，0-不检测，1-检测
    byScene: BYTE;  //场景变更是否检测，0-不检测，1-检测
    byDark: BYTE;  //图像过暗是否检测，0-不检测，1-检测
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_VQD_CFG = ^NET_DVR_PLAN_VQD_CFG;


type
  NET_DVR_TEST_SPOTCFG = record 
    dwSize: DWORD;  
    byStepCount: BYTE;  //总步数
    byStepIndex: BYTE;  //当前第几步
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_TEST_SPOTCFG = ^NET_DVR_TEST_SPOTCFG;

//第三方IPC列表
type
  NET_DVR_IPC_ENUM =  
  (  
    ENUM_BUSINESS_INVALID = -1,  

    ENUM_BUSINESS_HIKVISION = 0,  
    ENUM_BUSINESS_PANASONIC,  
    ENUM_BUSINESS_SONY,  
    ENUM_BUSINESS_AXIS,  
    ENUM_BUSINESS_SANYO,  
    ENUM_BUSINESS_BOSCH,  
    ENUM_BUSINESS_ZAVIO,  
    ENUM_BUSINESS_GRANDEYE,  
    ENUM_BUSINESS_PROVIDEO,  
    ENUM_BUSINESS_ARECONT,  // 9
    ENUM_BUSINESS_ACTI,  
    ENUM_BUSINESS_PELCO,  
    ENUM_BUSINESS_VIVOTEK,  
    ENUM_BUSINESS_INFINOVA,  
    ENUM_BUSINESS_DAHUA,  //14

    ENUM_BUSINESS_HIK_STD_H264 = $20,  
    ENUM_BUSINESS_HIK_STD_MPEG4,  
    ENUM_BUSINESS_SUNELL,  //景阳
    ENUM_BUSINESS_ATEME,  
    ENUM_BUSINESS_LAUNCH,  //朗驰
    ENUM_BUSINESS_YAAN,  //雅安
    ENUM_BUSINESS_BLUESKY,  //蓝色星际
    ENUM_BUSINESS_BLUESKYLIMIT,  //蓝色星际LIMIT
    ENUM_BUSINESS_TDWY,  //天地伟业
    ENUM_BUSINESS_HBGK,  //汉邦高科
    ENUM_BUSINESS_SANTACHI,  //金三立
    ENUM_BUSINESS_HIGHEASY,  //恒忆
    ENUM_BUSINESS_SAMSUNG,  

    ENUM_BUSINESS_URL_RTSP = $40,  // url类型取流 
    ENUM_BUSINESS_ONVIF,  

    ENUM_MAX_BUSINESS_TYPE  //最大厂商类型
  );
  LPNET_DVR_IPC_ENUM = ^NET_DVR_IPC_ENUM;

//后端传显统一后第三方IPC列表
type
  NET_DVR_IPC_ENUM_UNIFY =  
  (  
    ENUM_IPC_PROTOCOL_INVALID = -1,  
    ENUM_IPC_PROTOCOL_HIKVISION = 0,  //海康威视
    ENUM_IPC_PROTOCOL_PANASONIC,  //松下
    ENUM_IPC_PROTOCOL_SONY,  //索尼

    ENUM_IPC_PROTOCOL_AXIS = 4,  //安讯士
    ENUM_IPC_PROTOCOL_SANYO,  //三洋
    ENUM_IPC_PROTOCOL_BOSCH,  //博世
    ENUM_IPC_PROTOCOL_ZAVIO,  //ZAVIO
    ENUM_IPC_PROTOCOL_GRANDEYE,  //GRANDEYE
    ENUM_IPC_PROTOCOL_PROVIDEO,  //创视
    ENUM_IPC_PROTOCOL_ARECONT,  //爱锐康特
    ENUM_IPC_PROTOCOL_ACTI,  //大卫通
    ENUM_IPC_PROTOCOL_PELCO,  //帕尔高
    ENUM_IPC_PROTOCOL_VIVOTEK,  //晶睿通讯
    ENUM_IPC_PROTOCOL_DAHUA,  //大华
    ENUM_IPC_PROTOCOL_SAMSUNG,  //三星

    ENUM_IPC_PROTOCOL_PSIA = 17,  //PSIA
    ENUM_IPC_PROTOCOL_ONVIF,  //ONVIF
    ENUM_IPC_PROTOCOL_BRICKCOM,  //金砖通信
    ENUM_IPC_PROTOCOL_GB28181,  //GB28181

    ENUM_IPC_PROTOCOL_CANON = 23,  //佳能

    ENUM_IPC_PROTOCOL_HUINT = 32,  //HUINT
    ENUM_IPC_PROTOCOL_INFINOVA,  //英飞拓
    ENUM_IPC_PROTOCOL_HIK_STD_H264,  //海康标准264
    ENUM_IPC_PROTOCOL_HIK_STD_MPEG4,  //海康标准MPEG4
    ENUM_IPC_PROTOCOL_SUNELL,  //景阳
    ENUM_IPC_PROTOCOL_ATEME,  //安特姆
    ENUM_IPC_PROTOCOL_LAUNCH,  //郎驰
    ENUM_IPC_PROTOCOL_YAAN,  //亚安
    ENUM_IPC_PROTOCOL_BLUESKY,  //蓝色星际
    ENUM_IPC_PROTOCOL_BLUESKYLIMIT,  //蓝色星际LIMIT
    ENUM_IPC_PROTOCOL_TDWY,  //天地伟业
    ENUM_IPC_PROTOCOL_HBGK,  //汉邦高科
    ENUM_IPC_PROTOCOL_SANTACHI,  //金三立
    ENUM_IPC_PROTOCOL_HIGHEASY,  //恒亿
    ENUM_IPC_PROTOCOL_HANBANG,  //汉邦高科
    ENUM_IPC_PROTOCOL_SAMSUNG_3120,  //三星3120
    ENUM_IPC_PROTOCOL_SAMSUNG_3080,  //三星3080
    ENUM_IPC_PROTOCOL_SAMSUNG_2000,  //三星2000
    ENUM_IPC_PROTOCOL_SAMSUNG_5200,  //三星5200
    ENUM_IPC_PROTOCOL_JINGYUAN,  //警院
    ENUM_IPC_PROTOCOL_VIDEOTREC,  //动力盈科
    ENUM_IPC_PROTOCOL_CHENOVA,  //上海诚丰
    ENUM_IPC_PROTOCOL_FENGHUO,  //烽火
    ENUM_IPC_PROTOCOL_ZB_5301,  //浙江贝尔5301
    ENUM_IPC_PROTOCOL_ZB_5401,  //浙江贝尔5401
    ENUM_IPC_PROTOCOL_HAIXIN,  //海信
    ENUM_IPC_PROTOCOL_ZHONGYINGXIN,  //中瀛鑫
    ENUM_IPC_PROTOCOL_AVUN,  //信诺安达
    ENUM_IPC_PROTOCOL_GOVTY,  //广州吉田
    ENUM_IPC_PROTOCOL_SAE,  //艾里克
    ENUM_IPC_PROTOCOL_DONGFANGWANGLI,  //东方网力
    ENUM_IPC_PROTOCOL_CHANGHONG,  //长虹
    ENUM_IPC_PROTOCOL_H3C,  //华三
    ENUM_IPC_PROTOCOL_BAIAN,  //百安
    ENUM_IPC_PROTOCOL_HAT,  //华安泰
    ENUM_IPC_PROTOCOL_YUANYE,  //远业
    ENUM_IPC_PROTOCOL_HIKCARD,  //海康板卡
    ENUM_IPC_PROTOCOL_HAIXINCAP,  //海信抓拍机
    ENUM_IPC_PROTOCOL_WENANCAP,  //文安抓拍机
    ENUM_IPC_PROTOCOL_XUNMEI,  //讯美
    ENUM_IPC_PROTOCOL_BAIWO,  //佰沃
    ENUM_IPC_PROTOCOL_APD,  //安普达
    ENUM_IPC_PROTOCOL_REACHDEV,  //锐取
    ENUM_IPC_PROTOCOL_XUNMEI_DAHUA,  //讯美大华OEM
    ENUM_IPC_PROTOCOL_HUANGHE,  //黄河设备
    ENUM_IPC_PROTOCOL_LIANCHEN,  //联宸
    ENUM_IPC_PROTOCOL_CHENGYE,  //诚业
    ENUM_IPC_PROTOCOL_VISIONDIGI,  //威乾
    ENUM_IPC_PROTOCOL_HENGHE,  //恒河
    ENUM_IPC_PROTOCOL_KODAK,  //科达
    ENUM_IPC_PROTOCOL_AIRONIX,  //奥尼克斯
    ENUM_IPC_PROTOCOL_LG,  //乐金
    ENUM_IPC_PROTOCOL_HASEE,  //神州
    ENUM_IPC_PROTOCOL_8000ME,  //8000ME
    ENUM_IPC_PROTOCOL_POVITEL,  //普天博威
    ENUM_IPC_PROTOCOL_YIVIEW,  //亿维
    ENUM_IPC_PROTOCOL_TIANYUE,  //天跃
    ENUM_IPC_PROTOCOL_HOWELL,  //浩维
    ENUM_IPC_PROTOCOL_WAPA,  //波粒
    ENUM_IPC_PROTOCOL_SANLE,  //三乐
    ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION,  //加密海康板卡
    ENUM_IPC_PROTOCOL_JUNSDA,  //宙视达
    ENUM_IPC_PROTOCOL_LIYUAN,  //立元
    ENUM_IPC_PROTOCOL_XINCHAN,  //信产
    ENUM_IPC_PROTOCOL_BITE,  //比特
    ENUM_IPC_PROTOCOL_MEIAN,  //美安
    ENUM_IPC_PROTOCOL_ROSEEK,  //锐势
    ENUM_IPC_PROTOCOL_AEBELL,  //美电贝尔
    ENUM_IPC_PROTOCOL_JSL_ST,  //金三立ST
    ENUM_IPC_PROTOCOL_VIMICRO,  //中星微电子
    ENUM_IPC_PROTOCOL_UNIVIEW,  //宇视

    ENUM_IPC_PROTOCOL_TYPE  //最大厂商类型
  );
  LPNET_DVR_IPC_ENUM_UNIFY = ^NET_DVR_IPC_ENUM_UNIFY;



type
  NET_DVR_MRD_SEARCH_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    struStreamInfo: NET_DVR_STREAM_INFO;  // 布防点
    wYear: WORD;  // 年
    byMonth: BYTE;  // 月
    byDrawFrame: BYTE;  // 0-不抽帧 1-抽帧
    byStreamType: BYTE;  //0-主码流 1-子码流
    byLocalOrUTC: BYTE;  //0-设备本地时区  1-UTC
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_MRD_SEARCH_PARAM = ^NET_DVR_MRD_SEARCH_PARAM;

type
  NET_DVR_MRD_SEARCH_RESULT = record 
    dwSize: DWORD;  // 结构体大小
    byRecordDistribution: array[0..LEN_32-1] of BYTE;  // 录像分布，byRecordDistribution[0]=1表示1日存在录像，byRecordDistribution[0]=0表示没有录像，
    //byRecordDistribution[1]表示2日，以此类推
    byHasEventRecode: array[0..LEN_31-1] of BYTE;  //事件录像 0-无事件录像，1-有事件录像
    byRes: BYTE;  //保留
  end;
  LPNET_DVR_MRD_SEARCH_RESULT = ^NET_DVR_MRD_SEARCH_RESULT;


type
  NET_DVR_ACCESS_DEVICE_INFO = record 
    dwSize: DWORD;  // 结构体大小
    byGroup: BYTE;  // 组号，每组可获取 64个通道，从0开始, 0表示第1组，以此类推
    byProType: BYTE;  //协议类型，0-私有协议，1-松下协议，2-索尼
    byAccessMode: BYTE;  //接入模式，0-IP地址，1-域名
    byRes1: BYTE;  //保留字段，置0
    szUserName: array[0..NAME_LEN-1] of AnsiChar;  //用户名
    szPassword: array[0..PASSWD_LEN-1] of AnsiChar;  //密码
    szDomain: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //设备域名
    struIP: NET_DVR_IPADDR;  //IP地址
    wPort: WORD;  // 端口号
    szGB28181DevID: array[0..DEV_ID_LEN-1] of BYTE;  //GB28181协议接入时的设备服务器ID
    byRes2: array[0..2-1] of BYTE;  //保留字段，置0
  end;
  LPNET_DVR_ACCESS_DEVICE_INFO = ^NET_DVR_ACCESS_DEVICE_INFO;

type
  NET_DVR_ACCESS_DEVICE_CHANNEL_INFO = record 
    dwSize: DWORD;  // 结构体大小
    dwTotalChannelNum: DWORD;  //设备总通道个数，设备不在线时返回0，byChannel无效
    byChannel: array[0..MAX_CHANNUM_V30-1] of BYTE;  {byChannel[i]为0表示第（byGroup+1）*（i-1）通道未接入到NVR，
                                    为1表示该通道已接入到NVR byGroup在NET_DVR_ACCESS_DEVICE_INFO中}
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO = ^NET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

type
  NET_DVR_PREVIEW_SWITCH_COND = record 
    dwSize: DWORD;  //组号
    byGroup: BYTE;  //组号，每组可配置64个画面
    byVideoOutType: BYTE;  {视频输出接口类型,0-主CVBS,1-HDMI 2-VGA 3-辅助输出一
                     4-辅助输出二 5-辅助输出三 6-辅助输出四, 7-辅助HDMI, 8-扩展HDMI1,
                     9-扩展HDMI2, 10-扩展HDMI3, 11-扩展HDMI4, 12-非同源VGA1，
                     13-非同源VGA2，14-非同源VGA3，15-非同源VGA4，16-同源VGA, 17-主LCD,18-辅助VGA,19-辅助LCD}
    byGetDefaultPreviewSet: BYTE;  //是否获取预设，0-否，1-是；若为是时，byPreviewNumber字段有效
    byPreviewNumber: BYTE;  //预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面6-25画面,7-32画面, 8-36画面 0xfb-自定义分屏4, 0xfc-自定义分屏3, 0xfd-自定义分屏2, 0xfe-自定义分屏1,0xff:最大画面
  end;
  LPNET_DVR_PREVIEW_SWITCH_COND = ^NET_DVR_PREVIEW_SWITCH_COND;

type
  NET_DVR_PREVIEW_SWITCH_CFG = record 
    dwSize: DWORD;  // 版本管理及结构体大小
    wSwitchSeq: array[0..MAX_WINDOW_V40-1] of WORD;  {bySwitchSeq [i]=6，表示第（组号*64+i+1）个窗口
                    显示第六通道，为0xff表示该窗口不显示}
    byPreviewNumber: BYTE;  {预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面，6-25画面,7-32画面, 8-36画面, 9-64画面
                    0xff:最大画面}
    byEnableAudio: BYTE;  //是否声音预览,0-不预览,1-预览
    bySwitchTime: BYTE;  //切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
    bySameSource: BYTE;  //是否同源，当视频输出口类型为非同源VGA1-非同源VGA4时有效
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_PREVIEW_SWITCH_CFG = ^NET_DVR_PREVIEW_SWITCH_CFG;

type
  NET_DVR_USER_COND = record 
    szUserName: array[0..NAME_LEN-1] of AnsiChar;  
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_USER_COND = ^NET_DVR_USER_COND;

type
  NET_DVR_USER_RIGHT_CFG = record 
    dwSize: DWORD;  
    byAddMonitoringPointRight: BYTE;  // 添加布防点（前端设备）权限0-无 1-有
    byModMonitoringPointRight: BYTE;  // 修改布防点（前端设备）权限0-无 1-有
    byDelMonitoringPointRight: BYTE;  // 添加布防点（前端设备）权限0-无 1-有
    bySetRecordPlanRight: BYTE;  // 制定录像策略权限0-无 1-有
    byDelRecordPlanRight: BYTE;  // 删除录像策略权限0-无 1-有
    byEnableOrDisableRecordPlanRight: BYTE;  // 启用和禁用录像计划权限0-无 1-有
    byManualRecordRight: BYTE;  // 启动和停止手动录像权限0-无 1-有
    bySetAlarmRecordRight: BYTE;  // 报警录像设定权限0-无 1-有
    byRecordBackupRight: BYTE;  // 录像存档权限0-无 1-有
    byRecordDownloadRight: BYTE;  // 录像下载权限0-无 1-有
    byRecordDeleteRight: BYTE;  // 录像删除权限0-无 1-有（保留）
    byDelBackupRecordRight: BYTE;  // 删除存档录像权限0-无 1-有（保留）
    bySetBackupVolumeRight: BYTE;  // 设置存档卷权限0-无 1-有
    byRecordPlayBackRight: BYTE;  // 录像回放权限0-无 1-有 DWORD dwZoneIndex
    byLogDeleteRight: BYTE;  // 日志清空权限0-无 1-有（保留）
    byLogDownloadRight: BYTE;  // 日志下载权限0-无 1-有（保留）
    byAddUserRight: BYTE;  // 添加用户权限0-无 1-有
    byDelUserRight: BYTE;  // 删除用户权限0-无 1-有
    byModUserRight: BYTE;  // 修改用户权限0-无 1-有
    byAllocUserRight: BYTE;  // 用户权限分配权限0-无 1-有
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_USER_RIGHT_CFG = ^NET_DVR_USER_RIGHT_CFG;

type
  NET_DVR_MACHINE_MAX_NUM_CFG = record 
    dwSize: DWORD;  
    dwMaxNum: DWORD;  // 最大备机数目
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNETDVR_MACHINE_MAX_NUM_CFG = ^NET_DVR_MACHINE_MAX_NUM_CFG;

//配置N+1设备工作机模式，NVR需要这步，CVR不需要
type
  NET_DVR_N_PLUS_ONE_WORK_MODE_CFG = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //0-工作机 1-备机
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG = ^NET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

type
  NET_DVR_ADD_PARAM = record 
    struIP: NET_DVR_IPADDR;  // 设备IP
    szPassword: array[0..PASSWD_LEN-1] of AnsiChar;  //备机密码，需简易加密
    byAddType: BYTE;  // 0-（工作机上）添加备机，1-（备机上）添加工作机
    byDisableBackup: BYTE;  //备份功能使能开关 0-开启1-关闭 CVR默认开启
  end;
  LPNET_DVR_ADD_PARAM = ^NET_DVR_ADD_PARAM;

type
  NET_DVR_DEL_PARAM = record 
    struIP: NET_DVR_IPADDR;  // 设备IP
    byDelType: BYTE;  // 0-删除指定的机器（备机或工作机）1-全删
  end;
  LPNET_DVR_DEL_PARAM = ^NET_DVR_DEL_PARAM;

type
  NET_DVR_NPO_PARAM_UNION = record 
    case Byte of
    0: (struAddParam: NET_DVR_ADD_PARAM);  //添加信息
    1: (struDelParam: NET_DVR_DEL_PARAM);  //删除信息
  end;
  LPNET_DVR_NPO_PARAM_UNION = ^NET_DVR_NPO_PARAM_UNION;

// N+1模式设备参数
type
  NET_DVR_N_PLUS_ONE_DEVICE_PARAM = record 
    dwSize: DWORD;  
    unionParam: NET_DVR_NPO_PARAM_UNION;  
    byType: BYTE;  // 0-添加，对应unionParam中的struAddParam 1-删除，对应unionParam中的struDelParam  2-添加且用户名生效，对应unionParam中的struAddParam 和szUserName
    byRes: array[0..3-1] of BYTE;  
    szUserName: array[0..NAME_LEN-1] of AnsiChar;  //用户名
    byRes2: array[0..220-1] of BYTE;  // 保留
  end;
  LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM = ^NET_DVR_N_PLUS_ONE_DEVICE_PARAM;

// 数据回迁
type
  NET_DVR_DATA_CALLBACK_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  // 0-不启用数据回迁 1-启用数据回迁
    byDelData: BYTE;  // 当byEnable为1是有效 0-不删除备机录像数据 1-删除备机录像数据
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_DATA_CALLBACK_CFG = ^NET_DVR_DATA_CALLBACK_CFG;

type
  NET_DVR_HD_STATUS = record 
    dwSize: DWORD;  
    bySleepStatus: BYTE;  //休眠状态0-不休眠 1-休眠
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_HD_STATUS = ^NET_DVR_HD_STATUS;

type
  NET_DVR_RAID_BTS_CFG = record 
    dwSize: DWORD;  
    bySpeed: BYTE;  //0-高速 1-中速 2-低速
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_RAID_BTS_CFG = ^NET_DVR_RAID_BTS_CFG;

type
  NET_DVR_LUN_CLONE = record 
    dwSize: DWORD;  
    dwSrcLunID: DWORD;  // 源LUN ID
    dwDstLunID: DWORD;  // 目的LUN ID
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LUN_CLONE = ^NET_DVR_LUN_CLONE;

type
  NET_DVR_LUN_EXPAND = record 
    dwSize: DWORD;  
    dwLunID: DWORD;  // LUN ID
    dwHSize: DWORD;  // 扩展的大小高32位
    dwLSize: DWORD;  // 扩展的大小低32位
    szArrayIDGroup: array[0..NAME_LEN-1] of AnsiChar;  // 使用的阵列ID组，以逗号隔开，为空则为默认
    szNewLunName: array[0..MAX_NAMELEN-1] of AnsiChar;  // 新LUN名
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LUN_EXPAND = ^NET_DVR_LUN_EXPAND;


type
  NET_DVR_DVR_NET_DISK_MODIFY = record 
    dwSize: DWORD;  
    szOldDvrNetDiskName: array[0..MAX_NAMELEN-1] of AnsiChar;  // 原DVR网盘共享名
    szNewDvrNetDiskName: array[0..MAX_NAMELEN-1] of AnsiChar;  // 新DVR网盘共享名
    struWarrantIP: NET_DVR_IPADDR;  // 新授权的DVR网盘IP
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DVR_NET_DISK_MODIFY = ^NET_DVR_DVR_NET_DISK_MODIFY;


type
  NET_DVR_NAS_PARAM = record 
    dwSize: DWORD;  
    dwLunID: DWORD;  // LUN ID
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_NAS_PARAM = ^NET_DVR_NAS_PARAM;

type
  NET_DVR_ISCSI_PARAM = record 
    dwSize: DWORD;  
    dwTargetID: DWORD;  // iSCSI服务的Target ID
    dwLunID: DWORD;  // LUN ID
    dwAccessMode: DWORD;  //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    struClientIP: NET_DVR_IPADDR;  // 客户端IP，0.0.0.0为所以IP
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ISCSI_PARAM = ^NET_DVR_ISCSI_PARAM;

type
  NET_DVR_FC_PARAM = record 
    dwSize: DWORD;  
    dwStoreLunID: DWORD;  // 存储LUN ID
    dwLogicLunID: DWORD;  // 逻辑LUN ID，-1表示自动生成
    dwHbaID: DWORD;  // 光纤通道号
    dwAccessMode: DWORD;  //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    szClientWWWPN: array[0..NAME_LEN-1] of AnsiChar;  // 客户光纤卡
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FC_PARAM = ^NET_DVR_FC_PARAM;


// 逻辑卷 60字节
type
  NET_DVR_LUN_PARAM = record 
    dwHCapacity: DWORD;  // 逻辑卷大小高32位
    dwLCapacity: DWORD;  // 逻辑卷大小低32位
    szName: array[0..MAX_NAMELEN-1] of AnsiChar;  // 逻辑卷名称
    dwBlockSize: DWORD;  // 逻辑卷的最小存储单元块大小
    szArrayIDGroup: array[0..NAME_LEN-1] of AnsiChar;  //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
  end;
  LPNET_DVR_LUN_PARAM = ^NET_DVR_LUN_PARAM;

type
  NET_DVR_DVR_PARAM = record 
    dwHCapacity: DWORD;  // DVR网盘大小高32位
    dwLCapacity: DWORD;  // DVR网盘大小低32位
    szName: array[0..MAX_NAMELEN-1] of AnsiChar;  // DVR网盘名称
    dwBlockSize: DWORD;  // 逻辑卷的最小存储单元块大小
    struWarrantIP: NET_DVR_IPADDR;  // 授权的DVR网盘IP
    szArrayIDGroup: array[0..NAME_LEN-1] of AnsiChar;  //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
  end;
  LPNET_DVR_DVR_PARAM = ^NET_DVR_DVR_PARAM;

type
  NET_DVR_VD_UNION = record 
    case Byte of
    0: (byUnionLen: array[0..256-1] of BYTE);  // 联合体大小
    1: (struHikVDParam: NET_DVR_OPERATE_VD_PARAM);  // 虚拟磁盘
    2: (struLunParam: NET_DVR_LUN_PARAM);  // 逻辑卷
    3: (struDvrParam: NET_DVR_DVR_PARAM);  // DVR网盘
  end;
  LPNET_DVR_VD_UNION = ^NET_DVR_VD_UNION;

type
  NET_DVR_OPERATE_VD_PARAM_EX = record 
    byVDType: BYTE;  //虚拟磁盘类型：0-私有虚拟磁盘 1-逻辑卷 2-DVR网盘
    byRes1: array[0..3-1] of BYTE;  
    uVDParam: NET_DVR_VD_UNION;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OPERATE_VD_PARAM_EX = ^NET_DVR_OPERATE_VD_PARAM_EX;

type
  NET_DVR_CVR_ALARM = record 
    szFirstType: array[0..NAME_LEN-1] of AnsiChar;  //主类型，不能为空
    szFirstIndex: array[0..NAME_LEN-1] of AnsiChar;  //主类型编号
    szSecondType: array[0..NAME_LEN-1] of AnsiChar;  //次类型，可以为空
    struTime: NET_DVR_TIME;  //报警时间
    byStatus: BYTE;  //状态 0-正常 非0-不正常，不同类型值表示意义不同，见下表
    byAlarmLevel: BYTE;  //报警级别
    byRes1: array[0..2-1] of BYTE;  
    szSecondIndex: array[0..NAME_LEN-1] of AnsiChar;  //次类型编号，可以为空
    szThirdType: array[0..NAME_LEN-1] of AnsiChar;  //第三类型，可以为空
    szThirdIndex: array[0..NAME_LEN-1] of AnsiChar;  //第三类型编号
    szFourthType: array[0..NAME_LEN-1] of AnsiChar;  //第四类型，可以为空
    szFourthIndex: array[0..NAME_LEN-1] of AnsiChar;  //第四类型编号
    byRes2: array[0..92-1] of BYTE;  //保留
  end;
  LPNET_DVR_CVR_ALARM = ^NET_DVR_CVR_ALARM;

type
  NET_DVR_WORKING_DEVICE_INFO = record 
    struIP: NET_DVR_IPADDR;  //设备IP
    byLinkStatus: BYTE;  //连接状态 0-连接失败1-连接成功
    byWorkStatus: BYTE;  //工作状态 0-正常1-异常
    byBacupStatus: BYTE;  //备份状态0-不在备份1-正在备份
    bySyncProgress: BYTE;  //录像同步进度，0表示未开始，100表示同步完成
    struSyncBeginTime: NET_DVR_TIME_EX;  //同步开始时间
    struSyncEndTime: NET_DVR_TIME_EX;  //同步结束时
    szSerialNumber: array[0..SERIALNO_LEN-1] of AnsiChar;  //设备序列号
    dwSoftwareVersion: DWORD;  //设备软件版本
    byWorkingDeviceGUID: array[0..GUID_LEN-1] of BYTE;  //工作机GUID，非字符串，用于备机上搜索工作机录像
    szDevTypeName: array[0..DEV_TYPE_NAME_LEN-1] of AnsiChar;  //设备类型名称
    wDevType: WORD;  //设备类型值
  end;
  LPNET_DVR_WORKING_DEVICE_INFO = ^NET_DVR_WORKING_DEVICE_INFO;

type
  NET_DVR_REDUNDANT_DEVICE_INFO = record 
    struIP: NET_DVR_IPADDR;  //设备IP
    byWorkStatus: BYTE;  //工作状态 0-正常1-异常
    byBackupStatus: BYTE;  //备份状态0-不在布防 1-正在布防2-正在备份中2-正在同步
    wBackupPort: WORD;  //备份端口
  end;
  LPNET_DVR_REDUNDANT_DEVICE_INFO = ^NET_DVR_REDUNDANT_DEVICE_INFO;

type
  NET_DVR_WORKING_DEVICE_INFO_V50 = record 
    struWorkingDeviceInfo: NET_DVR_WORKING_DEVICE_INFO;  //工作机信息
    szUserName: array[0..NAME_LEN-1] of AnsiChar;  //用户名
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WORKING_DEVICE_INFO_V50 = ^NET_DVR_WORKING_DEVICE_INFO_V50;

type
  NET_DVR_REDUNDANT_DEVICE_INFO_V50 = record 
    struRedundantDeviceInfo: NET_DVR_REDUNDANT_DEVICE_INFO;  //备机信息
    szUserName: array[0..NAME_LEN-1] of AnsiChar;  //用户名
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_REDUNDANT_DEVICE_INFO_V50 = ^NET_DVR_REDUNDANT_DEVICE_INFO_V50;

type
  NET_DVR_NPO_DEV_INFO_UNION = record 
    case Byte of
    0: (byUnionLen: array[0..512-1] of BYTE);  //联合体长度
    1: (struWorkingDeviceInfo: NET_DVR_WORKING_DEVICE_INFO);  //工作机信息
    2: (struRedundantDeviceInfo: NET_DVR_REDUNDANT_DEVICE_INFO);  //备机信息
    3: (struWorkingDeviceInfoV50: NET_DVR_WORKING_DEVICE_INFO_V50);  //工作机信息V50
    4: (struRedundantDeviceInfoV50: NET_DVR_REDUNDANT_DEVICE_INFO_V50);  //备机信息V50
  end;
  LPNET_DVR_NPO_DEV_INFO_UNION = ^NET_DVR_NPO_DEV_INFO_UNION;


type
  NET_DVR_N_PLUS_ONE_DEVICE_INFO = record 
    dwSize: DWORD;  
    unionDevInfo: NET_DVR_NPO_DEV_INFO_UNION;  
    byType: BYTE;  {类型 0-工作机，对应unionDevInfo中的struWorkingDeviceInfo     1-备机，对应unionDevInfo中的struRedundantDeviceInfo
                                           2-工作机V50，对应unionDevInfo中的struWorkingDeviceInfoV50     3-备机V50，对应unionDevInfo中的struRedundantDeviceInfoV50}
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_N_PLUS_ONE_DEVICE_INFO = ^NET_DVR_N_PLUS_ONE_DEVICE_INFO;

//ipc升级参数
type
  NET_DVR_UPGRADE_IPC_PARAM = record 
    struStreamInfo: array[0..MAX_CHANNUM_V30-1] of NET_DVR_STREAM_INFO;  // 64个布防点
    szFileName: array[0..260-1] of AnsiChar;  // 升级文件名
  end;
  LPNET_DVR_UPGRADE_IPC_PARAM = ^NET_DVR_UPGRADE_IPC_PARAM;


type
  NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE = record 
    struStreamInfo: NET_DVR_STREAM_INFO;  //布防点
    wErrCode: WORD;  //对应错误码
    byRes: array[0..30-1] of BYTE;  //保留
  end;
  LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE = ^NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

type
  NET_DVR_UPGRADE_IPC_ERR_INFO = record 
    struErrInfoSingle: array[0..MAX_CHANNUM_V30-1] of NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;  
  end;
  LPNET_DVR_UPGRADE_IPC_ERR_INFO = ^NET_DVR_UPGRADE_IPC_ERR_INFO;

//IPC配置文件导入
type
  NET_DVR_IPC_CFG_FILE_PARAM = record 
    szFileName: array[0..260-1] of AnsiChar;  // 配置文件名
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IPC_CFG_FILE_PARAM = ^NET_DVR_IPC_CFG_FILE_PARAM;

type
  NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE = record 
    wRow: WORD;  //出错的行，0表示没出错，1表示第1行出错，以此类推
    wErrCode: WORD;  //错误码
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE = ^NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

type
  NET_DVR_IPC_CFG_FILE_ERR_INFO = record 
    struErrInfoSingle: array[0..MAX_CHANNUM_V30-1] of NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;  
  end;
  LPNET_DVR_IPC_CFG_FILE_ERR_INFO = ^NET_DVR_IPC_CFG_FILE_ERR_INFO;

type
  NET_DVR_TRANSFER_SWITCH = record 
    dwEnable: DWORD;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_TRANSFER_SWITCH = ^NET_DVR_TRANSFER_SWITCH;

type
  NET_DVR_PTZ_PATTERN = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwPatternCmd: DWORD;  //云台操作命令码,详见下面定义
    dwPatternID: DWORD;  //云台ID（删除所有时无效）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_PATTERN = ^NET_DVR_PTZ_PATTERN;

type
  NET_DVR_PTZ_PARKACTION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byOneTouchSwitch: BYTE;  //一键开关, 0-不启用，1-启用 (和wActionType组合使用)
    byRes1: array[0..2-1] of BYTE;  
    dwParkTime: DWORD;  //守望等待时间，单位s
    wActionType: WORD;  //守望动作类型，0-自动扫描，1-帧扫描，2-随机扫描，3-巡航扫描，4-花样扫描，5-预置点，6-全景扫描，7-垂直扫描, 8-区域扫描
    wID: WORD;  //ID号（巡航扫描、预置点、花样扫描的ID）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_PARKACTION_CFG = ^NET_DVR_PTZ_PARKACTION_CFG;

type
  NET_DVR_PTZ_MANUALTRACE = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    struPoint: NET_VCA_POINT;  //定位坐标
    byTrackType: BYTE;  //类型0、非自动取证(普通取证) 1、高速道路 2、城市道路（手动取证）3、静态取证
    byLinkageType: BYTE;  //联动动作: 0-手动 1-联动不
    byRes: array[0..2-1] of BYTE;  
    struPointEnd: NET_VCA_POINT;  //定位坐标终点
    struTime: NET_DVR_TIME_V30;  //手动定位，当前时间。
    dwSerialNo: DWORD;  //序号；
    byRes1: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_MANUALTRACE = ^NET_DVR_PTZ_MANUALTRACE;

type
  VQD_TYPE =  
  (  
    VQD_BLUR_FLAG = $00000001,  //图像模糊
    VQD_LUMA_FLAG = $00000002,  //亮度异常
    VQD_CHROMA_FLAG = $00000004,  //图像偏色
    VQD_SNOW_FLAG = $00000008,  //雪花干扰
    VQD_STREAK_FLAG = $00000010,  //条纹干扰
    VQD_FREEZE_FLAG = $00000020,  //画面冻结
    VQD_SIGLOSE_FLAG = $00000040,  //信号丢失
    VQD_PTZ_FLAG = $00000080  //云台失控
  );

type
  NET_DVR_VQD_LOOP_DIAGNOSE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  // 诊断使能 0 :关闭，开启 1:开启
    byRes1: array[0..3-1] of BYTE;  //保留
    byVQDTypeEnable: array[0..32-1] of BYTE;  //VQD诊断模式，0 --不启用 1--启用  每种诊断类型对应有灵敏度，灵敏度的下标与诊断类型的下标一致
    //数组0 图像模糊     数组1 亮度异常 数组2 图像偏色
    //数组3 雪花干扰     数组4 条纹干扰 数组5 画面冻结
    //数组6 信号丢失     数组7 云台失控
    byThresholdValue: array[0..32-1] of BYTE;  //阈值0~100，不同诊断模式有各自对应的阈值
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V40;  //报警处理方式
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    struHolidayAlarmTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间段
    byRes: array[0..324-1] of BYTE;  //保留
  end;
  LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG = ^NET_DVR_VQD_LOOP_DIAGNOSE_CFG;


type
  NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO = record 
    dwChannelNO: DWORD;  //通道号
    dwVQDType: DWORD;  // VQD诊断类型
    struDiagnoseTime: NET_DVR_TIME;  //诊断时间
    byScoreValue: BYTE;  //分数值 ，百分制
    byRes: array[0..27-1] of BYTE;  
  end;
  LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO = ^NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


type
  NET_DVR_VQD_DIAGNOSE_INFO = record 
    dwSize: DWORD;  //结构体大小
    struVQDDiagnoseExceptionInfo: NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;  //诊断异常信息结构体
  end;
  LPNET_DVR_VQD_DIAGNOSE_INFO = ^NET_DVR_VQD_DIAGNOSE_INFO;

type
  NET_DVR_DEC_RESOURCE_LIST = record 
    dwSize: DWORD;  
    byDecStatus: array[0..MAX_SUBSYSTEM_NUM_V40{120}-1] of BYTE;  
    //解码资源状态列表，byDecStatus[i]表示槽位号i的子系统状态，0-无效，1-空闲，2-普通解码(包括普通解码上墙和大屏主从屏)，3-智能解码
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEC_RESOURCE_LIST = ^NET_DVR_DEC_RESOURCE_LIST;

type
  NET_DVR_DEC_APPLICANT_INFO = record 
    dwSize: DWORD;  
    dwDecResource: DWORD;  {申请的解码资源，以分辨率衡量，0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,
                         6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,
                         19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536,
                         31-2448*2048,32-2448*1200,33-2448*800,34-XGA（1024*768），35-SXGA（1280*1024）,36-WD1(960*576/960*480),
    37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)}
    dwChannel: DWORD;  //智能通道号
    struIP: NET_DVR_IPADDR;  //申请者IP
    wPort: WORD;  //申请者端口号(智能分析仪通讯端口)
    byRes: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_DEC_APPLICANT_INFO = ^NET_DVR_DEC_APPLICANT_INFO;

type
  NET_DVR_DEC_RESOURCE_INFO = record 
    dwSize: DWORD;  
    dwSlotNum: DWORD;  //槽位号，此参数做释放解码资源和登陆解码子系统校验用
    struIP: NET_DVR_IPADDR;  //解码子系统IP地址
    wPort: WORD;  //端口号
    byRes1: array[0..2-1] of BYTE;  
    dwDecChan: DWORD;  //解码通道号
    sUserName: array[0..NAME_LEN-1] of BYTE;  // 解码子系统登陆帐号 
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  // 解码子系统登陆密码 
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEC_RESOURCE_INFO = ^NET_DVR_DEC_RESOURCE_INFO;

type
  NET_DVR_DEC_CHAN_COND = record 
    dwSize: DWORD;  
    dwSlotNum: DWORD;  //槽位号,填申请解码资源时返回的槽位号
    dwDecChan: DWORD;  //解码通道号
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_DEC_CHAN_COND = ^NET_DVR_DEC_CHAN_COND;

type
  NET_DVR_DEC_YUV_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //关联使能，0-无关联，1-关联
    byRes1: array[0..3-1] of BYTE;  
    //byEnable = 1时以下参数有效
    dwYUVAddress: array[0..3-1] of DWORD;  //YUV输出地址
    wWidth: WORD;  //YUV输出宽
    wHeight: WORD;  //YUV输出高
    byEnableAudio: BYTE;  //使能音频，0-不启用，1-启用
    byRes2: array[0..3-1] of BYTE;  
    dwAudioAddr: DWORD;  //音频输出地址
    byRes3: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_DEC_YUV_CFG = ^NET_DVR_DEC_YUV_CFG;

type
  NET_DVR_INPUT_INFO = record 
    dwSize: DWORD;  
    byChanType: BYTE;  //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    byRes1: array[0..3-1] of BYTE;  
    dwChanNo: DWORD;  //通道号，设备通道号，支持byChanType所有类型
    dwSubChanNo: DWORD;  //槽位号，485槽位号，在byChanType为3-485通道时有效，表示通道号下的子通道号
    dwVariableNo: DWORD;  //变量编号，当byChanType为2-本地开关量通道时(1-输入，2-输出)
    byRemoteType: BYTE;  //获取变量类型，0-全部类型，1-遥信，2-遥测
    byLinkageIPCType: BYTE;  //联动IPC配置类型：0-默认，1-按变量号配置，2-按通道号配置
    byLinkageTriggerType: BYTE;  //联动触发器配置类型：0-默认，1-按变量号配置，2-按通道号配置
    byRes2: array[0..57-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_INFO = ^NET_DVR_INPUT_INFO;

type
  NET_DVR_ALARM_VARIABLE_CFG = record 
    dwSize: DWORD;  
    wVariableIndex: WORD;  //变量编号，只能获取
    wVariableType: WORD;  //变量类型 1-模拟量 2-开关量，只能获取
    sDescribe: array[0..NAME_LEN-1] of BYTE;  //变量描述
    byLimitLineType: BYTE;  //报警限值配置类型，0-不支持报警限值配置，1-两限值配置（即上限、下限），2-四限值配置
    byRemoteType: BYTE;  //变量远动系统类型：0-全部类型，1-遥信，2遥测
    byOsdEnabled: BYTE;  //变量是否支持OSD叠加:0-默认，1-支持，2-不支持
    byRes: array[0..29-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARM_VARIABLE_CFG = ^NET_DVR_ALARM_VARIABLE_CFG;


//模拟量点号相关参数
type
  NET_DVR_ALARM_SENSOR_POINT_CFG = record 
    nMeasureHigh: INT;  // 量程上限 外部值*1000传入 可以为负数
    nMeasureLow: INT;  // 量程下限 外部值*1000传入
    byAlarmMode: BYTE;  // 报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL，
    // 即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    byRes1: array[0..3-1] of BYTE;  
    nAlarmValue: array[0..4-1] of INT;  // 报警限
    dwOsdCfg: DWORD;  // 模拟量字符叠加，按位表示0-15对应视频通道1-16
    dwSensitive: DWORD;  // 灵敏度范围10~1000。外部 float*1000。 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化，需要上传。如果为1，则表示变化超过1时上报。
    dwIPChanOsd: DWORD;  // 数字通道叠加模拟量字符，按位表示，0~31对应数字通道1-32
    szOSDUnit: array[0..MAX_OSD_UNIT_LEN-1] of AnsiChar;  //OSD叠加单位
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_SENSOR_POINT_CFG = ^NET_DVR_ALARM_SENSOR_POINT_CFG;

//开关量点号相关参数或485遥信信号
type
  NET_DVR_ALARM_SWITCH_POINT_CFG = record 
    dwIPCChanOsd: DWORD;  //支持osd开关量叠加的IPC通道信息，按位表示，0~31对应数字通道1-32
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_SWITCH_POINT_CFG = ^NET_DVR_ALARM_SWITCH_POINT_CFG;

//模拟量点号相关参数或485遥测信号
type
  NET_DVR_ALARM_POINT_PARAM_UNION = record 
    case Byte of
    0: (byLength: array[0..64-1] of BYTE);  //联合体长度为64
    1: (struSensor: NET_DVR_ALARM_SENSOR_POINT_CFG);  //模拟量（或485遥测信号）相关参数
    2: (struSwitch: NET_DVR_ALARM_SWITCH_POINT_CFG);  //开关量（或485遥信信号）相关参数
  end;
  LPNET_DVR_ALARM_POINT_PARAM_UNION = ^NET_DVR_ALARM_POINT_PARAM_UNION;

//点号信息
type
  NET_DVR_ALARM_POINT_CFG = record 
    dwSize: DWORD;  
    dwPointNo: DWORD;  //点号
    sPointDescribe: array[0..NAME_LEN-1] of BYTE;  //点号描述
    struPointParam: NET_DVR_ALARM_POINT_PARAM_UNION;  //当变量类型为模拟量或485遥信信号时，使用结构体struSensor，当变量类型为开关量或485遥信信号时，使用结构体struSwitch
    byPointType: BYTE;  //点号类型，1-模拟量，2-开关量
    byChanType: BYTE;  //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    byRes1: array[0..2-1] of BYTE;  
    dwChanNo: DWORD;  //通道号
    dwSubChanNo: DWORD;  //槽位号
    dwVariableNo: DWORD;  //变量编号，当byChanType为开关量时(1-输入信号，2-输出信号)
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARM_POINT_CFG = ^NET_DVR_ALARM_POINT_CFG;

//历史数据查询
type
  NET_DVR_SEARCH_CONDITION = record 
    dwSize: DWORD;  
    byMajorType: BYTE;  //查询方式，1-全部，2-按时间， 3-按类型，4-时间+类型
    byMinorType: BYTE;  //1-点号，2-通道+槽位+变量号
    byRes1: array[0..2-1] of BYTE;  
    struStartTime: NET_DVR_TIME;  //起始时间
    struStopTime: NET_DVR_TIME;  //结束时间
    byChanType: BYTE;  //通道类型，1-模拟量，2-485通道，3-网络通道，0xff表示无效
    byRes2: array[0..3-1] of BYTE;  
    dwChanNo: DWORD;  //通道号，从1开始，0xffffffff表示无效
    dwSubChanNo: DWORD;  //槽位号，从1开始，0xffffffff表示无效
    dwVariableNo: DWORD;  //变量号，从1开始，0xffffffff表示无效
    dwPointNo: DWORD;  //点号，0xffffffff表示无效
    byRes3: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_SEARCH_CONDITION = ^NET_DVR_SEARCH_CONDITION;

type
  NET_DVR_HISTORY_DATA = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME;  //时间点
    byChanType: BYTE;  //通道类型，1-模拟量，2-485通道，3-网络通道，0xff表示无效
    byRes1: array[0..3-1] of BYTE;  
    dwChanNo: DWORD;  //通道号，从1开始，0xffffffff表示无效
    dwSubChanNo: DWORD;  //槽位号，从1开始，0xffffffff表示无效
    dwVariableNo: DWORD;  //变量号，从1开始，0xffffffff表示无效
    dwPointNo: DWORD;  //点号，0xffffffff表示无效
    iData: INT;  //历史数据
    byDataType: BYTE;  //0-正常数据，1-越上限数据，2-越下限数据
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_HISTORY_DATA = ^NET_DVR_HISTORY_DATA;

type
  NET_DVR_ALARMHOST_ALARM_MODE_CFG = record 
    dwSize: DWORD;  
    byDataUploadMode: BYTE;  //1-按通道上传，2-按显示点上传
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_ALARM_MODE_CFG = ^NET_DVR_ALARMHOST_ALARM_MODE_CFG;


type
  NET_DVR_ALARMHOST_POINT_VALUE = record 
    byChanType: BYTE;  //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    byPointType: BYTE;  //点类型，1-遥测（模拟量），2-遥信（开关量）
    byRes1: array[0..2-1] of BYTE;  //保留
    dwChanNo: DWORD;  //485通道号，0xffffffff表示无效，通道类型为1时：表示本地模拟量通道号，通道类型为2时表示本地开关量通道号，通道类型为3时表示485通道号。
    dwSubChanNo: DWORD;  //槽位号， 0xffffffff表示无效，通道类型为3时使用
    dwVariableNo: DWORD;  //变量编号，0xffffffff表示无效
    dwPointNo: DWORD;  //104点号，0xffffffff表示无效
    iValue: INT;  //显示点的值，表示低32位
    iValueEx: INT;  //显示点的值，表示高32位
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_POINT_VALUE = ^NET_DVR_ALARMHOST_POINT_VALUE;

type
  NET_DVR_ALARMHOST_DATA_UNION = record 
    case Byte of
    0: (byLength: array[0..40-1] of BYTE);  
    1: (struPointValue: NET_DVR_ALARMHOST_POINT_VALUE);  //显示点实时数据
  end;
  LPNET_DVR_ALARMHOST_DATA_UNION = ^NET_DVR_ALARMHOST_DATA_UNION;

type
  NET_DVR_ALARMHOST_DATA_UPLOAD = record 
    dwSize: DWORD;  
    byDataType: BYTE;  //数据类型，1-显示点实时数据上传
    byRes1: array[0..3-1] of BYTE;  
    struAlarmData: NET_DVR_ALARMHOST_DATA_UNION;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_DATA_UPLOAD = ^NET_DVR_ALARMHOST_DATA_UPLOAD;

type
  NET_DVR_INPUTVOLUME = record 
    dwSize: DWORD;  //结构长度
    byAudioInputChan: BYTE;  //音频输入通道号
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_INPUTVOLUME = ^NET_DVR_INPUTVOLUME;

type
  NET_DVR_AUDIOOUT_VOLUME = record 
    dwSize: DWORD;  
    byAudioOutVolume: BYTE;  // 输出音量等级：归一化为0-100；
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_AUDIOOUT_VOLUME = ^NET_DVR_AUDIOOUT_VOLUME;

type
  NET_DVR_FUZZY_UPGRADE = record 
    dwSize: DWORD;  
    sUpgradeInfo: array[0..MAX_UPGRADE_INFO_LEN-1] of AnsiChar;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FUZZY_UPGRADE = ^NET_DVR_FUZZY_UPGRADE;

type
  NET_DVR_RS485_WORK_MODE = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //工作模式，0-控制台，1-私有透明通道，2-透明通道
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_RS485_WORK_MODE = ^NET_DVR_RS485_WORK_MODE;

type
  NET_DVR_TRANSPARENT_CLIENT_SINGLE = record 
    byEnable: BYTE;  //使能透明通道，0-不使能，1-使能
    byRes1: array[0..3-1] of BYTE;  
    struIP: NET_DVR_IPADDR;  //远程设备IP地址
    wPort: WORD;  //远程设备端口
    byRes2: array[0..18-1] of BYTE;  
  end;
  LPNET_DVR_TRANSPARENT_CLIENT_SINGLE = ^NET_DVR_TRANSPARENT_CLIENT_SINGLE;

type
  NET_DVR_TRANSPARENT_SERVER_SINGLE = record 
    byEnable: BYTE;  //使能透明通道，0-不使能，1-使能
    byRes1: array[0..3-1] of BYTE;  
    struIP: NET_DVR_IPADDR;  //允许接入的远程设备IP
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_TRANSPARENT_SERVER_SINGLE = ^NET_DVR_TRANSPARENT_SERVER_SINGLE;

type
  NET_DVR_TRANSPARENT_CLIENT_MODE = record 
    struClientSingle: array[0..MAX_TRANSPARENT_CHAN_NUM-1] of NET_DVR_TRANSPARENT_CLIENT_SINGLE;  
    byRes: array[0..320-1] of BYTE;  
  end;
  LPNET_DVR_TRANSPARENT_CLIENT_MODE = ^NET_DVR_TRANSPARENT_CLIENT_MODE;

type
  NET_DVR_TRANSPARENT_SERVER_MODE = record 
    wPort: WORD;  //本地监听的端口号，和RS485口一一对应
    byRes1: array[0..2-1] of BYTE;  
    struServerSingle: array[0..MAX_TRANSPARENT_ACCESS_NUM-1] of NET_DVR_TRANSPARENT_SERVER_SINGLE;  
    byRes2: array[0..332-1] of BYTE;  
  end;
  LPNET_DVR_TRANSPARENT_SERVER_MODE = ^NET_DVR_TRANSPARENT_SERVER_MODE;

type
  NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION = record 
    case Byte of
    0: (byRes: array[0..512-1] of BYTE);  
    1: (struClientMode: NET_DVR_TRANSPARENT_CLIENT_MODE);  //客户端模式参数
    2: (struServerMode: NET_DVR_TRANSPARENT_SERVER_MODE);  //服务器模式参数
  end;
  LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION = ^NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

type
  NET_DVR_TRANSPARENT_CHAN_CFG = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //工作模式，1-客户端模式，2-服务器模式
    byRes: array[0..3-1] of BYTE;  
    struTransparentPara: NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;  
  end;
  LPNET_DVR_TRANSPARENT_CHAN_CFG = ^NET_DVR_TRANSPARENT_CHAN_CFG;

type
  NET_DVR_NAKED_DATA_INFO = record 
    sSocketIP: array[0..128-1] of AnsiChar;  
    wSocktPort: WORD;  
    byRes: array[0..258-1] of BYTE;  
  end;
  LPNET_DVR_NAKED_DATA_INFO = ^NET_DVR_NAKED_DATA_INFO;

type
  NAKED_DATA_TYPE =  
  (  
    NAKED_DATA_TYPE_NOT_DEFINED = 0,  //未定义
    NAKED_DATA_TYPE_POS_INFO  //接收的是Pos信息
  );


type
  NET_DVR_NAKED_DATA_PARAM = record 
    wPort: WORD;  //IP端口号，对于Pos信息接收，该值为0，则使用默认端口7050
    byRes: array[0..130-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_NAKED_DATA_PARAM = ^NET_DVR_NAKED_DATA_PARAM;

const
  UPLOAD_POS_INFO = 1001;    //上传Pos信息

type
  NET_DVR_POS_INFO = record 
    struVerHead: NET_DVR_STRUCTHEAD;  //版本头
    dwChannelNum: DWORD;  //通道号
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_POS_INFO = ^NET_DVR_POS_INFO;


const
  MAX_IGNORE_STRING_NUM = 4;    
  FILTERRULE_NUM = 4;    
  MAX_POS_FILTER_DATA_LEN = 128;    

type
  NET_DVR_POS_OSD_REGION = record 
    struStart: NET_VCA_POINT;  //起点坐标
    struEnd: NET_VCA_POINT;  //终点坐标
  end;
  LPNET_DVR_POS_OSD_REGION = ^NET_DVR_POS_OSD_REGION;


type
  NET_DVR_POS_ACTION = record 
    dwDelayTime: DWORD;  //delay time(5-3600s)
    byPrevOsd: BYTE;  //overlay osd on preview
    byRes1: array[0..3-1] of BYTE;  //preserve
    struOsdPosInfo: NET_DVR_POS_OSD_REGION;  //overlay osd rect info
    byRes: array[0..64-1] of BYTE;  //preserve
  end;
  LPNET_DVR_POS_ACTION = ^NET_DVR_POS_ACTION;

type
  NET_DVR_GENERIC_START = record 
    sData: array[0..MAX_POS_FILTER_DATA_LEN-1] of BYTE;  //交易开始标志，目前最大为32，只有anyCharacter为否时才生效
    byExclusive: BYTE;  //是否包含标志本身 0-包含 1-不包含
    byFlagType: BYTE;  //标志类型：0-字符串；1-十六进制
    byRes: array[0..2-1] of BYTE;  //保留
  end;
  LPNET_DVR_GENERIC_START = ^NET_DVR_GENERIC_START;

type
  NET_DVR_GENERIC_END = record 
    sData: array[0..MAX_POS_FILTER_DATA_LEN-1] of BYTE;  //交易结束标志，目前最大为32
    byExclusive: BYTE;  //是否包含标志本身 0-包含 1-不包含
    byFlagType: BYTE;  //标志类型：0-字符串；1-十六进制
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_GENERIC_END = ^NET_DVR_GENERIC_END;

type
  NET_DVR_GENERIC_DATA_CFG = record 
    sData: array[0..MAX_POS_FILTER_DATA_LEN-1] of BYTE;  //数据标志，目前最大为32
    byFlagType: BYTE;  //标志类型：0-字符串；1-十六进制
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_GENERIC_DATA_CFG = ^NET_DVR_GENERIC_DATA_CFG;

type
  NET_DVR_IGNORE_STRING = record 
    sData: array[0..MAX_POS_FILTER_DATA_LEN-1] of BYTE;  //忽略的字符，目前最大为32
  end;
  LPNET_DVR_IGNORE_STRING = ^NET_DVR_IGNORE_STRING;

type
  NET_DVR_POS_GENERIC = record 
    byCaseSensitive: BYTE;  //是否区分大小写，0->不区分，1->区分
    byRes1: array[0..7-1] of BYTE;  
    struTransactionStart: NET_DVR_GENERIC_START;  //交易开始
    struTransactionEnd: NET_DVR_GENERIC_END;  //交易结束
    struLineDeli: NET_DVR_GENERIC_DATA_CFG;  //行间隔符
    struIgnoreString: array[0..MAX_IGNORE_STRING_NUM-1] of NET_DVR_IGNORE_STRING;  //忽略字符串，目前为4个
    byRes: array[0..40-1] of BYTE;  //保留
  end;
  LPNET_DVR_GENERIC = ^NET_DVR_POS_GENERIC;

type
  NET_DVR_POS_AVE = record 
    dwPosAddr: DWORD;  //pos地址编号
    byRes: array[0..948-1] of BYTE;  
  end;
  LPNET_DVR_AVE = ^NET_DVR_POS_AVE;

const
  SERIAL_NUM_LEN = 8;    
type
  NET_DVR_POS_NUCLEUS = record //size 952byte
    szEmployeeNo: array[0..SERIAL_NUM_LEN-1] of AnsiChar;  //员工编号，如1（备注：标题e<employee#>）
    szTerminalNo: array[0..SERIAL_NUM_LEN-1] of AnsiChar;  // Pos机编号，如1（备注：标题t<terminal#>）
    szShiftNo: array[0..SERIAL_NUM_LEN-1] of AnsiChar;  //轮班（备注：标题s<shift#>）
    byRes: array[0..928-1] of BYTE;  
  end;
  LPNET_DVR_POS_NUCLEUS = ^NET_DVR_POS_NUCLEUS;
type
  NET_DVR_POS_PROTOCOL_UNION = record 
    case Byte of
    0: (byLenth: array[0..952-1] of BYTE);  //用于表示联合体长度，无实际意义
    1: (struGeneric: NET_DVR_POS_GENERIC);  
    2: (struAve: NET_DVR_POS_AVE);  
    3: (struNUCLEUS: NET_DVR_POS_NUCLEUS);  
  end;
  LPNET_DVR_POS_PROTOCOL_UNION = ^NET_DVR_POS_PROTOCOL_UNION;

type
  NET_DVR_CHARSET_ENUM =  //编码方式
  (  
    ENUM_UTF8 = 0,  
    ENUM_GB2312,  
    ENUM_LATIN1,  
    ENUM_LATIN2,  
    ENUM_LATIN3,  
    ENUM_LATIN4,  
    ENUM_CYRILLIC,  
    ENUM_ARABIC,  
    ENUM_GREEK,  
    ENUM_HEBREW,  
    ENUM_TURKISH,  
    ENUM_NORDIC,  
    ENUM_THAI,  
    ENUM_LATIN7,  
    ENUM_LATIN8,  
    ENUM_LATIN9,  
    ENUM_LATIN10,  
    ENUM_CENTRAL_EUROPEAN,  
    ENUM_CYRILLIC_SCRIPT,  
    ENUM_HEBREW_DOS862  
  );
  LPNET_DVR_CHARSET_ENUM = ^NET_DVR_CHARSET_ENUM;


type
  NET_DVR_POS_FILTER_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //规则使能
    byCharSetType: BYTE;  //编码方式0-UTF-8,1-GB2312
    byRes1: BYTE;  //保留
    byProtocolType: BYTE;  //协议类型，1->generic text协议(universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON(该类型无需处理pos协议参数), 5-NUCLEUS
    //6- Gilbarco（配置对应结构体NET_DVR_POS_GENERIC）,7- NCR（配置对应结构体NET_DVR_POS_GENERIC）
    uPosProtocol: NET_DVR_POS_PROTOCOL_UNION;  //POS协议
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_POS_FILTER_CFG = ^NET_DVR_POS_FILTER_CFG;

type
  NET_DVR_NET_SNIFF = record //网络侦听结构体 312byte
    byEnableSourcePort: BYTE;  //是否启用对数据源端口过滤  0-不启用，1-启用
    byEnableDestAddr: BYTE;  //是否启用对目标IP地址进行过滤 0-不启用，1-启用
    byEnableDestPort: BYTE;  //是否启用对目标地址的端口号进行过滤
    byRes1: BYTE;  //保留
    bySourceIpAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //数据源地址
    byDestinationIpAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //数据发送目标地址
    wSourcePort: WORD;  //数据源端口号
    wDestinationPort: WORD;  //数据发送目标端口号
    byRes: array[0..16-1] of BYTE;  //保留
  end;
  LPNET_DVR_NET_SNIFF = ^NET_DVR_NET_SNIFF;

type
  NET_DVR_NET_RECEIVE = record 
    wNetPort: WORD;  //device net port
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_NET_RECEIVE = ^NET_DVR_NET_RECEIVE;

type
  NET_DVR_MONITOR_INFO = record //监听
    wPort: WORD;  //监听端口号
    byRes1: array[0..2-1] of BYTE;  
    struRestrictRemoteIP: NET_DVR_IPADDR;  //保留限制远程访问IP
    byRes: array[0..164-1] of BYTE;  
  end;
  LPNET_DVR_MONITOR_INFO = ^NET_DVR_MONITOR_INFO;

type
  NET_DVR_POS_CONNECTMODE_UNION = record 
    case Byte of
    0: (byLen: array[0..312-1] of BYTE);  //联合体长度，无实际意义
    1: (struNetRecv: NET_DVR_NET_RECEIVE);  //网络接受模式
    2: (struTcpMonitor: NET_DVR_MONITOR_INFO);  //网络监听模式
    3: (struRS232: NET_DVR_SINGLE_RS232);  //串口方式
    4: (struUdpMonitor: NET_DVR_MONITOR_INFO);  //网络监听-UDP模式
    5: (struSniff: NET_DVR_NET_SNIFF);  //网络侦听模式
    6: (struMcast: NET_DVR_ADDRESS);  //多播模式
    7: (struUSBRS232: NET_DVR_USB_RS232);  //USB转串口方式
  end;
  LPNET_DVR_POS_CONNECTMODE_UNION = ^NET_DVR_POS_CONNECTMODE_UNION;


//DVR与POS连接方式配置结构体
type
  NET_DVR_CONNECT_POS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byConnectMode: BYTE;  //连接模式:0->网络监听(TCP),1->网络接受,2->串口接收3-网络监听（UDP）,4-网络侦听,5-多播
    byRes1: array[0..3-1] of BYTE;  //保留
    uPosConnMode: NET_DVR_POS_CONNECTMODE_UNION;  //连接模式配置
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CONNECT_POS_CFG = ^NET_DVR_CONNECT_POS_CFG;

type
  NET_DVR_CHAN_FILTER_CFG = record 
    dwSize: DWORD;  //结构体大小
    byFilterID: BYTE;  //POS过滤规则ID
    byFontSize: BYTE;  //字号大小，0-- 8*16  1--16*32  2--32*64
    byShowPosInfo: BYTE;  //码流中是否叠加pos信息
    byOverlayMode: BYTE;  //叠加方式，0-滚屏，1-翻页
    dwDelayTime: DWORD;  //delay time(5-3600s)
    struOsdPosInfo: NET_DVR_POS_OSD_REGION;  //overlay osd rect info
    struOsdColor: NET_DVR_RGB_COLOR;  //OSD颜色
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //本组内关联的录象通道数
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  //触发录像通道
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组内后续的关联通道号无效
    dwTimeOut: DWORD;  {time Out(5-3600s)}//数据超时指在多长时间接收不到POS数据即判定一次数据包的结束。
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_CHAN_FILTER_CFG = ^NET_DVR_CHAN_FILTER_CFG;

const
  MAX_LAN_ENCODE_LEN = 32;    //语言编码格式最大长度
type
  NET_DVR_DEVICE_LAN_ENCODE = record 
    dwSize: DWORD;  
    byLanEncode: array[0..MAX_LAN_ENCODE_LEN-1] of BYTE;  //设备语言编码格式
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_LAN_ENCODE = ^NET_DVR_DEVICE_LAN_ENCODE;

type
  NET_DVR_SCENECHANGE_DETECTION = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能，是否开启 0~不开启,1~开启
    bySensitiveLevel: BYTE;  // 1-100，默认50，灵敏度越高，越容易报警
    byRes1: array[0..2-1] of BYTE;  
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道 数 实际支持的数量
    dwRelRecordChan: array[0..MAX_CHANNUM_V30-1] of DWORD;  //触发录像通道
    //报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SCENECHANGE_DETECTION = ^NET_DVR_SCENECHANGE_DETECTION;

type
  NET_DVR_SCENECHANGE_DETECTION_RESULT = record 
    dwSize: DWORD;  // 结构大小
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRes: array[0..126-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SCENECHANGE_DETECTION_RESULT = ^NET_DVR_SCENECHANGE_DETECTION_RESULT;

type
  MODULE_TYPE =  
  (  
    PREVIEW_MOD = 0,  
    ALARM_MOD,  
    PLAYBACK_MOD,  
    MAX_TYPE  
  );

//车位信息
type
  NET_DVR_PARK_INFO = record 
    sPlateNo: array[0..MAX_PlATE_NO_LEN-1] of AnsiChar;  //车牌号码
    sParkIndex: array[0..MAX_PlATE_NO_LEN-1] of AnsiChar;  //车位编号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PARK_INFO = ^NET_DVR_PARK_INFO;


type
  NET_DVR_CROSSLINE_ALARM = record 
    dwSize: DWORD;  
    struDevInfo: NET_VCA_DEV_INFO;  
    struTriggerTime: NET_DVR_TIME_EX;  //触发时间
    struParkInfo: NET_DVR_PARK_INFO;  //车位信息
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CROSSLINE_ALARM = ^NET_DVR_CROSSLINE_ALARM;

type
  NET_DVR_STREAM_SRC_CFG = record 
    dwSize: DWORD;  
    struStreamID: NET_DVR_STREAM_INFO;  //流信息
    struStreamSrcInfo: NET_DVR_STREAM_SRC_INFO;  //流源信息
  end;
  LPNET_DVR_STREAM_SRC_CFG = ^NET_DVR_STREAM_SRC_CFG;

type
  NET_DVR_ENCODEINFO = record 
    byFormatType: BYTE;  //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP, 9-RTP+PS（国标：GB28181），0xff-无效
    byVideoEncType: BYTE;  //视频编码类型，0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，0xff-无效
    wWidth: WORD;  //图像宽度
    wHeight: WORD;  //图像高度
    byRes1: array[0..2-1] of BYTE;  
    dwVideoBitrate: DWORD;  //视频码率,单位Kbps
    dwVideoFrameRate: DWORD;  //帧率，200起表示小于1帧/秒的状态，其余值表示实际帧率值,200-1/2,201-1/4,202-1/8,203-1/16
    byAudioEncType: BYTE;  //音频编码类型，0-G722，1-G711_U，2-G711_A，5-MPEG2,6-G726，7-AAC,0xff-无效
    byRes2: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_ENCODEINFO = ^NET_DVR_ENCODEINFO;


type
  NET_DVR_TRANSSTATUS = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  //流ID、转码通道信息
    byMode: BYTE;  //转码模式，1-主动转码，2-被动转码
    byLinkNums: BYTE;  //连接数
    byPassiveTransMode: BYTE;  //被动转码模式，0-无效，1-实时流，2-文件流
    byRes: BYTE;  
    struDstIPInfo: array[0..MAX_LINK-1] of NET_DVR_ADDRESS;  //目标转码ip地址
    byTransResource: BYTE;  //所使用的转码资源数，按D1计算
    byRes1: array[0..15-1] of BYTE;  
    struSrcEncodeInfo: NET_DVR_ENCODEINFO;  //源编码信息
    struDstEncodeInfo: array[0..MAX_LINK{6}-1] of NET_DVR_ENCODEINFO;  //目标编码信息
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_TRANSSTATUS = ^NET_DVR_TRANSSTATUS;

type
  NET_DVR_TRANSDEVICE_STATUS = record 
    dwSize: DWORD;  
    dwTotalResource: DWORD;  //全部转码资源，以D1为单位计算
    dwIdleResource: DWORD;  //剩余转码资源，以D1为单位计算
    byCpuLoad: BYTE;  //CPU利用率
    byRes: array[0..67-1] of BYTE;  
  end;
  LPNET_DVR_TRANSDEVICE_STATUS = ^NET_DVR_TRANSDEVICE_STATUS;

type
  NET_DVR_DEV_WORK_MODE = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //1-通道模式，2-流ID模式
    byDisplayMode: BYTE;  //0-普通，1-畅显
    byEnableVcaDec: BYTE;  //是否启用智能解码，0-不启用，非0-启用
    byRes: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_DEV_WORK_MODE = ^NET_DVR_DEV_WORK_MODE;


type
  NET_DVR_PASSIVETRANSINFO = record 
    dwSize: DWORD;  
    byStreamType: BYTE;  // 码流类型，0-主码流，1-子码流
    byLinkMode: BYTE;  // 0：TCP方式,1：UDP方式（保留）
    byPassiveTransMode: BYTE;  //被动转码模式，1-实时流，2-文件流
    byRes1: array[0..5-1] of BYTE;  
    byDataType: BYTE;  //缓冲区类型，1-SDP，2-码流头
    byRes2: BYTE;  
    wDataLength: WORD;  //数据长度
    pBuffer: PAnsiChar;  //缓冲区
    byRes3: array[0..32-1] of BYTE;  // 保留
  end;
  LPNET_DVR_PASSIVETRANSINFO = ^NET_DVR_PASSIVETRANSINFO;

type
  NET_DVR_BASEMAP_CONTROL_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否显示，1-显示，0-隐藏
    byBaseMapType: BYTE;  //底图类型，1-图片底图，2-超高清输入底图，3-底图轮训
    byBaseMapCircleNo: BYTE;  //底图轮训参数编号，byBaseMapType为3时有效
    byRes1: BYTE;  
    dwBaseMapNo: DWORD;  //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_BASEMAP_CONTROL_CFG = ^NET_DVR_BASEMAP_CONTROL_CFG;

type
  NET_DVR_VIRTUAL_SCREEN_CFG = record 
    dwSize: DWORD;  
    dwResolution: DWORD;  //分辨率，MAKE_RESOLUTION宏定义的值，从电视墙能力获取支持的分辨率值
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VIRTUAL_SCREEN_CFG = ^NET_DVR_VIRTUAL_SCREEN_CFG;

type
  NET_DVR_BASEMAP_WINCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  
    byWndOperateMode: BYTE;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    byRes1: array[0..6-1] of BYTE;  
    struWinPosition: NET_DVR_RECTCFG_EX;  //目的窗口(相对显示墙),底图窗口的起始坐标和大小必须是基准坐标的整数倍
    struResolution: NET_DVR_RECTCFG_EX;  //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
    dwXCoordinate: DWORD;  //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
    dwYCoordinate: DWORD;  //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_BASEMAP_WINCFG = ^NET_DVR_BASEMAP_WINCFG;

type
  NET_DVR_BASEMAP_PIC_INFO = record 
    dwSize: DWORD;  
    sPicName: array[0..NAME_LEN-1] of BYTE;  //图片名称
    byUsed: BYTE;  //是否已存在，0-不存在，1-存在
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_BASEMAP_PIC_INFO = ^NET_DVR_BASEMAP_PIC_INFO;

type
  NET_DVR_MATRIX_LOGO_INFO = record 
    dwSize: DWORD;  
    dwLogoSize: DWORD;  //LOGO大小，包括BMP的文件头，图片大小超限，限100K，高和宽须是32的倍数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_LOGO_INFO = ^NET_DVR_MATRIX_LOGO_INFO;

type
  NET_DVR_MATRIX_LOGO_CFG = record 
    dwSize: DWORD;  
    byExist: BYTE;  //logo是否存在，0-不存在，1-存在（此参数只能获取）
    byRes1: array[0..3-1] of BYTE;  
    dwLogoSize: DWORD;  //LOGO大小，包括BMP的文件头(此参数只能获取)
    byLogoName: array[0..NAME_LEN-1] of BYTE;  //logo名称
    dwLogoNo: DWORD;  //logo编号（获取所有logo信息时有效）
    byRes2: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_LOGO_CFG = ^NET_DVR_MATRIX_LOGO_CFG;

type
  NET_DVR_WIN_LOGO_CFG = record 
    dwSize: DWORD;  
    dwLogoNo: DWORD;  //logo号
    byEnable: BYTE;  //logo是否显示，1-显示，0-隐藏
    byRes1: array[0..3-1] of BYTE;  
    dwCoordinateX: DWORD;  //图片显示区域X坐标
    dwCoordinateY: DWORD;  //图片显示区域Y坐标
    byFlash: BYTE;  //是否闪烁1-闪烁，0-不闪烁
    byTranslucent: BYTE;  //是否半透明1-半透明，0-不半透明
    byRes2: array[0..34-1] of BYTE;  //保留
  end;
  LPNET_DVR_WIN_LOGO_CFG = ^NET_DVR_WIN_LOGO_CFG;


type
  NET_DVR_BIG_SCREEN_AUDIO_CFG = record 
    dwSize: DWORD;  
    dwWinIndex: DWORD;  //窗口号，从1开始，0表示底图
    byEnable: BYTE;  //是否打开音频，1-打开音频，0-关闭音频
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_BIG_SCREEN_AUDIO_CFG = ^NET_DVR_BIG_SCREEN_AUDIO_CFG;

type
  NET_DVR_WIN_ZOOM_STATUS = record 
    dwSize: DWORD;  
    byZoomStatus: BYTE;  //0-正常状态，1-放大状态
    byRes1: array[0..3-1] of BYTE;  
    struPointFrame: NET_DVR_POINT_FRAME;  //放大区域，当byZoomStatus为1时有效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WIN_ZOOM_STATUS = ^NET_DVR_WIN_ZOOM_STATUS;

type
  NET_DVR_RESUME_INITRACKPOS_CFG = record 
    dwSize: DWORD;  // 结构大小
    dwChannel: DWORD;  // 通道号
    byRes: array[0..16-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_RESUME_INITRACKPOS_CFG = ^NET_DVR_RESUME_INITRACKPOS_CFG;

type
  NET_DVR_TEST_SELFCHECK_RESULT = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    bySelfCheckStatus: BYTE;  //自检状态值 0-未开始，1-成功，2-失败，3-自检中
    byRes: array[0..23-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_TEST_SELECHECK_RESULT = ^NET_DVR_TEST_SELFCHECK_RESULT;


type
  NET_DVR_TEST_COMMAND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byTestCommand: array[0..MAX_TEST_COMMAND_NUM-1] of BYTE;  
    //0-表示不开启测试， 1-表示开启测试
    //数组下标0 开启老化测试程序
    //数组下标1 红外灯进入测试模式
    //数组下标2 ICR老化测试，0表示关闭，1表示开启，可以与bit0 组合，如0000_0001(只开启巡航老化)、0000_0101（同时开启巡航和ICR老化）、0000_0100（只开启ICR老化）
    //数组下标3 -球机pt自矫正功能状态，0表示球机自矫正功能未清除，1表示球机自矫正功能已清除
    //数组下标4 花样扫描测试程序，0表示关闭，1表示开启
    //数组下标5 电子罗盘校正程序，0表示关闭，1表示开启
    wICRIntervalTime: WORD;  //icr间隔时间（byTestCommand 数组下表2内的值为1时，ICR开关间隔时间，单位秒）
    byElectronicCompassState: BYTE;  //罗盘状态返回， 0-正常， 1-不正常
    byRes1: array[0..1-1] of BYTE;  
    fDeviceTem: FLOAT;  //设备机芯温度，精确度0.001
    byTemp: array[0..9-1] of BYTE;  //用于多个温敏设备， 下标0-全景的温敏， 标1-4：全景1的4个sensor的温敏， 标5-8：全景2的4个sensor的温敏,目前用于鹰眼全景
    byRes: array[0..3-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_TEST_COMMAND = ^NET_DVR_TEST_COMMAND;

type
  NET_DVR_AGING_TRICK_SCAN = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byAging: BYTE;  // 表示设置的参数 为老化前工具还是老化后工具， 0-老化前、1-老化后
    byWriteReadEnalbe: BYTE;  //读写指令使能，0-设置读指令， 1-设置写指令
    byRes: array[0..126-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_AGING_TRICK_SCAN = ^NET_DVR_AGING_TRICK_SCAN;

const
  IPC_PARAM_AGING_TRICK_SCAN = $00000001;    //清除花样扫描参数设置
type
  NET_DVR_IPC_PARAM_TYPE = record 
    dwSize: DWORD;  
    dwParamType: DWORD;  //参数类型，按位表示
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //清除花样扫描参数设置
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IPC_PARAM_TYPE = ^NET_DVR_IPC_PARAM_TYPE;

type
  NET_DVR_ECCENTRIC_CORRECT_STATE = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byEccentricCorrectState: BYTE;  // 偏心矫正状态，0-校正失败、1-校正成功、2-校正中
    byRes: array[0..127-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ECCENTRIC_CORRECT_STATE = ^NET_DVR_ECCENTRIC_CORRECT_STATE;



const
  MAX_DEVMODULE_NUM = 8;    
type
  NET_DVR_TEST_DEVMODULE_CFG = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byDevFanModuleType: array[0..MAX_DEVMODULE_NUM-1] of BYTE;  //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试风扇1
    // bit1-测试风扇2
    byDevHeaterModuleType: array[0..MAX_DEVMODULE_NUM-1] of BYTE;  //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试加热器1
    // bit1-测试加热器2
    byRes: array[0..22-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_TEST_DEVMODULE_CFG = ^NET_DVR_TEST_DEVMODULE_CFG;

//出入口条件
type
  NET_DVR_BARRIERGATE_COND = record 
    byLaneNo: BYTE;  //车道号（0-表示无效值(设备需要做有效值判断),1-车道1）
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_BARRIERGATE_COND = ^NET_DVR_BARRIERGATE_COND;

type
  NET_DVR_VEHICLE_CONTROL = record 
    byGateOperateType: BYTE;  //0-无操作,1-开道闸
    byRes1: BYTE;  
    wAlarmOperateType: WORD;  //0-无操作,bit0-继电器输出报警 bit1-布防上传报警 bit3-告警主机上传（可复选）(0-表示关，1-表示开)
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_CONTROL = ^NET_DVR_VEHICLE_CONTROL;

type
  NET_DVR_RELAY_PARAM = record 
    byAccessDevInfo: BYTE;  //0-不接入设备，1-开道闸、2-关道闸、3-停道闸、4-报警信号、5-常亮灯
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_RELAY_PARAM = ^NET_DVR_RELAY_PARAM;

//出入口配置
type
  NET_DVR_ENTRANCE_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  // 使能0-表示关闭，1-表示打开
    byBarrierGateCtrlMode: BYTE;  //0-相机自动控制，1-平台外部控制
    byRes1: array[0..2-1] of BYTE;  
    dwRelateTriggerMode: DWORD;  //关联触发模式 参考ITC_TRIGGERMODE_TYPE
    //0x00: 不做匹配
    //0x01: 车牌匹配（带车牌颜色）
    //0x02: 车牌匹配（不带车牌颜色）
    //0x04: 卡号匹配
    dwMatchContent: DWORD;  //异常处理,异常处理方式的"或"结果
    struRelayRelateInfo: array[0..MAX_RELAY_NUM{12}-1] of NET_DVR_RELAY_PARAM;  //继电器关联配置信息(一个继电器只能控制一个接入设备) 数组0表示继电器1 数组1表示继电器2 依次类推 12
    byGateSingleIO: array[0..MAX_IOIN_NUM{8}-1] of BYTE;  //单个IO触发参数，单个IO触发参数，数组0表示IO1，数组1表示IO2，依次类推 ; 具体数组值的含义（0-无，1-道闸开到位，2-道闸关到位，3-消防报警）
    //车辆信息管控
    //数组0表示临时车辆配置的模式
    //数组1-禁止名单车辆的模式,
    //数组2-允许名单车辆的模式
    struVehicleCtrl: array[0..MAX_VEHICLE_TYPE_NUM{8}-1] of NET_DVR_VEHICLE_CONTROL;  //车辆信息管控
    byNotCloseCarFollow: BYTE;  //启用跟车不落闸使能，0~为不启用，1~启用
    byParkingDetectEnabled: BYTE;  //启用驻车检测使能，0~为不启用，1~启用
    byParkingDetectJudgeTime: BYTE;  //驻车检测判断时间，单位秒
    byRes2: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_ENTRANCE_CFG = ^NET_DVR_ENTRANCE_CFG;
////////////////////////////出入口参数配置 end///////////////////////////////

// 道闸控制
type
  NET_DVR_BARRIERGATE_CFG = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byLaneNo: BYTE;  //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    {
    若老的平台不支持byUnlock字段，该字段将赋值为0，通过“0-关闭道闸,1-开启道闸,2-停止道闸”中的任何一种操作皆可进行解锁。
    若新平台支持byUnlock字段，需byUnlock字段赋值为1，并结合4~解锁道闸来进行解锁。byUnlock字段赋值为1后，“0-关闭道闸,1-开启道闸,2-停止道闸”操作将不可用于解锁。
    }
    byBarrierGateCtrl: BYTE;  //0-关闭道闸,1-开启道闸,2-停止道闸 3-锁定道闸,4~解锁道闸
    byEntranceNo: BYTE;  //出入口编号 [1,8]
    byUnlock: BYTE;  //启用解锁使能，0~为不启用，1~启用
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_BARRIERGATE_CFG = ^NET_DVR_BARRIERGATE_CFG;

//出入口名单的数据同步
type
  NET_DVR_VEHICLE_CONTROL_LIST_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号0xff - 全部通道（ITC 默认是1）
    dwDataIndex: DWORD;  //数据流水号（平台维护的数据唯一值，客户端操作的时候，该值不会起效。该值主要用于数据增量同步）
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码
    byListType: BYTE;  //名单属性（名单）0-允许名单，1-禁止名单
    byPlateType: BYTE;  //车牌类型
    byPlateColor: BYTE;  //车牌颜色
    byRes: array[0..21-1] of BYTE;  
    sCardNo: array[0..MAX_CARDNO_LEN-1] of AnsiChar;  // 卡号
    struStartTime: NET_DVR_TIME_V30;  //有效开始时间
    struStopTime: NET_DVR_TIME_V30;  //有效结束时间
    //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
    sOperateIndex: array[0..MAX_OPERATE_INDEX_LEN-1] of AnsiChar;  
    byRes1: array[0..224-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VEHICLE_CONTROL_LIST_INFO = ^NET_DVR_VEHICLE_CONTROL_LIST_INFO;

//数据全部获取接口 （长连接获取）
type
  NET_DVR_VEHICLE_CONTROL_COND = record 
    dwChannel: DWORD;  //通道号0xffffffff - 全部通道（ITC 默认是1）
    dwOperateType: DWORD;  //操作类型，参照VCA_OPERATE _TYPE。（可复选）
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码
    sCardNo: array[0..MAX_CARDNO_LEN-1] of AnsiChar;  // 卡号
    byListType: BYTE;  //名单属性0-允许名单，1-禁止名单，0xff-全部
    //2014-02-25
    byRes1: array[0..3-1] of BYTE;  
    dwDataIndex: DWORD;  //数据流水号
    byRes: array[0..116-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_CONTROL_COND = ^NET_DVR_VEHICLE_CONTROL_COND;

//名单数据需要同步报警
type
  NET_DVR_VEHICLE_CONTROL_LIST_DSALARM = record 
    dwSize: DWORD;  
    dwDataIndex: DWORD;  //数据流水号（这个值返回设备当前接收到的数据的最后一个数据流水号,平台同步的时候从下一个流水号开始同步）
    sOperateIndex: array[0..MAX_OPERATE_INDEX_LEN-1] of AnsiChar;  //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0） 2014-03-03
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM = ^NET_DVR_VEHICLE_CONTROL_LIST_DSALARM;

//车辆报警
type
  NET_DVR_VEHICLE_CONTROL_ALARM = record 
    dwSize: DWORD;  
    byListType: BYTE;  //名单属性0-允许名单，1-禁止名单，2-临时名单
    byPlateType: BYTE;  //车牌类型
    byPlateColor: BYTE;  //车牌颜色
    byRes1: BYTE;  
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码
    sCardNo: array[0..MAX_CARDNO_LEN-1] of AnsiChar;  // 卡号
    struAlarmTime: NET_DVR_TIME_V30;  //报警时间
    dwChannel: DWORD;  //设备通道号，如果直连的是IPC，则为ipc通道号；如果连的DVR\nvr,则为DVR\NVR的通道号
    dwPicDataLen: DWORD;  //图片数据大小，0表示无图片，不为0是表示后面带图片数据
    byPicType: BYTE;  //图片类型，0-JPEG
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes3: array[0..2-1] of BYTE;  
    pPicData: PAnsiChar;  
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_CONTROL_ALARM = ^NET_DVR_VEHICLE_CONTROL_ALARM;

//消防报警
type
  NET_DVR_FIRE_ALARM = record 
    dwSize: DWORD;  
    struAlarmTime: NET_DVR_TIME_V30;  //报警时间
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FIRE_ALARM = ^NET_DVR_FIRE_ALARM;

//清除设备车牌禁止名单数据库信息
type
  NET_DVR_VEHICLE_CONTROL_DELINFO = record 
    dwSize: DWORD;  
    dwDelType: DWORD;  //删除条件类型，删除条件类型，参照VCA_OPERATE _TYPE。（可复选）
    sLicense: array[0..16-1] of AnsiChar;  //车牌号码
    sCardNo: array[0..48-1] of AnsiChar;  // 卡号
    byPlateType: BYTE;  //车牌类型
    byPlateColor: BYTE;  //车牌颜色
    byOperateType: BYTE;  //删除操作类型(0-条件删除,0xff-删除全部)
    //2014-02-25
    byListType: BYTE;  //名单属性0-允许名单，1-禁止名单 2014-03-03
    dwDataIndex: DWORD;  //数据流水号
    //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
    sOperateIndex: array[0..MAX_OPERATE_INDEX_LEN-1] of AnsiChar;  
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_CONTROL_DELINFO = ^NET_DVR_VEHICLE_CONTROL_DELINFO;

//常亮灯功能
type
  NET_DVR_GATELAMP_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byLaneNo: BYTE;  //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    byBrightlampCtrl: BYTE;  //0-关闭常亮灯，1-开启常亮灯
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_GATELAMP_INFO = ^NET_DVR_GATELAMP_INFO;


//SDI矩阵1.0
const
  MATRIX_MAX_OUTPUT_NUM = 256;    //矩阵最大输出通道个数
type
  NET_DVR_MATRIX_BASE_CFG = record 
    dwSize: DWORD;  
    dwValidInputNum: DWORD;  //有效的输入通道数
    dwValidOutputNum: DWORD;  //有效的输出通道数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_BASE_CFG = ^NET_DVR_MATRIX_BASE_CFG;

type
  NET_DVR_MATRIX_SWITCH_INFO = record 
    dwSize: DWORD;  
    dwInputChan: DWORD;  //输入通道号，为0表示取消和指定输出的关联关系
    dwOutputChan: DWORD;  //要切换到的输出通道号, (屏幕服务器为屏幕索引号(1字节设备号+1字节保留+2字节屏幕索引号)), 0xffffffff表示切换到所有输出
    dwMatrixID: DWORD;  //矩阵ID号
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_SWITCH_INFO = ^NET_DVR_MATRIX_SWITCH_INFO;

type
  NET_DVR_IO_RELATION_INFO = record 
    dwSize: DWORD;  
    dwIORelation: array[0..MATRIX_MAX_OUTPUT_NUM-1] of DWORD;  //输出通道关联的输入通道, dwIORelation[i] = j表示输出通道(i + 1)和输入通道j关联,
    //dwIORelation[i] = 0表示输出通道i + 1未关联输入通道
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_IO_RELATION_INFO = ^NET_DVR_IO_RELATION_INFO;


//批量接口配置
type
  NET_DVR_EXTERNAL_DEVCOND = record 
    dwSize: DWORD;  
    byExternalDevTpye: BYTE;  //0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    byRelativeIndex: BYTE;  //0-其他(保留)，索引(相对于接入类型) 范围 1~8 Led的相对索引范围是（1～255）   0xff-全部信息（长连接获取时使用）
    //    BYTE   byLaneID;// 逻辑车道号
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_DEVCOND = ^NET_DVR_EXTERNAL_DEVCOND;

type
  NET_DVR_EXTERNAL_DEVCFG = record 
    dwSize: DWORD;  
    byExternalDevTpye: BYTE;  //0-其他，1-远距离读头设备，2-出入口控制机，3-led屏
    byRes2: array[0..3-1] of BYTE;  
    sDevName: array[0..MAX_DEVNAME_LEN-1] of AnsiChar;  
    uExternalDevInfo: record 
      case Byte of
      0: (byUnionLen: array[0..656-1] of BYTE);  
      1: (struRrReader: record
        struDevIP: NET_DVR_IPADDR;  //DEV IP地址 144
        wDevPort: WORD;  //设备端口
        byRes: array[0..510-1] of BYTE;  
      end);  //远距离读头设备
      2: (struGateway: record
        byRs485No: BYTE;  //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
        byDevCtrlCode: BYTE;  //拨码地址，用于区分设备(1-255)
        byAutoIssuedData: BYTE;  //是否自动下发卡片数据 0-不自动下发，1-自动下发
        byOfflineDetEnable: BYTE;  //离线检测 0-关闭，1-开启
        byDetCycle: BYTE;  //检测周期（0～60 单位 s）
        byRes: array[0..651-1] of BYTE;  
      end);  //出入口控制机
      3: (struLed: record
        byExternalMode: BYTE;  //0-RS485,1-网络
        byRes: array[0..3-1] of BYTE;  
        struDevIP: NET_DVR_IPADDR;  //DEV IP地址 144 (在byExternalMode == 1 时生效)
        wDevPort: WORD;  //设备端口(在byExternalMode == 1 时生效)
        byRs485No: BYTE;  //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
        byDevCtrlCode: BYTE;  //拨码地址，用于区分设备(1-255)
            //led屏通过控制卡控制显示的，不同的控制卡类型支持的显示方式不同
        byCtrlCardType: BYTE;  //控制卡类型 0-保留(无效值) 1- EQ2013
        byLedScreenType: BYTE;  //屏类型 0-单色屏 1-双色屏
        byLedScreenUse: BYTE;  //屏用途0-其它 1-区位屏 2-提示屏 3-收费屏
        byLedDisplayMode: BYTE;  //屏幕字体显示方式: 1 "立即显示",    2 "左移" ,3 "右移" ,4 "上移",     5 "下移"
        sLedCustomInfo: array[0..MAX_LED_INFO-1] of AnsiChar;  //屏幕字体显示信息
            //led屏是由控制卡控制的，led屏可以根据项目实际使用更换大小，此时需要终端通知控制卡目前使用的屏宽和屏高
        dwLedScreenH: DWORD;  //显示屏组成高度上需要的LED点数
        dwLedScreenW: DWORD;  //显示屏组成宽度上需要的LED点数
        byRes1: array[0..236-1] of BYTE;  
      end);  //led屏
    end;  //由byExternalMode 值来决定哪个有效
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_DEVCFG = ^NET_DVR_EXTERNAL_DEVCFG;

//长连接获取配置
type
  NET_DVR_EXTERNAL_DEVSTATUS = record //远距离读头设备
    dwSize: DWORD;  
    sDevName: array[0..MAX_DEVNAME_LEN-1] of AnsiChar;  //设备名称
    byExternalDevTpye: BYTE;  //0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    byRelativeIndex: BYTE;  //0-其他(保留)，相对索引(相对于接入类型能) 范围 1~8  0xff-全部信息（长连接获取时使用）
    byOnline: BYTE;  //0-不在线，1-在线
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNAL_DEVSTATUS = ^NET_DVR_EXTERNAL_DEVSTATUS;

//终端出入口检测配置
type
  NET_DVR_ENTRANCEDET_CFG = record 
    dwSize: DWORD;  //结构长度
    //离线检测开启时，如果检测到设备在线，则由终端匹配卡片信息，并发送道闸控制指令给出入口控制机；否则由出入口控制机自身匹配控制道闸
    byOfflineDetEnable: BYTE;  //离线检测 0-关闭，1-开启
    byDetCycle: BYTE;  //检测周期（0～60 单位 s）
    byDevCtrlCode: BYTE;  //出入口控制机拨码地址，用于区分设备(1-255)
    byRes: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_ENTRANCEDET_CFG = ^NET_DVR_ENTRANCEDET_CFG;

//终端出入口控制(控制接口 下发卡片信息)
type
  NET_DVR_ENTRANCEDEV_COMMAND = record 
    dwSize: DWORD;  //结构长度
    byDevCtrlCode: BYTE;  //出入口控制机拨码地址，用于区分设备(1-255)
    byManualIssuedData: BYTE;  //手动数据下发 0-关闭，1-开启
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_ENTRANCEDEV_COMMAND = ^NET_DVR_ENTRANCEDEV_COMMAND;

//终端出入口控制(控制接口 清空下发卡片信息)
type
  NET_DVR_ENISSUED_DATADEL = record 
    dwSize: DWORD;  //结构长度
    byDevCtrlCode: BYTE;  //出入口控制机拨码地址，用于区分设备(1-255)
    byRes: array[0..27-1] of BYTE;  
  end;
  LPNET_DVR_ENISSUED_DATADEL = ^NET_DVR_ENISSUED_DATADEL;

//出入口过车收费明细（监听方式）
type
  NET_ITS_PASSVEHICLE_COST_ITEM = record 
    dwSize: DWORD;  //结构长度
    dwPassVehicleID: DWORD;  //过车序号与出入口数据的过车序号相关联
    byIntime: array[0..MAX_TIME_LEN-1] of BYTE;  //入场时间格式为yyyymmddhh24missfff
    byOuttime: array[0..MAX_TIME_LEN-1] of BYTE;  //出场时间格式为yyyymmddhh24missfff
    byCardNo: array[0..MAX_CARD_LEN-1] of BYTE;  //卡号
    byPlateInfo: array[0..MAX_LICENSE_LEN-1] of BYTE;  //车牌号码
    fPayCost: FLOAT;  //收费金额(单位元)
    byOperatorName: array[0..MAX_OPERATORNAME_LEN-1] of BYTE;  //操作人员名称
    byVehicleType: BYTE;  //车辆类型  0-小型车 2 大型车
    byRes1: array[0..3-1] of BYTE;  //预留字段1
    dwPayRuleID: DWORD;  // 收费规则流水号
    dwFreeRuleID: DWORD;  // 减免规则流水号
    byRes2: array[0..256-1] of BYTE;  // 预留字段2
  end;
  LPNET_ITS_PASSVEHICLE_COST_ITEM = ^NET_ITS_PASSVEHICLE_COST_ITEM;

//出入口交接班数据（监听方式）
type
  NET_ITS_HANDOVER_INFO = record 
    dwSize: DWORD;  //结构长度
    byOperatorName: array[0..MAX_OPERATORNAME_LEN-1] of BYTE;  //操作人员名称
    byOperatorCard: array[0..MAX_CARD_LEN-1] of BYTE;  //操作人员卡号
    byStartTime: array[0..MAX_TIME_LEN-1] of BYTE;  //上班时间格式形如yyyymmddhh24miss
    byEndTime: array[0..MAX_TIME_LEN-1] of BYTE;  //下班时间格式形如yyyymmddhh24miss
    fTotal_Pay: FLOAT;  //本次上班期间总的收费金额(单位元)
    dwTotal_Records: DWORD;  //本次上班期间总的过车收费的记录条数
    byRes: array[0..64-1] of BYTE;  //预留
  end;
  LPNET_ITS_HANDOVER_INFO = ^NET_ITS_HANDOVER_INFO;


type
  NET_DVR_CURTRIGGERMODE = record //(3.7Ver)
    dwSize: DWORD;  
    dwTriggerType: DWORD;  //触发类型，详见ITC_TRIGGERMODE_TYPE
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_CURTRIGGERMODE = ^NET_DVR_CURTRIGGERMODE;



type
  NET_DVR_TEMP_HUMI = record 
    dwSize: DWORD;  // 内容长度 && 版本（用于后期扩展）
    dwChannel: DWORD;  // 通道号，默认1
    iHumidity: INT;  // 湿度，整数部分：val/1000，小数部分：val%1000
    iTemp: INT;  // 温度，整数部分：val/1000，小数部分：val%100
    byRes: array[0..8-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_TEMP_HUMI = ^NET_DVR_TEMP_HUMI;


type
  NET_DVR_ALARMSOUNDMODE_CFG = record 
    dwSize: DWORD;  // 内容长度 && 版本（用于后期扩展）
    dwChannel: DWORD;  // 通道号，默认1
    dwSoundMode: DWORD;  // 报警模式: 0提醒模式；1警报模式；2静音模式
    byRes: array[0..12-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARMSOUNDMODE_CFG = ^NET_DVR_ALARMSOUNDMODE_CFG;

type
  NET_DVR_SECURITYMODE = record 
    dwSize: DWORD;  // 内容长度 && 版本（用于后期扩展）
    dwChannel: DWORD;  // 通道号，默认1
    dwMode: DWORD;  // 安全模式: 1启用，码流加密；2不启用，码流不加密
    szRandCode: array[0..6-1] of AnsiChar;  //设备出厂的"随机验证码"
    byRes: array[0..6-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_SECURITYMODE = ^NET_DVR_SECURITYMODE;

type
  NET_DVR_MOBILE_CAPTUREPIC_CFG = record 
    dwSize: DWORD;  
    byPreviewFpsAdjMode: BYTE;  // 预览帧率调节模式:0-不调节，标准帧率预览,1-标准低帧率预览,2-根据GPS速度进行帧率调节 
    bySelPeccType: BYTE;  // 是否选择违章类型 
    byOptHabit: BYTE;  // 取证操作习惯, 0:长按取证;1:短按两次取证 
    byEnablePeccRec: BYTE;  // 1: 使能违章录像抓取, 0: 禁止违章录像抓取 
    byPicSize: BYTE;  //0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA，7-XVGA，8-HD900p，9-HD1080，10-2560*1920，11-1600*304，12-2048*1536，13-2448*2048,14-2448*1200，15-2448*800，16-XGA(1024*768)，17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i 
    byPicQuality: BYTE;  // 图片质量系数 0-最好 1-较好 2-一般 
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_MOBILE_CAPTUREPIC_CFG = ^NET_DVR_MOBILE_CAPTUREPIC_CFG;

type
  NET_DVR_CMS_PARAM = record 
    dwSize: DWORD;  
    struAddr: NET_DVR_IPADDR;  // 平台服务器IP
    wServerPort: WORD;  // 平台服务器侦听端口，
    bySeverProtocolType: BYTE;  //平台协议类型 1-私有，2-Ehome
    byStatus: BYTE;  //设备注册到该平台的状态，1-未注册，2-已注册
    sDeviceId: array[0..NAME_LEN{32}-1] of BYTE;  //设备ID，由平台提供
    sPassWord: array[0..PASSWD_LEN-1] of AnsiChar;  //密码
    //******** IPC5.1.7 新增参数 Begin 2014-03-21**********
    sPlatformEhomeVersion: array[0..NAME_LEN-1] of BYTE;  //平台EHOME协议版本
    //******** IPC5.1.7 新增参数 end 2014-03-21**********
    byNetWork: BYTE;  //网络类型：0- 无意义，1-自动，2-有线网络优先，3-有线网络，4-3G网络（无线网络），5-有线网络1，6-有线网络2
    byAddressType: BYTE;  //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    byProtocolVersion: BYTE;  //协议版本 0 - 无意义, 1 C v2.0，2 C v4.0,3-v2.6
    byRes1: BYTE;  
    sDomainName: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //平台服务器域名，byAddressType为2时有效
    byEnable: BYTE;  //0-关闭，1-开启
    byRes: array[0..139-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_CMS_PARAM = ^NET_DVR_CMS_PARAM;

//条件结构
type
  NET_DVR_HEATMAP_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byDetSceneID: BYTE;  //检测场景号[1],球机当前支持1个场景, IPC默认是0
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_COND = ^NET_DVR_HEATMAP_COND;

type
  NET_DVR_HEATMAP_PARAM = record 
    byTargetTrackEnable: BYTE;  //目标：0-关闭，1-开启，默认0-关闭
    bySensitivity: BYTE;  //灵敏度参数，范围1-100，默认50
    byBackgroundUpdateRate: BYTE;  //背景更新速度：范围1-100，默认50
    bySceneChangeLevel: BYTE;  //场景变化等级：范围1-100，默认50
    byMinTargetSize: BYTE;  //最小目标尺寸：范围1-100，默认50
    {
    0- 默认上传类型：COMM_UPLOAD_HEATMAP_RESULT；
    1- 上传类型：COMM_UPLOAD_HEATMAP_RESULT_PDC 和 COMM_UPLOAD_HEATMAP_RESULT_DURATION；
    }
    byUploadHeatMapResultType: BYTE;  
    byDayReport: BYTE;  
    byWeekReport: BYTE;  
    fConfidence: FLOAT;  //置信度[0.00,100.00]
    byMonthReport: BYTE;  
    byYearReport: BYTE;  
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_PARAM = ^NET_DVR_HEATMAP_PARAM;

const
  MAX_HEATMAPREGION_NUM = 8;    

//热度图检测配置结构
type
  NET_DVR_HEATMAP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能，是否开启
    byRes: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_HEATMAPREGION_NUM{8}-1] of NET_VCA_POLYGON;  //区域范围
    struHeatMap: NET_DVR_HEATMAP_PARAM;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    //布防时间
    struAlarmSched: array[0..MAX_DAYS{7}-1, 0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_SCHEDTIME;  
    byRes1: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_CFG = ^NET_DVR_HEATMAP_CFG;

//热度图报警上传
type
  NET_DVR_HEATMAP_RESULT = record 
    dwSize: DWORD;  
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    dwMaxHeatMapValue: DWORD;  //最大热度值
    dwMinHeatMapValue: DWORD;  //最小热度值
    dwTimeHeatMapValue: DWORD;  // (时间热度值)平均热度值
    wArrayLine: WORD;  //图片像素点行值
    wArrayColumn: WORD;  //图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
    pBuffer: PBYTE;  //热度图片像素点数据信息
    byDetSceneID: BYTE;  //检测场景号[1],球机当前支持1个场景, IPC默认是0
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不是重传数据，1-重传数据
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14，+表示东区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14， +表示东区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区
    byArrayUnitType: BYTE;  //矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），1-byte，2-short,4-int
    byRes1: array[0..2-1] of BYTE;  
    dwTotalTime: DWORD;  //停留时间总和，单位秒，按人员停留时间报警时上传
    byRes: array[0..112-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_RESULT = ^NET_DVR_HEATMAP_RESULT;

//热度图报警查找 条件结构体
type
  NET_DVR_HEATMAP_QUERY_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    byReportType: BYTE;  //0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    byDetSceneID: BYTE;  //检测场景号[1],球机当前支持1个场景, IPC默认是0
    byHeatMapInfoType: BYTE;  //0~获取空间热度图片方式，1~获取空间热度矩阵信息方式，2~获取空间热度图片和空间热度矩阵信息
    byStatisticalModel: BYTE;  //统计模式  0s-保留（默认），1-停留时间，2-按人数统计）
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_QUERY_COND = ^NET_DVR_HEATMAP_QUERY_COND;

//热度图报警查找
type
  NET_DVR_HEATMAP_INFO = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_EX;  //间隔开始时间
    struEndTime: NET_DVR_TIME_EX;  //间隔结束时间
    dwHeatMapPicLen: DWORD;  //空间热度图片长度(当含有图片的时候，该字段为非0，没有图片的时候，该字段为0)
    pBuffer: PBYTE;  //热度图片数据信息
    dwTimeHeatMapValue: DWORD;  //时间热度值(含有空热度图的时候,该字段不需要传值)
    dwHeatMapMaxValue: DWORD;  //检测区域最高热度点人员活动时间(s)(空间热度图时有效)
    dwHeatMapMinValue: DWORD;  //检测区域最低热度点人员活动时间(s) (空间热度图时有效)
    wArrayLine: WORD;  //图片像素点行值 （上传热度矩阵信息时生效）
    wArrayColumn: WORD;  //图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）（上传热度矩阵信息时生效）
    pArrayBuffer: PBYTE;  //热度矩阵数据信息（矩阵数据的透传，信息长度为wArrayLine* wArrayColumn*单元数据类型长度（例如byArrayUnitType为1表示为int型，这里就要乘以4个字节））
    byArrayUnitType: BYTE;  //矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），0~byte，1~int；(当设备有返回矩阵信息时生效)
    byRes: array[0..107-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_INFO = ^NET_DVR_HEATMAP_INFO;


type
  NET_DVR_PDC_QUERY_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    byReportType: BYTE;  //0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    byEnableProgramStatistics: BYTE;  //是否按节目统计，0-否，1-是
    byTriggerPeopleCountingData: BYTE;  //触发客流统计数据的使能, 0-否，1-是
    byMultiChannelSearch: BYTE;  //多通道查询使能, 0-否，1-是（pSearchChannel 、dwSearchChannelNum有效）
    dwPlayScheduleNo: DWORD;  //按节目统计时关联的日程号
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes1: array[0..3-1] of BYTE;  
    dwSearchChannelNum: DWORD;  //查询通道数目
    pSearchChannel: PAnsiChar;  //查询通道号，大小为sizeof(DWORD)* dwSearchChannelNum
    byChild: BYTE;  //只检测儿童, 0-否，1-是
    byMinTimeInterva: BYTE;  // 最小时间间隔,0-无效，1-15分钟, 2-30分钟, 3一小时, 4-天, 5-周, 6-月
    byStatisticType: BYTE;  //统计类型，0-无效值，1-进入人数，2-离开人数，3-全部,4-进入离开重复人数,5-人脸属性(需要下发具体支持的人脸属性),0-无效值表示不进行统计类型的条件查询，相当于保留字节。全部表示统计类型为进入和离开（不包括经过）。
    byFaceExpression: BYTE;  //参见FACE_EXPRESSION_GROUP_ENUM
    byGender: BYTE;  //性别，1-男，2-女，3-全部，0xff-算法支持，但是没有识别出来
    byMask: BYTE;  //是否戴口罩 0-表示“未知”（算法不支持），1-不戴，2-戴，3-全部，0xff-算法支持的，但是没有识别出来
    byGroup: BYTE;  //段
    byGlasses: BYTE;  //是否带眼镜，0-未知，1-是，2-否，3-戴墨镜,  4 - 全部,  0xff-算法支持，但是没有识别出来
    byRes: array[0..96-1] of BYTE;  
  end;
  LPNET_DVR_PDC_QUERY_COND = ^NET_DVR_PDC_QUERY_COND;

type
  NET_DVR_PROGRAM_INFO = record 
    dwProgramNo: DWORD;  //节目编号
    sProgramName: array[0..NAME_LEN-1] of BYTE;  //节目名称
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PROGRAM_INFO = ^NET_DVR_PROGRAM_INFO;
type
  NET_DVR_POSINFO_OVERLAY = record 
    dwSize: DWORD;  
    byEnable: BYTE;  // Pos信息叠加，0-不叠加，1-叠加
    byBackpackEnanble: BYTE;  //是否叠加背包信息是否叠加，0-不叠加，1-叠加
    bySexEnanble: BYTE;  //是否叠加性别信息是否叠加，0-不叠加，1-叠加
    byCarryEnanble: BYTE;  //是否叠加拎东西信息是否叠加，0-不叠加，1-叠加
    byRideEnanble: BYTE;  //是否叠加骑车信息是否叠加，0-不叠加，1-叠加
    byMaskEnanble: BYTE;  //是否叠加带口罩信息是否叠加，0-不叠加，1-叠加
    byHatEnanble: BYTE;  //是否叠加戴帽子信息是否叠加，0-不叠加，1-叠加
    bySleeveEnanble: BYTE;  //是否叠加长短袖情况，0-不叠加，1-叠加
    byPantsTypeEnanble: BYTE;  //是否叠加裤子属性信息是否叠加，0-不叠加，1-叠加
    byHairEnanble: BYTE;  //是否叠加长短发信息是否叠加，0-不叠加，1-叠加
    byGlassesEnanble: BYTE;  //是否叠加戴眼镜信息是否叠加，0-不叠加，1-叠加
    byResEnanble: BYTE;  //是否叠加信息是否叠加，0-不叠加，1-叠加
    byHeightEnanble: BYTE;  //是否叠加身高信息是否叠加，0-不叠加，1-叠加
    byRes: array[0..511-1] of BYTE;  
  end;
  LPNET_DVR_POSINFO_OVERLAY = ^NET_DVR_POSINFO_OVERLAY;

type
  NET_DVR_PDC_RESULT = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    dwEnterNum: DWORD;  //进入人数
    dwLeaveNum: DWORD;  //离开人数
    struProgramInfo: NET_DVR_PROGRAM_INFO;  //节目信息
    dwPeoplePassing: DWORD;  //经过人数
    byRes1: array[0..8-1] of BYTE;  //保留字节
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes3: array[0..3-1] of BYTE;  //保留字节
    dwDuplicatePeople: DWORD;  // 重复人数
    dwExpressionUnknown: DWORD;  //表情未知
    dwPokerFace: DWORD;  //表情中性
    dwHappy: DWORD;  //表情高兴
    dwSurprised: DWORD;  //表情惊讶
    dwDisgusted: DWORD;  //表情厌恶
    dwSad: DWORD;  //表情难过
    dwAngry: DWORD;  //表情愤怒
    dwContemptuous: DWORD;  //表情轻蔑
    dwPanic: DWORD;  //表情害怕
    dwGenderUnknown: DWORD;  //性别未知
    dwFemale: DWORD;  //性别女
    dwMale: DWORD;  //性别男
    dwMaskUnknown: DWORD;  //面具未知
    dwMaskYes: DWORD;  //戴面具
    dwMaskNo: DWORD;  //不戴面具
    dwGlassUnknown: DWORD;  //眼镜未知
    dwGlassYes: DWORD;  //戴眼镜
    dwGlassNo: DWORD;  //不戴眼镜
    dwSunglasses: DWORD;  //墨镜
    byRes: array[0..104-1] of BYTE;  
  end;
  LPNET_DVR_PDC_RESULT = ^NET_DVR_PDC_RESULT;


type
  NET_DVR_MOBILE_PLATE_RECOGCFG = record 
    dwSize: DWORD;  
    byDefaultCHN: array[0..MAX_CHJC_NUM-1] of BYTE;  //设备运行省份的汉字简写  3 
    byTimeOsd: BYTE;  // 时间信息叠加 0 - 不叠加， 1- 叠加
    byRecogResultOsd: BYTE;  //识别结果叠加  0 - 不叠加， 1- 叠加
    byRecogHint: BYTE;  //识别成功提示 0 - 不提示， 1- 提示
    byRecogDir: BYTE;  //识别方向 0: 正向, 1: 背向
    byRecogEnv: BYTE;  //识别环境 0: 白天, 1: 晚上
    byRecogPlateType: BYTE;  //0-小车牌识别，1-大车牌识别
    byUploadPlate: BYTE;  //是否上传车牌 0 -不上传， 1-上传
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_MOBILE_PLATE_RECOGCFG = ^NET_DVR_MOBILE_PLATE_RECOGCFG;

type
  NET_DVR_MOBILE_RADAR_CFG = record 
    dwSize: DWORD;  
    byEnableRadar: BYTE;  // 0:不开启雷达  1:开启雷达 
    byEnableAlarm: BYTE;  // 0:不开启报警  1:开启报警 
    wOverSpeed: WORD;  // 范围为20~250 
    bySpeedUnits: BYTE;  // 0:公里/小时   1:英里/小时 
    bydirection: BYTE;  // 0:反向（雷达与车相向） 1:正向（雷达与车反向） 
    byMeasureMode: BYTE;  // 0:静态 (雷达状态)       1:动态 (雷达状态)
    byTargetType: BYTE;  // 0:最快(雷达测速车辆最快)  1:最近(雷达测速车辆最近)
    bySensitivity: BYTE;  // 灵敏度[0,100] 
    byCaptureNum: BYTE;  // 抓拍张数[0,255] 
    byUploadPlate: BYTE;  //是否上传超速抓拍图片 0-不上传，1-上传
    byRes: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_MOBILE_RADAR_CFG = ^NET_DVR_MOBILE_RADAR_CFG;

type
  NET_DVR_MOBILE_LOCALPLATECHK_CFG = record 
    dwSize: DWORD;  
    byCheck: BYTE;  // 稽查任务是否进行禁止名单稽查 0-稽查，1-不稽查
    byCheckAlarm: BYTE;  // 稽查成功报警 0-不报警，1-报警
    byCheckHint: BYTE;  // 稽查成功提示 (软件提示) 0-不提示，1-提示
    byUploadUnlicensedCar: BYTE;  //是否上传非法车信息 0-不上传，1-上传
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MOBILE_LOCALPLATECHK_CFG = ^NET_DVR_MOBILE_LOCALPLATECHK_CFG;

type
  NET_DVR_VEHICLE_CHECK = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号0xff - 全部通道（默认是1,代表一个通道）
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息
    wIllegalType: WORD;  //违章类型采用国标定义 （参考附件）
    byRes: array[0..2-1] of BYTE;  
    sIllegalTypeInfo: array[0..128-1] of AnsiChar;  // 违规类型信息（128）
    struIllegalTime: NET_DVR_TIME_V30;  //违规时间
    byIllegalVehicleNum: BYTE;  //车辆违法次数
    byRes1: array[0..3-1] of BYTE;  
    sCustomInfo: array[0..64-1] of AnsiChar;  //自定义信息
    byRes2: array[0..128-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VEHICLE_CHECK = ^NET_DVR_VEHICLE_CHECK;

type
  LONG_CFG_SEND_DATA_TYPE_ENUM =  
  (  
    ENUM_DVR_VEHICLE_CHECK = 1,  //禁止名单车辆数据稽查类型
    ENUM_MSC_SEND_DATA = 2,  //屏幕控制器数据类型
    ENUM_ACS_SEND_DATA = 3,  //门禁主机数据类型
    ENUM_TME_CARD_SEND_DATA = 4,  //停车场(出入口控制机)卡片数据类型
    ENUM_TME_VEHICLE_SEND_DATA = 5,  //停车场(出入口控制机)车辆数据类型
    ENUM_DVR_DEBUG_CMD = 6,  //调试命令信息
    ENUM_DVR_SCREEN_CTRL_CMD = 7,  //屏幕互动命令类型
    ENUM_CVR_PASSBACK_SEND_DATA = 8,  //CVR获取布防点回传任务可执行性
    ENUM_ACS_INTELLIGENT_IDENTITY_DATA = 9,  //智能身份识别终端数据类型
    ENUM_VIDEO_INTERCOM_SEND_DATA = 10,  //可视对讲数据类型
    ENUM_SEND_JSON_DATA = 11  //透传JSON数据
  );

type
  LONG_CFG_RECV_DATA_TYPE_ENUM =  
  (  
    ENUM_DVR_ERROR_CODE = 1,  //错误码
    ENUM_MSC_RECV_DATA = 2,  //屏幕控制器数据类型
    ENUM_ACS_RECV_DATA = 3  //门禁主机数据类型
  );

type
  NET_DVR_WIPER_CONTINUEWORK_PARAM = record 
    byWorkTimeInterval: BYTE;  //工作时间间隔（单位：秒）[2s~60s]
    byRes: array[0..3-1] of BYTE;  
    dwContinueWorkTime: DWORD;  //持续工作时间（单位：秒）[2min~24h]界面显示按分钟单位
    byRes1: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_WIPER_CONTINUEWORK_PARAM = ^NET_DVR_WIPER_CONTINUEWORK_PARAM;

type
  NET_DVR_WIPERMODE_PARAM_UNION = record 
    case Byte of
    0: (uLen: array[0..16-1] of BYTE);  
    //当byWiperWorkMode = 1时生效
    1: (struWiperContinueWorkParam: NET_DVR_WIPER_CONTINUEWORK_PARAM);  
  end;
  LPNET_DVR_WIPERMODE_PARAM_UNION = ^NET_DVR_WIPERMODE_PARAM_UNION;

type
  NET_DVR_WIPERINFO_CFG = record 
    dwSize: DWORD;  
    //雨刷工作模式
    //0-单次模式，1-持续模式（针对配置结构NET_DVR_ROTATE_OPERATE_PARAM），2-智能模式，0xff-关闭
    byWiperWorkMode: BYTE;  
    byRes1: BYTE;  
    wSensitivity: WORD;  //降雨灵敏度
    byRes: array[0..20-1] of BYTE;  
    ustruWiperModeParam: NET_DVR_WIPERMODE_PARAM_UNION;  
  end;
  LPNET_DVR_WIPERINFO_CFG = ^NET_DVR_WIPERINFO_CFG;

//保存自动对焦参数
type
  NET_DVR_AUTOFOCUS_TESTCFG = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..24-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_AUTOFOCUS_TESTCFG = ^NET_DVR_AUTOFOCUS_TESTCFG;


type
  NET_DVR_VIDEO_OUT_CFG = record 
    byDisplayMode: BYTE;  //显示模式，1-标准，2-冷色，3-暖色，0xff-自定义
    byBrightnessLevel: BYTE;  // 亮度值0-100
    byContrastLevel: BYTE;  // 对比度0-100
    bySharpnessLevel: BYTE;  // 锐度0-100
    bySaturationLevel: BYTE;  // 饱和度0-100
    byHueLevel: BYTE;  // 色调0-100
    byImageMode: BYTE;  // 图像模式，0-正常模式，1-夜模式1，2-夜模式2，3-夜模式3，4-日照模式1，5-日照模式2，6-日照模式3
    byRes: array[0..5-1] of BYTE;  // 保留
  end;
  LPNET_DVR_VIDEO_OUT_CFG = ^NET_DVR_VIDEO_OUT_CFG;
//色温
type
  NET_DVR_COLOR_TEMPERATURE_CFG = record 
    byRed: BYTE;  //红色， 0-100
    byGreen: BYTE;  //绿色， 0-100
    byBlue: BYTE;  //蓝色，0-100
    byRedOffset: BYTE;  //红色偏移，0-100
    byGreenOffset: BYTE;  //绿色偏移，0-100
    byBlueOffset: BYTE;  //蓝色偏移，0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_COLOR_TEMPERATURE_CFG = ^NET_DVR_COLOR_TEMPERATURE_CFG;

type
  NET_DVR_ADC_CFG = record 
    byGainR: BYTE;  //增益R， 0-100
    byGainG: BYTE;  //增益G，0-100
    byGainB: BYTE;  //增益B，0-100
    byOffsetR: BYTE;  //偏移量R，0-100
    byOffsetG: BYTE;  //偏移量G，0-100
    byOffsetB: BYTE;  //偏移量B，0-100
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_ADC_CFG = ^NET_DVR_ADC_CFG;

type
  NET_DVR_SCREEN_EDGE_CFG = record 
    byEnable: BYTE;  //是否启用屏幕边缘 0-不启用 1-启用
    byLeftEdge: BYTE;  //左边缘，0-100
    byRightEdge: BYTE;  //右边缘，0-100
    byTopEdge: BYTE;  //上边缘，0-100
    byLowerEdge: BYTE;  //下边缘，0-100
    byRes: array[0..7-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_EDGE_CFG = ^NET_DVR_SCREEN_EDGE_CFG;

type
  NET_DVR_SCREEN_DISPLAY_CFG = record 
    dwSize: DWORD;  
    byCfgType: BYTE;  //设置的参数类型，获取时此参数无效，0-无效，1-背光参数，2-视频参数，3-色温参数，4-ADC参数，5-屏幕边缘参数
    byBackLight: BYTE;  //背光 0~100
    byRes1: array[0..2-1] of BYTE;  
    struVideoOutCfg: NET_DVR_VIDEO_OUT_CFG;  //视频参数（画面模式）
    struColorTempCfg: NET_DVR_COLOR_TEMPERATURE_CFG;  //色温参数
    struAdcCfg: NET_DVR_ADC_CFG;  //ADC参数
    struScreenEdgeCfg: NET_DVR_SCREEN_EDGE_CFG;  //屏幕边缘参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_DISPLAY_CFG = ^NET_DVR_SCREEN_DISPLAY_CFG;
//模拟遥控类型
type
  SCREEN_REMOTE_CTRL_TYPE =  
  (  
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,  //1-电源开
    REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,  //2-电源关
    REMOTE_CTRL_SIGNALSOURCE,  //3-信号源
    REMOTE_CTRL_MENU,  //4-菜单
    REMOTE_CTRL_DETERMINATION,  //5-确定
    REMOTE_CTRL_ON,  //6-上
    REMOTE_CTRL_UNDER,  //7-下
    REMOTE_CTRL_LEFT,  //8-左
    REMOTE_CTRL_RIGHT,  //9-右
    REMOTE_CTRL_INFO,  //10-INFO
    REMOTE_CTRL_RETURN,  // 11-返回上一层
    REMOTE_CTRL_NUM  //12-数字键盘
  );

//模拟遥控按键
type
  NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL = record 
    dwSize: DWORD;  
    byControlType: BYTE;  //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键,13-开关一体按键
    byControlParam: BYTE;  //操作参数，操作类型为12时，表示按键值（0-9），其他操作时此参数无效
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL = ^NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//屏幕信号源配置
type
  NET_DVR_SCREEN_SIGNAL_CFG = record 
    dwSize: DWORD;  
    bySignalSourceType: BYTE;  //输入源索引，见枚举 NET_DVR_CAM_MODE
    byNoSignalPic: BYTE;  //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_SIGNAL_CFG = ^NET_DVR_SCREEN_SIGNAL_CFG;

//屏幕拼接配置
type
  NET_DVR_SCREEN_SPLICE_CFG = record 
    dwSize: DWORD;  
    bySpliceIndex: BYTE;  //自拼接屏号，0就是没有拼接，其他值表示自拼接屏的屏号。例如拼接0101~0202这4块屏，则这4块屏的bySpliceIndex必须相同，且非0.
    bySpliceX: BYTE;  //屏幕在自拼接屏中的行位置
    bySpliceY: BYTE;  //屏幕在自拼接屏中的列位置
    byWidth: BYTE;  //拼接规模宽，以屏幕为单位
    byHeight: BYTE;  //拼接规模高，以屏幕为单位
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_SPLICE_CFG = ^NET_DVR_SCREEN_SPLICE_CFG;

//风扇工作方式配置
type
  NET_DVR_SCREEN_FAN_WORK_MODE_CFG = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //1-常开，2-自动
    byTemperatureLimitValue: BYTE;  //风扇开启的温度阀值，工作模式为自动时该参数有效。
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG = ^NET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA信号配置
type
  NET_DVR_SCREEN_VGA_CFG = record 
    dwSize: DWORD;  
    byEnableAutoAdjust: BYTE;  //是否自动调整，0-否，1-是，当自动调整启用时以下参数无效
    byHorizontalPosition: BYTE;  //水平位置 0-100
    byVerticalPosition: BYTE;  //垂直位置 0-100
    byClock: BYTE;  //时钟 ，0-100
    byPhase: BYTE;  //相位，0-100
    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_VGA_CFG = ^NET_DVR_SCREEN_VGA_CFG;

//屏幕菜单配置
type
  NET_DVR_SCREEN_MENU_CFG = record 
    dwSize: DWORD;  
    byMenuLanguage: BYTE;  //语言，1-中文，2-英文
    byTransparency: BYTE;  //透明度 0-不透明，1-低，2-中，3-高
    byDuration: BYTE;  //持续时间，0-常开，1-5秒，2-15秒，3-30秒
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_MENU_CFG = ^NET_DVR_SCREEN_MENU_CFG;

//画中画
type
  NET_DVR_PIP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用画中画 0-不启用 1-启用
    bySubWindowSource: BYTE;  //子画面信号源，参考枚举NET_DVR_CAM_MODE
    bySubWindowBorderColor: BYTE;  //子画面边框颜色， 1-蓝色，2-黑色
    byRes1: BYTE;  
    struPosition: NET_DVR_RECTCFG;  //子画面位置，屏幕总大小为100*100
    byRes2: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_PIP_CFG = ^NET_DVR_PIP_CFG;

//透雾配置
type
  NET_DVR_DEFOG_LCD = record 
    dwSize: DWORD;  
    byDefogEnable: BYTE;  //开启透雾开关，0~关闭，1~开启
    byDefogModel: BYTE;  //透雾模式，0~自动去雾，1~手动去雾
    byDefogLevel: BYTE;  //透雾强度等级，1-7个等级，默认等级为4。等级1为0.5；等级2为0.55；等级3为0.60；等级4为0.65；等级5为0.70；等级6为0.75；等级7为0.80。（去雾模式为手动去雾时，可配置去雾强度等级）
    byRes: array[0..33-1] of BYTE;  
  end;
  LPNET_DVR_DEFOG_LCD = ^NET_DVR_DEFOG_LCD;

//屏幕维墙
type
  NET_DVR_SCREEN_WALL_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //状态开关。0-为关闭；1-为开启
    byRes: array[0..35-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_WALL_CFG = ^NET_DVR_SCREEN_WALL_CFG;

//屏幕位置
type
  NET_DVR_SCREEN_POS_CFG = record 
    dwSize: DWORD;  
    byScreenRowNum: BYTE;  //屏幕行号。
    byScreenColNum: BYTE;  //屏幕列号。
    byRes: array[0..34-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_POS_CFG = ^NET_DVR_SCREEN_POS_CFG;

type
  NET_DVR_VIDEO_AUDIOIN_CFG = record 
    dwSize: DWORD;  //结构体的长度
    dwChanNo: DWORD;  //视音频通道号， 绑定且启用后，被绑定的语音对讲通道则作为该通道的音频源
    byEnable: BYTE;  //是否启用语音对讲作为音频输入源 0-不启用 1-启用
    byRes: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_AUDIOIN_CFG = ^NET_DVR_VIDEO_AUDIOIN_CFG;

type
  NET_DVR_VCA_DETION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    struHandleException: NET_DVR_HANDLEEXCEPTION_V40;  //异常处理方式
    dwMaxRelRecordChanNum: DWORD;  //报警触发的录象通道 数（只读）最大支持数量
    dwRelRecordChanNum: DWORD;  //报警触发的录象通道 数 实际支持的数量
    dwRelRecordChan: array[0..MAX_CHANNUM_V30{64}-1] of DWORD;  //触发录像通道号
    byEnablePreset: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byPresetNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byEnableCruise: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byCruiseNo: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byEnablePtzTrack: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    byPTZTrack: array[0..MAX_CHANNUM_V30-1] of BYTE;  
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    byRes: array[0..224-1] of BYTE;  
  end;
  LPNET_DVR_VCA_DETION_CFG = ^NET_DVR_VCA_DETION_CFG;

type
  NET_DVR_VCA_DETECTION_CFG_V40 = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    struAlarmSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  
    dwHandleType: DWORD;  //异常处理,异常处理方式的"或"结果
    //0x00: 无响应
    //0x01: 显示器上警告
    //0x02: 声音警告
    //0x04: 上传中心
    //0x08: 触发报警输出
    //0x10: 触发JPRG抓图并上传Email
    //0x20: 无线声光报警器联动
    //0x40: 联动电子地图(目前只有PCNVR支持)
    //0x200: 抓图并上传FTP
    dwMaxRelAlarmOutChanNum: DWORD;  //触发的报警输出通道数（只读）最大支持数量
    dwRelAlarmOut: array[0..MAX_ALARMOUT_V40{4128}-1] of DWORD;  //* 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff则后续无效}
    //触发的录像通道
    dwMaxRecordChanNum: DWORD;  //设备支持的最大关联录像通道数-只读
    dwRelRecordChan: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  // 实际触发录像通道，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff,则后续无效
    dwEnablePresetChanNum: DWORD;  //当前已启用预置点的数目
    struPresetChanInfo: array[0..MAX_CHANNUM_V40{512}-1] of NET_DVR_PRESETCHAN_INFO;  //启用的预置点信息，当dwEnablePresetChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用预置点
    byRes2: array[0..516-1] of BYTE;  //保留
    dwEnableCruiseChanNum: DWORD;  //当前已启用巡航的通道数目
    struCruiseChanInfo: array[0..MAX_CHANNUM_V40{512}-1] of NET_DVR_CRUISECHAN_INFO;  //启用巡航功能通道的信息，当dwEnableCruiseChanNum不为0时，数组下标0-( dwEnableCruiseChanNum -1)有效，当为0时，表示未启用巡航
    dwEnablePtzTrackChanNum: DWORD;  //当前已启云台通道数目
    struPtzTrackInfo: array[0..MAX_CHANNUM_V40{512}-1] of NET_DVR_PTZTRACKCHAN_INFO;  //调用云台的通道信息，当dwEnablePtzTrackChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用云台
    struHolidayTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    byRes: array[0..224-1] of BYTE;  
  end;
  LPNET_DVR_VCA_DETECTION_CFG_V40 = ^NET_DVR_VCA_DETECTION_CFG_V40;

type
  NET_DVR_CLOUD_STORAGE_CFG = record 
    dwSize: DWORD;  //结构体大小;
    byEnableCS: BYTE;  //开启云存储服务  0-关闭 1-开启
    byRes: array[0..511-1] of BYTE;  //保留
  end;
  LPNET_DVR_CLOUD_STORAGE_CFG = ^NET_DVR_CLOUD_STORAGE_CFG;


type
  NET_DVR_CHAN_RECORD_STATUS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byValid: BYTE;  //是否有效
                           {(只读)录像类型，0: 不在录像；1：在录像 2-空闲
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中}
    byRecord: BYTE;  
    dwRelatedHD: DWORD;  //关联磁盘
    byOffLineRecord: BYTE;  //断网录像功能 0-关闭 1-开启
    byRes: array[0..63-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_CHAN_RECORD_STATUS_CFG = ^NET_DVR_CHAN_RECORD_STATUS_CFG;

const
  MAX_CAMERAID_LEN = 64;    
type
  NET_DVR_UPLOAD_RECORD_INFO = record 
    dwSize: DWORD;  
    dwRecordType: DWORD;  //录像类型  0- 定时录像，1- 移动侦测录像，2- 报警录像，3- 报警或移动侦测录像，4- 报警和移动侦测录像， 5- 命令触发，6- 手动录像，7- 震动报警，8- 环境触发报警，9- 智能报警，10- 回传录像
    sCameraID: array[0..MAX_CAMERAID_LEN-1] of BYTE;  //camera id;
    struStartTime: NET_DVR_TIME_EX;  //录像开始时间
    struStopTime: NET_DVR_TIME_EX;  //录像结束时间
    dwStoragePoolID: DWORD;  //存储池ID
    byFormatType: BYTE;  //封装类型：1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP，9-RTP+PS（国标：GB28181），0xff-无效
    byVideoEncType: BYTE;  //视频编码类型：0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，0xfe- 自动（和源一致），0xff-无效
    byAudioEncType: BYTE;  //音频编码类型：0-G722，1-G711_U，2-G711_A，5-MP2L2，6-G726，7-AAC，0xfe- 自动（和源一致），0xff-无效
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_RECORD_INFO = ^NET_DVR_UPLOAD_RECORD_INFO;

//补光灯参数配置  条件结构体
type
  NET_DVR_IOOUT_COND = record 
    dwSize: DWORD;  
    bySyncOutputNo: BYTE;  //同步输出号(0-F1,1-F2,2-F3)
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_IOOUT_COND = ^NET_DVR_IOOUT_COND;

//补光灯参数配置
type
  NET_DVR_IOOUT_CFG = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  // 0-报警输出,1-频闪灯(默认)
    byRes1: array[0..3-1] of BYTE;  
    uWorkModeInfo: record 
      case Byte of
      0: (byUnionLen: array[0..128-1] of BYTE);  
      1: (struStrobeLamp: record
        byDefaultState: BYTE;  //默认状态 0-低电平(默认)，1-高电平
        byWorkState: BYTE;  //生效状态 0-低电平(默认),1-高电平,2-脉冲
        byFreqMulti: BYTE;  //倍频，数值范围[1,15]
        byDutyRatio: BYTE;  //占空比，[0,40%]
        byRes: array[0..3-1] of BYTE;  
        byFlashLightEnable: BYTE;  //设置闪光灯时间使能:0-关;1-开
        struFlashLightTime: NET_DVR_SCHEDTIME;  //启用闪光灯时间
        byRes1: array[0..116-1] of BYTE;  
      end);  // 频闪灯 时有效
    end;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_IOOUT_CFG = ^NET_DVR_IOOUT_CFG;

//信号灯同步参数
type
  NET_DVR_SIGNAL_SYNCCFG = record 
    dwSize: DWORD;  
    wPhase: WORD;  //相位(0~360)
    byLineLock: BYTE;  //电源同步 0-否，1-是
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_SIGNAL_SYNCCFG = ^NET_DVR_SIGNAL_SYNCCFG;

// 萤石EZVIZ接入参数结构体
type
  NET_DVR_EZVIZ_ACCESS_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  // 启用EZVIZ接入 0～禁用，1～启用
    //******** IPC5.1.7 新增参数 Begin 2014-03-21**********
    byDeviceStatus: BYTE;  //设备是否在线状态，0-保留，1-在线，2-离线
    byAllowRedirect: BYTE;  //是否允许重定向,0-保留,1-是,2-否,0表示保持不变,兼容老SDK接新设备的情况
    byDomainName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //域名服务器地址
    byRes1: BYTE;  
    byVerificationCode: array[0..NET_SDK_MAX_VERIFICATION_CODE_LEN{32}-1] of BYTE;  //萤石云验证码
    byNetMode: BYTE;  //网络模式，0-无意义，1-自动，2-有线网络优先，3-有线网络(默认)，4-无线网络
    byOfflineStatus: BYTE;  //设备离线具体状态: 0-保留，1-萤石注册验证码无效。该字段为只读，且当DeviceStatus为2时生效。
    byEnableTiming: BYTE;  // 启用EZVIZ校时 0～禁用，1～启用
    byRes2: BYTE;  
    byOperateCode: array[0..NET_SDK_MAX_OPERATE_CODE_LEN-1] of BYTE;  //操作码，用户绑定设备时使用
    byRes: array[0..344-1] of BYTE;  
  end;
  LPNET_DVR_EZVIZ_ACCESS_CFG = ^NET_DVR_EZVIZ_ACCESS_CFG;

type
  NET_DVR_ALARM_RELATE_COND = record 
    dwSize: DWORD;  
    {
    0表示移动侦测，
    1表示视频遮挡，
    2表示视频丢失，
    3表示PIR报警，
    4表示无线报警，
    5表示呼救报警，
    6表示智能抓图，
    7表示人脸侦测，
    8表示越界侦测侦测，
    9表示区域入侵侦测，
    10表示场景变更侦测，
    11 表示异常侦测，
    0xff 表示报警输入
    }
    byAlarmType: BYTE;  
    //联动动作 0-无效,1-抓图上传FTP,2-Jpeg抓图上传Email
    byRelateActType: BYTE;  
    byRes: array[0..2-1] of BYTE;  
    //报警输入号或者通道号或者无线编号
    //(当byAlarmType ==0xff时,dwChannel表示的是报警输入号)
    //(当byAlarmType ==4时,dwChannel表示的是无线编号)
    dwChannel: DWORD;  
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_RELATE_COND = ^NET_DVR_ALARM_RELATE_COND;

type
  NET_DVR_ALARM_RELATE_CFG = record 
    dwSize: DWORD;  
    dwMaxRelateChanNum: DWORD;  //触发的报警关联通道数（只读）最大支持数量
    //dwRelateChan的初始值是0xffffffff;数组内填写是实际的通道号;
    dwRelateChan: array[0..MAX_CHANNUM_V40{512}-1] of DWORD;  
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_RELATE_CFG = ^NET_DVR_ALARM_RELATE_CFG;

type
  NET_DVR_PTZ_BASICPARAMCFG = record 
    dwSize: DWORD;  
    byProportionalPan: BYTE;  //启用比例变倍配置 0-否，1-是
    byPresetFreezing: BYTE;  //启用预置点视频冻结 0-否，1-是
    byPresetSpeed: BYTE;  //预置点速度等级 1--8，默认4
    byKeyboardCtrlSpeed: BYTE;  //手控速度等级0-低,1-中,2-高
    byAutoScanSpeed: BYTE;  //扫描速度等级：1--40，默认28
    byZoomingSpeed: BYTE;  //变倍速度：1--3，默认3
    byManualControlSpeed: BYTE;  //手控速度模式：0-兼容，1-行人，2-非机动车，3-机动车，4-自适应
    byPTZMotionTrack: BYTE;  //启用运动（锁定云台操作） 0-默认（开启），1-关闭
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_BASICPARAMCFG = ^NET_DVR_PTZ_BASICPARAMCFG;

type
  NET_DVR_PTZ_OSDCFG = record 
    dwSize: DWORD;  
    byZoomStatus: BYTE;  //镜头倍数显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    byPtStatus: BYTE;  //方位角显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    byPresetStatus: BYTE;  //预置点标题显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    byPositionDisplayFormat: BYTE;  //方位角显示格式 0-按照PT显示(例 P179|T-02)，1-按照方位显示(SE123|T-02)
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_OSDCFG = ^NET_DVR_PTZ_OSDCFG;

type
  NET_DVR_PTZ_POWEROFFMEMCFG = record 
    dwSize: DWORD;  
    byResumeTimePoint: BYTE;  //掉电记忆模式：Oxff-禁用、1-30秒、2-60秒、3-300秒、4-600秒，默认30秒
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_POWEROFFMEMCFG = ^NET_DVR_PTZ_POWEROFFMEMCFG;

type
  NET_DVR_PTZ_LIMITCOND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byLimitMode: BYTE;  //限位模式 0-保留，1-键控限位，2-扫描限位
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_LIMITCOND = ^NET_DVR_PTZ_LIMITCOND;

type
  NET_DVR_PTZ_LIMITCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //启用使能，0-否，1-是
    byLimitStatus: BYTE;  //限位状态 0-未限位，1-已限位（不可编辑）
    byRes: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_LIMITCFG = ^NET_DVR_PTZ_LIMITCFG;

type
  NET_DVR_PTZ_LIMITCTRL = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byLimitMode: BYTE;  //限位模式 0-保留，1-键控限位，2-扫描限位
    byWorkMode: BYTE;  //0-设置，1-清除
    byRes: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_LIMITCTRL = ^NET_DVR_PTZ_LIMITCTRL;

type
  NET_DVR_PTZ_LOCKCFG = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //云台锁定控制 0-解锁，1-锁定
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_LOCKCFG = ^NET_DVR_PTZ_LOCKCFG;

type
  NET_DVR_PTZLOCKINFO_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PTZLOCKINFO_COND = ^NET_DVR_PTZLOCKINFO_COND;

type
  NET_DVR_PTZLOCKINFO = record 
    dwSize: DWORD;  
    dwRemainingSec: DWORD;  //剩余秒数
    byRes: array[0..128-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PTZLOCKINFO = ^NET_DVR_PTZLOCKINFO;

type
  NET_DVR_CRUISEPOINT_COND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    wRouteNo: WORD;  //巡航路径号
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_CRUISEPOINT_COND = ^NET_DVR_CRUISEPOINT_COND;

type
  NET_DVR_CRUISEPOINT_PARAM = record 
    wPresetNo: WORD;  //预置点
    wDwell: WORD;  //停留时间
    bySpeed: BYTE;  //速度
    bySupport256PresetNo: BYTE;  //兼容之前的 第256号预置点是否生效
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_CRUISEPOINT_PARAM = ^NET_DVR_CRUISEPOINT_PARAM;

type
  NET_DVR_CRUISEPOINT_V40 = record 
    dwSize: DWORD;  
    // 最大支持128个巡航点
    struCruisePoint: array[0..MAX_CRUISE_POINT_NUM-1] of NET_DVR_CRUISEPOINT_PARAM;  
    Res: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_CRUISEPOINT_V40 = ^NET_DVR_CRUISEPOINT_V40;

type
  NET_DVR_CRUISEPOINT_V50 = record 
    dwSize: DWORD;  
    // 最大支持256个巡航点
    struCruisePoint: array[0..MAX_CRUISEPOINT_NUM_V50-1] of NET_DVR_CRUISEPOINT_PARAM;  
    Res: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_CRUISEPOINT_V50 = ^NET_DVR_CRUISEPOINT_V50;


type
  NET_DVR_TEST_VERSION_HEAD = record 
    dwSize: DWORD;  
    dwParam1: DWORD;  
    byParam2: BYTE;  
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_TEST_VERSION_HEAD = ^NET_DVR_TEST_VERSION_HEAD;

type
  NET_DVR_TEST_VERSION_HEAD_V1 = record 
    dwSize: DWORD;  
    dwParam1: DWORD;  
    byParam2: BYTE;  
    byRes: array[0..31-1] of BYTE;  
    dwParam1_1: DWORD;  
    byParam1_2: BYTE;  
    byRes1: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_TEST_VERSION_HEAD_V1 = ^NET_DVR_TEST_VERSION_HEAD_V1;

type
  NET_DVR_TEST_VERSION_HEAD_V2 = record 
    dwSize: DWORD;  
    dwParam1: DWORD;  
    byParam2: BYTE;  
    byRes: array[0..31-1] of BYTE;  
    dwParam1_1: DWORD;  
    byParam1_2: BYTE;  
    byRes1: array[0..31-1] of BYTE;  
    dwParam2_1: DWORD;  
    byParam2_2: BYTE;  
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_TEST_VERSION_HEAD_V2 = ^NET_DVR_TEST_VERSION_HEAD_V2;

const
  MAX_DISPLAY_NUM = 512;    //最大显示输出个数
  MAX_LEDCONTENT_NUM = 512;    //虚拟LED字符串最大长度
  MAX_PPT_CHAN = 128;    //PPT长度

type
  NET_DVR_VIDEOWALLDISPLAYMODE = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    struRect: NET_DVR_RECTCFG_EX;  //坐标范围，依据基准坐标计算出支持的拼控模式
    sName: array[0..NAME_LEN-1] of BYTE;  //电视墙名称
    byRes2: array[0..100-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOWALLDISPLAYMODE = ^NET_DVR_VIDEOWALLDISPLAYMODE;

type
  NET_DVR_DISPLAYPARAM = record 
    dwDisplayNo: DWORD;  //显示输出号
    byDispChanType: BYTE;  {输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI,11-VGA/DVI自适应，12-HDBaseT,13-HDTVI, 14-TVI，0xff-无效}

    byRes: array[0..11-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAYPARAM = ^NET_DVR_DISPLAYPARAM;

type
  NET_DVR_DISPLAYCFG = record 
    dwSize: DWORD;  
    struDisplayParam: array[0..MAX_DISPLAY_NUM{512}-1] of NET_DVR_DISPLAYPARAM;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_DISPLAYCFG = ^NET_DVR_DISPLAYCFG;

type
  NET_DVR_VIDEOWALLDISPLAYPOSITION = record 
    dwSize: DWORD;  
    byEnable: BYTE;  
    byCoordinateType: BYTE;  //坐标类型。0-基准坐标，1-实际坐标
    byRes1: array[0..2-1] of BYTE;  
    //墙号,1字节墙号（高字节，对于合码器设备，为合码通道号）+3字节保留
    dwVideoWallNo: DWORD;  
    dwDisplayNo: DWORD;  //显示输出号
    //坐标须为基准坐标的整数倍（1920*1920），宽度和高度值不用设置，即为基准值
    struRectCfg: NET_DVR_RECTCFG_EX;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOWALLDISPLAYPOSITION = ^NET_DVR_VIDEOWALLDISPLAYPOSITION;

//窗口信息
type
  NET_DVR_VIDEOWALLWINDOWPOSITION = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //窗口使能,0-不使能，1-使能
    byWndOperateMode: BYTE;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    byRes1: array[0..6-1] of BYTE;  
    dwWindowNo: DWORD;  //窗口号
    dwLayerIndex: DWORD;  //窗口相对应的图层号，图层号到最大即置顶，置顶操作
    struRect: NET_DVR_RECTCFG_EX;  //目的窗口统一坐标(相对显示墙)，获取或按统一坐标设置时有效
    struResolution: NET_DVR_RECTCFG_EX;  //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
    dwXCoordinate: DWORD;  //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
    dwYCoordinate: DWORD;  //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
    byRes2: array[0..36-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOWALLWINDOWPOSITION = ^NET_DVR_VIDEOWALLWINDOWPOSITION;

type
  NET_DVR_VIDEO_WALL_INFO = record 
    dwSize: DWORD;  
    //窗口号：1字节墙号（对于合码器设备，为合码通道号）+1字节保留+2字节窗口号
    dwWindowNo: DWORD;  
    dwSceneNo: DWORD;  //场景号
    dwDestWallNo: DWORD;  //目的墙号
    dwDestSceneNo: DWORD;  //目的场景号
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_VIDEO_WALL_INFO = ^NET_DVR_VIDEO_WALL_INFO;

type
  NET_DVR_VIRTUALLED_PARAM = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byDispMode: BYTE;  //显示模式，1-透明，2-半透明，3-覆盖
    byWndOperateMode: BYTE;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    byType: BYTE;  //虚拟LED类型，0-文本，1-时间
    byDirection: BYTE;  //虚拟LED方向，0-水平方向，1-垂直方向
    byTimeType: BYTE;  //时间类型，byType为1时有效，0-无效，1-只显示时间，2-显示日期和时间
    byDateFormat: BYTE;  //日期显示格式，byTimeType为2时有效
    //0-无效，1-XXXX-XX-XX(年月日)，2-XX-XX-XXXX(月日年)，3-XX-XX-XXXX(日月年)，4-XXXX年XX月XX日，5-XX月XX日XXXX年，6-XX日XX月XXXX年
    byTimeFormat: BYTE;  //时间显示格式，byTimeType不为零时有效
    //0-无效，1-H:MM:SS，2-HH:MM:SS
    struContentColor: NET_DVR_RGB_COLOR;  //字体颜色
    struBackColor: NET_DVR_RGB_COLOR;  //背景颜色
    struRect: NET_DVR_RECTCFG_EX;  
    dwContentNum: DWORD;  //文本内容长度，byType为0时有效
    byLedContent: array[0..MAX_LEDCONTENT_NUM{512}-1] of BYTE;  //文本内容，byType为0时有效
    byMoveMode: BYTE;  //移动模式，1-普通；2-平滑；3-静止
    byFontSize: BYTE;  //字体大小，1-1倍，2-2倍，3-4倍
    byMoveDirection: BYTE;  //移动方向，0-默认（从左到右），1-从左到右，2-从右到左，3-从上到下，4-从下到上，动态虚拟LED时有效
    byMoveSpeed: BYTE;  //移动速度，1-速度1，2-速度2，动态虚拟LED时有效
    struResolution: NET_DVR_RECTCFG_EX;  //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
    dwXCoordinate: DWORD;  //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
    dwYCoordinate: DWORD;  //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
    byHourFormat: BYTE;  //时间制式，byTimeType不为零时有效，0-无效，1-12小时制，2-24小时制
    byAMFormat: BYTE;  //AM格式，byHourFormat为1时有效，0-无效，1-AM，2-上午
    byPMFormat: BYTE;  //PM格式，byHourFormat为1时有效，0-无效，1-PM，2-下午
    byAlignmentX: BYTE;  //水平对齐方式，byDirection为0时有效，0-无效，1-左对齐，2-居中对齐，3-右对齐
    byAlignmentY: BYTE;  //垂直对齐方式，byDirection为1时有效，0-无效，1-顶端对齐，2-居中对齐，3-底端对齐
    byFontType: BYTE;  //字体类型，0-默认，1-宋体，2-黑体，3-楷体，255-自定义
    byRes2: array[0..90-1] of BYTE;  
  end;
  LPNET_DVR_VIRTUALLED_PARAM = ^NET_DVR_VIRTUALLED_PARAM;

type
  NET_DVR_IMAGE_CUT_MODE = record 
    dwSize: DWORD;  
    byCutMode: BYTE;  //图像切割模式，1-4:3,2-16:9
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_IMAGE_CUT_MODE = ^NET_DVR_IMAGE_CUT_MODE;

type
  NET_DVR_USING_SERIALPORT = record 
    dwSize: DWORD;  
    dwSerialPort: DWORD;  //当前使用串口号
    byProtocolType: BYTE;  //串口协议类型，1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 ， 4-LCD-DLP， 5-LCD-S3 , 6-LCD-D20，7-LCD-L2,8-LCD-Z1，9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_USING_SERIALPORT = ^NET_DVR_USING_SERIALPORT;

type
  NET_DVR_VIDEOWALLSCENECFG = record 
    dwSize: DWORD;  
    sSceneName: array[0..NAME_LEN-1] of BYTE;  //场景名称
    byEnable: BYTE;  //场景是否有效 1-有效，0-无效
    bySceneIndex: BYTE;  //场景号，只能获取。获取所有场景时使用该参数
    byRes: array[0..78-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOWALLSCENECFG = ^NET_DVR_VIDEOWALLSCENECFG;

type
  NET_DVR_SCENE_CONTROL_INFO = record 
    dwSize: DWORD;  
    struVideoWallInfo: NET_DVR_VIDEO_WALL_INFO;  //电视墙信息
    dwCmd: DWORD;  //场景控制命令，1-场景模式切换（如果要切换的是当前场景，则不进行切换），2-初始化场景（将此场景的配置清空，如果是当前场景，则同时对当前场景进行清屏操作），3-强制切换（无论是否是当前场景，强制切换），4-保存当前模式到某场景 5-删除场景 ,6-场景复制
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_SCENE_CONTROL_INFO = ^NET_DVR_SCENE_CONTROL_INFO;

type
  NET_DVR_SHOW_CONTROL_INFO = record 
    dwSize: DWORD;  
    dwDisplayNo: DWORD;  //显示输出口号，0xffffffff表示对所用输出口进行操作
    byEnable: BYTE;  //使能显示，0-不显示，1-显示
    byChanType: BYTE;  //显示的通道类型，1-显示通道号，2-虚拟屏号
    byRes1: array[0..2-1] of BYTE;  
    dwWallNo: DWORD;  //墙号，1字节墙号（高位）+3字节保留，显示屏幕序号时有效
    byRes2: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_SHOW_CONTROL_INFO = ^NET_DVR_SHOW_CONTROL_INFO;

type
  NET_DVR_BUF_INFO = record 
    pBuf: PVOID;  //缓冲区指针
    nLen: DWORD;  //缓冲区长度
  end;
  LPNET_DVR_BUF_INFO = ^NET_DVR_BUF_INFO;

type
  NET_DVR_IN_PARAM = record 
    struCondBuf: NET_DVR_BUF_INFO;  //条件缓冲区
    struInParamBuf: NET_DVR_BUF_INFO;  //参数缓冲区
    dwRecvTimeout: DWORD;  //接收数据超时时间，单位：ms,置0采用接口默认超时
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_IN_PARAM = ^NET_DVR_IN_PARAM;

type
  NET_DVR_OUT_PARAM = record 
    struOutBuf: NET_DVR_BUF_INFO;  //输出参数缓冲区
    lpStatusList: PVOID;  //状态缓冲区
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OUT_PARAM = ^NET_DVR_OUT_PARAM;

type
  NET_DVR_AUDIO_CHAN_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //音频通道号组合（1字节设备号+1字节子板号+2字节音频通道号）
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_CHAN_INFO = ^NET_DVR_AUDIO_CHAN_INFO;

type
  NET_DVR_AUDIO_CHAN_CFG = record 
    dwSize: DWORD;  
    sChanName: array[0..NAME_LEN-1] of BYTE;  //音频通道名称
    byEnable: BYTE;  //音频是否开启， 0-关， 1-开
    byAudioSwitchType: BYTE;  //音频切换方式，1-按前端源方式，2-按窗口解码源方式
    byRes: array[0..2-1] of BYTE;  
    struAudioSrcInfo: NET_DVR_PU_STREAM_CFG_V41;  //音频源信息 byAudioSwitchType为1时有效
    dwWindowNo: DWORD;  //子窗口号（1字节墙号+1字节子窗口号+2字节窗口号），byAudioSwitchType为2时有效
    byRes2: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_CHAN_CFG = ^NET_DVR_AUDIO_CHAN_CFG;

const
  MAX_SUBBOARD_NUM = 42;    //集中式大屏设备板数目
  MAX_SINGLE_BOARD_EXCEPTION_NUM = 16;    //单板最大并发异常数
type
  NET_DVR_MAINBOARD_SERIAL_CFG = record 
    dwSize: DWORD;  
    bySerialWorkMode: BYTE;  //串口工作模式，1-RS484,2-RS232
    byFunType: BYTE;  //串口功能，1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    byDataBit: BYTE;  // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  // 停止位 0－1位，1－2位;
    dwBaudRate: DWORD;  //波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验;
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控
    wProtocol: WORD;  //串口协议，不同串口功能对应串口协议不一样
    byVariable: BYTE;  //串口是否可变，1-不可变  2-可变 （只获取）
    byGateWayEnable: BYTE;  //是否用于网关，0-不用于网关，!0用于网关
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_MAINBOARD_SERIAL_CFG = ^NET_DVR_MAINBOARD_SERIAL_CFG;

type
  NET_DVR_SUBBOARD_INFO = record 
    dwSize: DWORD;  
    byBoardType: BYTE;  //类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型 //类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型
    byInterfaceNum: BYTE;  //接口数
    byStatus: BYTE;  //状态，0-异常， 1-正常
    bySyncStatus: BYTE;  // 超高清板同步状态，0-未启用同步， 1-启用同步
    dwSlotNo: DWORD;  //所在槽位号
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SUBBOARD_INFO = ^NET_DVR_SUBBOARD_INFO;

type
  NET_DVR_DEVICE_SUBBOARD_INFO = record 
    dwSize: DWORD;  
    byBackBoardType: BYTE;  //背板类型， 1-4U， 2-8U， 3-13U, 0xff-未知类型
    bySoltNum: BYTE;  //槽位数目
    byBoardNum: BYTE;  //有效数目
    byRes1: array[0..1-1] of BYTE;  
    struSubBoadInfo: array[0..MAX_SUBBOARD_NUM-1] of NET_DVR_SUBBOARD_INFO;  //前byBoardNum项有效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_SUBBOARD_INFO = ^NET_DVR_DEVICE_SUBBOARD_INFO;

type
  NET_DVR_DEVICE_BOARD_EXCEPINFO = record 
    dwSize: DWORD;  
    byExceptNum: BYTE;  //异常项数
    byRes1: array[0..3-1] of BYTE;  
    byMajor: array[0..MAX_SINGLE_BOARD_EXCEPTION_NUM-1] of BYTE;  //主类型
    wMinor: array[0..MAX_SINGLE_BOARD_EXCEPTION_NUM-1] of WORD;  //次类型
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_BOARD_EXCEPINFO = ^NET_DVR_DEVICE_BOARD_EXCEPINFO;


type
  NET_DVR_LINEARSCAN = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byLinearScanType: BYTE;  //限位类型，0-保留,1-左边界设置,2-右边界设置
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_LINEARSCAN = ^NET_DVR_LINEARSCAN;

//码流附加信息
type
  NET_DVR_STREAM_ATTACHINFO_CFG = record 
    dwSize: DWORD;  //结构体大小
    byStreamWithVca: BYTE;  //码流中叠加智能信息，可供进行后检索。0-不叠加,1-叠加
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_STREAM_ATTACHINFO_CFG = ^NET_DVR_STREAM_ATTACHINFO_CFG;

type
  NET_DVR_SUBSYSTEM_NETCFG = record 
    dwSize: DWORD;  
    byDefaultRoute: BYTE;  //默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
    byNetworkCardNum: BYTE;  //设备实际可配置的网卡数目
    byRes1: array[0..2-1] of BYTE;  //保留
    struEtherNet: array[0..MAX_NETWORK_CARD-1] of NET_DVR_ETHERNET_MULTI;  //以太网口
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEM_NETCFG = ^NET_DVR_SUBSYSTEM_NETCFG;

//配置清除
type
  NET_DVR_CLEARCTRL = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byAllPreset: BYTE;  //清除所有的预置点：0-否,1-是
    byAllPatrols: BYTE;  //清除所有的巡航路径：0-否,1-是
    byAllPatterms: BYTE;  //清除所有的花样扫描：0-否,1-是
    byAllPrivacyMasks: BYTE;  //清除所有的隐私块：0-否,1-是
    byAllPTZLimited: BYTE;  //清除所有的限位设置：0-否,1-是
    byAllScheduledTasks: BYTE;  //清除所有的定时任务：0-否,1-是
    byAllParkAction: BYTE;  //清除所有的守望：0-否,1-是
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_CLEARCTRL = ^NET_DVR_CLEARCTRL;

//云台优先配置信息
type
  NET_DVR_PTZ_PRIORITIZECFG = record 
    dwSize: DWORD;  
    byPTZPrioritize: BYTE;  //云台优先：0-Rs485，1-网络，默认网络
    byRes: array[0..3-1] of BYTE;  
    dwDelay: DWORD;  //延时：2---200秒
    byRes1: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_PTZ_PRIORITIZECFG = ^NET_DVR_PTZ_PRIORITIZECFG;

//零方位角控制
type
  NET_DVR_INITIALPOSITIONCTRL = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byWorkMode: BYTE;  //0-设置，1-清除
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_INITIALPOSITIONCTRL = ^NET_DVR_INITIALPOSITIONCTRL;

//隐私遮蔽参数
type
  NET_DVR_PRIVACY_MASKS_COND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byRegionalID: BYTE;  //区域ID号 1～24
    //删除当前ID对应的隐私遮蔽信息 0-保留，1-删除 （WriteOnly）
    byDelPrivacyMaskCfg: BYTE;  
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_PRIVACY_MASKS_COND = ^NET_DVR_PRIVACY_MASKS_COND;

type
  NET_DVR_PRIVACY_MASKS_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用 0-否，1-是
    //隐私遮蔽区域配置参数是否显示  0-否，1-是 （ReadOnly）
    byPrivacyMaskCfgEnable: BYTE;  
    byColorType: BYTE;  //0-保留,1-灰、2-红、3-绿、4-蓝、5-橙、6-黄、0xff-马赛克
    byActiveZoomRatio: BYTE;  //屏蔽倍率：1--100
    sPrivacyMaskName: array[0..NAME_LEN{32}-1] of AnsiChar;  //遮挡区域名称，只使用16个字节
    struRegion: NET_VCA_POLYGON;  //区域范围
    //当前区域坐标是否有效 0-否，1-是 （针对单个区域设置区域坐标信息，和单场景下的多区域设置区域坐标信息）
    byCurrentRegionEnable: BYTE;  
    //当前倍率使用字段 0- byActiveZoomRatio ;1- fActiveZoomRatio(支持能力节点curActiveZoomRatioType)
    byCurZoomRatio: BYTE;  
    byRes: array[0..2-1] of BYTE;  
    fActiveZoomRatio: FLOAT;  //屏蔽倍率(精确到小数点1位)：[1.0-100.0]
    byRes1: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_PRIVACY_MASKS_CFG = ^NET_DVR_PRIVACY_MASKS_CFG;

//全局使能
type
  NET_DVR_PRIVACY_MASKS_ENABLECFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //启用使能，0-否，1-是
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_PRIVACY_MASKS_ENABLECFG = ^NET_DVR_PRIVACY_MASKS_ENABLECFG;

//智能运动配置信息
type
  NET_DVR_SMARTTRACKCFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //启动使能 0-否，1-是
    byRes: array[0..3-1] of BYTE;  
    dwDuration: DWORD;  //持续时间：0--300秒，默认300秒
    byRes1: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_SMARTTRACKCFG = ^NET_DVR_SMARTTRACKCFG;

//倍率
type
  NET_DVR_ZOOMRATIOCTRL = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ZOOMRATIOCTRL = ^NET_DVR_ZOOMRATIOCTRL;


//拨码开关信息
type
  NET_DVR_DIAL_SWITCH_CFG = record 
    dwSize: DWORD;  
    dwSwitchState: DWORD;  //拨号开关状态
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_DIAL_SWITCH_CFG = ^NET_DVR_DIAL_SWITCH_CFG;

type
  NET_ALARM_RECORDFILE_LOSS = record //录像丢失报警子结构
    struInspectStart: NET_DVR_TIME_EX;  //巡检开始时间
    struInspectEnd: NET_DVR_TIME_EX;  //巡检结束时间
    struIP: NET_DVR_IPADDR;  //录像丢失对应通道的IP地址
    dwChanNo: DWORD;  //通道号
    dwIDIndex: DWORD;  //编码器ID
    sName: array[0..STREAM_ID_LEN-1] of BYTE;  //编码器名称
    struLossStartTime: NET_DVR_TIME_EX;  //录像丢失开始时间
    struLossEndTime: NET_DVR_TIME_EX;  //录像丢失结束时间
    dwLostNum: DWORD;  //录像丢失个数 0xffffffff表示全部丢失
    byRes: array[0..240-1] of BYTE;  
  end;
  LPNET_ALARM_RECORDFILE_LOSS = ^NET_ALARM_RECORDFILE_LOSS;

type
  NET_ALARM_STREAM_EXCEPTION = record //取流异常报警  子结构
    struIP: NET_DVR_IPADDR;  //发生视频异常通道的IP地址
    dwChanNo: DWORD;  //通道号
    dwIDIndex: DWORD;  //编码器ID
    sName: array[0..STREAM_ID_LEN-1] of BYTE;  //编码器名称
    byExceptionCase: BYTE;  //异常原因，0-数据写入异常 1-网络接收异常
    byRes: array[0..307-1] of BYTE;  //保留
  end;
  LPNET_ALARM_STREAM_EXCEPTION = ^NET_ALARM_STREAM_EXCEPTION;


type
  NET_ALARM_RESOURCE_USAGE = record //资源使用报警 子结构
    byLevel: BYTE;  //使用情况，严重程度递增： 0-正常，1-一级告警上限 2-二级告警上限 3-三级告警上限
    byRes: array[0..491-1] of BYTE;  //保留
  end;
  LPNET_ALARM_RESOURCE_USAGE = ^NET_ALARM_RESOURCE_USAGE;

type
  NET_ALARM_RECORD_EXCEPTION = record //录像异常报警 子结构
    byReason: BYTE;  //异常原因 0-录像卷满 1-录像卷异常 2-无可用lun卷
    byRes1: array[0..3-1] of BYTE;  //保留
    sVolumeName: array[0..MAX_VOLUMENAME_LEN-1] of BYTE;  
    dwVolumeID: DWORD;  //录像卷ID（硬盘号）
    byRes: array[0..452-1] of BYTE;  //保留
  end;
  LPNET_ALARM_RECORD_EXCEPTION = ^NET_ALARM_RECORD_EXCEPTION;

type
  NET_ALARM_CVR_SUBINFO_UNION = record 
    case Byte of//CVR报警子结构
    0: (byLen: array[0..492-1] of BYTE);  //联合体长度
    1: (struRecordLost: NET_ALARM_RECORDFILE_LOSS);  //录像丢失
    2: (struStreamException: NET_ALARM_STREAM_EXCEPTION);  //取流异常
    3: (struResourceUsage: NET_ALARM_RESOURCE_USAGE);  //资源使用
    4: (struRecordException: NET_ALARM_RECORD_EXCEPTION);  //录像异常
  end;
  LPNET_ALARM_CVR_SUBINFO_UNION = ^NET_ALARM_CVR_SUBINFO_UNION;

const
  MAX_VARIABLE_DATA_NUM = 65535;    //最大可变数据个数

type
  NET_DVR_ALARMINFO_DEV_V40 = record 
    dwAlarmType: DWORD;  //报警子类型 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；6-编码器(通道)移动侦测报警；
    //7-编码器(通道)遮挡报警; 8-录像丢失报警; 9-视频实时显示报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    struTime: NET_DVR_TIME;  
    uSubAlarmInfo: NET_ALARM_CVR_SUBINFO_UNION;  //报警信息子结构 报警类型为8,9,10,11,12时该联合体有效
    byRes: array[0..256-1] of BYTE;  
    dwNumber: DWORD;  //可变数据个数
    pNO: PWORD;  //当类型为0、3、6、7时，可能会有通道号；当类型为5时，可能会有磁盘号。可表示的值范围为0~65535
  end;
  LPNET_DVR_ALARMINFO_DEV_V40 = ^NET_DVR_ALARMINFO_DEV_V40;

type
  NET_DVR_CONTROL_START_CFG = record //一键开始控制信息
    byUseDefine: BYTE;  //使用自定义， 0-使用默认，1-使用自定义
    byRes1: BYTE;  
    wCourseIndex: WORD;  //课程索引
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CONTROL_START_CFG = ^NET_DVR_CONTROL_START_CFG;

type
  NET_DVR_CONTROL_DELAY_CFG = record //一键延长录像控制信息
    byUseDefine: BYTE;  //使用自定义， 0-使用默认，1-使用自定义
    byRes1: BYTE;  
    wDelayTime: WORD;  //录像延长时间<继续录像时间以此为准>，单位s
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CONTROL_DELAY_CFG = ^NET_DVR_CONTROL_DELAY_CFG;

type
  NET_DVR_CONTROL_INFO_UNION = record 
    case Byte of//控制信息联合体
    0: (byLen: array[0..132-1] of BYTE);  //联合体长度
    1: (struStartCfg: NET_DVR_CONTROL_START_CFG);  //一键开始
    2: (struDelayCfg: NET_DVR_CONTROL_DELAY_CFG);  //一键延迟
  end;
  LPNET_DVR_CONTROL_INFO_UNION = ^NET_DVR_CONTROL_INFO_UNION;

type
  NET_DVR_RECORDING_CONTROL_CFG = record 
    dwSize: DWORD;  //结构体大小
    wCmdType: WORD;  //控制命令类型，0-一键开始，1-一键结束，2-一键暂停，3-一键恢复，4-一键延长,5-一键开始屏蔽 6-一键停止屏蔽
    byRes1: array[0..2-1] of BYTE;  //保留
    struControlInfo: NET_DVR_CONTROL_INFO_UNION;  //控制信息，具体使用结合控制命令类型
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORDING_CONTROL_CFG = ^NET_DVR_RECORDING_CONTROL_CFG;

type
  NET_DVR_RECORDING_HOST_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwOneKeyDelayTime: DWORD;  //一键本地延迟时间  录像继续录的时间 单位 S
    byDirectedMode: BYTE;  //导播模式，0-自动导播，1手动导播，2-半自动导播
    byClassroomType: BYTE;  //教室类型，0-无效，1-主教室，2-从教室
    byCourseDataStorageEnabled: BYTE;  //课堂数据统计是否存储在硬盘, 0-不存储，1-存储
    byElectronicEnlargeMode: BYTE;  //是否使用电子放大导播, 0-不使用，1-使用
    byRes: array[0..124-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORDING_HOST_CFG = ^NET_DVR_RECORDING_HOST_CFG;

type
  NET_DVR_STATISTIC_DATA_COND = record 
    dwSize: DWORD;  
    dwTypeTarget: DWORD;  //统计对象类型，详见TARGET_TYPE
    struStartTime: NET_DVR_TIME;  //开始统计时间
    struStopTime: NET_DVR_TIME;  //结束统计时间
    byRes: array[0..280-1] of BYTE;  
  end;
  LPNET_DVR_STATISTIC_DATA_COND = ^NET_DVR_STATISTIC_DATA_COND;

type
  NET_DVR_STATISTIC_DATA_CFG = record 
    dwSize: DWORD;  
    dwTypeTarget: DWORD;  //统计对象类型，详见TARGET_TYPE
    struStartTime: NET_DVR_TIME;  //事件开始时间
    struStopTime: NET_DVR_TIME;  //事件结束时间
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_STATISTIC_DATA_CFG = ^NET_DVR_STATISTIC_DATA_CFG;

//typedef enum
//<
//    NET_SDK_ALL_TARGET = 0,          //统计所有对象
//    NET_SDK_PPT_TARGET_ALARM,     //PPT报警
//    NET_SDK_PPT_TARGET_VIEW,       //PPT视图
//    NET_SDK_STU_SINGLE_ALARM,     //单个学生报警
//    NET_SDK_STU_SINGLE_VIEW,       //单个学生视图
//    NET_SDK_SUT_MULT_ALARM,       //多个学生报警
//    NET_SDK_STU_MULT_VIEW,         //多个学生视图
//    NET_SDK_STU_TEACHER_VIEW,     //师生互动视图
//    NET_SDK_TEA_UP_DOWN_ALARM,  //教师上下讲台
//    NET_SDK_TEA_START_VIEW,        //教师授课视图
//    NET_SDK_BLA_WRITE_ALARM,      //书写板书报警
//    NET_SDK_BLA_WRITE_VIEW,       //书写板书视图
//    NET_SDK_TEA_FULL_VIEW,         //教师全景视图
//    NET_SDK_TEA_START_ALARM,      //教师开始授课报警
//    NET_SDK_TEA_WALK_ALARM,      //教师走动报警
//    NET_SDK_TEA_LEFT_ALARM,       //教师离开报警
//    NET_SDK_TEA_RUN_ALARM,        //教师奔跑报警
//    NET_SDK_TEA_MULT_ALARM       //教师多人报警
//>TARGET_TYPE;

type
  NET_DVR_AUTO_TRACK_CFG = record 
    dwSize: DWORD;  //结构体大小
    struSDIInfo: array[0..MAX_CHANNUM_V30-1] of NET_DVR_DIRECT_CONNECT_CHAN_INFO;  
    //SDI通道，设备端实际的流返回形式是模拟通道，而控制前端使用IP通道。
    byCameraType: array[0..MAX_CHANNUM_V30-1] of BYTE;  //通道接入的相机类型，值为 0-无意义，1-老师聚焦，2-学生聚焦，3-老师全景，4-学生全景，5-多媒体，6-教师定位,7-学生定位,8-板书定位,9-板书相机, 0xff-未接入
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_AUTO_TRACK_CFG = ^NET_DVR_AUTO_TRACK_CFG;

type
  NET_DVR_PUBLISH_FTP_CFG = record 
    byProtocolType: BYTE;  //协议类型 0-FTP，1-SFTP
    byRes1: BYTE;  //保留
    wFTPPort: WORD;  //端口
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    szUserName: array[0..NAME_LEN{32}-1] of BYTE;  //用户名<加密>
    szPassWord: array[0..PASSWD_LEN{16}-1] of BYTE;  //密码<加密>
    szCustomDir: array[0..128-1] of BYTE;  //发布目录,支持目录结构
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_DVR_PUBLISH_FTP_CFG = ^NET_DVR_PUBLISH_FTP_CFG;

type
  NET_DVR_PUBLISH_HTTP_CFG = record 
    strUrl: array[0..256-1] of BYTE;  //发布的URL地址信息
  end;
  LPNET_DVR_PUBLISH_HTTP_CFG = ^NET_DVR_PUBLISH_HTTP_CFG;

type
  NET_DVR_PUBLISH_FTP_CFG_DIR = record 
    byProtocolType: BYTE;  //协议类型 0-FTP，1-SFTP
    byRes1: BYTE;  //保留
    wFTPPort: WORD;  //端口
    byAddress: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    szUserName: array[0..NAME_LEN{32}-1] of BYTE;  //用户名<加密>
    szPassWord: array[0..PASSWD_LEN{16}-1] of BYTE;  //密码<加密>
    byDirLevel: BYTE;  //0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录
    byTopDirMode: BYTE;  // 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址                     0xff=使用自定义
    bySubDirMode: BYTE;  //二级目录，0x1=使用通道名称,0x2=使用通道号，0x3=使用课程名称，0x4-使用授课日期，0xff-使用自定义
    byRes2: BYTE;  
    byTopCustomDir: array[0..MAX_CUSTOMDIR_LEN{32}-1] of BYTE;  //自定义一级目录
    bySubCustomDir: array[0..MAX_CUSTOMDIR_LEN{32}-1] of BYTE;  //自定义二级目录
    byRes: array[0..72-1] of BYTE;  //保留
  end;
  LPNET_DVR_PUBLISH_FTP_CFG_DIR = ^NET_DVR_PUBLISH_FTP_CFG_DIR;


type
  NET_DVR_PUBLISH_ADD_UNION = record 
    case Byte of
    0: (byLen: array[0..256-1] of BYTE);  //联合体长度
    1: (struHttpCfg: NET_DVR_PUBLISH_HTTP_CFG);  //http地址信息
    2: (struFtpCfg: NET_DVR_PUBLISH_FTP_CFG);  //ftp地址信息
    3: (struDirFtpCfg: NET_DVR_PUBLISH_FTP_CFG_DIR);  //按目录方式的FTP
  end;
  LPNET_DVR_PUBLISH_ADD_UNION = ^NET_DVR_PUBLISH_ADD_UNION;

type
  NET_DVR_RECORD_PUBLISH_INFO = record //通道录像发布信息
    byPublish: BYTE;  //是否发布，0-不发布， 1-发布
    byRes1: array[0..3-1] of BYTE;  
    dwStreamType: DWORD;  //一键发布码流类型，按位表示
    //&0x1-表示主码流
    //&0x2-表示子码流
    //&0x4-表示码流三
    byRes: array[0..12-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PUBLISH_INFO = ^NET_DVR_RECORD_PUBLISH_INFO;


type
  NET_DVR_PUBLISH_CFG = record 
    dwSize: DWORD;  //结构体大小
    byPublishType: BYTE;  //发布方式，0-http,1-ftp,2-Dir FTP
    byRes1: array[0..3-1] of BYTE;  //保留
    struPublishAddr: NET_DVR_PUBLISH_ADD_UNION;  //一键发布地址信息
    struChanPublish: array[0..MAX_CHANNUM_V30-1] of NET_DVR_RECORD_PUBLISH_INFO;  //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    struDirectChanPublish: NET_DVR_RECORD_PUBLISH_INFO;  //导播通道录像发布信息
    byUploadTime: BYTE;  //是否启动定时ftp上传功能 0-无意义，1-不启动，2-启用
    byTimerMode: BYTE;  //0-无意义，1-按课表定时上传最近一节课的录像，2-按时间点方式上传前24小时录像
    byUploadStartHour: BYTE;  //按时间定时上传起始时间  时
    byUoploadStartMin: BYTE;  //按时间定时上传 开始时间 分
    byRes: array[0..1020-1] of BYTE;  //保留
  end;
  LPNET_DVR_PUBLISH_CFG = ^NET_DVR_PUBLISH_CFG;

type
  NET_DVR_ONEKEY_PUBLISH_CFG = record 
    dwSize: DWORD;  //结构体大小
    byUseDefine: BYTE;  //使用自定义  0-使用默认发布配置信息，1-使用自定义发布配置信息
    byRes1: array[0..3-1] of BYTE;  
    struChanPublish: array[0..MAX_CHANNUM_V30-1] of NET_DVR_RECORD_PUBLISH_INFO;  //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    struDirectChanPublish: NET_DVR_RECORD_PUBLISH_INFO;  //导播通道录像发布信息
    struStartTime: NET_DVR_TIME_EX;  //课程开始时间
    struEndTime: NET_DVR_TIME_EX;  //课程结束时间
    bySchedulePublish: BYTE;  //是否按课表发布，0不按课表发布1按课表发布
    sFileName: array[0..COURSE_NAME_LEN{32}-1] of BYTE;  //发布文件名称
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_ONEKEY_PUBLISH_CFG = ^NET_DVR_ONEKEY_PUBLISH_CFG;

type
  NET_DVR_COURSE_RECORDING_INFO = record 
    dwSize: DWORD;  
    sCourseName: array[0..COURSE_NAME_LEN{32}-1] of AnsiChar;  
    sInstructorName: array[0..INSTRUCTOR_NAME_LEN{16}-1] of AnsiChar;  
    sCourseDescription: array[0..COURSE_DESCRIPTION_LEN{256}-1] of AnsiChar;  
    byIndex: BYTE;  //课程索引
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_COURSE_RECORDING_INFO = ^NET_DVR_COURSE_RECORDING_INFO;

type
  NET_DVR_EACH_LESSON_INFO = record 
    struSchedTime: NET_DVR_SCHEDTIME;  //课程起止时间
    wCourseIndex: WORD;  //课程索引
    wSessionIndex: WORD;  //节次
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_EACH_LESSON_INFO = ^NET_DVR_EACH_LESSON_INFO;
// 流录像状态
type
  NET_DVR_CURRICULUM_CFG = record //课表计划 按年月日配置
    dwSize: DWORD;  //结构体大小
    struLessonInfo: array[0..MAX_TIMESEGMENT_V40{16}-1] of NET_DVR_EACH_LESSON_INFO;  //每节课信息
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_CURRICULUM_CFG = ^NET_DVR_CURRICULUM_CFG;

type
  NET_DVR_DATE = record 
    wYear: WORD;  //年
    byMonth: BYTE;  //月
    byDay: BYTE;  //日
  end;
  LPNET_DVR_DATE = ^NET_DVR_DATE;

type
  NET_DVR_PPT_DETECT_CFG = record 
    dwSize: DWORD;  
    byEnablePPTDetect: BYTE;  //是否启用PPT检测
    byPptDetLevel: BYTE;  //灵敏度
    byEnablePartScreen: BYTE;  //是否配置部分区域
    byRes1: BYTE;  
    wX: WORD;  //区域坐标
    wY: WORD;  
    wWidth: WORD;  
    wHeight: WORD;  
    dwChangePixelNum: DWORD;  //像素点检测阈值[0,1000](ps : 一幅图像有多少像素在变化)
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_PPT_DETECT_CFG = ^NET_DVR_PPT_DETECT_CFG;

type
  NET_DVR_SCREEN_SWITCH = record 
    dwSize: DWORD;  
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCREEN_SWITCH = ^NET_DVR_SCREEN_SWITCH;

type
  NET_DVR_PPT_CHANNEL_CFG = record 
    dwSize: DWORD;  
    byChan: array[0..MAX_PPT_CHAN-1] of BYTE;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PPT_CHANNEL_CFG = ^NET_DVR_PPT_CHANNEL_CFG;

type
  NET_DVR_BACKUP_RECORD_INFO = record 
    byEnable: BYTE;  //是否启用
    byRes: array[0..11-1] of BYTE;  
    //备份码流类型，按位表示
    //&0x1-表示主码流
    //&0x2-表示子码流
    //&0x4-表示码流三
    dwStreamType: DWORD;  
  end;
  LPNET_DVR_BACKUP_RECORD_INFO = ^NET_DVR_BACKUP_RECORD_INFO;

type
  NET_DVR_BACKUP_RECORD_PARAM = record 
    dwSize: DWORD;  
    struChanBackUp: array[0..MAX_CHANNUM_V30{64}-1] of NET_DVR_BACKUP_RECORD_INFO;  //需要备份的通道,数组下标对应相应的通道号
    struDirectedChanBackUp: NET_DVR_BACKUP_RECORD_INFO;  //导播通道备份信息
    byRes: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_BACKUP_RECORD_PARAM = ^NET_DVR_BACKUP_RECORD_PARAM;

//室内机编号
type
  NET_DVR_INDOOR_UNIT_DEVICEID = record 
    wFloorNumber: SHORT;  //层号
    wRoomNumber: WORD;  //房间号
    wDevIndex: WORD;  //室内机编号，0-10
    byRes: array[0..122-1] of BYTE;  //保留
  end;
  LPNET_DVR_INDOOR_UNIT_DEVICEID = ^NET_DVR_INDOOR_UNIT_DEVICEID;

//门口机编号
type
  NET_DVR_OUTDOOR_UNIT_DEVICEID = record 
    wPeriod: WORD;  //期号, 范围[0,9]
    wBuildingNumber: WORD;  //楼号
    wUnitNumber: WORD;  //单元号
    wFloorNumber: SHORT;  //层号
    wDevIndex: WORD;  //门口机序号，每一层中门口机的序号唯一，从0开始
    byRes: array[0..118-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTDOOR_UNIT_DEVICEID = ^NET_DVR_OUTDOOR_UNIT_DEVICEID;

//围墙机编号
type
  NET_DVR_OUTDOOR_FENCE_DEVICEID = record 
    wPeriod: WORD;  //期号, 范围[0,9]
    wDevIndex: WORD;  //围墙机序号，每一层中门口机的序号唯一，从0开始
    byRes: array[0..124-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTDOOR_FENCE_DEVICEID = ^NET_DVR_OUTDOOR_FENCE_DEVICEID;

//管理机编号
type
  NET_DVR_MANAGE_UNIT_DEVICEID = record 
    wPeriod: WORD;  //期号，范围[0,9]
    wDevIndex: WORD;  //管理机序号，每一期中管理机的序号唯一,从0开始
    byRes: array[0..124-1] of BYTE;  //保留
  end;
  LPNET_DVR_MANAGE_UNIT_DEVICEID = ^NET_DVR_MANAGE_UNIT_DEVICEID;

//可视对讲设备编号联合体
type
  NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION = record 
    case Byte of
    0: (byLen: array[0..128-1] of BYTE);  //联合体大小
    1: (struIndoorUnit: NET_DVR_INDOOR_UNIT_DEVICEID);  //室内机
    2: (struOutdoorUnit: NET_DVR_OUTDOOR_UNIT_DEVICEID);  //门口机/门禁智能设备
    3: (struManageUnit: NET_DVR_MANAGE_UNIT_DEVICEID);  //管理机
    4: (struFenceUnit: NET_DVR_OUTDOOR_FENCE_DEVICEID);  //围墙机
    5: (struVillaOutdoorUnit: NET_DVR_OUTDOOR_UNIT_DEVICEID);  //别墅门口机
    6: (struAgainConfirmUnit: NET_DVR_OUTDOOR_UNIT_DEVICEID);  //二次确认机
  end;
  LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION = ^NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;

//设备编号参数结构体
type
  NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG = record 
    dwSize: DWORD;  //结构体大小
    byUnitType: BYTE;  //设备类型，1-门口机，2-管理机 4-围墙机,5-别墅门口机，6-二次确认机，7-门禁智能设备,8-4200客户端, 9-APP,10-交互终端，11-IPC设备，12-解码器设备,13-模拟室内机
    byIsAutoReg: BYTE;  //是否自动注册，0-否，1-是
    byRes1: array[0..2-1] of BYTE;  //保留
    uVideoIntercomUnit: NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;  //取值参考byUnitType
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG = ^NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;

//权限密码类型
type
  PRIVILEGE_PASSWORD_TYPE_ENUM =  
  (  
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1,  //工程密码
    ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2,  //布/撤防密码
    ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK = 3,  //户主开锁密码
    ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING = 4,  //防劫持密码
    ENUM_PRIVILEGE_PASSWORD_PUBLIC1 = 5,  //公共密码1
    ENUM_PRIVILEGE_PASSWORD_PUBLIC2 = 6,  //公共密码2
    ENUM_PRIVILEGE_PASSWORD_PUBLIC3 = 7,  //公共密码3
    ENUM_PRIVILEGE_PASSWORD_SENDCARD = 8  //发卡密码
  );

//权限密码信息
type
  NET_DVR_PRIVILEGE_PASSWORD_CFG = record 
    dwSize: DWORD;  //结构体大小
    byPwdType: BYTE;  //密码类型，参考PRIVILEGE_PASSWORD_TYPE_ENUM
    byRes1: array[0..3-1] of BYTE;  //保留
    byOldPassword: array[0..PASSWD_LEN-1] of BYTE;  //旧密码
    byNewPassword: array[0..PASSWD_LEN-1] of BYTE;  //新密码
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_PRIVILEGE_PASSWORD_CFG = ^NET_DVR_PRIVILEGE_PASSWORD_CFG;


//室内机操作时间配置
type
  NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG = record 
    dwMaxMonitoringTime: DWORD;  //最大显示时间，范围[10,60]秒
    dwMaxRingTime: DWORD;  //最大振铃时间，范围[15,60]秒
    dwCallForwardingTime: DWORD;  //呼叫转移超时时间，范围[0,20]秒
    dwRingDurationTime: DWORD;  //响铃超时时间，范围[30,60]秒，默认30秒
    byRes: array[0..112-1] of BYTE;  //保留
  end;
  LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG = ^NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

//室外机操作时间配置
type
  NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG = record 
    dwMaxMessageTime: DWORD;  //最大留言时间，范围[30,60]秒
    dwMaxTalkTime: DWORD;  //最大通话时间，范围[90,120]秒
    byRes: array[0..120-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG = ^NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;

//管理机操作时间配置
type
  NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG = record 
    dwMaxMonitoringTime: DWORD;  //最大显示时间，范围[10,60]秒
    dwMaxRingTime: DWORD;  //最大振铃时间，范围[15,60]秒
    dwMaxTalkTime: DWORD;  //最大通话时间，单位s
    byRes: array[0..116-1] of BYTE;  //保留
  end;
  LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG = ^NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;

//可视对讲操作时间联合体
type
  NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION = record 
    case Byte of
    0: (byLen: array[0..128-1] of BYTE);  //联合体大小
    1: (struIndoorUnit: NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG);  //室内机
    2: (struOutdoorUnit: NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG);  //门口机/围墙机/别墅门口机/二次确认机
    3: (struManageUnit: NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG);  //管理机
  end;
  LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION = ^NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;

//可视对讲操作时间配置
type
  NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG = record 
    dwSize: DWORD;  //结构体大小
    byUnitType: BYTE;  //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机
    byRes1: array[0..3-1] of BYTE;  //保留
    uVideoIntercomUnit: NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;  //取值参考byUnitType
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG = ^NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;

//室内机关联的网络设备
type
  NET_DVR_INDOOR_UNIT_RELATEDEV = record 
    struOutdoorUnit: NET_DVR_IPADDR;  //主门口机IP
    struManageUnit: NET_DVR_IPADDR;  //管理机IP
    struSIPServer: NET_DVR_IPADDR;  //SIP服务器IP
    struAgainUnit: NET_DVR_IPADDR;  //二次确认机IP
    byOutDoorType: BYTE;  //主门口机类型，0保留，1-主单元门口机，2-主别墅门口机
    byOutInConnectMode: BYTE;  //门口机与室内分机组网模式：1-门口机与室内分机同一局域网,2-门口机与室内分机不同局域网；
    byIndoorConnectMode: BYTE;  //室内主机与室内分机组网模式：1-通过无线网卡、2-通过有线网卡；
    byRes1: BYTE;  
    struIndoorUnit: NET_DVR_IPADDR;  //室内主机IP
    byManageCenterID: array[0..32-1] of BYTE;  //标准sip模式下使用，管理中心ID，支持数字，字母，@和.
    byRes: array[0..268-1] of BYTE;  //保留
  end;
  LPNET_DVR_INDOOR_UNIT_RELATEDEV = ^NET_DVR_INDOOR_UNIT_RELATEDEV;

//门口机相关联的网络设备
type
  NET_DVR_OUTDOOR_UNIT_RELATEDEV = record 
    struMainOutdoorUnit: NET_DVR_IPADDR;  //主门口机IP，副门口机时有效
    struManageUnit: NET_DVR_IPADDR;  //管理机IP
    struSIPServer: NET_DVR_IPADDR;  //SIP服务器IP，副门口机时无效
    byManageCenterID: array[0..32-1] of BYTE;  //标准sip模式下使用，管理中心ID，支持数字，字母，@和.
    byRes: array[0..560-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTDOOR_UNIT_RELATEDEV = ^NET_DVR_OUTDOOR_UNIT_RELATEDEV;

//二次确认机相关联的网络设备
type
  NET_DVR_AGAIN_RELATEDEV = record 
    struSIPServer: NET_DVR_IPADDR;  //SIP服务器IP
    struCenterAddr: NET_DVR_IPADDR;  //中心平台IP
    wCenterPort: WORD;  //中心平台端口
    byRes1: array[0..2-1] of BYTE;  
    struIndoorUnit: NET_DVR_IPADDR;  //室内主机IP
    struAgainAddr: NET_DVR_IPADDR;  //主二次确认机IP（副二次确认机配置该字段）
    byRes: array[0..444-1] of BYTE;  //保留
  end;
  LPNET_DVR_AGAIN_RELATEDEV = ^NET_DVR_AGAIN_RELATEDEV;


//管理机相关联的网络设备
type
  NET_DVR_MANAGE_UNIT_RELATEDEV = record 
    struSIPServer: NET_DVR_IPADDR;  //SIP服务器IP
    byRes: array[0..880-1] of BYTE;  //保留
  end;
  LPNET_DVR_MANAGE_UNIT_RELATEDEV = ^NET_DVR_MANAGE_UNIT_RELATEDEV;


//可视对讲关联网络设备参数结构体
type
  NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION = record 
    case Byte of
    0: (dwRes: array[0..256-1] of DWORD);  //联合体大小
    1: (struIndoorUnit: NET_DVR_INDOOR_UNIT_RELATEDEV);  //室内机
    2: (struMainOutdoorUnit: NET_DVR_OUTDOOR_UNIT_RELATEDEV);  //门口机/围墙机/门禁智能设备
    3: (struManageUnit: NET_DVR_MANAGE_UNIT_RELATEDEV);  //管理机
    4: (struVillaUnit: NET_DVR_OUTDOOR_UNIT_RELATEDEV);  //别墅门口机
    5: (struAgainUnit: NET_DVR_AGAIN_RELATEDEV);  //二次确认机
  end;
  LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION = ^NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;

//关联网络设备参数结构体
type
  NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG = record 
    dwSize: DWORD;  //结构体大小
    byUnitType: BYTE;  //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-门禁智能设备
    byRes1: array[0..3-1] of BYTE;  //保留
    uVideoIntercomUnit: NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;  //取值参考byUnitType
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG = ^NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

type
  NET_DVR_CONTROL_GATEWAY = record 
    dwSize: DWORD;  //结构体大小
    dwGatewayIndex: DWORD;  //门禁序号，从1开始
    byCommand: BYTE;  //操作命令，0-关闭，1-打开，2-常开（通道状态），3-恢复（普通状态）
    byLockType: BYTE;  //锁类型，0-普通（以前默认都为0）,1-智能锁
    wLockID: WORD;  //锁ID，从1开始（远程开门口机锁时，0表示门口机本机控制器上接的锁、1表示外接控制器上接的锁）
    byControlSrc: array[0..NAME_LEN-1] of BYTE;  //操作发起源信息
    byControlType: BYTE;  //开锁类型，1-显示，2-通话
    byRes3: array[0..3-1] of BYTE;  
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  //锁密码，当byLockType为智能锁时有效
    byRes2: array[0..108-1] of BYTE;  //保留
  end;
  LPNET_DVR_CONTROL_GATEWAY = ^NET_DVR_CONTROL_GATEWAY;


//公告图片信息结构体
type
  NET_DVR_NOTICE_PIC = record 
    pPicData: PBYTE;  //图片指针
    dwPicDataLen: DWORD;  //图片数据长度
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_NOTICE_PIC = ^NET_DVR_NOTICE_PIC;

//公告数据
type
  NET_DVR_NOTICE_DATA = record 
    dwSize: DWORD;  //结构体大小
    struTime: NET_DVR_TIME_EX;  //公告时间
    byNoticeNumber: array[0..MAX_NOTICE_NUMBER_LEN-1] of BYTE;  //公告编号
    byNoticeTheme: array[0..MAX_NOTICE_THEME_LEN-1] of BYTE;  //公告主题
    byNoticeDetail: array[0..MAX_NOTICE_DETAIL_LEN-1] of BYTE;  //公告详情
    byLevel: BYTE;  //公告等级，1-广告类信息；2-物业信息；3-报警类信息;4-通知类信息
    byPicNum: BYTE;  //公告图片数量
    byRes1: array[0..2-1] of BYTE;  //保留
    struNoticePic: array[0..MAX_NOTICE_PIC_NUM-1] of NET_DVR_NOTICE_PIC;  //公告图片
    byRes2: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_NOTICE_DATA = ^NET_DVR_NOTICE_DATA;

//操作权限验证参数
type
  NET_DVR_OPERATION_AUTH = record 
    dwSize: DWORD;  //结构体大小
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  //验证密码
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_OPERATION_AUTH = ^NET_DVR_OPERATION_AUTH;

//开锁类型
type
  UNLOCK_TYPE_ENUM =  
  (  
    ENUM_UNLOCK_PASSWORD = 1,  //密码开锁
    ENUM_UNLOCK_HIJACKING = 2,  //劫持开锁
    ENUM_UNLOCK_CARD = 3,  //刷卡开锁
    ENUM_UNLOCK_HOUSEHOLDER = 4,  //户主开锁
    ENUM_UNLOCK_CENTER_PLATFORM = 5,  //中心平台开锁
    ENUM_UNLOCK_BLUETOOTH = 6,  //蓝牙开锁
    ENUM_UNLOCK_QR_CODE = 7,  //二维码开锁
    ENUM_UNLOCK_FACE = 8,  //人脸开锁
    ENUM_UNLOCK_FINGERPRINT = 9,  //指纹开锁
    ENUM_UNLOCK_DYNAMIC_CODE = 10  //动态权限码开锁
  );


//防区类型，和产品线确认，此定义没有使用，使用的是DETECTOR_TYPE
// typedef enum tagALARM_ZONE_TYPE_ENUM
// <
//     ENUM_ALARM_ZONE_SMOKE = 1, //烟感
//         ENUM_ALARM_ZONE_GAS  = 2,  //煤气
//         ENUM_ALARM_ZONE_INFRARED = 3, //红外
//         ENUM_ALARM_ZONE_MAGNETIC  = 4, //门磁
//         ENUM_ALARM_ZONE_MANUAL = 5 //手动
// >ALARM_ZONE_TYPE_ENUM;

//开锁记录
type
  NET_DVR_UNLOCK_RECORD_INFO = record 
    byUnlockType: BYTE;  //开锁方式，参考UNLOCK_TYPE_ENUM
    byRes1: array[0..3-1] of BYTE;  //保留
    byControlSrc: array[0..NAME_LEN-1] of BYTE;  //操作发起源信息，刷卡开锁时为卡号，蓝牙开锁时为萤石的APP账号，二维码开锁时为访客的手机号，其余情况下为设备编号
    dwPicDataLen: DWORD;  //图片数据长度
    pImage: PBYTE;  //图片指针
    dwCardUserID: DWORD;  //持卡人ID
    nFloorNumber: SHORT;  //刷卡开锁时有效，为楼层号
    wRoomNumber: WORD;  //操作发起源附加信息，刷卡开锁时有效，为房间号，
    wLockID: WORD;  //（对于门口机，0-表示本机控制器上接的锁、1-表示外接控制器上接的锁）
    byRes2: array[0..2-1] of BYTE;  
    byLockName: array[0..LOCK_NAME_LEN-1] of BYTE;  //刷卡开锁时有效，锁名称，对应门参数配置中门名称
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byMask: BYTE;  //是否带口罩：0-保留，1-未知，2-未戴口罩，3-戴口罩
    byRes: array[0..135-1] of BYTE;  //保留
  end;
  LPNET_DVR_UNLOCK_RECORD_INFO = ^NET_DVR_UNLOCK_RECORD_INFO;

//公告信息阅读回执
type
  NET_DVR_NOTICEDATA_RECEIPT_INFO = record 
    byNoticeNumber: array[0..MAX_NOTICE_NUMBER_LEN-1] of BYTE;  //公告编号
    byRes: array[0..224-1] of BYTE;  //保留
  end;
  LPNET_DVR_NOTICEDATA_RECEIPT_INFO = ^NET_DVR_NOTICEDATA_RECEIPT_INFO;

//认证记录（设备未实现）
type
  NET_DVR_AUTH_INFO = record 
    byAuthResult: BYTE;  //认证结果：0-无效，1-认证成功，2-认证失败
    byAuthType: BYTE;  //认证方式：0-无效，1-指纹，2-人脸
    byRes1: array[0..2-1] of BYTE;  //保留
    byCardNo: array[0..ACS_CARD_NO_LEN{32}-1] of BYTE;  //卡号
    dwPicDataLen: DWORD;  //图片数据长度（当认证方式byAuthType为人脸时有效）
    pImage: PBYTE;  //图片指针（当认证方式byAuthType为人脸时有效）
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN{32}-1] of BYTE;  //工号（人员ID
    byRes: array[0..180-1] of BYTE;  //保留
  end;
  LPNET_DVR_AUTH_INFO = ^NET_DVR_AUTH_INFO;

//车牌信息上传
type
  NET_DVR_UPLOAD_PLATE_INFO = record 
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码
    byColor: BYTE;  //车牌颜色，参考结构VCA_PLATE_COLOR
    byRes: array[0..239-1] of BYTE;  //保留
  end;
  LPNET_DVR_UPLOAD_PLATE_INFO = ^NET_DVR_UPLOAD_PLATE_INFO;

type
  NET_DVR_SEND_CARD_INFO = record 
    byCardNo: array[0..ACS_CARD_NO_LEN{32}-1] of BYTE;  //卡号
    byRes: array[0..224-1] of BYTE;  //保留
  end;
  LPNET_DVR_SEND_CARD_INFO = ^NET_DVR_SEND_CARD_INFO;

//门磁状态上报
type
  NET_DVR_MAGNETIC_DOOR_STATUS = record 
    byMagneticDoorStatus: BYTE;  //门磁状态 1-打开 2-关闭
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_MAGNETIC_DOOR_STATUS = ^NET_DVR_MAGNETIC_DOOR_STATUS;

//可视对讲事件记录信息联合体
type
  NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON = record 
    case Byte of
    0: (byLen: array[0..256-1] of BYTE);  //联合体大小
    1: (struUnlockRecord: NET_DVR_UNLOCK_RECORD_INFO);  //开锁记录
    2: (struNoticedataReceipt: NET_DVR_NOTICEDATA_RECEIPT_INFO);  //公告信息阅读回执
    3: (struAuthInfo: NET_DVR_AUTH_INFO);  //认证记录（设备未实现）
    4: (struUploadPlateInfo: NET_DVR_UPLOAD_PLATE_INFO);  //车牌信息上传
    5: (struSendCardInfo: NET_DVR_SEND_CARD_INFO);  //门口机发卡,对应设备处于发卡状态，刷卡时上传该事件
    6: (struMagneticDoorStatus: NET_DVR_MAGNETIC_DOOR_STATUS);  //门磁状态
  end;
  LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON = ^NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;

//可视对讲事件记录
type
  NET_DVR_VIDEO_INTERCOM_EVENT = record 
    dwSize: DWORD;  //结构体大小
    struTime: NET_DVR_TIME_EX;  //时间
    byDevNumber: array[0..MAX_DEV_NUMBER_LEN-1] of BYTE;  //设备编号
    byEventType: BYTE;  //事件信息类型，1-开锁记录，2-公告信息阅读回执，3-认证记录，4-车牌信息上传，5非法卡刷卡事件，6-门口机发卡记录(需要启动门口机发卡功能，刷卡时才会上传该事件)，7-口罩检测事件，8-门磁状态记录
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes1: array[0..2-1] of BYTE;  //保留
    uEventInfo: NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;  //事件信息，具体内容参考byEventType取值
    dwIOTChannelNo: DWORD;  //IOT通道号
    byRes2: array[0..252-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_EVENT = ^NET_DVR_VIDEO_INTERCOM_EVENT;


//防区报警信息
type
  NET_DVR_ZONE_ALARM_INFO = record 
    byZoneName: array[0..NAME_LEN-1] of BYTE;  //防区名称
    dwZonendex: DWORD;  //防区号
    byZoneType: BYTE;  //防区类型，参考DETECTOR_TYPE
    byRes: array[0..219-1] of BYTE;  //保留
  end;
  LPNET_DVR_ZONE_ALARM_INFO = ^NET_DVR_ZONE_ALARM_INFO;

//锁报警信息
type
  NET_DVR_LOCK_ALARM_INFO = record 
    dwLockID: DWORD;  //锁ID，从0开始
    byRes: array[0..252-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_LOCK_ALARM_INFO = ^NET_DVR_LOCK_ALARM_INFO;

type
  NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION = record 
    case Byte of
    0: (byLen: array[0..256-1] of BYTE);  //联合体大小
    1: (struZoneAlarm: NET_DVR_ZONE_ALARM_INFO);  //防区报警
    2: (struLockAlarm: NET_DVR_LOCK_ALARM_INFO);  //锁报警信息
  end;
  LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION = ^NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;


//可视对讲报警信息联合体
type
  NET_DVR_VIDEO_INTERCOM_ALARM = record 
    dwSize: DWORD;  //结构体大小
    struTime: NET_DVR_TIME_EX;  //报警时间
    byDevNumber: array[0..MAX_DEV_NUMBER_LEN-1] of BYTE;  //设备编号
    byAlarmType: BYTE;  //报警类型，1-防区报警，2-防拆报警，3-劫持报警，4-多次密码开锁失败报警,5-门没开，6-门没关 7-SOS 、8-通话对讲，9-智能锁劫持指纹报警， 10-智能锁劫持密码报警，11-智能锁撬门报警，12-智能锁门锁锁定报警，13-智能锁电量不足报警 ,14-禁止名单报警,15-智能锁掉线
    //，16-门禁安全模块防拆报警，17-设备开始对讲，18-设备停止对讲, 19-取消SOS ,20-未佩戴口罩报警 21-消防输入报警 22-消防输入恢复 23-门磁被外力打开，24-卫生间报警，25-取消卫生间报警，26-换药提醒，27-人脸测温报警，28-取消换药提醒
    byRes1: array[0..3-1] of BYTE;  //保留
    uAlarmInfo: NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;  //报警信息，具体内容参考字段byAlarmType取值
    wLockID: WORD;  //（0-表示门口机本机控制器上接的锁、1-表示外接控制器上接的锁）（报警类型为5和6时有效）
    byRes3: array[0..2-1] of BYTE;  //保留
    dwIOTChannelNo: DWORD;  //IOT通道号
    byRes2: array[0..248-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_ALARM = ^NET_DVR_VIDEO_INTERCOM_ALARM;

type
  NET_DVR_PEOPLE_REGION = record 
    byID: BYTE;  //区域ID
    byNumber: BYTE;  //区域中的人员数量 0-表示区域中没有人员
    byDressType: BYTE;  //着装类型 0-未知，1-法袍、2-徽章、3-制服
    byRes: BYTE;  
    struRegion: NET_VCA_RECT;  
    dwPicLen: DWORD;  //检测图片长度 (0表示没有长度)
    pPicBuffer: PAnsiChar;  //具体的图片数据
    byRes1: array[0..24-1] of BYTE;  //保留(预留后期扩展区域属性)
  end;
  LPNET_DVR_PEOPLE_REGION = ^NET_DVR_PEOPLE_REGION;

type
  NET_DVR_PEOPLE_DETECTION_RESULT = record 
    dwSize: DWORD;  
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    struPeopleRegion: array[0..MAX_PEOPLE_DETECTION_NUM{8}-1] of NET_DVR_PEOPLE_REGION;  
    {人员检测报警类型
    （0-    未知，
    （1-    审讯室内打架斗殴报警
    （2-    审讯人员瞌睡检测报警
    （3-    被审讯人员起身检测报警
    （4-    审判人员检测）
    }
    byPeopleAlarmType: BYTE;  
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_PEOPLE_DETECTION_RESULT = ^NET_DVR_PEOPLE_DETECTION_RESULT;

type
  NET_DVR_SUPPLEMENTLIGHT = record 
    byEnable: BYTE;  //使能 0-关，1-开
    byMode: BYTE;  //补光灯模式 0-自动，1-定时
    byHighBeamBrightness: BYTE;  //远光灯亮度[0,10]
    byLowBeamBrightness: BYTE;  //近光灯亮度[0,10]
    struSchedTime: NET_DVR_SCHEDULE_DAYTIME;  //定时时间段
    wFilteringTime: WORD;  //过滤时间(s)[0,120]
    byBrightness: BYTE;  //补光灯亮度[0,10]（当支持该参数时， byHighBeamBrightness、byLowBeamBrightness不生效）
    bySensitivity: BYTE;  //补光灯灵敏度[0,7],默认4（当byMode为自动时生效）
    byBrightnessRegulatMode: BYTE;  // 亮度调节模式，0-手动，1-自动（当为自动时byBrightness不生效）
    byMaxBrightness: BYTE;  //补光灯最大亮度（仅亮度调节模式为自动时生效），[0,100]，默认50
    byRes: array[0..58-1] of BYTE;  
  end;
  LPNET_DVR_SUPPLEMENTLIGHT = ^NET_DVR_SUPPLEMENTLIGHT;

type
  NET_DVR_EXTERNALDEVICE = record 
    dwSize: DWORD;  //结构体大小
    struSupplementLight: NET_DVR_SUPPLEMENTLIGHT;  //补光灯结构信息
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_EXTERNALDEVICE = ^NET_DVR_EXTERNALDEVICE;
type
  NET_DVR_TEMPERATURE_TRIGGER_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChan: DWORD;  //通道号
    dwPreset: DWORD;  //预置点号
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_TEMPERATURE_TRIGGER_COND = ^NET_DVR_TEMPERATURE_TRIGGER_COND;
//(球机支持，软件实现，补光灯是设计在设备内部的)
type
  NET_DVR_BUILTIN_SUPPLEMENTLIGHT = record 
    dwSize: DWORD;  //结构体大小
    byMode: BYTE;  //补光灯模式 0-定时，1-开启，2-关闭，3-自动（非光敏，算法画面识别）
    byBrightnessLimit: BYTE;  //亮度限制[0,100]
    bySupplementLightMode: BYTE;  //补光灯类型,0~白光模式,1~混合模式
    byMixedLightRegulatMode: BYTE;  //混合补光灯亮度调节模式,0~自动,1~手动,当bySupplementLightMode = 1时生效
    byLrLightBrightness: BYTE;  //红外亮度控制[0,100],当byMixedLightRegulatMode = 1时生效。
    byHighLrLightBrightness: BYTE;  // 远光红外光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
    byHighBrightnessLimit: BYTE;  // 远光白光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
    byLowLrLightBrightness: BYTE;  // 近光红外光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
    struSchedTime: NET_DVR_SCHEDULE_DAYTIME;  //定时时间段
    byLowBrightnessLimit: BYTE;  //近光白光亮度配置[0,100],当byMixedLightRegulatMode = 1时生效
    byWhiteLightBrightness: BYTE;  // 白光灯亮度
    byIrLightbrightnessLimit: BYTE;  //混光球机,红外亮度限制
    byWhiteLightbrightnessLimit: BYTE;  //混光球机,白光亮度限制
    byRes1: array[0..252-1] of BYTE;  
  end;
  LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT = ^NET_DVR_BUILTIN_SUPPLEMENTLIGHT;
type
  NET_DVR_OIS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byMode: BYTE;  //是否光学防抖：0-关闭，1-普通，2-专家
    byOISLevel: BYTE;  //光学防抖等级，0-低，1-中，2-高
    byOISSensitivity: BYTE;  //光学防抖灵敏度，0-低，1-中，2-高
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_OIS_CFG = ^NET_DVR_OIS_CFG;

type
  NET_DVR_MACFILTER_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否开启MAC地址过滤：0-否，1-是
    byPermissionType: BYTE;  //MAC地址过滤类型，0-禁止，1-允许
    byRes1: array[0..2-1] of BYTE;  
    szMacAddress: array[0..MAC_ADDRESS_NUM-1, 0..MACADDR_LEN-1] of BYTE;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_MACFILTER_CFG = ^NET_DVR_MACFILTER_CFG;

type
  NET_DVR_EAGLEFOCUSING_SENCE = record 
    byRuleType: BYTE;  //规则类型，0-线
    bySceneID: BYTE;  //场景ID，0-保留， 1是表示场景1,2表示场景2，其余依次类推
    wRate: WORD;  //倍率，50-100
    struRegion: NET_VCA_POLYGON;  // 区域范围
    bySpotNum: BYTE;  //在标定线上取多少个点进行标定，3-5，默认3
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_EAGLEFOCUSING_SENCE = ^NET_DVR_EAGLEFOCUSING_SENCE;

type
  NET_DVR_EAGLEFOCUSING_CALCFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //是否开启标定：0-中止标定，1-开始标定（该节点设置时有效，获取时无效）
    byRes1: array[0..3-1] of BYTE;  
    struEagleFoucsing: array[0..MAX_SENCE_NUM{16}-1] of NET_DVR_EAGLEFOCUSING_SENCE;  
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_EAGLEFOCUSING_CALCFG = ^NET_DVR_EAGLEFOCUSING_CALCFG;

type
  NET_DVR_EAGLEFOCUSING_CTRL = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能：0-关闭鹰视聚焦，1-开启鹰视聚焦
    byHeightCompensationEnable: BYTE;  //高度补偿使能
    byHeightCompensationValue: BYTE;  //高度补偿值, 范围1-5,默认3,一个值代表0.5米
    byRes: array[0..509-1] of BYTE;  
  end;
  LPNET_DVR_EAGLEFOCUSING_CTRL = ^NET_DVR_EAGLEFOCUSING_CTRL;

type
  NET_DVR_SMARTCALIBRATION_REGION = record 
    byRuleID: BYTE;  //规则编号
    byMode: BYTE;  //0-default Mode,1-pix Mode,2-actual Mode
    byStrategy: BYTE;  //过滤策略 0-area(面积),1-widthHeight(宽高) (<!---,if mode == pix Mode -->)
    byPriority: BYTE;  //优先级 0-默认值, 1-低，2-中，3-高
    struMaxTargetSize: NET_VCA_POLYGON;  //最大目标尺寸
    struMinTargetSize: NET_VCA_POLYGON;  //最小目标尺寸
  end;
  LPNET_DVR_SMARTCALIBRATION_REGION = ^NET_DVR_SMARTCALIBRATION_REGION;

//  RULE_REGION_MAX = 128;    
type
  NET_DVR_SMARTCALIBRATION_CFG = record 
    dwSize: DWORD;  //结构体大小
    { SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    }
    bySmartType: BYTE;  //智能类型
    byRes: array[0..3-1] of BYTE;  
    strRegion: array[0..RULE_REGION_MAX{128}-1] of NET_DVR_SMARTCALIBRATION_REGION;  
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SMARTCALIBRATION_CFG = ^NET_DVR_SMARTCALIBRATION_CFG;

type
  NET_DVR_SMARTCALIBRATION_COND = record 
    dwSize: DWORD;  //结构体大小
    { SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    }
    bySmartType: BYTE;  //智能类型
    byRes: array[0..3-1] of BYTE;  
    dwChannel: DWORD;  //通道号
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SMARTCALIBRATION_COND = ^NET_DVR_SMARTCALIBRATION_COND;

type
  NET_DVR_SMARTCALIBRATION_REGION_CFG = record 
    dwSize: DWORD;  //结构体大小
    strRegion: array[0..RULE_REGION_MAX{128}-1] of NET_DVR_SMARTCALIBRATION_REGION;  
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SMARTCALIBRATION_REGION_CFG = ^NET_DVR_SMARTCALIBRATION_REGION_CFG;


type
  NET_DVR_OSD_BATTERY_POWER_CFG = record 
    dwSize: DWORD;  
    struOSDBatteryPower: NET_VCA_POINT;  //客流统计显示OSD显示左上角坐标
    byOSDBatteryPower: BYTE;  //电池电量OSD叠加显示使能,  0-否，1-是
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_OSD_BATTERY_POWER_CFG = ^NET_DVR_OSD_BATTERY_POWER_CFG;

const
  CARD_PARAM_CARD_VALID = $00000001;    //卡是否有效参数
  CARD_PARAM_VALID = $00000002;    //有效期参数
  CARD_PARAM_CARD_TYPE = $00000004;    //卡类型参数
  CARD_PARAM_DOOR_RIGHT = $00000008;    //门权限参数
  CARD_PARAM_LEADER_CARD = $00000010;    //首卡参数
  CARD_PARAM_SWIPE_NUM = $00000020;    //最大刷卡次数参数
  CARD_PARAM_GROUP = $00000040;    //所属群组参数
  CARD_PARAM_PASSWORD = $00000080;    //卡密码参数
  CARD_PARAM_RIGHT_PLAN = $00000100;    //卡权限计划参数
  CARD_PARAM_SWIPED_NUM = $00000200;    //已刷卡次数

type
  NET_DVR_VALID_PERIOD_CFG = record 
    byEnable: BYTE;  //使能有效期，0-不使能，1使能
    byBeginTimeFlag: BYTE;  //是否限制起始时间的标志，0-不限制，1-限制
    byEnableTimeFlag: BYTE;  //是否限制终止时间的标志，0-不限制，1-限制
    byTimeDurationNo: BYTE;  //有效期索引,从0开始（时间段通过SDK设置给锁，后续在制卡时，只需要传递有效期索引即可，以减少数据量）
    struBeginTime: NET_DVR_TIME_EX;  //有效期起始时间
    struEndTime: NET_DVR_TIME_EX;  //有效期结束时间
    byTimeType: BYTE;  //时间类型：0-设备本地时间（默认），1-UTC时间（对于struBeginTime，struEndTime字段有效）
    byRes2: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_VALID_PERIOD_CFG = ^NET_DVR_VALID_PERIOD_CFG;

type
  NET_DVR_CARD_CFG = record 
    dwSize: DWORD;  
    dwModifyParamType: DWORD;  
    // 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
    // #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
    // #define CARD_PARAM_VALID            0x00000002  //有效期参数
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
    // #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
    // #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    byCardValid: BYTE;  //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，默认普通卡
    byLeaderCard: BYTE;  //是否为首卡，1-是，0-否
    byRes1: BYTE;  
    dwDoorRight: DWORD;  //门权限，按位表示，1为有权限，0为无权限，从低位到高位表示对门1-N是否有权限
    struValid: NET_DVR_VALID_PERIOD_CFG;  //有效期参数
    dwBelongGroup: DWORD;  //所属群组，按位表示，1-属于，0-不属于，从低位到高位表示是否从属群组1-N
    byCardPassword: array[0..CARD_PASSWORD_LEN-1] of BYTE;  //卡密码
    byCardRightPlan: array[0..MAX_DOOR_NUM-1, 0..MAX_CARD_RIGHT_PLAN_NUM-1] of BYTE;  //卡权限计划，取值为计划模板编号，同个门不同计划模板采用权限或的方式处理
    dwMaxSwipeTime: DWORD;  //最大刷卡次数，0为无次数限制
    dwSwipeTime: DWORD;  //已刷卡次数
    wRoomNumber: WORD;  //房间号
    wFloorNumber: SHORT;  //层号
    byRes2: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_CARD_CFG = ^NET_DVR_CARD_CFG;

type
  NET_DVR_CARD_CFG_COND = record 
    dwSize: DWORD;  
    dwCardNum: DWORD;  //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    byCheckCardNo: BYTE;  //设备是否进行卡号校验，0-不校验，1-校验
    byRes1: array[0..3-1] of BYTE;  
    wLocalControllerID: WORD;  //就地控制器序号，表示往就地控制器下发离线卡参数，0代表是门禁主机
    byRes2: array[0..2-1] of BYTE;  
    dwLockID: DWORD;  //锁ID
    byRes3: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_CARD_CFG_COND = ^NET_DVR_CARD_CFG_COND;

type
  NET_DVR_CARD_CFG_SEND_DATA = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    dwCardUserId: DWORD;  //持卡人ID
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_CARD_CFG_SEND_DATA = ^NET_DVR_CARD_CFG_SEND_DATA;

type
  NET_DVR_CARD_USER_INFO_CFG = record //对应配置结构体
    dwSize: DWORD;  
    sUsername: array[0..NAME_LEN-1] of BYTE;  // 用户名
    byAssociateNetUser: BYTE;  //关联的网络用户编号
    byRes2: array[0..255-1] of BYTE;  //byRes2[0]--网络报警主机用作用户号
  end;
  LPNET_DVR_CARD_USER_INFO_CFG = ^NET_DVR_CARD_USER_INFO_CFG;

const
  ACS_PARAM_DOOR_STATUS_WEEK_PLAN = $00000001;    //门状态周计划参数
  ACS_PARAM_VERIFY_WEEK_PALN = $00000002;    //读卡器周计划参数
  ACS_PARAM_CARD_RIGHT_WEEK_PLAN = $00000004;    //卡权限周计划参数
  ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN = $00000008;    //门状态假日计划参数
  ACS_PARAM_VERIFY_HOLIDAY_PALN = $00000010;    //读卡器假日计划参数
  ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN = $00000020;    //卡权限假日计划参数
  ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP = $00000040;    //门状态假日组参数
  ACS_PARAM_VERIFY_HOLIDAY_GROUP = $00000080;    //读卡器验证方式假日组参数
  ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP = $00000100;    //卡权限假日组参数
  ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE = $00000200;    //门状态计划模板参数
  ACS_PARAM_VERIFY_PALN_TEMPLATE = $00000400;    //读卡器验证方式计划模板参数
  ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE = $00000800;    //卡权限计划模板参数
  ACS_PARAM_CARD = $00001000;    //卡参数
  ACS_PARAM_GROUP = $00002000;    //群组参数
  ACS_PARAM_ANTI_SNEAK_CFG = $00004000;    //反潜回参数
  ACS_PAPAM_EVENT_CARD_LINKAGE = $00008000;    //事件及卡号联动参数
  ACS_PAPAM_CARD_PASSWD_CFG = $00010000;    //密码开门使能参数
  ACS_PARAM_PERSON_STATISTICS_CFG = $00020000;    //人数统计参数
  ACS_PARAM_BLOCKLIST_PICTURE = $00040000;    //禁止名单图片参数
  ACS_PARAM_ID_BLOCKLIST = $00080000;    //身份证禁止名单参数
  ACS_PARAM_EXAM_INFO = $00100000;    //考试信息参数
  ACS_PARAM_EXAMINEE_INFO = $00200000;    //考生信息参数
  ACS_PARAM_FAILED_FACE_INFO = $00400000;    //升级设备人脸建模失败记录

type
  NET_DVR_ACS_PARAM_TYPE = record 
    dwSize: DWORD;  
    dwParamType: DWORD;  //参数类型，按位表示
    //#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //门状态周计划参数
    //#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //读卡器周计划参数
    //#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //卡权限周计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //门状态假日计划参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //读卡器假日计划参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //卡权限假日计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //门状态假日组参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //读卡器验证方式假日组参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //卡权限假日组参数
    //#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //门状态计划模板参数
    //#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //读卡器验证方式计划模板参数
    //#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //卡权限计划模板参数
    //#define ACS_PARAM_CARD                         0x00001000 //卡参数
    //#define ACS_PARAM_GROUP                        0x00002000 //群组参数
    //#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //反潜回参数
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE          0x00008000 //事件及卡号联动参数
    //#define ACS_PAPAM_CARD_PASSWD_CFG             0x00010000 //密码开门使能参数
    //#define ACS_PARAM_PERSON_STATISTICS_CFG       0x00020000 //人数统计参数
    //#define ACS_PARAM_BLOCKLIST_PICTURE          0x00040000 //禁止名单图片参数
    //#define ACS_PARAM_ID_BLOCKLIST               0x00080000 //身份证禁止名单参数
    //#define ACS_PARAM_EXAM_INFO                   0x00100000 //考试信息参数
    //#define ACS_PARAM_EXAMINEE_INFO               0x00200000 //考生信息参数
    //#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //升级设备人脸建模失败记录
    wLocalControllerID: WORD;  //就地控制器序号[1,64],0代表门禁主机
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_ACS_PARAM_TYPE = ^NET_DVR_ACS_PARAM_TYPE;

type
  NET_DVR_VIDEO_INTERCOM_IOIN_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byIOUseType: BYTE;  //用途，0-禁用，1-开门按钮，2-门状态，0xff-自定义
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG = ^NET_DVR_VIDEO_INTERCOM_IOIN_CFG;

type
  NET_DVR_VIDEO_INTERCOM_IOOUT_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byIOUseType: BYTE;  //用途，0-禁用，1-电锁，0xff-自定义
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG = ^NET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

type
  NET_DVR_ELEVATORCONTROL_CFG = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  //是否启用梯控，0-否，1-是
    byRes1: BYTE;  //保留
    byInterfaceType: BYTE;  //接口类型，0-无，1-RS485,2-网口
    byRS485Protocol: BYTE;  //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    byNetworkType: BYTE;  //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ELEVATORCONTROL_CFG = ^NET_DVR_ELEVATORCONTROL_CFG;

type
  NET_DVR_ELEVATORCONTROL_CFG_V40 = record 
    dwSize: DWORD;  // 结构体大小
    byEnable: BYTE;  //是否启用梯控，0-否，1-是
    byRes1: BYTE;  //保留
    byInterfaceType: BYTE;  //接口类型，0-无，1-RS485,2-网口
    byRS485Protocol: BYTE;  //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    byNetworkType: BYTE;  //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    byRes2: BYTE;  //保留
    wServerPort: WORD;  //梯控服务器端口号，当网卡协议类型为1-私有 时有效
    struServerIP: NET_DVR_IPADDR;  //梯控服务器IP，当网卡协议类型为1-私有 时有效
    byRes: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ELEVATORCONTROL_CFG_V40 = ^NET_DVR_ELEVATORCONTROL_CFG_V40;

type
  NET_DVR_ELEVATORCONTROL_CFG_V50 = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用梯控，0-否，1-是
    byNegativeFloor: BYTE;  //负楼层层数
    byInterfaceType: BYTE;  //接口类型，0-无，1-RS485,2-网口
    byRS485Protocol: BYTE;  //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    byNetworkType: BYTE;  //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    byElevatorControlType: BYTE;  //梯控器类型：0-无效，1-DS-K2201，2-DS-K2210，0xff-自定义
    wServerPort: WORD;  //梯控服务器端口号，当网卡协议类型为1-私有 时有效
    struServerIP: NET_DVR_IPADDR;  //梯控服务器IP，当网卡协议类型为1-私有 时有效
    sUserName: array[0..NET_DVR_LOGIN_USERNAME_MAX_LEN-1] of BYTE;  //用户名，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
    sPassword: array[0..NET_DVR_LOGIN_PASSWD_MAX_LEN-1] of BYTE;  //密码，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
    byRes: array[0..256-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ELEVATORCONTROL_CFG_V50 = ^NET_DVR_ELEVATORCONTROL_CFG_V50;

type
  NET_DVR_ROOM_CUSTOM_COND = record 
    dwSize: DWORD;  
    dwRoomNumber: DWORD;  //房间数目（设置时有效）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ROOM_CUSTOM_COND = ^NET_DVR_ROOM_CUSTOM_COND;

type
  NET_DVR_ROOM_CUSTOM_CFG = record 
    dwSize: DWORD;  
    dwFormerRoomNo: DWORD;  //原房间号
    dwCustomRoomNo: DWORD;  //自定义序号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ROOM_CUSTOM_CFG = ^NET_DVR_ROOM_CUSTOM_CFG;

type
  NET_DVR_ROOM_CUSTOM_STATUS = record 
    dwSize: DWORD;  
    dwFormerRoomNo: DWORD;  //原房间号
    byStatus: BYTE;  //下发状态：0-无效，1-失败，2-处理中，3-成功
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_ROOM_CUSTOM_STATUS = ^NET_DVR_ROOM_CUSTOM_STATUS;

type
  NET_DVR_VIDEOINTERCOM_STREAM = record 
    dwSize: DWORD;  
    byVisDevID: array[0..MAX_NAMELEN-1] of BYTE;  // 可视对讲设备编号，即长号，设备类型为IPC时全部为0
    byDeviceName: array[0..NAME_LEN-1] of BYTE;  //设备名称
    bySourceType: BYTE;  //视频源类型，0无意义，1-IPC、2-DVR/DVS/NVR、3-门口机、4-围墙机、5-二次确认机
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEOINTERCOM_STREAM = ^NET_DVR_VIDEOINTERCOM_STREAM;

const
  UNLOCK_PASSWORD_LEN = 8;    //解除密码长度
  LOCAL_CONTROLLER_NAME_LEN = 32;    //就地控制器名称长度
type
  NET_DVR_DOOR_CFG = record 
    dwSize: DWORD;  
    byDoorName: array[0..DOOR_NAME_LEN-1] of BYTE;  //门名称
    byMagneticType: BYTE;  //门磁类型，0-常闭，1-常开
    byOpenButtonType: BYTE;  //开门按钮类型，0-常闭，1-常开
    byOpenDuration: BYTE;  //开门持续时间，1-255s（楼层继电器动作时间）
    byAccessibleOpenDuration: BYTE;  //特殊群体卡开门持续时间，1-255s
    byMagneticAlarmTimeout: BYTE;  //门磁检测超时报警时间，0-255s，0表示不报警
    byEnableDoorLock: BYTE;  //是否启用闭门回锁，0-否，1-是
    byEnableLeaderCard: BYTE;  //是否启用首卡常开功能，0-否，1-是
    byLeaderCardMode: BYTE;  //首卡模式，0-不启用首卡功能，1-首卡常开模式，2-首卡授权模式（使用了此字段，则byEnableLeaderCard无效）
    dwLeaderCardOpenDuration: DWORD;  //首卡常开持续时间，1-1440min
    byStressPassword: array[0..STRESS_PASSWORD_LEN-1] of BYTE;  //胁迫密码
    bySuperPassword: array[0..SUPER_PASSWORD_LEN-1] of BYTE;  //超级密码
    byUnlockPassword: array[0..UNLOCK_PASSWORD_LEN-1] of BYTE;  //解除码NET_DVR_LOCAL_CONTROLLER_STATUS
    byUseLocalController: BYTE;  //只读，是否连接在就地控制器上，0-否，1-是
    byRes1: BYTE;  
    wLocalControllerID: WORD;  //只读，就地控制器序号，1-64,0代表未注册
    wLocalControllerDoorNumber: WORD;  //只读，就地控制器的门编号，1-4,0代表未注册
    wLocalControllerStatus: WORD;  //只读，就地控制器在线状态：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
    byLockInputCheck: BYTE;  //是否启用门锁输入检测(1字节，0不启用，1启用，默认不启用)
    byLockInputType: BYTE;  //门锁输入类型(1字节，0常闭，1常开，默认常闭)
    byDoorTerminalMode: BYTE;  //门相关端子工作模式(1字节，0防剪防短，1普通，默认防剪防短)
    byOpenButton: BYTE;  //是否启用开门按钮(1字节，0是，1否，默认是)
    byLadderControlDelayTime: BYTE;  //梯控访客延迟时间，1-255min
    byRes2: array[0..43-1] of BYTE;  
  end;
  LPNET_DVR_DOOR_CFG = ^NET_DVR_DOOR_CFG;

type
  NET_DVR_VIS_DEV_INFO = record 
    dwSize: DWORD;  
    szDevNumber: array[0..MAX_DEV_NUMBER_LEN-1] of BYTE;  //设备编号
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIS_DEV_INFO = ^NET_DVR_VIS_DEV_INFO;

type
  NET_DVR_VIS_REGISTER_INFO = record 
    dwSize: DWORD;  
    dwID: DWORD;  //ID
    szDevNumber: array[0..MAX_DEV_NUMBER_LEN-1] of BYTE;  //设备编号
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //mac地址
    byRes1: array[0..2-1] of BYTE;  //保留
    sSerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //设备序列号
    struDevIP: NET_DVR_IPADDR;  //设备IP地址
    struRegisterTime: NET_DVR_TIME_EX;  //注册时间
    byRegisterType: BYTE;  //注册类型，0-保留、1-门口机，2-管理机、3-室内机、4-围墙机、5-别墅门口机、6-二次确认机、7-8700客户端、8-4200客户端
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIS_REGISTER_INFO = ^NET_DVR_VIS_REGISTER_INFO;

type
  NET_DVR_CALLER_INFO = record 
    dwSize: DWORD;  //结构体大小
    wBuildingNo: WORD;  //楼号
    wFloorNo: SHORT;  //层号
    byZoneNo: BYTE;  //期号
    byUnitNo: BYTE;  //单元号
    byDevNo: BYTE;  //设备编号
    byDevType: BYTE;  //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP, 10- 门铃机，11-VOIP客户端，12-布防点IPC设备
    byLockNum: BYTE;  //锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
    byHighDevNo: BYTE;  // 设备编号高8位,用于支持1-9999的范围
    byRes1: array[0..2-1] of BYTE;  // 保留
    byVoipNo: array[0..16-1] of BYTE;  // VOIP客户端号码 byDevType：为11时有效
    byRes: array[0..80-1] of BYTE;  // 保留
  end;
  LPNET_DVR_CALLER_INFO = ^NET_DVR_CALLER_INFO;

type
  NET_DVR_CALL_STATUS = record 
    dwSize: DWORD;  //结构体大小
    byCallStatus: BYTE;  //获取通话状态，1-无呼叫、2-响铃、3-正在通话
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_CALL_STATUS = ^NET_DVR_CALL_STATUS;

const
  MAX_SERVER_DEVICE_NUMBER = 16;    //最大设备数量

type
  NET_DVR_SERVER_DEVICE_CFG = record 
    byDeviceName: array[0..NAME_LEN-1] of BYTE;  //设备名称
    byDeviceType: BYTE;  ////设备类型，1-门口机，2-管理机，3-室内机
    byDeviceID: BYTE;  //门口机编号
    byLockNum: BYTE;  //锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
    byRes: array[0..5-1] of BYTE;  //保留
  end;
  LPNET_DVR_SERVER_DEVICE_CFG = ^NET_DVR_SERVER_DEVICE_CFG;

type
  NET_DVR_SERVER_DEVICE_INFO = record 
    dwSize: DWORD;  //结构体大小
    dwDeviceNum: DWORD;  //设备数
    struDeviceCfg: array[0..MAX_SERVER_DEVICE_NUMBER-1] of NET_DVR_SERVER_DEVICE_CFG;  //设备信息
    byRes: array[0..200-1] of BYTE;  //保留
  end;
  LPNET_DVR_SERVER_DEVICE_INFO = ^NET_DVR_SERVER_DEVICE_INFO;

type
  NET_DVR_VIDEO_CALL_PARAM = record 
    dwSize: DWORD;  
    dwCmdType: DWORD;  //信令类型  0-请求呼叫，1-取消本次呼叫，2-接听本次呼叫 3-拒绝本地来电呼叫 4-被叫响铃超时 5-结束本次通话，6-设备正在通话中，7-客户端正在通话中，8室内机不在线
    wPeriod: WORD;  //期号, 范围[0,9]
    wBuildingNumber: WORD;  //楼号
    wUnitNumber: WORD;  //单元号
    wFloorNumber: SHORT;  //层号
    wRoomNumber: WORD;  //房间号
    wDevIndex: WORD;  //设备编号
    byUnitType: BYTE;  //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP
    byRes: array[0..115-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_CALL_PARAM = ^NET_DVR_VIDEO_CALL_PARAM;

const
  MAX_SCREEN_ADDRESS_LEN = 16;    //特征码最大长度
  MAX_DAY_TIME_POINT = 8;    //每天最大时间点个数
  MAX_TIME_POINT = 16;    //每年最大时间点个数

type
  NET_DVR_DEV_IP_INFO = record 
    byUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    byPassWord: array[0..PASSWD_LEN-1] of BYTE;  //密码
    struIPAddr: NET_DVR_IPADDR;  //IP地址
    wPort: WORD;  //端口号
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_DEV_IP_INFO = ^NET_DVR_DEV_IP_INFO;

type
  NET_DVR_SCREEN_BASE_INFO = record 
    case Byte of
    0: (byScreenAddress: array[0..MAX_SCREEN_ADDRESS_LEN-1] of BYTE);  //屏幕特征码，设备添加方式为0时有效
    1: (struIPInfo: NET_DVR_DEV_IP_INFO);  //屏幕ip地址信息
    2: (byRes: array[0..100-1] of BYTE);  
  end;
  LPNET_DVR_SCREEN_BASE_INFO = ^NET_DVR_SCREEN_BASE_INFO;

type
  NET_DVR_SCREEN_INDEX_CFG = record 
    dwSize: DWORD;  
    byEnbale: BYTE;  //使能，0-不使能，1-使能
    byDevAddType: BYTE;  //设备添加方式，0-按特征码(服务器和屏幕使用串口通信)，1-按IP地址(服务器和屏幕使用网络通信)
    byRes1: array[0..2-1] of BYTE;  
    struScreenBaseInfo: NET_DVR_SCREEN_BASE_INFO;  //屏幕设备基本信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_INDEX_CFG = ^NET_DVR_SCREEN_INDEX_CFG;

//模拟遥控器参数
type
  NET_DVR_SIMULATE_REMOTE_CTRL = record 
    byControlType: BYTE;  //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键
    byControlParam: BYTE;  //操作参数，操作类型为12时，表示按键值(0-9)，其他操作时此参数无效
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_SIMULATE_REMOTE_CTRL = ^NET_DVR_SIMULATE_REMOTE_CTRL;

//屏幕维墙参数
type
  NET_DVR_SCREEN_WALL_CTRL = record 
    byEnable: BYTE;  //状态开关。0-为关闭；1-为开启
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_WALL_CTRL = ^NET_DVR_SCREEN_WALL_CTRL;

//区域放大还原参数
type
  NET_DVR_AREA_ZOOM_CFG = record 
    byCmd: BYTE;  //区域放大还原指令，1-放大，2-还原
    byRes: array[0..3-1] of BYTE;  
    struArea: NET_DVR_RECTCFG;  //需要放大的区域，以1920*1920作为屏幕总大小，还原时此参数无效
  end;
  LPNET_DVR_AREA_ZOOM_CFG = ^NET_DVR_AREA_ZOOM_CFG;

type
  NET_DVR_SCREEN_CONTROL_PARAM = record 
    case Byte of
    0: (struInputCtrl: NET_DVR_INPUT_INTERFACE_CTRL);  
    1: (struDisplayCtrl: NET_DVR_DISPLAY_COLOR_CTRL);  
    2: (struPositionCtrl: NET_DVR_DISPLAY_POSITION_CTRL);  
    3: (struSimulateRemoteCrtl: NET_DVR_SIMULATE_REMOTE_CTRL);  //模拟遥控按键
    4: (struScreenWallCtrl: NET_DVR_SCREEN_WALL_CTRL);  //屏幕维墙参数
    5: (struZoomArea: NET_DVR_AREA_ZOOM_CFG);  //区域放大还原参数
    6: (byRes: array[0..16-1] of BYTE);  
  end;
  LPNET_DVR_SCREEN_CONTROL_PARAM = ^NET_DVR_SCREEN_CONTROL_PARAM;

type
  NET_DVR_SCREEN_CONTROL = record 
    dwSize: DWORD;  
    dwCommand: DWORD;  // 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制
    byProtocol: BYTE;  //串口协议类型,1:LCD-S1,2:LCD-S2
    byRes1: array[0..3-1] of BYTE;  
    struControlParam: NET_DVR_SCREEN_CONTROL_PARAM;  
    byRes2: array[0..52-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_CONTROL = ^NET_DVR_SCREEN_CONTROL;

type
  NET_DVR_SCREEN_CONTROL_V41 = record 
    dwSize: DWORD;  
    bySerialNo: BYTE;  //串口号
    byRes: array[0..2-1] of BYTE;  
    byProtocol: BYTE;  // 串口协议类型 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20，7-LCD-L2,8-LCD-Z1，
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-无效，使用预先绑定的协议类型
    dwCommand: DWORD;  { 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制，6-模拟遥控按键,7-显示屏幕状态,
    8-显示屏幕特征码（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）, 9-屏幕维墙,10-恢复屏幕默认参数，11-显示IP（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）,12-屏幕USB升级 13-区域放大还原}
    struControlParam: NET_DVR_SCREEN_CONTROL_PARAM;  
    byWallNo: BYTE;  // 电视墙号
    byDevNo: BYTE;  //设备号
    bySubboardNo: BYTE;  //子板号
    byRes1: BYTE;  
    struRect: NET_DVR_RECTCFG_EX;  //根据坐标进行计算，基准坐标
    byRes2: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_CONTROL_V41 = ^NET_DVR_SCREEN_CONTROL_V41;

type
  NET_DVR_MSC_SPLICE_CFG = record 
    dwSize: DWORD;  
    bySpliceNo: BYTE;  //拼接屏号
    byWallNo: BYTE;  //电视墙号
    byEnable: BYTE;  //是否使能，0-否，1-是
    byRes1: array[0..1-1] of BYTE;  
    struRectCfg: NET_DVR_RECTCFG_EX;  //需要进行拼接的区域，获取的时候此参数填0
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SPLICE_CFG = ^NET_DVR_MSC_SPLICE_CFG;

type
  NET_DVR_MSC_SCREEN_INTERFACE_CFG = record 
    dwSize: DWORD;  
    byInterfaceType: BYTE;  //输入源索引，见枚举 INPUT_INTERFACE_TYPE
    byNoSignalPic: BYTE;  //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_INTERFACE_CFG = ^NET_DVR_MSC_SCREEN_INTERFACE_CFG;

//背光参数
type
  NET_DVR_MSC_SCREEN_BACKLIGHT_CFG = record 
    dwSize: DWORD;  
    byBacklight: BYTE;  //背光，0-100
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG = ^NET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//画中画参数
type
  NET_DVR_MSC_SCREEN_PIP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用画中画 0-不启用 1-启用
    bySubWindowSource: BYTE;  //子画面信号源，参考枚举INPUT_INTERFACE_TYPE
    bySubWindowBorderColor: BYTE;  //子画面边框颜色， 1-蓝色，2-黑色
    byRes1: BYTE;  
    struPosition: NET_DVR_RECTCFG_EX;  //子画面位置，屏幕总大小为1920*1920
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_PIP_CFG = ^NET_DVR_MSC_SCREEN_PIP_CFG;

type
  NET_DVR_SCREEN_WORK_STATE = record 
    dwSize: DWORD;  
    byFanStatus: BYTE;  //风扇状态，0-关，1-开
    byFanExceptionStatus: BYTE;  //风扇异常状态，0-不支持，1-正常，2-异常
    byRes1: array[0..2-1] of BYTE;  
    dwWorkingHours: DWORD;  //累积工作时长，单位：小时
    byVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本号
    iTemperature: INT;  //板卡温度，精确到个位，单位：摄氏度
    byTempState: BYTE;  //板卡温度状态，0-不支持，1-正常，2-异常
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_WORK_STATE = ^NET_DVR_SCREEN_WORK_STATE;

//开机logo参数
type
  NET_DVR_BOOT_LOGO_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //开机是否显示logo,0-不显示，1-显示
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_BOOT_LOGO_CFG = ^NET_DVR_BOOT_LOGO_CFG;
//音频参数
type
  NET_DVR_LCD_AUDIO_CFG = record 
    dwSize: DWORD;  
    byMute: BYTE;  //是否静音，0-否，1-是
    byVolume: BYTE;  //音量大小，0-100
    byBalance: AnsiChar;  //声道平衡，-50-+50
    byRes: array[0..33-1] of BYTE;  
  end;
  LPNET_DVR_LCD_AUDIO_CFG = ^NET_DVR_LCD_AUDIO_CFG;

//屏幕参数联合体
type
  NET_DVR_MSC_SCREEN_PARAM = record 
    case Byte of
    0: (struInterfaceCfg: NET_DVR_MSC_SCREEN_INTERFACE_CFG);  //输入源参数
    1: (struFanWorkMode: NET_DVR_SCREEN_FAN_WORK_MODE_CFG);  //风扇工作模式参数
    2: (struVgaCfg: NET_DVR_SCREEN_VGA_CFG);  //VGA信号参数
    3: (struMenuCfg: NET_DVR_SCREEN_MENU_CFG);  //屏幕菜单参数
    4: (struOutEffectCfg: NET_DVR_VIDEO_OUT_CFG);  //显示效果参数
    5: (struColorTemperatureCfg: NET_DVR_COLOR_TEMPERATURE_CFG);  //色温参数
    6: (struAdcCfg: NET_DVR_ADC_CFG);  //ADC参数
    7: (struScreenEdgeCfg: NET_DVR_SCREEN_EDGE_CFG);  //屏幕边缘参数
    8: (struBacklight: NET_DVR_MSC_SCREEN_BACKLIGHT_CFG);  //背光参数
    9: (struPicInPicCfg: NET_DVR_MSC_SCREEN_PIP_CFG);  //画中画参数
    10: (struDefog: NET_DVR_DEFOG_LCD);  //去雾参数
    11: (struWorkState: NET_DVR_SCREEN_WORK_STATE);  //屏幕工作状态
    12: (struBootLogoCfg: NET_DVR_BOOT_LOGO_CFG);  //开始显示logo参数
    13: (struAudioCfg: NET_DVR_LCD_AUDIO_CFG);  //音频参数
    14: (byRes: array[0..256-1] of BYTE);  
  end;
  LPNET_DVR_MSC_SCREEN_PARAM = ^NET_DVR_MSC_SCREEN_PARAM;

type
  NET_DVR_MSC_SCREEN_PARAM_CFG = record 
    dwSize: DWORD;  
    byParamType: BYTE;  //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数  14-音频参数
    byRes1: array[0..3-1] of BYTE;  
    struParam: NET_DVR_MSC_SCREEN_PARAM;  //屏幕参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_PARAM_CFG = ^NET_DVR_MSC_SCREEN_PARAM_CFG;

type
  NET_DVR_MSC_SCREEN_REMOTE_CFG = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙号
    byRes1: array[0..3-1] of BYTE;  
    struRectCfg: NET_DVR_RECTCFG_EX;  //屏幕区域
    struScreenParam: NET_DVR_MSC_SCREEN_PARAM_CFG;  //配置的屏幕参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_REMOTE_CFG = ^NET_DVR_MSC_SCREEN_REMOTE_CFG;

type
  NET_DVR_MSC_SCREEN_PARAM_COND = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙号
    byParamType: BYTE;  //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数 14-音频参数
    byRes1: array[0..2-1] of BYTE;  
    struRectCfg: NET_DVR_RECTCFG_EX;  //屏幕区域
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MSC_SCREEN_PARAM_COND = ^NET_DVR_MSC_SCREEN_PARAM_COND;

type
  NET_DVR_SWITCH_DAY_TIME = record 
    byEnable: BYTE;  //是否启用该时间点,0-不启用，1-启用
    bySwitchType: BYTE;  //开关机类型，0-关机，1-开机
    byRes1: array[0..2-1] of BYTE;  
    struTimePoint: NET_DVR_DAYTIME;  //开关机时间点
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_SWITCH_DAY_TIME = ^NET_DVR_SWITCH_DAY_TIME;

type
  NET_DVR_SWITCH_TIME_POINT = record 
    byEnable: BYTE;  //是否启用该时间点,0-不启用，1-启用
    bySwitchType: BYTE;  //开关机类型，0-关机，1-开机
    byRes1: array[0..2-1] of BYTE;  
    struTimePoint: NET_DVR_SYSTEM_TIME;  //开关机时间点
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SWITCH_TIME_POINT = ^NET_DVR_SWITCH_TIME_POINT;

type
  NET_DVR_TIME_SWITCH_CFG = record 
    dwSize: DWORD;  
    struSwitchDayTime: array[0..MAX_DAYS-1, 0..MAX_DAY_TIME_POINT-1] of NET_DVR_SWITCH_DAY_TIME;  //周开关机计划
    struSwitchTimePoint: array[0..MAX_TIME_POINT-1] of NET_DVR_SWITCH_TIME_POINT;  //按时间点开关机参数
    byRes1: array[0..3-1] of BYTE;  
    byEnable: BYTE;  //是否启用定时开关机,0-不启用，1-启用
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_TIME_SWITCH_CFG = ^NET_DVR_TIME_SWITCH_CFG;

type
  NET_DVR_VIDEO_WALL_AREA = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙号
    byRes1: array[0..3-1] of BYTE;  
    struRect: NET_DVR_RECTCFG_EX;  //屏幕范围
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VIDEO_WALL_AREA = ^NET_DVR_VIDEO_WALL_AREA;

type
  NET_DVR_DELAY_TIME = record 
    dwSize: DWORD;  
    dwDelayTime: DWORD;  //延时时间，0-3000，单位：ms
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DELAY_TIME = ^NET_DVR_DELAY_TIME;

//双目标定类型
type
  BV_CALIBRATION_TYPE_ENUM =  
  (  
    ENUM_BV_CALIBRATION_NONE = 0,  //未标定
    ENUM_BV_CALIBRATION_DIRECT = 1,  //双目直接标定
    ENUM_BV_CALIBRATION_SAMPLE = 2  //双目样本标定
  );


//样本标定点
type
  NET_DVR_BV_SAMPLE_CALIB_POINT = record 
    byCalibPtID: BYTE;  //标定点ID，范围[1,5]。表示此点在双目标定过程中的序号
    byRes1: array[0..3-1] of BYTE;  //保留
    struPoint: NET_VCA_POINT;  //标定点坐标
    byRes2: array[0..16-1] of BYTE;  //保留
  end;
  LPET_DVR_BV_SAMPLE_CALIB_POINT = ^NET_DVR_BV_SAMPLE_CALIB_POINT;

//开始样本标定输入参数
type
  NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM = record 
    dwCameraHeight: DWORD;  //摄像机高度，单位cm
    dwHumanHeight: DWORD;  //人体身高，单位cm
    byRes: array[0..248-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM = ^NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//设置样本标定输入参数
type
  NET_DVR_BV_SAMPLE_CALIB_SET_PARAM = record 
    struCalibPoint: NET_DVR_BV_SAMPLE_CALIB_POINT;  //标定点。即当人员保持直立行走，人脸出现在特定画面区域中时，此点表示对象两眼连线的中点。
    byRes: array[0..228-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM = ^NET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//结束样本标定输入参数
type
  NET_DVR_BV_SAMPLE_CALIB_END_PARAM = record 
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM = ^NET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//样本标定输入参数联合体
type
  NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION = record 
    case Byte of
    0: (byRes: array[0..256-1] of BYTE);  //保留
    1: (struCalibBegin: NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM);  //开始标定输入参数
    2: (struCalibSet: NET_DVR_BV_SAMPLE_CALIB_SET_PARAM);  //设置标定输入参数
    3: (struCalibEnd: NET_DVR_BV_SAMPLE_CALIB_END_PARAM);  //结束标定输入参数
  end;
  LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION = ^NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//样本标定命令枚举
type
  BV_SAMPLE_CALIB_CMD_ENUM =  
  (  
    ENUM_BV_SAMPLE_CALIB_BEGIN = 1,  //开始标定
    ENUM_BV_SAMPLE_CALIB_SETTING = 2,  //设置参数
    ENUM_BV_SAMPLE_CALIB_END = 3  //结束标定
  );

//样本标定结构体
type
  NET_DVR_BV_SAMPLE_CALIBRATION = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byCommand: BYTE;  //标定命令，参见BV_SAMPLE_CALIB_CMD _ENUM
    byRes1: array[0..3-1] of BYTE;  //保留
    uCalibParam: NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;  //标定输入参数，取值依赖于字段byCommand
    byRes2: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_SAMPLE_CALIBRATION = ^NET_DVR_BV_SAMPLE_CALIBRATION;


//双目样本标定信息
type
  NET_DVR_BV_SAMPLE_CALIB_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwCameraHeight: DWORD;  //摄像机高度，单位cm
    fPitchAngle: FLOAT;  //摄像机俯视角度[0°, 60°],
    fInclineAngle: FLOAT;  //摄像机倾斜角度[-20°,20°]
    struCalibPoint: array[0..MAX_SAMPLE_NUM-1] of NET_DVR_BV_SAMPLE_CALIB_POINT;  //标定点组
    struCalibPointEx: array[0..MAX_SAMPLE_NUM_EX{7}-1] of NET_DVR_BV_SAMPLE_CALIB_POINT;  //标定点组扩展
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_SAMPLE_CALIB_CFG = ^NET_DVR_BV_SAMPLE_CALIB_CFG;

//双目图像校正参数结构体
type
  NET_DVR_BINOC_RECTIFY_PARAM = record 
    fCamInternalMatrix: array[0..3-1, 0..3-1] of FLOAT;  //相机内参矩阵，包括焦距及主点坐标
    fDistCoeffs: array[0..8-1] of FLOAT;  //镜头畸变系数
    fRotateMatrix: array[0..3-1, 0..3-1] of FLOAT;  //校正后的旋转矩阵
    fProjectMatrix: array[0..3-1, 0..4-1] of FLOAT;  //校正后的投影矩阵
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_BINOC_RECTIFY_PARAM = ^NET_DVR_BINOC_RECTIFY_PARAM;

//左右相机校正参数
type
  NET_DVR_BV_CORRECT_PARAM = record 
    dwSize: DWORD;  //结构大小
    fReprojectMatrix: array[0..4-1, 0..4-1] of FLOAT;  //重投影矩阵
    struLCamParam: NET_DVR_BINOC_RECTIFY_PARAM;  //左相机校正参数
    struRCamParam: NET_DVR_BINOC_RECTIFY_PARAM;  //右相机校正参数
    byLensType: BYTE;  //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm,9-2.0mm,10-2.8mm,11-4.3mm
    byRes1: array[0..3-1] of BYTE;  //保留
    {RotateMatrix 是双目标定后左相机相对于右相机的旋转矩阵,
    TransMatrix是平移矩阵,
    RotateMatrix和TransMatrix联合起来描述的是左相机相对于右相机的位置关系}
    fRotateMatrix: array[0..3-1, 0..3-1] of FLOAT;  //旋转矩阵
    fTransMatrix: array[0..3-1] of FLOAT;  //平移矩阵
    dwOriImgWidth: DWORD;  //原始标定图像的宽（如果是1920*1080分辨率的图像，则为1920）
    dwOriImgHeight: DWORD;  //原始标定图像的高（如果是1920*1080分辨率的图像，则为1080）
    byRes: array[0..196-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CORRECT_PARAM = ^NET_DVR_BV_CORRECT_PARAM;

//输出视频类型
type
  NET_DVR_OUTPUT_VIDEO_TYPE = record 
    dwSize: DWORD;  //结构大小
    byType: BYTE;  //输出视频类型，1-拼接图，2-深度图
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTPUT_VIDEO_TYPE = ^NET_DVR_OUTPUT_VIDEO_TYPE;

const
  MAX_CHECK_485CHAN = 64;    //485自检设备通道号个数

type
  NET_DVR_DEVICE_SELF_CHECK_STATE = record 
    dwSize: DWORD;  
    dwRS485Chan: array[0..MAX_CHECK_485CHAN-1] of DWORD;  //RS485通断情况有问题的通道号，值表示通道号，位表示槽位号
    dwSensorChan: array[0..4-1] of DWORD;  //模拟量无效的通道号，按位表示
    byRes: array[0..32-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_DEVICE_SELF_CHECK_STATE = ^NET_DVR_DEVICE_SELF_CHECK_STATE;

//设置完全获取出厂值
type
  NET_DVR_COMPLETE_RESTORE_INFO = record 
    dwSize: DWORD;  //结构体长度
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_COMPLETE_RESTORE_INFO = ^NET_DVR_COMPLETE_RESTORE_INFO;

type
  NET_DVR_UPLOAD_PICTURE_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //图片对应的通道号
    byPictureType: BYTE;  //图片格式,0-bmp，1-jpeg，2-PNG 3-SWF 4-GIF
    byRes1: array[0..3-1] of BYTE;  
    struTime: NET_DVR_TIME_V30;  //图片生成时间
    sPictureBuffer: PAnsiChar;  //图片缓冲区
    dwPictureLength: DWORD;  //图片长度
    dwPicMangeNo: DWORD;  //图片管理号
    sPicName: array[0..NAME_LEN-1] of BYTE;  //图片名称
    byUseType: BYTE;  //图片使用类型：0-屏保图片 1-开机logo图片
    byRes: array[0..91-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_PICTURE_INFO = ^NET_DVR_UPLOAD_PICTURE_INFO;

const
  MAX_UPLOADFILE_URL_LEN = 240;    

type
  NET_DVR_UPLOAD_FILE_RET = record 
    sUrl: array[0..MAX_UPLOADFILE_URL_LEN-1] of BYTE;  //url
    byRes: array[0..260-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_FILE_RET = ^NET_DVR_UPLOAD_FILE_RET;

type
  NET_DVR_FACE_EXTRA_INFO = record 
    struVcaRect: array[0..MAX_FACE_PIC_NUM-1] of NET_VCA_RECT;  //人脸子图坐标信息
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FACE_EXTRA_INFO = ^NET_DVR_FACE_EXTRA_INFO;
type
  NET_DVR_PIC_EXTRA_INFO_UNION = record 
    case Byte of
    0: (byUnionLen: array[0..544-1] of BYTE);  //联合体长度，无实际意义
    1: (struFaceExtraInfo: NET_DVR_FACE_EXTRA_INFO);  //人脸侦测信息
  end;
  LPNET_DVR_PIC_EXTRA_INFO_UNION = ^NET_DVR_PIC_EXTRA_INFO_UNION;

type
  NET_DVR_FIND_PICTURE_V40 = record //查找结果结构体
    sFileName: array[0..PICTURE_NAME_LEN-1] of AnsiChar;  //图片名
    struTime: NET_DVR_TIME;  //图片的时间
    dwFileSize: DWORD;  //图片的大小
    sCardNum: array[0..CARDNUM_LEN_V30-1] of AnsiChar;  //卡号
    byPlateColor: BYTE;  //参考结构 VCA_PLATE_COLOR
    byVehicleLogo: BYTE;  //参考结构 VLR_VEHICLE_CLASS
    byFileType: BYTE;  //文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测, 0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询
    byRecogResult: BYTE;  //识别结果参考结构VTR_RESULT
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    byEventSearchStatus: BYTE;  //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    byRes1: array[0..2-1] of BYTE;  //  保留字节
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    fFaceSnapTemperature: FLOAT;  // 人脸抓拍温度信息，精确到小数点后1位 ，(浮点数 + 100） * 10 取正数传输），单位固定为摄氏度（℃）。当byFileType为0x25-人脸抓拍时有效，其余情况下该字段为0值
    byRes: array[0..68-1] of BYTE;  //  保留字节
    uPicExtraInfo: NET_DVR_PIC_EXTRA_INFO_UNION;  //图片附件信息
  end;
  LPNET_DVR_FIND_PICTURE_V40 = ^NET_DVR_FIND_PICTURE_V40;

type
  NET_DVR_FIND_PICTURE_V50 = record //查找结果结构体
    sFileName: array[0..PICTURE_NAME_LEN-1] of AnsiChar;  //图片名
    struTime: NET_DVR_TIME;  //图片的时间
    dwFileSize: DWORD;  //图片的大小
    sCardNum: array[0..CARDNUM_LEN_V30-1] of AnsiChar;  //卡号
    byPlateColor: BYTE;  //参考结构 VCA_PLATE_COLOR
    byVehicleLogo: BYTE;  //参考结构 VLR_VEHICLE_CLASS
    byFileType: BYTE;  //文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
//                       0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测, 0x70-通道定时抓图
    byRecogResult: BYTE;  //识别结果参考结构VTR_RESULT
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    byEventSearchStatus: BYTE;  //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    struAddr: NET_DVR_ADDRESS;  //图片所在的地址信息，图片下载时用到
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30,0, 30, 45
    byRes: array[0..253-1] of BYTE;  //  保留字节
    uPicExtraInfo: NET_DVR_PIC_EXTRA_INFO_UNION;  //图片附件信息
  end;
  LPNET_DVR_FIND_PICTURE_V50 = ^NET_DVR_FIND_PICTURE_V50;


type
  NET_DVR_THUMBNAILS_COND = record 
    dwSize: DWORD;  // 结构体大小
    struStreamInfo: NET_DVR_STREAM_INFO;  //流信息
    bySearchDataType: BYTE;  // 查找数据类型 0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-图片数据
    byRes: array[0..3-1] of BYTE;  // 保留字节
    struStartTime: NET_DVR_TIME_V30;  //查找开始时间
    struStopTime: NET_DVR_TIME_V30;  // 查找结束时间
    dwIntervalTime: DWORD;  //间隔时间，单位秒，范围：0~24*60*60，若查找结束时间等于查找开始时间，则填0，填其他值无效
    byRes1: array[0..512-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_THUMBNAILS_COND = ^NET_DVR_THUMBNAILS_COND;

type
  NET_DVR_THUMBNAILS_RESULT = record //查找结果结构体
    byResultDataType: BYTE;  // 查找结果数据类型0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-系统头数据， 2-图片数据
    byIFrameType: BYTE;  // I帧类型，0-数据帧，1-参考帧（本数据只需送入播放库，但是不需要转为图片显示）
    byRes1: array[0..2-1] of BYTE;  // 保留字节
    struTime: NET_DVR_TIME_SEARCH;  //数据时间
    byRes: array[0..252-1] of BYTE;  // 保留字节
    dwFileSize: DWORD;  //数据大小
    pBuffer: PAnsiChar;  //数据信息(数据类型和条件结构体中NET_DVR_THUMBNAILS_RESULT 的字段 byResultDataType 值相关)
  end;
  LPNET_DVR_THUMBNAILS_RESULT = ^NET_DVR_THUMBNAILS_RESULT;

type
  NET_DVR_REGIONENTRANCE_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byAlarmConfidence: BYTE;  // 报警置信度, 0-低,1-较低,2-较高,3-高
    byRecordConfidence: BYTE;  // 录像置信度, 0-低,1-较低,2-较高,3-高
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_REGIONENTRANCE_REGION = ^NET_DVR_REGIONENTRANCE_REGION;

type
  NET_DVR_REGION_ENTRANCE_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byEnableHumanMisinfoFilter: BYTE;  // 启用人体去误报 0-不启用，1-启用
    byEnableVehicleMisinfoFilter: BYTE;  // 启用车辆去误报 0-不启用，1-启用
    byRes1: array[0..1-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_REGIONENTRANCE_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_REGION_ENTRANCE_DETECTION = ^NET_DVR_REGION_ENTRANCE_DETECTION;

type
  NET_DVR_SMART_REGION_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwRegion: DWORD;  //区域ID号
  end;
  LPNET_DVR_SMART_REGION_COND = ^NET_DVR_SMART_REGION_COND;

type
  NET_DVR_ENTRANCE_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byDetectionTarget: BYTE;  
    byAlarmConfidence: BYTE;  //报警置信度, 0-低,1-较低,2-较高,3-高
    byRecordConfidence: BYTE;  //录像置信度, 0-低,1-较低,2-较高,3-高
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_ENTRANCE_REGION = ^NET_DVR_ENTRANCE_REGION;

type
  NET_DVR_DENSEFOGDETECTION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    bySensitivity: BYTE;  //灵敏度参数，范围[0,100]
    byRes: array[0..258-1] of BYTE;  
  end;
  LPNET_DVR_DENSEFOGDETECTION_CFG = ^NET_DVR_DENSEFOGDETECTION_CFG;

type
  NET_DVR_EVENT_TRIGGER = record 
    dwSize: DWORD;  //结构体大小
    struHandleException: NET_DVR_HANDLEEXCEPTION_V41;  //异常处理方式
    dwRelRecordChan: array[0..MAX_CHANNUM_V40-1] of DWORD;  //实际触发录像通道，按值表示，采用紧凑型排列，从下标0开始顺序读取，中间遇到0xffffffff则后续无效。
    struPresetChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PRESETCHAN_INFO;  //启用的预置点信息
    struCruiseChanInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_CRUISECHAN_INFO;  //启用巡航功能通道的信息
    struPtzTrackInfo: array[0..MAX_CHANNUM_V40-1] of NET_DVR_PTZTRACKCHAN_INFO;  //调用云台的通道信息
    byDirection: BYTE;  //触发方向：0-保留；1-全部；2-正向；3-反向
    byRes2: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_TRIGGER = ^NET_DVR_EVENT_TRIGGER;

type
  NET_DVR_EVENT_SCHEDULE = record 
    dwSize: DWORD;  //结构体大小
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHolidayAlarmTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间
    bySceneID: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of BYTE;  //场景号,目前支持1~4场景，0为无效。该场景号与布防时间中每个时间段一一对应。
    byRes: array[0..72-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_SCHEDULE = ^NET_DVR_EVENT_SCHEDULE;

type
  NET_DVR_ANR_ARMING_HOST = record 
    dwSize: DWORD;  //sizeof(NET_DVR_ANR_ ARMING_HOST)
    struANRArmingHostIpAddr: NET_DVR_IPADDR;  //断网续传的主机IP地址
    wANRAlarmHostPort: WORD;  //断网续传的主机布防端口号
    byANRAlarmType: BYTE;  //断网续传连接类型， 0-SDK私有断网续传连接，1-ehome断网续传连接
    byConfirmMechanismEnabled: BYTE;  // 是否开启确认机制方式布防连接，0-保留，1-没有开启 2-开启
    byRes: array[0..512-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_ANR_ARMING_HOST = ^NET_DVR_ANR_ARMING_HOST;

type
  NET_DVR_REGIONEXITING_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byAlarmConfidence: BYTE;  //报警置信度, 0-低,1-较低,2-较高,3-高
    byRecordConfidence: BYTE;  //录像置信度, 0-低,1-较低,2-较高,3-高
    byRes: array[0..60-1] of BYTE;  //保留
  end;
  LPNET_DVR_REGIONEXITING_REGION = ^NET_DVR_REGIONEXITING_REGION;

type
  NET_DVR_REGION_EXITING_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byEnableHumanMisinfoFilter: BYTE;  // 启用人体去误报 0-不启用，1-启用
    byEnableVehicleMisinfoFilter: BYTE;  // 启用车辆去误报 0-不启用，1-启用
    byRes1: array[0..1-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_REGIONEXITING_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_REGION_EXITING_DETECTION = ^NET_DVR_REGION_EXITING_DETECTION;

type
  NET_DVR_LOITERING_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byTimeThreshold: BYTE;  //时间阈值，范围[0-10]，单位：s
    byRes: array[0..62-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOITERING_REGION = ^NET_DVR_LOITERING_REGION;

type
  NET_DVR_LOITERING_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_LOITERING_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LOITERING_DETECTION = ^NET_DVR_LOITERING_DETECTION;

type
  NET_DVR_GROUPDETECTION_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    byObjectOccup: BYTE;  //占比，范围[1-100]
    bySensitivityLevel: BYTE;  //灵敏度，范围1-100，默认65
    byDurationTime: BYTE;  //持续时间，范围1-600秒，默认3秒
    byFilterTime: BYTE;  //过滤时间，范围1-10分钟（表示，触发报警后，在此时间内不再触发报警）
    byMinTriggerNumber: BYTE;  //最低触发人数，范围2-50人，默认5人
    byLinkageTime: BYTE;  //联动球机检测时间，范围5-30秒，默认5秒（枪机触发后，联动球机转到触发报警的位置后停留的时间，该配置不区分枪机球机是否同一个账户登录，可以不同）
    byRes: array[0..58-1] of BYTE;  //保留
  end;
  LPNET_DVR_GROUPDETECTION_REGION = ^NET_DVR_GROUPDETECTION_REGION;
type
  NET_DVR_POS_HIDDEN_INFORMATION = record 
    szKeyWord: array[0..KEY_WORD_NUM{3}-1, 0..KEY_WORD_LEN{128}-1] of AnsiChar;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_POS_HIDDEN_INFORMATION = ^NET_DVR_POS_HIDDEN_INFORMATION;

type
  NET_DVR_HIDDEN_INFORMATION_CFG = record 
    dwSize: DWORD;  
    byFuncType: BYTE;  //0-Pos功能
    Res1: array[0..3-1] of BYTE;  
    struPosInfo: NET_DVR_POS_HIDDEN_INFORMATION;  
    byRes: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_HIDDEN_INFORMATION_CFG = ^NET_DVR_HIDDEN_INFORMATION_CFG;

type
  NET_DVR_GROUP_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_GROUPDETECTION_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_GROUP_DETECTION = ^NET_DVR_GROUP_DETECTION;

type
  NET_DVR_RAPIDMOVE_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    {
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    }
    byDetectionTarget: BYTE;  
    byRes: array[0..62-1] of BYTE;  //保留
  end;
  LPNET_DVR_RAPIDMOVE_REGION = ^NET_DVR_RAPIDMOVE_REGION;

type
  NET_DVR_RAPIDMOVE_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_RAPIDMOVE_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_RAPIDMOVE_DETECTION = ^NET_DVR_RAPIDMOVE_DETECTION;

type
  NET_DVR_PARKING_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byTimeThreshold: BYTE;  //时间阈值，范围[0-10]，单位：s
    byRes: array[0..62-1] of BYTE;  //保留
  end;
  LPNET_DVR_PARKING_REGION = ^NET_DVR_PARKING_REGION;

type
  NET_DVR_PARKING_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_PARKING_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PARKING_DETECTION = ^NET_DVR_PARKING_DETECTION;

type
  NET_DVR_UNATTENDED_BAGGAGE_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byTimeThreshold: BYTE;  //时间阈值，范围[0-10]，单位：s
    wTimeThreshold: WORD;  //时间阈值，范围[5-3600], 单位：s
    byTimeThresholdMode: BYTE;  //(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    byRes: array[0..59-1] of BYTE;  //保留留
  end;
  LPNET_DVR_UNATTENDED_BAGGAGE_REGION = ^NET_DVR_UNATTENDED_BAGGAGE_REGION;

type
  NET_DVR_UNATTENDED_BAGGAGE_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_UNATTENDED_BAGGAGE_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION = ^NET_DVR_UNATTENDED_BAGGAGE_DETECTION;

type
  NET_DVR_ATTENDED_BAGGAGE_REGION = record 
    struRegion: NET_VCA_POLYGON;  //区域范围
    bySensitivity: BYTE;  //灵敏度参数，范围[1-100]
    byTimeThreshold: BYTE;  //时间阈值，范围[0-10]，单位：s
    wTimeThreshold: WORD;  //时间阈值，范围[5-3600], 单位：s
    byTimeThresholdMode: BYTE;  //(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    byRes: array[0..59-1] of BYTE;  //保留
  end;
  LPNET_DVR_ATTENDED_BAGGAGE_REGION = ^NET_DVR_ATTENDED_BAGGAGE_REGION;

type
  NET_DVR_ATTENDED_BAGGAGE_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..MAX_REGION_NUM-1] of NET_DVR_ATTENDED_BAGGAGE_REGION;  
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ATTENDED_BAGGAGE_DETECTION = ^NET_DVR_ATTENDED_BAGGAGE_DETECTION;

type
  NET_DVR_REGION_CLIP_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    dwStreamType: DWORD;  //码流类型：0- 主码流，1- 子码流，2- 第三码流
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_REGION_CLIP_COND = ^NET_DVR_REGION_CLIP_COND;

type
  NET_DVR_REGION_CLIP_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    wResolutionWidth: WORD;  //分辨率的长
    wResolutionHeight: WORD;  //分辨率的宽
    struRegion: array[0..MAX_REGION_NUM-1] of NET_VCA_POLYGON;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_REGION_CLIP_CFG = ^NET_DVR_REGION_CLIP_CFG;

const
  MAX_DIALNUM_LENGTH = 32;    
type
  NET_DVR_WIRELESSDIAL_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否启用无线拨号：0-否，1- 是
    byDialMode: BYTE;  // 0-自动（Auto）、1-手动（Manual），默认自动，手动模式下可设置拨号计划、下线时间、手动拨号
    byNetworkMode: BYTE;  //0-自动，1-4G优先，2-3G优先，3-手动切换2G，4-手动切换3G，5-手动切换4G，6-有线优先
    byRes1: BYTE;  
    byDialNum: array[0..MAX_DIALNUM_LENGTH-1] of BYTE;  //拨号号码
    byUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    byPassword: array[0..NAME_LEN-1] of BYTE;  //密码
    byAPNName: array[0..NAME_LEN-1] of BYTE;  //APN
    byUIMCardNum: array[0..NAME_LEN-1] of BYTE;  //手机号码
    byVerifProtocol: BYTE;  // 0-自动（Auto），1-CHAP，2-PAP
    byRes2: BYTE;  
    wMTU: WORD;  //MTU
    dwOffineTime: DWORD;  //下线时间，30-65535，单位秒，手动模式下有效
    byNetAPN: array[0..NAME_LEN-1] of BYTE;  //私有专网APN字段配置
    byEnabled4G: BYTE;  //是否开启4G功能：0-否，1- 是
    byEnabledDNS: BYTE;  //是否开启DNS功能：0-否，1- 是
    byRes3: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSDIAL_CFG = ^NET_DVR_WIRELESSDIAL_CFG;

type
  NET_DVR_WIRELESSDIAL_SCHEDULE = record 
    dwSize: DWORD;  //结构体大小
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //布防时间
    struHolidayAlarmTime: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //假日布防时间段
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSDIAL_SCHEDULE = ^NET_DVR_WIRELESSDIAL_SCHEDULE;

const
  MAX_LENGTH_32 = 32;    
type
  NET_DVR_WIRELESSDIAL_STATUS = record 
    dwSize: DWORD;  //结构体大小
    byRealtimeMode: array[0..MAX_LENGTH_32-1] of BYTE;  //实时模式(CDMA 1x、EVDO、HYBRID、GSM、GPRS、EDGE、WCDMA、HSDPA、HSUPA、HSPA、TDSCDMA、TD-LTE、FDD-LTE)
    byUIMStatus: array[0..MAX_LENGTH_32-1] of BYTE;  {UIM状态(UNKNOWN-未知,VALID-有效,NOVALID-无效,ROAM-漫游,NOEXIST-不存在,
                                                WRONGPINCODE-PIN码错误,NONETWORKSERVICE-无网络服务,
                                                ONLYSUPPORTEMERGENCYCALL-网络仅支持紧急呼叫，PINCODELOCKED―PIN码锁定}
    dwSignalQuality: DWORD;  //信号质量，1-5
    byDialStatus: array[0..MAX_LENGTH_32-1] of BYTE;  {拨号状态码(disconnect-拨号断开,dialing-正在拨号,success-拨号成功,shmError-拨号异常,
                                                 certificationFailure-认证失败,invalidDialingCharacters-拨号字符无效,
                                                 networkTimeout C网络超时,wirelessModemError―无线模块错误,SIMError---SIM卡错误,,networkError-网络错误，unknown C未知错误)}
    struIpAddr: NET_DVR_IPADDR;  //IP地址
    struIPMask: NET_DVR_IPADDR;  //掩码地址
    struGatewayIPMask: NET_DVR_IPADDR;  //网关地址
    struDnsServerIpAddr: NET_DVR_IPADDR;  //DNS地址
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSDIAL_STATUS = ^NET_DVR_WIRELESSDIAL_STATUS;

type
  NET_DVR_WIRELESSDIAL_CONNECT_PARAM = record 
    dwSize: DWORD;  //结构体大小
    dwInterface: DWORD;  //网卡编号，1,2……
    byEnableConnect: BYTE;  //是否连网，0-断网，1-连网
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM = ^NET_DVR_WIRELESSDIAL_CONNECT_PARAM;


type
  NET_DVR_LITESTORAGE = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //使能 0-不启用,1-启用
    byStorageTime: BYTE;  //存储时间 1-30 默认7天
    byLevel: BYTE;  //等级参数，0-无效值（保留），1-低，2-中(默认)，3-高；
    byRes: BYTE;  
    fCapacity: FLOAT;  //可用SD卡录像空间，只读
    byDefLowStorageTime: BYTE;  // 低模式下推荐天数 只读
    byDefMediumStorageTime: BYTE;  // 中模式下推荐天数 只读
    byDefHighStorageTime: BYTE;  // 高模式下推荐天数 只读
    byRes1: array[0..61-1] of BYTE;  
  end;
  LPNET_DVR_LITESTORAGE = ^NET_DVR_LITESTORAGE;

type
  NET_DVR_CALIBRATION = record 
    dwSize: DWORD;  //结构体大小
    struRegion: NET_VCA_POLYGON;  //标定区域
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CALIBRATION = ^NET_DVR_CALIBRATION;

type
  NET_DVR_STD_CONFIG = record 
    lpCondBuffer: PVOID;  //[in]条件参数(结构体格式),例如通道号等.可以为NULL
    dwCondSize: DWORD;  //[in] lpCondBuffer指向的内存大小
    lpInBuffer: PVOID;  //[in]输入参数(结构体格式),设置时不为NULL，获取时为NULL
    dwInSize: DWORD;  //[in] lpInBuffer指向的内存大小
    lpOutBuffer: PVOID;  //[out]输出参数(结构体格式),获取时不为NULL,设置时为NULL
    dwOutSize: DWORD;  //[in] lpOutBuffer指向的内存大小
    lpStatusBuffer: PVOID;  //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    dwStatusSize: DWORD;  //[in] lpStatusBuffer指向的内存大小
    lpXmlBuffer: PVOID;  //[in/out]byDataType = 1时有效,xml格式数据
    dwXmlSize: DWORD;  //[in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
    byDataType: BYTE;  //[in]输入/输出参数类型,0-使用结构体类型lpInBuffer/lpOutBuffer有效,1-使用XML类型lpXmlBuffer有效
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_STD_CONFIG = ^NET_DVR_STD_CONFIG;

type
  NET_DVR_STD_ABILITY = record 
    lpCondBuffer: PVOID;  //[in]条件参数(码字格式),例如通道号等.可以为NULL
    dwCondSize: DWORD;  //[in] dwCondSize指向的内存大小
    lpOutBuffer: PVOID;  //[out]输出参数(XML格式),不为NULL
    dwOutSize: DWORD;  //[in] lpOutBuffer指向的内存大小
    lpStatusBuffer: PVOID;  //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    dwStatusSize: DWORD;  //[in] lpStatusBuffer指向的内存大小
    dwRetSize: DWORD;  //[out]获取到的数据长度(lpOutBuffer或者lpStatusBuffer指向的实际数据长度)
    byRes: array[0..32-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_STD_ABILITY = ^NET_DVR_STD_ABILITY;

type
  NET_DVR_STD_CONTROL = record 
    lpCondBuffer: PVOID;  //[in]条件参数(码字格式),例如通道号等.可以为NULL
    dwCondSize: DWORD;  //[in] dwCondSize指向的内存大小
    lpStatusBuffer: PVOID;  //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    dwStatusSize: DWORD;  //[in] lpStatusBuffer指向的内存大小
    lpXmlBuffer: PVOID;  //[in/out]byDataType = 1时有效,xml格式数据
    dwXmlSize: DWORD;  //[in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
    byDataType: BYTE;  //[in]输入/输出参数类型,0-使用结构体类型lpCondBuffer有效,1-使用XML类型lpXmlBuffer有效
    byRes: array[0..55-1] of BYTE;  
  end;
  LPNET_DVR_STD_CONTROL = ^NET_DVR_STD_CONTROL;

//  MAX_FILE_PATH_LEN = 256;    //文件路径长度
type
  NET_DVR_MIME_UNIT = record 

    //格式如下
    //Content-Disposition: form-data; name="upload"; filename="C:\Users\test\Desktop\11.txt"
    //Content-Type: text/plain
    szContentType: array[0..32-1] of AnsiChar;  //对应Content-Type
    szName: array[0..MAX_FILE_PATH_LEN-1] of AnsiChar;  //对应name字段
    szFilename: array[0..MAX_FILE_PATH_LEN-1] of AnsiChar;  //对应filename字段
    dwContentLen: DWORD;  //Content的长度，大小限制512K以内
    pContent: PAnsiChar;  //数据指针
    bySelfRead: BYTE;  // 0-外界传入文件 1-内部读取数据（通过szFilename传递完整路径），下发数据时该字段生效，获取数据时无效
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_MIME_UNIT = ^NET_DVR_MIME_UNIT;

type
  NET_DVR_MIME_DATA = record 
    byContentType: BYTE;  //文件类型 0-无效, 1-json, 2-bmp
    byRes1: array[0..3-1] of BYTE;  //保留
    lpContent: PVOID;  //文件内容，如果指针为空，表示无文件
    dwContentSize: DWORD;  //文件内容大小，大小限制为512k以内
    sContentID: array[0..32-1] of AnsiChar;  //表单格式中Content-ID头域的值，与ISAPI报文中特定节点值一一对应
    byRes: array[0..512-1] of BYTE;  //保留
  end;
  LPNET_DVR_MIME_DATA = ^NET_DVR_MIME_DATA;

type
  NET_DVR_XML_CONFIG_INPUT = record 
    dwSize: DWORD;  //结构体大小
    lpRequestUrl: PVOID;  //请求信令，字符串格式
    dwRequestUrlLen: DWORD;  //请求信令长度，字符串长度
    lpInBuffer: PVOID;  //输入参数缓冲区，XML格式
    dwInBufferSize: DWORD;  //输入参数缓冲区大小
    dwRecvTimeOut: DWORD;  //接收超时时间，单位：ms，填0则使用默认超时5s
    byForceEncrpt: BYTE;  //是否强制加密，0-否，1-是
    byNumOfMultiPart: BYTE;  //0-无效，其他值表示报文分段个数，非零时lpInBuffer传入的是NET_DVR_MIME_UNIT结构体数组的指针，该值即代表结构体个数
    byMIMEType: BYTE;  //0-无效，1-表示使用NET_DVR_MIME_UNIT结构体，2-表示使用NET_DVR_MIME_DATA结构体，该字段仅在byNumOfMultiPart有效时生效
    byRes1: BYTE;  
    dwSendTimeOut: DWORD;  //发送超时时间，单位：ms，填0则使用默认超时5s
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_XML_CONFIG_INPUT = ^NET_DVR_XML_CONFIG_INPUT;

type
  NET_DVR_XML_CONFIG_OUTPUT = record 
    dwSize: DWORD;  //结构体大小
    lpOutBuffer: PVOID;  //输出参数缓冲区，XML格式
    dwOutBufferSize: DWORD;  //输出参数缓冲区大小(内存大小)
    dwReturnedXMLSize: DWORD;  //实际输出的XML内容大小
    lpStatusBuffer: PVOID;  //返回的状态参数(XML格式),获取命令成功时不会赋值,如果不需要,可以置NULL
    dwStatusSize: DWORD;  //状态缓冲区大小(内存大小)
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    lpDataBuffer: PVOID;  //当byNumOfMultiPart>0时，配合报文结构体使用，存放透传数据内容，通过NET_DVR_MIME_UNIT的dwContentLen偏移访问
{$ELSE}
    lpDataBuffer: PVOID;  //当byNumOfMultiPart>0时，配合报文结构体使用，存放透传数据内容，通过NET_DVR_MIME_UNIT的dwContentLen偏移访问
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    byNumOfMultiPart: BYTE;  //0-无效。 其他值表示报文分段个数，非零时lpInBuffer传入的是NET_DVR_MIME_UNIT结构体数组的指针，该值即代表结构体个数。
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_XML_CONFIG_OUTPUT = ^NET_DVR_XML_CONFIG_OUTPUT;

type
  NET_DVR_FORM_DATA_CFG = record 
    dwSize: DWORD;  //结构体大小
    lpBuffer: PVOID;  //数据缓冲区，指向NET_DVR_MIME_DATA结构体数组
    dwBufferSize: DWORD;  //数据缓冲区大小
    byNumOfMultiPart: BYTE;  // 0-无效，其他值表示报文分段个数，非零时lpBuffer传入的是NET_DVR_MIME_DATA结构体数组的指针，该值即代表结构体个数，限制最多为3个
    byRes: array[0..67-1] of BYTE;  //保留
  end;
  LPNET_DVR_FORM_DATA_CFG = ^NET_DVR_FORM_DATA_CFG;

type
  NET_DVR_JSON_DATA_CFG = record 
    dwSize: DWORD;  //结构体大小
    lpJsonData: PVOID;  //JSON报文
    dwJsonDataSize: DWORD;  //JSON报文大小
    lpPicData: PVOID;  //图片内容
    dwPicDataSize: DWORD;  //图片内容大小
    dwInfraredFacePicSize: DWORD;  //红外人脸图片数据大小，等于0时，代表无人脸图片数据(当JSON报文为当ResponseStatus（JSON）报文时，该字段无意义；当Inbound Data（JSON）报文中没有infraredFaceURL时，该字段需要带上二进制图片内容）
    lpInfraredFacePicBuffer: PVOID;  //红外人脸图片数据缓存
    byRes: array[0..248-1] of BYTE;  //保留
  end;
  LPNET_DVR_JSON_DATA_CFG = ^NET_DVR_JSON_DATA_CFG;

type
  NET_DVR_SIMPLE_DAYTIME = record 
    byHour: BYTE;  //时
    byMinute: BYTE;  //分
    bySecond: BYTE;  //秒
    byRes: BYTE;  
  end;
  LPNET_DVR_SIMPLE_DAYTIME = ^NET_DVR_SIMPLE_DAYTIME;

type
  NET_DVR_TIME_SEGMENT = record 
    struBeginTime: NET_DVR_SIMPLE_DAYTIME;  //开始时间点
    struEndTime: NET_DVR_SIMPLE_DAYTIME;  //结束时间点
  end;
  LPNET_DVR_TIME_SEGMENT = ^NET_DVR_TIME_SEGMENT;

type
  NET_DVR_SINGLE_PLAN_SEGMENT = record 
    byEnable: BYTE;  //是否使能，1-使能，0-不使能
    byDoorStatus: BYTE;  //门状态模式（梯控模式），0-无效，1-休眠，2-常开状态（自由），3-常闭状态（禁用），4-普通状态（门状态计划使用）
    byVerifyMode: BYTE;  //验证方式，0-无效，1-刷卡，2-刷卡+密码(读卡器验证方式计划使用)，3-刷卡,4-刷卡或密码(读卡器验证方式计划使用), 5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码（无先后顺序），10-人脸或指纹或刷卡或密码，11-人脸+指纹，
    //12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡,23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸,26-刷卡或人脸或指纹,
    //27-刷卡或指纹或密码,28-人脸或密码,29-工号+人脸+密码,30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    byRes: array[0..5-1] of BYTE;  
    struTimeSegment: NET_DVR_TIME_SEGMENT;  //时间段参数
  end;
  LPNET_DVR_SINGLE_PLAN_SEGMENT = ^NET_DVR_SINGLE_PLAN_SEGMENT;

type
  NET_DVR_WEEK_PLAN_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否使能，1-使能，0-不使能
    byRes1: array[0..3-1] of BYTE;  
    struPlanCfg: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SINGLE_PLAN_SEGMENT;  //周计划参数
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_WEEK_PLAN_CFG = ^NET_DVR_WEEK_PLAN_CFG;

type
  NET_DVR_HOLIDAY_PLAN_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否使能，1-使能，0-不使能
    byRes1: array[0..3-1] of BYTE;  
    struBeginDate: NET_DVR_DATE;  //假日开始日期
    struEndDate: NET_DVR_DATE;  //假日结束日期
    struPlanCfg: array[0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SINGLE_PLAN_SEGMENT;  //时间段参数
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_HOLIDAY_PLAN_CFG = ^NET_DVR_HOLIDAY_PLAN_CFG;

type
  NET_DVR_HOLIDAY_PLAN_COND = record 
    dwSize: DWORD;  
    dwHolidayPlanNumber: DWORD;  //假日计划编号
    wLocalControllerID: WORD;  //就地控制器序号[1,64]
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_HOLIDAY_PLAN_COND = ^NET_DVR_HOLIDAY_PLAN_COND;

type
  NET_DVR_WEEK_PLAN_COND = record 
    dwSize: DWORD;  
    dwWeekPlanNumber: DWORD;  //周计划编号
    wLocalControllerID: WORD;  //就地控制器序号[1,64]
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_WEEK_PLAN_COND = ^NET_DVR_WEEK_PLAN_COND;

type
  NET_DVR_HOLIDAY_GROUP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，1-启用，0-不启用
    byRes1: array[0..3-1] of BYTE;  
    byGroupName: array[0..HOLIDAY_GROUP_NAME_LEN-1] of BYTE;  //假日组名称
    dwHolidayPlanNo: array[0..MAX_HOLIDAY_PLAN_NUM-1] of DWORD;  //假日计划编号，就前填充，遇0无效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_HOLIDAY_GROUP_CFG = ^NET_DVR_HOLIDAY_GROUP_CFG;

type
  NET_DVR_HOLIDAY_GROUP_COND = record 
    dwSize: DWORD;  
    dwHolidayGroupNumber: DWORD;  //假日组编号
    wLocalControllerID: WORD;  //就地控制器序号[1,64]
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_HOLIDAY_GROUP_COND = ^NET_DVR_HOLIDAY_GROUP_COND;

type
  NET_DVR_PLAN_TEMPLATE = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，1-启用，0-不启用
    byRes1: array[0..3-1] of BYTE;  
    byTemplateName: array[0..TEMPLATE_NAME_LEN-1] of BYTE;  //模板名称
    dwWeekPlanNo: DWORD;  //周计划编号，0为无效
    dwHolidayGroupNo: array[0..MAX_HOLIDAY_GROUP_NUM-1] of DWORD;  //假日组编号，就前填充，遇0无效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_TEMPLATE = ^NET_DVR_PLAN_TEMPLATE;

type
  NET_DVR_PLAN_TEMPLATE_COND = record 
    dwSize: DWORD;  
    dwPlanTemplateNumber: DWORD;  //计划模板编号，从1开始，最大值从门禁能力集获取
    wLocalControllerID: WORD;  //就地控制器序号[1,64]，0无效
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_TEMPLATE_COND = ^NET_DVR_PLAN_TEMPLATE_COND;

type
  NET_DVR_DOOR_STATUS_PLAN = record 
    dwSize: DWORD;  
    dwTemplateNo: DWORD;  //计划模板编号，为0表示取消关联，恢复默认状态（普通状态）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DOOR_STATUS_PLAN = ^NET_DVR_DOOR_STATUS_PLAN;

type
  NET_DVR_CARD_READER_PLAN = record 
    dwSize: DWORD;  
    dwTemplateNo: DWORD;  //计划模板编号，为0表示取消关联，恢复默认状态（刷卡开门）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CARD_READER_PLAN = ^NET_DVR_CARD_READER_PLAN;

type
  NET_DVR_GROUP_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    struValidPeriodCfg: NET_DVR_VALID_PERIOD_CFG;  //群组有效期参数
    byGroupName: array[0..GROUP_NAME_LEN-1] of BYTE;  //群组名称
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_GROUP_CFG = ^NET_DVR_GROUP_CFG;

type
  NET_DVR_GROUP_COMBINATION_INFO = record 
    byEnable: BYTE;  //是否启用该群组组合
    byMemberNum: BYTE;  //刷卡成员数量
    bySequenceNo: BYTE;  //群组刷卡次序号
    byRes: BYTE;  
    dwGroupNo: DWORD;  //群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
  end;
  LPNET_DVR_GROUP_COMBINATION_INFO = ^NET_DVR_GROUP_COMBINATION_INFO;

type
  NET_DVR_MULTI_CARD_GROUP_CFG = record 
    byEnable: BYTE;  //是否启用该多重卡组参数，0-不启用，1-启用
    byEnableOfflineVerifyMode: BYTE;  //是否启用主机离线时验证方式（超级密码代替远程开门）
    byRes1: array[0..2-1] of BYTE;  
    dwTemplateNo: DWORD;  //启用多重卡功能的计划模板编号
    struGroupCombination: array[0..GROUP_COMBINATION_NUM-1] of NET_DVR_GROUP_COMBINATION_INFO;  //群组组合参数
  end;
  LPNET_DVR_MULTI_CARD_GROUP_CFG = ^NET_DVR_MULTI_CARD_GROUP_CFG;

type
  NET_DVR_MULTI_CARD_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用多重卡功能，0-不启用，1-启用
    bySwipeIntervalTimeout: BYTE;  //刷卡间隔超时时间，1-255s，默认10s
    byRes1: array[0..2-1] of BYTE;  
    struGroupCfg: array[0..MULTI_CARD_GROUP_NUM-1] of NET_DVR_MULTI_CARD_GROUP_CFG;  //群组刷卡参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_CARD_CFG = ^NET_DVR_MULTI_CARD_CFG;

type
  NET_DVR_GROUP_COMBINATION_INFO_V50 = record 
    byEnable: BYTE;  //是否启用该群组组合
    byMemberNum: BYTE;  //刷卡成员数量
    bySequenceNo: BYTE;  //群组刷卡次序号
    byRes: BYTE;  
    dwGroupNo: DWORD;  //群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
  end;
  LPNET_DVR_GROUP_COMBINATION_INFO_V50 = ^NET_DVR_GROUP_COMBINATION_INFO_V50;

type
  NET_DVR_MULTI_CARD_GROUP_CFG_V50 = record 
    byEnable: BYTE;  //是否启用该多重卡组参数，0-不启用，1-启用
    byEnableOfflineVerifyMode: BYTE;  //是否启用主机离线时验证方式（超级密码代替远程开门），1-启用，0-不启用
    byRes1: array[0..2-1] of BYTE;  
    dwTemplateNo: DWORD;  //启用多重卡功能的计划模板编号
    struGroupCombination: array[0..GROUP_COMBINATION_NUM-1] of NET_DVR_GROUP_COMBINATION_INFO_V50;  //群组组合参数
  end;
  LPNET_DVR_MULTI_CARD_GROUP_CFG_V50 = ^NET_DVR_MULTI_CARD_GROUP_CFG_V50;

type
  NET_DVR_MULTI_CARD_CFG_V50 = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用多重卡功能，0-不启用，1-启用
    bySwipeIntervalTimeout: BYTE;  //刷卡间隔超时时间，1-255s，默认10s
    byRes1: array[0..2-1] of BYTE;  
    struGroupCfg: array[0..NET_SDK_MULTI_CARD_GROUP_NUM_20-1] of NET_DVR_MULTI_CARD_GROUP_CFG_V50;  //群组刷卡参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_CARD_CFG_V50 = ^NET_DVR_MULTI_CARD_CFG_V50;

//2014-12-03  T1测试状态结构体
type
  NET_DVR_T1TEST_PARAMCFG = record 
    dwSize: DWORD;  //结构体大小
    wPort: WORD;  //端口号
    //(设备通过端口控制（端口号设备端固定，上层不做配置），开始单独socket连接，单独交互T1测试内容，走XML格式)
    //0- 关闭(关闭设备的连接线程，释放端口)，1- 开启(设备内部单独起连接线程)
    byPortState: BYTE;  
    byRes: array[0..61-1] of BYTE;  //保留
  end;
  LPNET_DVR_T1TEST_PARAMCFG = ^NET_DVR_T1TEST_PARAMCFG;

//  CARD_PARAM_CARD_VALID = $00000001;    //卡是否有效参数
//  CARD_PARAM_VALID = $00000002;    //有效期参数
//  CARD_PARAM_CARD_TYPE = $00000004;    //卡类型参数
//  CARD_PARAM_DOOR_RIGHT = $00000008;    //门权限参数
//  CARD_PARAM_LEADER_CARD = $00000010;    //首卡参数
//  CARD_PARAM_SWIPE_NUM = $00000020;    //最大刷卡次数参数
//  CARD_PARAM_GROUP = $00000040;    //所属群组参数
//  CARD_PARAM_PASSWORD = $00000080;    //卡密码参数
//  CARD_PARAM_RIGHT_PLAN = $00000100;    //卡权限计划参数
//  CARD_PARAM_SWIPED_NUM = $00000200;    //已刷卡次数
const
  CARD_PARAM_EMPLOYEE_NO = $00000400;    //工号
  CARD_PARAM_NAME = $00000800;    //姓名
  CARD_PARAM_DEPARTMENT_NO = $00001000;    //部门编号
  CARD_SCHEDULE_PLAN_NO = $00002000;    //排班计划编号
  CARD_SCHEDULE_PLAN_TYPE = $00004000;    //排班计划类型
  CARD_ROOM_NUMBER = $00008000;    //房间号
  CARD_SIM_NO = $00010000;    //SIM卡号（手机号）
  CARD_FLOOR_NUMBER = $00020000;    //楼层号
  CARD_USER_TYPE = $00040000;    //用户类型

type
  NET_DVR_ANTI_SNEAK_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能反潜回功能，1-使能，0-不使能
    byRes1: array[0..3-1] of BYTE;  
    dwStartCardReaderNo: DWORD;  //反潜回起始读卡器编号
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ANTI_SNEAK_CFG = ^NET_DVR_ANTI_SNEAK_CFG;

type
  NET_DVR_CARD_READER_ANTI_SNEAK_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否加入反潜回路径，1-加入，0-不加入
    byRes1: array[0..3-1] of BYTE;  
    dwFollowUpCardReader: array[0..MAX_SNEAK_PATH_NODE-1] of DWORD;  //后续读卡器编号，为0表示不关注起始读卡器编号
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG = ^NET_DVR_CARD_READER_ANTI_SNEAK_CFG;

type
  NET_DVR_PHONE_DOOR_RIGHT_CFG = record 
    dwSize: DWORD;  
    byOpenRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否有开门权限，-无权限，-有权限
    byCloseRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否有关门权限，-无权限，-有权限
    byNormalOpenRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否有常开权限，-无权限，-有权限
    byNormalCloseRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否有常闭权限，-无权限，-有权限
    byArmRight: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //按数组表示,是否有布防权限，-无权限，-有权限
    byDisarmRight: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //按数组表示,是否有撤防权限，-无权限，-有权限
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_PHONE_DOOR_RIGHT_CFG = ^NET_DVR_PHONE_DOOR_RIGHT_CFG;

type
  NET_DVR_MULTI_DOOR_INTERLOCK_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用多门互锁功能，1-启用，0-不启用
    byRes1: array[0..3-1] of BYTE;  
    dwMultiDoorGroup: array[0..MAX_MULTI_DOOR_INTERLOCK_GROUP-1, 0..MAX_INTER_LOCK_DOOR_NUM-1] of DWORD;  //多门互锁组参数，取值为门编号
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG = ^NET_DVR_MULTI_DOOR_INTERLOCK_CFG;

type
  NET_DVR_CARD_READER_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否使能，1-使能，0-不使能
    byCardReaderType: BYTE;  //读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线,8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A
                            //11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，
                            //21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP
                            //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C，36-DS-K1T803F/MF/SF/EF，37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
                            //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    byOkLedPolarity: BYTE;  //OK LED极性，0-阴极，1-阳极
    byErrorLedPolarity: BYTE;  //Error LED极性，0-阴极，1-阳极
    byBuzzerPolarity: BYTE;  //蜂鸣器极性，0-阴极，1-阳极
    bySwipeInterval: BYTE;  //重复刷卡间隔时间，单位：秒
    byPressTimeout: BYTE;  //按键超时时间，单位：秒
    byEnableFailAlarm: BYTE;  //是否启用读卡失败超次报警，0-不启用，1-启用
    byMaxReadCardFailNum: BYTE;  //最大读卡失败次数
    byEnableTamperCheck: BYTE;  //是否支持防拆检测，0-disable ，1-enable
    byOfflineCheckTime: BYTE;  //掉线检测时间 单位秒
    byFingerPrintCheckLevel: BYTE;  //指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    byUseLocalController: BYTE;  //只读，是否连接在就地控制器上，0-否，1-是
    byRes1: BYTE;  
    wLocalControllerID: WORD;  //只读，就地控制器序号，1-64,0代表未注册
    wLocalControllerReaderID: WORD;  //只读，就地控制器的读卡器ID，0代表未注册
    wCardReaderChannel: WORD;  //只读，读卡器通信通道号，0韦根或离线，1-RS485A,2-RS485B
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_CARD_READER_CFG = ^NET_DVR_CARD_READER_CFG;

type
  NET_DVR_CARD_READER_CFG_V50 = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否使能，1-使能，0-不使能
    byCardReaderType: BYTE;  //读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线，8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A，11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP，33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/F-M/F-S/F-E,37-DS-K1A801F/F-M/F-S/F-E,38-DS-K1107M/MK,39-DS-K1107E/EK,40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    byOkLedPolarity: BYTE;  //OK LED极性，0-阴极，1-阳极
    byErrorLedPolarity: BYTE;  //Error LED极性，0-阴极，1-阳极
    byBuzzerPolarity: BYTE;  //蜂鸣器极性，0-阴极，1-阳极
    bySwipeInterval: BYTE;  //重复刷卡间隔时间，单位：秒
    byPressTimeout: BYTE;  //按键超时时间，单位：秒
    byEnableFailAlarm: BYTE;  //是否启用读卡失败超次报警，0-不启用，1-启用
    byMaxReadCardFailNum: BYTE;  //最大读卡失败次数
    byEnableTamperCheck: BYTE;  //是否支持防拆检测，0-disable ，1-enable
    byOfflineCheckTime: BYTE;  //掉线检测时间 单位秒
    byFingerPrintCheckLevel: BYTE;  //指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure（目前门禁不支持）
    byUseLocalController: BYTE;  //只读，是否连接在就地控制器上，0-否，1-是
    byRes1: BYTE;  
    wLocalControllerID: WORD;  //只读，就地控制器序号, byUseLocalController=1时有效，1-64,0代表未注册
    wLocalControllerReaderID: WORD;  //只读，就地控制器的读卡器ID，byUseLocalController=1时有效，0代表未注册
    wCardReaderChannel: WORD;  //只读，读卡器通信通道号，byUseLocalController=1时有效，0韦根或离线，1-RS485A,2-RS485B
    byFingerPrintImageQuality: BYTE;  //指纹图像质量，0-无效，1-低质量(V1)，2-中等质量(V1)，3-高质量(V1)，4-最高质量(V1)，5-低质量(V2)，6-中等质量(V2)，7-高质量(V2)，8-最高质量(V2)
    byFingerPrintContrastTimeOut: BYTE;  //指纹对比超时时间，0-无效，范围1-20代表:1s-20s，0xff-无限大
    byFingerPrintRecogizeInterval: BYTE;  //指纹连续识别间隔，0-无效，范围1-10代表:1s-10s，0xff-无延迟
    byFingerPrintMatchFastMode: BYTE;  //指纹匹配快速模式，0-无效，范围1-5代表:快速模式1-快速模式5，0xff-自动
    byFingerPrintModuleSensitive: BYTE;  //指纹模组灵敏度，0-无效，范围1-8代表：灵敏度级别1-灵敏度级别8
    byFingerPrintModuleLightCondition: BYTE;  //指纹模组光线条件，0-无效，1-室外，2-室内
    byFaceMatchThresholdN: BYTE;  //人脸比对阀值，范围0-100
    byFaceQuality: BYTE;  //人脸质量，范围0-100
    byFaceRecogizeTimeOut: BYTE;  //人脸识别超时时间，范围1-20代表：1s-20s，0xff-无限大
    byFaceRecogizeInterval: BYTE;  //人脸连续识别间隔，0-无效，范围1-10代表：1s-10s，0xff-无延迟
    wCardReaderFunction: WORD;  //只读，读卡器种类，按位表示：第1位-指纹，第二位-人脸，第三位-指静脉，第四位-虹膜
    byCardReaderDescription: array[0..CARD_READER_DESCRIPTION-1] of BYTE;  //读卡器描述
    wFaceImageSensitometry: WORD;  //只读，人脸图像曝光度，范围0-65535
    byLivingBodyDetect: BYTE;  //真人检测，0-无效，1-不启用，2-启用
    byFaceMatchThreshold1: BYTE;  //人脸1:1匹配阀值，范围0-100
    wBuzzerTime: WORD;  //蜂鸣时间，范围0s-5999s（0-代表长鸣）
    byFaceMatch1SecurityLevel: BYTE;  //人脸1:1识别安全等级，0-无效，1-一般，2-较强，3-极强
    byFaceMatchNSecurityLevel: BYTE;  //人脸1:N识别安全等级，0-无效，1-一般，2-较强，3-极强
    byEnvirMode: BYTE;  //人脸识别环境模式，0-无效，1-室内，2-其他；
    byLiveDetLevelSet: BYTE;  //活体检测阈值等级设置，0-无效，1-低，2-中，3-高；
    byLiveDetAntiAttackCntLimit: BYTE;  //活体检测防攻击次数， 0-无效，1-255次（客户端、设备统一次数限制，根据能力级限制）；
    byEnableLiveDetAntiAttack: BYTE;  //活体检测防攻击使能，0-无效，1-不启用，2-启用
    bySupportDelFPByID: BYTE;  //只读，读卡器是否支持按手指ID删除指纹，0-无效，1-不支持，2-支持
    byFaceContrastMotionDetLevel: BYTE;  //人脸比对时移动侦测级别，0-无效，1-低，2-中，3-高，0xff-禁用
    byDayFaceMatchThresholdN: BYTE;  //白天人脸1:N匹配阀值，范围0-100
    byNightFaceMatchThresholdN: BYTE;  //夜晚人脸1:N匹配阀值，范围0-100
    byFaceRecogizeEnable: BYTE;  //人脸识别使能：0-无效，1-开启，2-关闭
    byBlockListMatchThreshold: BYTE;  //禁止名单匹配阀值，范围0-100
    byRes3: BYTE;  
    byDefaultVerifyMode: BYTE;  //只读，读卡器默认验证方式（出厂默认），1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
    dwFingerPrintCapacity: DWORD;  //只读，指纹容量
    dwFingerPrintNum: DWORD;  //只读，已存在指纹数量
    byEnableFingerPrintNum: BYTE;  //只读，指纹容量使能：0-不使能，1-使能（只有当该字段为1-使能时，dwFingerPrintCapacity和dwFingerPrintNum才有效）
    byEnableReverseCardNo: BYTE;  //卡号翻转使能 0-不使能1-使能
    byRes2: array[0..2-1] of BYTE;  
    dwIndependSwipeIntervals: DWORD;  //人员认证间隔（每个人单独计算间隔，区别于重复认证间隔）；
    byRes: array[0..224-1] of BYTE;  
  end;
  LPNET_DVR_CARD_READER_CFG_V50 = ^NET_DVR_CARD_READER_CFG_V50;

type
  NET_DVR_FAILED_FACE_COND = record 
    dwSize: DWORD;  
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_FAILED_FACE_COND = ^NET_DVR_FAILED_FACE_COND;

type
  NET_DVR_FAILED_FACE_INFO = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byErrorCode: BYTE;  //建模失败详细错误,0-无效，1-读取文件失败，2-打开文件失败，3-内存不足，4-注册人脸失败，5-眼间距太小，6-卡权限不存在
    byRes1: array[0..3-1] of BYTE;  
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byRes: array[0..92-1] of BYTE;  
  end;
  LPNET_DVR_FAILED_FACE_INFO = ^NET_DVR_FAILED_FACE_INFO;

type
  NET_DVR_FACE_PARAM_COND = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号（设置时该参数可不设置）
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //人脸的读卡器是否有效，0-无效，1-有效（设置时该参数可不设置）
    dwFaceNum: DWORD;  //设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    byFaceID: BYTE;  //人脸编号，有效值范围为1-2   0xff表示该卡所有人脸（设置时该参数可不设置）
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_PARAM_COND = ^NET_DVR_FACE_PARAM_COND;

type
  NET_DVR_FACE_PARAM_CFG = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    dwFaceLen: DWORD;  //人脸数据长度<DES加密处理>，设备端返回的即加密后的数据
    pFaceBuffer: PAnsiChar;  //人脸数据指针
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //需要下发人脸的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
    byFaceID: BYTE;  //人脸编号，有效值范围为1-2
    byFaceDataType: BYTE;  //人脸数据类型：0-模板（默认），1-图片
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_FACE_PARAM_CFG = ^NET_DVR_FACE_PARAM_CFG;

type
  NET_DVR_FACE_PARAM_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byCardReaderRecvStatus: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
    //,6-算法建模失败，7-未下发卡权限，8-未定义（保留），9-人眼间距小距小，10-图片数据长度小于1KB，11-图片格式不符（png/jpg/bmp）,12-图片像素数量超过上限，13-图片像素数量低于下限，14-图片信息校验失败，15-图片解码失败，16-人脸检测失败，17-人脸评分失败
    byErrorMsg: array[0..ERROR_MSG_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
    dwCardReaderNo: DWORD;  //纹读卡器编号，可用于下发错误返回
    byTotalStatus: BYTE;  //下发总的状态，0-当前人脸未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    byFaceID: BYTE;  //人脸编号，有效值范围为1-2
    byRes: array[0..130-1] of BYTE;  
  end;
  LPNET_DVR_FACE_PARAM_STATUS = ^NET_DVR_FACE_PARAM_STATUS;

type
  NET_DVR_FACE_PARAM_BYCARD = record 
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //人脸的读卡器信息，按数组表示
    byFaceID: array[0..MAX_FACE_NUM-1] of BYTE;  //需要删除的人脸编号，按数组下标，值表示0-不删除，1-删除该人脸
    byRes1: array[0..42-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_PARAM_BYCARD = ^NET_DVR_FACE_PARAM_BYCARD;

type
  NET_DVR_FACE_PARAM_BYREADER = record 
    dwCardReaderNo: DWORD;  //按值表示，人脸读卡器编号
    byClearAllCard: BYTE;  //是否删除所有卡的人脸信息，0-按卡号删除人脸信息，1-删除所有卡的人脸信息
    byRes1: array[0..3-1] of BYTE;  //保留
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byRes: array[0..548-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_PARAM_BYREADER = ^NET_DVR_FACE_PARAM_BYREADER;

type
  NET_DVR_DEL_FACE_PARAM_MODE = record 
    case Byte of
    0: (uLen: array[0..588-1] of BYTE);  //联合体长度
    1: (struByCard: NET_DVR_FACE_PARAM_BYCARD);  //按卡号的方式删除
    2: (struByReader: NET_DVR_FACE_PARAM_BYREADER);  //按读卡器的方式删除
  end;
  LPNET_DVR_DEL_FACE_PARAM_MODE = ^NET_DVR_DEL_FACE_PARAM_MODE;

type
  NET_DVR_FACE_PARAM_CTRL = record 
    dwSize: DWORD;  
    byMode: BYTE;  //删除方式，0-按卡号方式删除，1-按读卡器删除
    byRes1: array[0..3-1] of BYTE;  //保留
    struProcessMode: NET_DVR_DEL_FACE_PARAM_MODE;  //处理方式
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_PARAM_CTRL = ^NET_DVR_FACE_PARAM_CTRL;

type
  NET_DVR_LOCAL_CONTROLLER_STATUS_COND = record 
    dwSize: DWORD;  
    wLocalControllerID: WORD;  //就地控制器序号(分控器序号),为0表示所有
    byRes: array[0..306-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_CONTROLLER_STATUS_COND = ^NET_DVR_LOCAL_CONTROLLER_STATUS_COND;

type
  NET_DVR_LOCAL_CONTROLLER_STATUS = record 
    dwSize: DWORD;  
    wLocalControllerID: WORD;  //就地控制器序号(分控器序号)
    byLocalAntiDismantleStatus: BYTE;  //就地控制器防拆状态，0-关闭，1-开启
    byPowerSupplyStatus: BYTE;  //设备供电状态，1-交流电供电，2-蓄电池供电
    wBatteryVoltage: WORD;  //蓄电池电压值，实际值乘10，单位：伏特
    byBatteryLowVoltage: BYTE;  //蓄电池是否处于低压状态，0-否，1-是
    byFireAlarm: BYTE;  //消防报警，0-正常，1-短接报警，2-断开报警
    bySerialNumber: array[0..SERIALNO_LEN-1] of BYTE;  //设备序列号
    byMagneticStatus: array[0..MAX_DOOR_NUM-1] of BYTE;  // 门磁状态：0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警
    byDoorLockStatus: array[0..MAX_DOOR_NUM-1] of BYTE;  //门锁状态，0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警
    byCardReaderOnlineStatus: array[0..MAX_CARD_READER_NUM-1] of BYTE;  //读卡器在线状态，0-不在线，1-在线
    wLocalControllerStatus: WORD;  //只读，就地控制器在线状态(分控器在线状态)：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
    byRes2: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_CONTROLLER_STATUS = ^NET_DVR_LOCAL_CONTROLLER_STATUS;

type
  NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG = record 
    dwSize: DWORD;  
    byLocalControllerName: array[0..LOCAL_CONTROLLER_NAME_LEN-1] of BYTE;  //就地控制器名称
    wLocalControllerID: WORD;  //就地控制器序号
    wDevPort: WORD;  // 设备端口号
    struDevIP: NET_DVR_IPADDR;  // 设备IP地址
    struSubnetMask: NET_DVR_IPADDR;  // 设备子网掩码
    struGateway: NET_DVR_IPADDR;  // 设备网关
    bySearchProgress: BYTE;  //搜索进度，0表示未开始，100表示同步完成
    byEffectData: BYTE;  //是否为有效数据,0表示有效，1表示设备只返回搜索进度，作为心跳包
    byRes: array[0..302-1] of BYTE;  
  end;
  LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG = ^NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG;

type
  NET_DVR_ACS_WORK_STATUS = record 
    dwSize: DWORD;  
    byDoorLockStatus: array[0..MAX_DOOR_NUM-1] of BYTE;  //门锁状态，0-关，1-开
    byDoorStatus: array[0..MAX_DOOR_NUM-1] of BYTE;  //门状态，1-休眠，2-常开状态，3-常闭状态，4-普通状态
    byMagneticStatus: array[0..MAX_DOOR_NUM-1] of BYTE;  //门磁状态，0-闭合，1-开启
    byCaseStatus: array[0..MAX_CASE_SENSOR_NUM-1] of BYTE;  ////事件触发器状态，0-无输入，1-有输入
    wBatteryVoltage: WORD;  //蓄电池电压值，实际值乘10，单位：伏特
    byBatteryLowVoltage: BYTE;  //蓄电池是否处于低压状态，0-否，1-是
    byPowerSupplyStatus: BYTE;  //设备供电状态，1-交流电供电，2-蓄电池供电
    byMultiDoorInterlockStatus: BYTE;  //多门互锁状态，0-关闭，1-开启
    byAntiSneakStatus: BYTE;  //反潜回状态，0-关闭，1-开启
    byHostAntiDismantleStatus: BYTE;  //主机防拆状态，0-关闭，1-开启
    byIndicatorLightStatus: BYTE;  //指示灯状态，0-掉线，1-在线
    byCardReaderOnlineStatus: array[0..MAX_CARD_READER_NUM-1] of BYTE;  //读卡器在线状态，0-不在线，1-在线
    byCardReaderAntiDismantleStatus: array[0..MAX_CARD_READER_NUM-1] of BYTE;  //读卡器防拆状态，0-关闭，1-开启
    byCardReaderVerifyMode: array[0..MAX_CARD_READER_NUM-1] of BYTE;  //读卡器当前验证方式，1-刷卡，2-刷卡+密码，3-刷卡，4-刷卡或密码
    bySetupAlarmStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    byAlarmInStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    byAlarmOutStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
    dwCardNum: DWORD;  //已添加的卡数量
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ACS_WORK_STATUS = ^NET_DVR_ACS_WORK_STATUS;

type
  NET_DVR_ACS_WORK_STATUS_V50 = record 
    dwSize: DWORD;  
    byDoorLockStatus: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //门锁状态(继电器开合状态)，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
    byDoorStatus: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //门状态(楼层状态)，1-休眠，2-常开状态(自由)，3-常闭状态(禁用)，4-普通状态(受控)
    byMagneticStatus: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //门磁状态，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
    byCaseStatus: array[0..MAX_CASE_SENSOR_NUM-1] of BYTE;  //事件触发器状态，0-无输入，1-有输入
    wBatteryVoltage: WORD;  //蓄电池电压值，实际值乘10，单位：伏特
    byBatteryLowVoltage: BYTE;  //蓄电池是否处于低压状态，0-否，1-是
    byPowerSupplyStatus: BYTE;  //设备供电状态，1-交流电供电，2-蓄电池供电
    byMultiDoorInterlockStatus: BYTE;  //多门互锁状态，0-关闭，1-开启
    byAntiSneakStatus: BYTE;  //反潜回状态，0-关闭，1-开启
    byHostAntiDismantleStatus: BYTE;  //主机防拆状态，0-关闭，1-开启
    byIndicatorLightStatus: BYTE;  //指示灯状态，0-掉线，1-在线
    byCardReaderOnlineStatus: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //读卡器在线状态，0-不在线，1-在线
    byCardReaderAntiDismantleStatus: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //读卡器防拆状态，0-关闭，1-开启
    byCardReaderVerifyMode: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //读卡器当前验证方式，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码
    bySetupAlarmStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    byAlarmInStatus: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //按位表示报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    byAlarmOutStatus: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //按位表示报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
    dwCardNum: DWORD;  //已添加的卡数量
    byFireAlarmStatus: BYTE;  //消防报警状态显示：0-正常、1-短路报警、2-断开报警
    byBatteryChargeStatus: BYTE;  //电池充电状态：0-无效；1-充电中；2-未充电
    byMasterChannelControllerStatus: BYTE;  //主通道控制器在线状态：0-无效；1-不在线；2-在线
    bySlaveChannelControllerStatus: BYTE;  //从通道控制器在线状态：0-无效；1-不在线；2-在线
    byAntiSneakServerStatus: BYTE;  //反潜回服务器状态：0-无效，1-未启用，2-正常，3-断开
    byRes3: array[0..3-1] of BYTE;  
    dwAllowFaceNum: DWORD;  //已添加的允许名单人脸数量（通过能力集判断）
    dwBlockFaceNum: DWORD;  //已添加的禁止名单人脸数量（通过能力集判断）
    byRes2: array[0..108-1] of BYTE;  
  end;
  LPNET_DVR_ACS_WORK_STATUS_V50 = ^NET_DVR_ACS_WORK_STATUS_V50;

type
  NET_DVR_CASE_SENSOR_CFG = record 
    dwSize: DWORD;  
    byHostBuzzer: BYTE;  //触发主机蜂鸣器，0-不触发，1-触发
    byRes1: array[0..3-1] of BYTE;  
    byCardReaderBuzzer: array[0..MAX_CARD_READER_NUM-1] of BYTE;  //触发读卡器蜂鸣器，1-触发，0-不触发
    byAssociateAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联触发的报警输出，1-关联，0-不关联
    byDoorOpen: array[0..MAX_DOOR_NUM-1] of BYTE;  //对门1-N关联门打开，0-不关联，1-关联（即打开）
    byDoorClose: array[0..MAX_DOOR_NUM-1] of BYTE;  //对门1-N关联门关闭，0-不关联，1-关联（即关闭）
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CASE_SENSOR_CFG = ^NET_DVR_CASE_SENSOR_CFG;

type
  ENUM_UPGRADE_TYPE =  
  (  
    ENUM_UPGRADE_DVR = 0,  //普通设备升级
    ENUM_UPGRADE_ADAPTER = 1,  //DVR适配器升级
    ENUM_UPGRADE_VCALIB = 2,  //智能库升级
    ENUM_UPGRADE_OPTICAL = 3,  //光端机升级
    ENUM_UPGRADE_ACS = 4,  //门禁系统升级
    ENUM_UPGRADE_AUXILIARY_DEV = 5,  //辅助设备升级
    ENUM_UPGRADE_LED = 6,  //LED发送卡和接收卡升级
    ENUM_UPGRADE_INTELLIGENT = 7,  //中心智能设备升级
    ENUM_UPGRADE_CUSTOM = 8  //自定义URL ISAPI登陆有效
  );

type
  NET_DVR_ACS_EVENT_INFO = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号，为0无效
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    byAllowListNo: BYTE;  //允许名单单号,1-8，为0无效
    byReportChannel: BYTE;  //报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
    byCardReaderKind: BYTE;  //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    dwCardReaderNo: DWORD;  //读卡器编号，为0无效
    dwDoorNo: DWORD;  //门编号(楼层编号)，为0无效（当接的设备为人员通道设备时，门1为进方向，门2为出方向）
    dwVerifyNo: DWORD;  //多重卡认证序号，为0无效
    dwAlarmInNo: DWORD;  //报警输入号，为0无效
    dwAlarmOutNo: DWORD;  //报警输出号，为0无效
    dwCaseSensorNo: DWORD;  //事件触发器编号
    dwRs485No: DWORD;  //RS485通道号，为0无效
    dwMultiCardGroupNo: DWORD;  //群组编号
    wAccessChannel: WORD;  //人员通道号
    byDeviceNo: BYTE;  //设备编号，为0无效
    byDistractControlNo: BYTE;  //分控器编号，为0无效
    dwEmployeeNo: DWORD;  //工号，为0无效
    wLocalControllerID: WORD;  //就地控制器编号，0-门禁主机，1-64代表就地控制器
    byInternetAccess: BYTE;  //网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
    byType: BYTE;  //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //物理地址，为0无效
    bySwipeCardType: BYTE;  //刷卡类型，0-无效，1-二维码
    byMask: BYTE;  //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    dwSerialNo: DWORD;  //事件流水号，为0无效
    byChannelControllerID: BYTE;  //通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
    byChannelControllerLampID: BYTE;  //通道控制器灯板ID，为0无效（有效范围1-255）
    byChannelControllerIRAdaptorID: BYTE;  //通道控制器红外转接板ID，为0无效（有效范围1-255）
    byChannelControllerIREmitterID: BYTE;  //通道控制器红外对射ID，为0无效（有效范围1-255）
    byHelmet: BYTE;  //可选，是否戴安全帽：0-保留，1-未知，2-不戴安全, 3-戴安全帽
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EVENT_INFO = ^NET_DVR_ACS_EVENT_INFO;

type
  NET_DVR_ACS_EVENT_INFO_EXTEND = record 
    dwFrontSerialNo: DWORD;  //事件流水号，为0无效（若该字段为0，平台根据dwSerialNo判断是否丢失事件；若该字段不为0，平台根据该字段和dwSerialNo字段共同判断是否丢失事件）（主要用于解决报警订阅后导致dwSerialNo不连续的情况）
    byUserType: BYTE;  //人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
    byCurrentVerifyMode: BYTE;  //读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码，28-人脸或密码，29-工号+人脸+密码，30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    byCurrentEvent: BYTE;  //是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
    byPurePwdVerifyEnable: BYTE;  //设备是否支持纯密码认证， 0-不支持，1-支持
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
    byAttendanceStatus: BYTE;  //考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
    byStatusValue: BYTE;  //考勤状态值
    byRes2: array[0..2-1] of BYTE;  
    byUUID: array[0..NET_SDK_UUID_LEN{36}-1] of BYTE;  //UUID（该字段仅在对接萤石平台过程中才会使用）
    byDeviceName: array[0..NET_DEV_NAME_LEN-1] of BYTE;  //设备序列号
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EVENT_INFO_EXTEND = ^NET_DVR_ACS_EVENT_INFO_EXTEND;

//扩展结构体信息V20
type
  NET_DVR_ACS_EVENT_INFO_EXTEND_V20 = record 
    byRemoteCheck: BYTE;  //是否需要远程核验（0-无效，1-不需要（默认），2-需要）
    byThermometryUnit: BYTE;  //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    byIsAbnomalTemperature: BYTE;  //人脸抓拍测温是否温度异常：1-是，0-否
    byRes2: BYTE;  
    fCurrTemperature: FLOAT;  //人脸温度（精确到小数点后一位）
    struRegionCoordinates: NET_VCA_POINT;  //人脸温度坐标
    dwQRCodeInfoLen: DWORD;  //二维码信息长度，不为0是表示后面带数据
    dwVisibleLightDataLen: DWORD;  //热成像相机可见光图片长度，不为0是表示后面带数据
    dwThermalDataLen: DWORD;  //热成像图片长度，不为0是表示后面带数据
    pQRCodeInfo: PAnsiChar;  //二维码信息指针
    pVisibleLightData: PAnsiChar;  //热成像相机可见光图片指针
    pThermalData: PAnsiChar;  //热成像图片指针
    byAttendanceLabel: array[0..64-1] of BYTE;  //考勤自定义名称
    wXCoordinate: WORD;  //x坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wYCoordinate: WORD;  //y坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wWidth: WORD;  //人脸框宽度，范围0-1000
    wHeight: WORD;  //人脸框高度，范围0-1000
    byHealthCode: BYTE;  //健康码状态, 0-保留, 1-未请求, 2-未申领, 3-绿码, 4-黄码, 5-红码, 6-无此人员, 7-其他错误信息（如接口异常导致查询失败）, 8-查询健康码超时
    byNADCode: BYTE;  //核酸检测结果, 0-保留, 1-未查询到核酸检测结果, 2-核酸检测阴性（代表正常）, 3-核酸检测阳性（代表确诊）, 4-核酸检测有效期已过
    byTravelCode: BYTE;  //行程编码, 0-保留, 1-14天内一直在当地, 2-14天内离开过当地, 3-14天内到过疫区, 4-其他
    byVaccineStatus: BYTE;  //打疫苗状态, 0-保留, 1-未打疫苗, 2-部分注射疫苗, 3-打过疫苗
    byRes: array[0..948-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EVENT_INFO_EXTEND_V20 = ^NET_DVR_ACS_EVENT_INFO_EXTEND_V20;

type
  NET_DVR_ACS_ALARM_INFO = record 
    dwSize: DWORD;  
    dwMajor: DWORD;  //报警主类型，参考宏定义
    dwMinor: DWORD;  //报警次类型，参考宏定义
    struTime: NET_DVR_TIME;  //时间
    sNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    struAcsEventInfo: NET_DVR_ACS_EVENT_INFO;  //详细参数
    dwPicDataLen: DWORD;  //图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  
    wInductiveEventType: WORD;  //归纳事件类型，0-无效，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes1: BYTE;  //保留字节
    dwIOTChannelNo: DWORD;  //IOT通道号
    pAcsEventInfoExtend: PAnsiChar;  //byAcsEventInfoExtend为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND结构体
    byAcsEventInfoExtend: BYTE;  //pAcsEventInfoExtend是否有效：0-无效，1-有效
    byTimeType: BYTE;  //时间类型：0-设备本地时间，1-UTC时间（struTime的时间）
    byRes2: BYTE;  //保留字节
    byAcsEventInfoExtendV20: BYTE;  //pAcsEventInfoExtendV20是否有效：0-无效，1-有效
    pAcsEventInfoExtendV20: PAnsiChar;  //byAcsEventInfoExtendV20为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND_V20结构体
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_ACS_ALARM_INFO = ^NET_DVR_ACS_ALARM_INFO;

const
  JUDGE_MAX_VIDEOOUT_NUM = 9;    

type
  NET_DVR_AUDIO_ACTIVATION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用
    byRes1: array[0..3-1] of BYTE;  
    dwChanNo: DWORD;  //语音激励的视频通道号
    bySensitivity: BYTE;  //灵敏度 1-100，灵敏度越高，表示较低的音量就能使能该音频输入激励功能；灵敏度越低，表示需要较高的音量才能使能该音频输入的激励功能
    byPriority: BYTE;  //优先级  0-优先级0，1-优先级1， 值越大级别越高
    wDelayTime: WORD;  //语音激励结束画面切换延迟时间，单位s, 超时后自动回到预置点1对应的画面
    byRes2: BYTE;  //保留
    byEnablePreset: BYTE;  //是否启用预置点
    wPreset: WORD;  //预置点
    wBase: WORD;  //基准点编号
    byRes3: array[0..2-1] of BYTE;  
    byVoChanNo: array[0..JUDGE_MAX_VIDEOOUT_NUM-1] of BYTE;  //语音激励是否输出到视频输出口。值0表示不输出，1-表示输出。下标表示通道顺序如下：0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_AUDIO_ACTIVATION_CFG = ^NET_DVR_AUDIO_ACTIVATION_CFG;

type
  NET_DVR_INFRARED_OUTPUT_CTRL_CFG = record 
    dwSize: DWORD;  //结构体大小
    byIROutPort: BYTE;  //红外输出索引，1-红外输出口1，2-红外输出口2
    byIRCmdIndex: BYTE;  //红外学码命令对应的索引；
    byRes: array[0..254-1] of BYTE;  //保留
  end;
  LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG = ^NET_DVR_INFRARED_OUTPUT_CTRL_CFG;

const
  MAX_IR_CMD_NAME_LEN = 32;    //红外输出命令名称长度
  MAX_IR_CMD_NUM = 32;    //红外命令个数

type
  NET_DVR_INFRARED_CMD_INFO = record //红外命令名称信息
    sCmdName: array[0..MAX_IR_CMD_NAME_LEN-1] of AnsiChar;  //红外命令名称
    byRes: array[0..8-1] of BYTE;  //保留
  end;
  LPNET_DVR_INFRARED_CMD_INFO = ^NET_DVR_INFRARED_CMD_INFO;


type
  NET_DVR_INFRARED_CMD_NAME_CFG = record 
    dwSize: DWORD;  //结构体大小
    sIROutName: array[0..MAX_IR_CMD_NAME_LEN-1] of BYTE;  //红外输出口名称
    struIRCmdInfo: array[0..MAX_IR_CMD_NUM-1] of NET_DVR_INFRARED_CMD_INFO;  //红外命令子信息
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_INFRARED_CMD_NAME_CFG = ^NET_DVR_INFRARED_CMD_NAME_CFG;

type
  IR_LEARN_SEND_DATA_TYPE_ENUM =  
  (  
    ENUM_SENDDATA = $0,  //发送数据
    ENUM_SEND_LEARN_IR_CMD_START,  //发送红外学码
    ENUM_SEND_LEARN_IR_CMD_END = $2  //红外学码结束
  );


type
  NET_DVR_INFRARED_LEARN_INFO = record 
    dwSize: DWORD;  //结构体大小
    byIROutPort: BYTE;  //红外输出索引，1-红外输出口1，2-红外输出口2
    byIRCmdIndex: BYTE;  //红外学码命令对应的索引
    byRes: array[0..30-1] of BYTE;  //保留
  end;
  LPNET_DVR_INFRARED_LEARN_INFO = ^NET_DVR_INFRARED_LEARN_INFO;

type
  NET_DVR_INFRARED_LEARN_END = record 
    dwSize: DWORD;  //结构体大小
    bySaveLearnInfo: BYTE;  //保存学码信息，0-保存，1-不保存
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_INFRARED_LEARN_END = ^NET_DVR_INFRARED_LEARN_END;

const
  MAX_VIDEOIN_TYPE_NUM = 10;    //最大支持的视频输入源类型

type
  NET_DVR_VIDEOIN_TYPE_INFO = record 
    wInType: WORD;  //输入源类型  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
    wInNum: WORD;  //支持的输入个数
    wStartNo: WORD;  //输入对应的起始号
    byRes: array[0..6-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOIN_TYPE_INFO = ^NET_DVR_VIDEOIN_TYPE_INFO;

type
  NET_DVR_TRIAL_SYSTEM_INFO = record 
    dwSize: DWORD;  //结构体大小
    byVideoInTypeNum: BYTE;  //视频输入源类型个数
    byRes1: array[0..3-1] of BYTE;  
    struVideoIn: array[0..MAX_VIDEOIN_TYPE_NUM-1] of NET_DVR_VIDEOIN_TYPE_INFO;  //视频输入源
    byRes: array[0..512 -1] of BYTE;  //保留
  end;
  LPNET_DVR_TRIAL_SYSTEM_INFO = ^NET_DVR_TRIAL_SYSTEM_INFO;

type
  NET_DVR_CASE_INFO = record 
    dwSize: DWORD;  //结构体大小
    byCaseNo: array[0..CASE_NO_LEN-1] of BYTE;  //案件编号
    byCaseName: array[0..CASE_NAME_LEN-1] of BYTE;  //案件名称；
    byLitigant1: array[0..LITIGANT_LEN-1] of BYTE;  //当事人1；
    byLitigant2: array[0..LITIGANT_LEN-1] of BYTE;  //当事人2；
    byChiefJudge: array[0..CHIEF_JUDGE_LEN-1] of BYTE;  //审判长
    byCaseType: BYTE;  //案件类型；1-刑事案件、2-民事案件、3- sCaseTypeCustom生效
    byShowCaseInfoTime: BYTE;  // 案件信息显示时间,单位秒, 取值范围1~30
    byRes1: array[0..2-1] of BYTE;  //保留
    sCaseTypeCustom: array[0..NET_SDK_CASETYPE_LEN{32}-1] of AnsiChar;  //自定义案件类型
    byRes: array[0..220-1] of BYTE;  //保留
  end;
  LPNET_DVR_CASE_INFO = ^NET_DVR_CASE_INFO;

const
  MICROPHONE_NUM = 16;    
  FAN_NUM = 8;    
  FPGA_NUM = 8;    
  MAIN_BOARD = 8;    
  LOCAL_INPUT_NUM = 24;    
  LAMP_STATE_NAME = 32;    
  LAMP_NAME = 32;    
  FILE_NAME_LEN = 32;    
type
  NET_DVR_REMOTE_PLAY = record 
    dwSize: DWORD;  
    byFileName: array[0..FILE_NAME_LEN-1] of BYTE;  //需要播放的文件名称
    byVideoOut: array[0..7-1] of BYTE;  //播放输出口
    byRes1: array[0..5-1] of BYTE;  
    byType: BYTE;  // 0-无意义，1-开始播放，2-停止播放
    byRes: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_REMOTE_PLAY = ^NET_DVR_REMOTE_PLAY;

type
  NET_DVR_TRIAL_MICROPHONE_STATUS = record 
    dwSize: DWORD;  
    byMicrophoneStatus: array[0..MICROPHONE_NUM-1] of BYTE;  //麦克风状态下标表示麦克风号0-供电，1-不供电
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_TRIAL_MICROPHONE_STATUS = ^NET_DVR_TRIAL_MICROPHONE_STATUS;

type
  NET_DVR_TRIAL_HOST_STATUS = record 
    dwSize: DWORD;  
    dwFanSpeed: array[0..FAN_NUM-1] of DWORD;  //风扇转速
    wMainBoardTemp: array[0..MAIN_BOARD-1] of WORD;  //主板温度
    byFpgaTempWarn: array[0..FPGA_NUM-1] of BYTE;  //数组0-主板温度暂无报警状态，数组1-FPGA温度报警状态位，1-处于报警状态   0-处于无报警状态
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_TRIAL_HOST_STATUS = ^NET_DVR_TRIAL_HOST_STATUS;

type
  NET_DVR_LOCAL_INPUT_INFO = record 
    dwSize: DWORD;  
    byChannelName: array[0..NAME_LEN-1] of BYTE;  //通道名称
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_LOCAL_INPUT_INFO = ^NET_DVR_LOCAL_INPUT_INFO;

type
  NET_DVR_LAMP_STATUS = record 
    byEnable: BYTE;  //是否启用
    byRes1: array[0..3-1] of BYTE;  
    byLampName: array[0..LAMP_NAME-1] of BYTE;  //Lamp 名称，报警输出3、4口为Lamp1。报警5、6输出口为lamp2。
    byLampState1: array[0..LAMP_STATE_NAME-1] of BYTE;  //状态1对应名称，
    byLampState2: array[0..LAMP_STATE_NAME-1] of BYTE;  //状态2对应名称
    byLampState3: array[0..LAMP_STATE_NAME-1] of BYTE;  //状态3对应名称
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LAMP_STATUS = ^NET_DVR_LAMP_STATUS;

type
  NET_DVR_LAMP_OUT = record 
    dwSize: DWORD;  
    struLampInfo: array[0..2-1] of NET_DVR_LAMP_STATUS;  //数组0-表示lamp1,数组1表述lamp2
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_LAMP_OUT = ^NET_DVR_LAMP_OUT;

type
  NET_DVR_LAMP_CONTROL = record 
    dwSize: DWORD;  
    byLampNo: BYTE;  //Lamp编号，对应配置Lamp数组下标
    byLampStateNo: BYTE;  //Lamp状态编号 0-无意义，1-状态1, 2-状态2， 3-状态3  对应LAMP输出口配置状态
    byRes: array[0..14-1] of BYTE;  //保留
  end;
  LPNET_DVR_LAMP_CONTROL = ^NET_DVR_LAMP_CONTROL;


//实时信息
type
  NET_DVR_TPS_PARAM = record 
    byStart: BYTE;  // 开始码
    byCMD: BYTE;  // 命令号，01-进入指令，02-离开指令，03-拥堵状态指令(为03时，只有byLaneState和byQueueLen有效)，04-多线圈状态（为04时，wLoopState和wStateMask有效，表示byLane车道上多个线圈的过车状态）
    wSpaceHeadway: WORD;  //车头间距，以米来计算
    wDeviceID: WORD;  // 设备ID
    wDataLen: WORD;  // 数据长度
    byLane: BYTE;  // 对应车道号
    bySpeed: BYTE;  // 对应车速（KM/H）
    byLaneState: BYTE;  // 车道状态；0-无状态，1-畅通，2-拥挤，3-堵塞
    byQueueLen: BYTE;  // 堵塞状态下排队长度（比如50米）
    wLoopState: WORD;  //线圈状态，第几位表示几号线圈状态。状态1-到达，0-离开，线圈编号从镜头由近到远依次增大，用户在解析时优先解析车道号，再解析线圈号，单个车道的线圈号是唯一的。
    wStateMask: WORD;  //线圈状态掩码，掩码位为1对应wLoopState状态位有效，为0表示无效
    dwDownwardFlow: DWORD;  //当前车道 从上到下车流量
    dwUpwardFlow: DWORD;  //当前车道 从下到上车流量
    byJamLevel: BYTE;  //拥堵等级，当byLaneState为3时有效，1-轻度，2-中度，3-重度
    byVehicleDirection: BYTE;  //0-未知，1-由上而下，2-由下而上
    byJamFlow: BYTE;  //拥堵新增流量，每新增一辆车就上报一次累计车辆的信息
    byChannelizationLane: BYTE;  //渠化车道号（渠化表示，车道数量变化的情况，一般为路口车道的数目）
    byVehicleType: BYTE;  //车型识别：0- 未知，1- 客车(大型)，2- 货车(大型)，3- 轿车(小型)，4- 非机动车
    byRes1: array[0..5-1] of BYTE;  //保留
    wTimeHeadway: WORD;  // 车头时距，以秒计算
  end;
  LPNET_DVR_TPS_PARAM = ^NET_DVR_TPS_PARAM;

//TPS实时过车数据上传
type
  NET_DVR_TPS_REAL_TIME_INFO = record 
    dwSize: DWORD;  // 结构体大小
    dwChan: DWORD;  //通道号
    struTime: NET_DVR_TIME_V30;  //检测时间
    struTPSRealTimeInfo: NET_DVR_TPS_PARAM;  // 交通参数统计信息
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pAddInfoBuffer: PBYTE;  
{$ELSE}
    //附加信息指针,指向NET_DVR_TPS_ADDINFO结构体
    pAddInfoBuffer: PBYTE;  
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    //附加信息标识（即是否有NET_DVR_TPS_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
    byAddInfoFlag: BYTE;  
    byRes1: array[0..3-1] of BYTE;  // 保留
    dwDeviceIDEx: DWORD;  // 设备ID扩展
    byRes: array[0..8-1] of BYTE;  // 保留
  end;
  LPNET_DVR_TPS_REAL_TIME_INFO = ^NET_DVR_TPS_REAL_TIME_INFO;

//统计信息
type
  NET_DVR_TPS_LANE_PARAM = record 
    byLane: BYTE;  // 对应车道号
    bySpeed: BYTE;  // 车道过车平均速度
    wArrivalFlow: WORD;  //到达流量
    dwLightVehicle: DWORD;  // 小型车数量
    dwMidVehicle: DWORD;  // 中型车数量
    dwHeavyVehicle: DWORD;  // 重型车数量
    dwTimeHeadway: DWORD;  // 车头时距，以秒计算
    dwSpaceHeadway: DWORD;  // 车头间距，以米来计算
    fSpaceOccupyRation: FLOAT;  // 空间占有率，百分比计算,浮点数*1000
    fTimeOccupyRation: FLOAT;  // 时间占有率，百分比计算,浮点数*1000
    byStoppingTimes: BYTE;  //平均停车次数
    byQueueLen: BYTE;  // 堵塞状态下排队长度（比如50米）
    byFlag: BYTE;  //上传标识，0-表示T1时间的统计结果,1-表示T2时间的统计
    byVehicelNum: BYTE;  //区域车辆数
    wDelay: WORD;  //平均延误
    byRes1: array[0..6-1] of BYTE;  // 保留
    dwNonMotor: DWORD;  // 非机动车数量
  end;
  LPNET_DVR_TPS_LANE_PARAM = ^NET_DVR_TPS_LANE_PARAM;

type
  NET_DVR_PANORAMA_LINKAGE = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //0-关闭，1-开启
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_PANORAMA_LINKAGE = ^NET_DVR_PANORAMA_LINKAGE;

// 交通参数统计信息
type
  NET_DVR_TPS_STATISTICS_PARAM = record 
    byStart: BYTE;  // 开始码
    byCMD: BYTE;  // 命令号， 08-定时成组数据指令
    byRes: array[0..2-1] of BYTE;  // 预留字节
    wDeviceID: WORD;  // 设备ID
    wDataLen: WORD;  // 数据长度
    byTotalLaneNum: BYTE;  // 有效车道总数
    byRes2: array[0..3-1] of BYTE;  
    dwDeviceIDEx: DWORD;  // 设备ID扩展
    byRes1: array[0..8-1] of BYTE;  
    struStartTime: NET_DVR_TIME_V30;  //统计开始时间
    dwSamplePeriod: DWORD;  //统计时间,单位秒
    struLaneParam: array[0..MAX_TPS_RULE{8}-1] of NET_DVR_TPS_LANE_PARAM;  
  end;
  LPNET_DVR_TPS_STATISTICS_PARAM = ^NET_DVR_TPS_STATISTICS_PARAM;

//TPS统计过车数据上传
type
  NET_DVR_TPS_STATISTICS_INFO = record 
    dwSize: DWORD;  // 结构体大小
    dwChan: DWORD;  //通道号
    struTPSStatisticsInfo: NET_DVR_TPS_STATISTICS_PARAM;  // 交通参数统计信息
    dwJsonLen: DWORD;  //Json报警信息长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pJsonBuf: PBYTE;  
{$ELSE}
    // Json报警信息指针,其JSON对应到EventNotificationAlert Json Block
    pJsonBuf: PBYTE;  
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    byJsonInfoFlag: BYTE;  //是否有Json透传数据，0-无，1-有
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不重传数据，1-重传数据
    byRes: array[0..114-1] of BYTE;  //保留
  end;
  LPNET_DVR_TPS_STATISTICS_INFO = ^NET_DVR_TPS_STATISTICS_INFO;

const
  DPC_CORRECT = 1;    //校正
  DPC_CORRECT_CANCEL = 2;    //取消校正
  DPC_CROSS_DISPALY_OPEN = 3;    //坏点检测十字叉显示开启
  DPC_CROSS_DISPALY_CLOSE = 4;    //坏点检测十字叉显示关闭
  DPC_POINT = 5;    //坏点校正坐标
  DPC_UP = 6;    //坏点校正坐标点向上偏移
  DPC_DOWN = 7;    //坏点校正坐标点向下偏移
  DPC_RIGHT = 8;    //坏点校正坐标点向右偏移
  DPC_LEFT = 9;    //坏点校正坐标点向左偏移
  DPC_ALL_CORRECT = 10;    //所有坏点校正
  DPC_SAVE = 11;    //坏点保存

type
  NET_DVR_DPC_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    wCtrlType: WORD;  //参考宏定义
    {
    手动校正：默认为手动校正模式，使用wCtrlType操作类型进行手动校正。
    自动校正：设备将自动进行校正，无需再进行手动校正，此时wCtrlType、struPoint参数无效。
    }
    byDPCMode: BYTE;  //坏点校正模式：0-手动校正，1-自动校正
    byRes: BYTE;  
    struPoint: NET_VCA_POINT;  //输入的图像平面坐标，归一化到0-1
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DPC_PARAM = ^NET_DVR_DPC_PARAM;

//非均匀性校正(FFC)手动模式
type
  NET_DVR_FFC_MANUAL_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FFC_MANUAL_INFO = ^NET_DVR_FFC_MANUAL_INFO;

//非均匀性校正(FFC)背景补偿
type
  NET_DVR_FFC_BACKCOMP_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FFC_BACKCOMP_INFO = ^NET_DVR_FFC_BACKCOMP_INFO;

//存储服务器开关状态
type
  NET_DVR_STORAGE_SERVER_SWITCH_CFG = record 
    dwSize: DWORD;  
    {存储图片开关；按位表示，0-关闭，1-开启
    数组0-移动侦测抓图(暂不支持)
    数组1-报警抓图(暂不支持)
    ……
    }
    byPicEnable: array[0..MAX_PIC_SWITCH_STORAGE_SERVER-1] of BYTE;  
    {存储附加信息开关；按位表示，0-关闭，1-开启
    数组0-热度图(暂不支持)
    数组1-客流量(暂不支持)
    ……
    }
    byAddInfoEnable: array[0..MAX_INFO_SWITCH_STORAGE_SERVER-1] of BYTE;  
    byRes: array[0..324-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_SERVER_SWITCH_CFG = ^NET_DVR_STORAGE_SERVER_SWITCH_CFG;

//强制停止取证
type
  NET_DVR_FORCESTOP_FORENSICS_CFG = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FORCESTOP_FORENSICS_CFG = ^NET_DVR_FORCESTOP_FORENSICS_CFG;

type
  NET_DVR_DEC_VCA_ALARM = record 
    dwSize: DWORD;  
    dwDisplayNo: DWORD;  //产生智能报警的显示通道号
    bySubWinNo: BYTE;  //产生智能报警的子窗口号
    byRes1: array[0..3-1] of BYTE;  
    struTime: NET_DVR_TIME_V30;  //产生报警时间
    struSourceInfo: NET_DVR_PU_STREAM_CFG_V41;  //码流源信息
    byAlarmPic: PBYTE;  //报警图片缓冲区
    dwAlarmPicSize: DWORD;  //报警图片大小，单位：字节
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DEC_VCA_ALARM = ^NET_DVR_DEC_VCA_ALARM;

type
  NET_DVR_DEC_VCA_ALARM_LOGO = record 
    byEnableLogo: BYTE;  //是否叠加智能报警logo，0-不叠加，非0-叠加
    byFlash: BYTE;  //是否闪烁，0-不闪烁，非0-闪烁
    wFlashTime: WORD;  //闪烁时间，单位：秒，取值范围从解码器能力集获取
    dwLogoX: DWORD;  //logo X坐标，解码窗口总大小：1920*1920
    dwLogoY: DWORD;  //logo Y坐标
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEC_VCA_ALARM_LOGO = ^NET_DVR_DEC_VCA_ALARM_LOGO;

type
  NET_DVR_DEC_VCA_ALARM_PIC = record 
    byUploadPic: BYTE;  //智能报警时是否上传报警图片，0-不上传，非0-上传
    byOverlayTargetInfo: BYTE;  //报警图片是否叠加目标信息，0-不叠加，非0-叠加
    byOverlayRuleInfo: BYTE;  //报警图片是否叠加智能规则信息，0-不叠加，非0-叠加
    byPicQuality: BYTE;  //图片质量系数 0-最好 1-较好 2-一般
    {图片大小 可以通过能力集获取
    0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
    6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
    11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(使用当前码流分辨率)}
    byPicSize: BYTE;  
    byRes: array[0..27-1] of BYTE;  
  end;
  LPNET_DVR_DEC_VCA_ALARM_PIC = ^NET_DVR_DEC_VCA_ALARM_PIC;

type
  NET_DVR_VCA_ALARM_CFG = record 
    dwSize: DWORD;  
    struAlarmLogo: NET_DVR_DEC_VCA_ALARM_LOGO;  //智能报警logo叠加参数
    struAlarmPic: NET_DVR_DEC_VCA_ALARM_PIC;  //智能报警图片参数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DEC_VCA_ALARM_CFG = ^NET_DVR_VCA_ALARM_CFG;

const
  MAX_OSD_LEN = 64;    //输出口OSD长度
type
  NET_DVR_OUTPUT_PIC_INFO = record 
    dwSize: DWORD;  
    sPicName: array[0..NAME_LEN-1] of BYTE;  //图片名称
    byUsed: BYTE;  //是否已存在，0-不存在，1-存在
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_OUTPUT_PIC_INFO = ^NET_DVR_OUTPUT_PIC_INFO;

type
  NET_DVR_OUTPUT_PIC_CFG = record 
    dwSize: DWORD;  
    dwOutputPicNo: DWORD;  //图片序号
    byEnable: BYTE;  //logo是否显示，1-显示，0-隐藏
    byRes1: array[0..3-1] of BYTE;  
    struRect: NET_DVR_RECTCFG_EX;  //logo位置，输出口范围总大小为1920*1920
    byFlash: BYTE;  //是否闪烁1-闪烁，0-不闪烁
    byTranslucent: BYTE;  //是否半透明1-半透明，0-不半透明
    byRes2: array[0..2-1] of BYTE;  //保留
    dwOutputPicWinNo: DWORD;  //输出口图片窗口号（1字节设备号+1字节输出口号+2字节输出口图片窗口号）,获取全部时有效
    byRes3: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_OUTPUT_PIC_CFG = ^NET_DVR_OUTPUT_PIC_CFG;

type
  NET_DVR_OUTPUT_OSD_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //OSD是否显示，0-不显示，1-显示
    byFontSize: BYTE;  //字体大小，1-大，2-中，3-小
    byOSDColor: BYTE;  //OSD颜色配置，0-默认， 1-黑，2-白，3-红，4-绿，5-蓝
    byRes1: array[0..1-1] of BYTE;  
    byOsdContent: array[0..MAX_OSD_LEN-1] of BYTE;  //OSD内容
    struRect: NET_DVR_RECTCFG_EX;  //OSD位置，输出口范围总大小为1920*1920
    dwOsdWinNo: DWORD;  //输出口OSD窗口号（1字节设备号+1字节输出口号+2字节OSD窗口号），获取所有时有效
    byRes2: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTPUT_OSD_CFG = ^NET_DVR_OUTPUT_OSD_CFG;

type
  NET_DVR_CHAN_RELATION_RESOURCE = record 
    dwSize: DWORD;  
    dwDisplayChan: DWORD;  //显示通道号（1字节设备号+1字节保留+2字节显示通道号）
    byRelateAudio: BYTE;  //是否关联子窗口音频
    byRes1: array[0..3-1] of BYTE;  
    dwSubWinNo: DWORD;  //关联音频的子窗口号（1字节电视墙号+1字节子窗口号+2字节窗口号）
    dwChannel: DWORD;  //编码通道号，获取全部时有效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CHAN_RELATION_RESOURCE = ^NET_DVR_CHAN_RELATION_RESOURCE;

type
  NET_DVR_ALARM_CHAN_ABLITITY = record 
    dwSize: DWORD;  
    bySensorChan: array[0..64-1] of BYTE;  //模拟量通道 下标表示通道号 0-表示不支持，1-表示支持
    byAlarmInChan: array[0..64-1] of BYTE;  //报警输入通道 下标表示通道号 0-表示不支持，1-表示支持
    byAlarmOutChan: array[0..64-1] of BYTE;  //报警输出通道 下标表示通道号 0-表示不支持，1-表示支持
    by485Chan: array[0..64-1] of BYTE;  //485通道 下标表示通道号 0-表示不支持，1-表示支持
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_CHAN_ABLITITY = ^NET_DVR_ALARM_CHAN_ABLITITY;

type
  NET_DVR_OUT_SCALE_CFG = record 
    dwSize: DWORD;  
    byOutScale: array[0..8-1] of BYTE;  //下标表示主辅口号，0-表示不支持，1-表示12V，2-表示24V
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_OUT_SCALE_CFG = ^NET_DVR_OUT_SCALE_CFG;

type
  NET_DVR_MONITOR_LOCATION_COND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  
    {
    0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
    1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    }
    byRelateType: BYTE;  
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_MONITOR_LOCATION_COND = ^NET_DVR_MONITOR_LOCATION_COND;

type
  NET_DVR_MONITOR_LOCATION_CFG = record 
    dwSize: DWORD;  
    byMonitoringSiteID: array[0..MAX_ID_LEN{48}-1] of BYTE;  //显示点编号
    byDeviceID: array[0..MAX_ID_LEN{48}-1] of BYTE;  //设备编号
    byDirectionNo: BYTE;  //显示方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
    byRes1: array[0..3-1] of BYTE;  //保留
    byMonitorInfo: array[0..MONITORSITE_ID_LEN{48}-1] of BYTE;  //显示点信息描述
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_MONITOR_LOCATION_CFG = ^NET_DVR_MONITOR_LOCATION_CFG;

type
  NET_DVR_REMOTECONTROL_COND = record 
    dwSize: DWORD;  //结构大小
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROL_COND = ^NET_DVR_REMOTECONTROL_COND;

type
  NET_DVR_REMOTECONTROL_STATUS = record 
    dwSize: DWORD;  //结构大小
    byAlarmStatus: BYTE;  //布防状态，0-保留,1-撤防,2-布防
    byRes: array[0..3-1] of BYTE;  
    wAlarmDealyTime: WORD;  //布防延迟时间，单位s
    wDisAlarmDealyTime: WORD;  //撤防延迟时间，单位s
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROL_STATUS = ^NET_DVR_REMOTECONTROL_STATUS;

type
  NET_DVR_SECURITY_CFG = record 
    dwSize: DWORD;  
    byCommuMode: BYTE;  //私有协议通信模式，0-兼容模式，1-安全模式
    byRes1: array[0..2-1] of BYTE;  
    byWebAuthentication: BYTE;  //web认证配置 0-digest、1-basic、2-digest/basic;默认basic认证
    byRtspAuthentication: BYTE;  //rtsp认证配置 0-disable、1-basic、2-digest、3-digest/basic;默认basic认证
    byTelnetServer: BYTE;  //telnet设置 0～禁用，1～启用
    bySSHServer: BYTE;  //SSH设置 0～禁用(默认)，1～启用
    byIllegalLoginLock: BYTE;  //开启登陆锁定, 0-启用（默认），1-禁用
    byStreamEncryption: BYTE;  //码流加密 0-不加密，1-加密
    byAntiAttack: BYTE;  //是否开启防攻击功能，0- 不启用，1-启用(socket延时5s关闭)
    byRes: array[0..26-1] of BYTE;  
  end;
  LPNET_DVR_SECURITY_CFG = ^NET_DVR_SECURITY_CFG;

type
  NET_DVR_PASSWORD_MANAGE_CFG = record 
    dwSize: DWORD;  
    byRes: array[0..3-1] of BYTE;  
    byLockCount: BYTE;  //对应用户名或IP被几次连续的错误密码登录后，对该用户进行锁定，0-不锁定，其他值为锁定的次数。 默认为0，例如1表示错误登录1次以后就锁定该用户名。
    dwLockTime: DWORD;  //锁定时间，表示错误后锁定的时间，单位：秒。不能为0，byLockCount不为0时，dwLockTime才有效
    byRes1: array[0..128-1] of BYTE;  //4字节对齐
  end;
  LPNET_DVR_PASSWORD_MANAGE_CFG = ^NET_DVR_PASSWORD_MANAGE_CFG;


type
  NET_DVR_UNLOCK_INFO = record 
    dwSize: DWORD;  
    byUnlockType: BYTE;  //0-无效， 1-按IP解锁，2-解锁所有IP
    byIPVersion: BYTE;  //1-IPV4，2-IPV6，当byUnlockType为1时，该参数有效
    byRes1: array[0..2-1] of BYTE;  
    struIPAddr: NET_DVR_IPADDR;  //IP地址
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_UNLOCK_INFO = ^NET_DVR_UNLOCK_INFO;

type
  NET_DVR_LOCKED_INFO = record 
    dwSize: DWORD;  
    byIPType: BYTE;  //IP类型 0-无效，1-IPV4，2-IPV6
    byRes1: array[0..3-1] of BYTE;  
    struIPAddress: NET_DVR_IPADDR;  
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_LOCKED_INFO = ^NET_DVR_LOCKED_INFO;


type
  NET_DVR_VEHICLE_PARA = record 
    sLicense: array[0..MAX_LICENSE_LEN-1] of BYTE;  
                            {国家索引值
                            0-算法库不支持牌识国家，1-捷克共和国(CZ - Czech Republic)，2-法国(FRA - France)，
                            3-德国(DE - Germany),4-西班牙(E - Spain), 5-意大利(IT - Italy)，6-荷兰(NL - Netherlands)，7-波兰(PL - Poland)，8-斯洛伐克(SVK - Slovakia), 9-白俄罗斯(BY - Belorussia), 10-摩尔多瓦(MDA - Moldova)，11-俄罗斯(RU - Russia)，12-乌克兰(UA - Ukraine),
                            169-加拿大(Canada), 172-美国(US), 227-澳大利亚(Australia), 0xfe-无法识别
    }
    byCountry: BYTE;  // 国家索引值

    byRes: array[0..239-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_PARA = ^NET_DVR_VEHICLE_PARA;

type
  NET_DVR_FACE_PIC_DATA_INFO = record 
    dwImageLen: DWORD;  //图片大小
    struVcaRect: NET_VCA_RECT;  //子图在大图中的坐标位置，归一化坐标
    dwFaceScore: DWORD;  //相似度，取值范围0-100
    byVcaRectOnly: BYTE;  //是否只上传坐标：0-否；1-是
    byRes1: array[0..3-1] of BYTE;  
    dwPID: DWORD;  //图片ID
    dwFaceSearchNum: DWORD;  // 搜索人脸区域个数
    struMultiVcaRect: array[0..NET_DVR_MAX_FACE_SEARCH_NUM-1] of NET_VCA_RECT;  //（多个）子图在大图中的坐标位置，归一化坐标, byVcaRectOnly=1时启用，紧凑排列
    byRes: array[0..136-1] of BYTE;  
    pImage: PBYTE;  //其中图片要求为jpg格式
  end;
  LPNET_DVR_FACE_PIC_DATA_INFO = ^NET_DVR_FACE_PIC_DATA_INFO;

type
  NET_DVR_BEHAVIOUR_COND = record 
    dwSearchType: DWORD;  //搜索类型
    //&0x1 - 穿越警戒线
    //&0x2 - 区域入侵
    //&0x4 - 物品遗留
    //&0x8 - 物品拿取
    //&0x10 - 进入区域
    //&0x20 - 离开区域
    //&0x40 - 非法停车
    //&0x80 - 徘徊
    //&0x100 -人员聚集
    //&0x200 - 快速移动
    //&0x400 - 离岗检测
    //&0x800 - 人数变化
    //&0x1000 - 剧烈运动
    //&0x2000 - 人员奔跑
    //&0x4000 - 人员倒地
    //&0x8000 - 人员滞留
    //&0x10000 C态势分析
    //&0x20000 C 玩手机
    byHumanMisinfo: BYTE;  // 只获取人体误报信息 0-否，1-是
    byRes: array[0..251-1] of BYTE;  //保留
  end;
  LPNET_DVR_BEHAVIOUR_COND = ^NET_DVR_BEHAVIOUR_COND;


type
  NET_DVR_SMARTSEARCH_PIC_UNION = record 
    case Byte of
    0: (byLen: array[0..256-1] of BYTE);  //联合体长度
    1: (struVehiclePara: NET_DVR_VEHICLE_PARA);  //车辆检测信息
    2: (struHumaFeature: NET_VCA_HUMAN_FEATURE);  //人脸属性
    3: (struHumaPic: NET_DVR_FACE_PIC_DATA_INFO);  //根据人脸子图信息查询（用于远程图片的以图索图功能）
    4: (struBehaviourCond: NET_DVR_BEHAVIOUR_COND);  //异常行为检测搜索条件
  end;
  LPNET_DVR_SMARTSEARCH_PIC_UNION = ^NET_DVR_SMARTSEARCH_PIC_UNION;

type
  NET_DVR_SMART_SEARCH_PIC_PARA = record //智能图片搜索结构体 size 344
    dwChanNo: DWORD;  //通道号
    byStreamID: array[0..STREAM_ID_LEN-1] of DWORD;  //流ID信息，与dwChanNo相比，优先级较高，即当byStreamID不为空时，则使用流ID，为空的情况下使用dwChanNo字段
    struStartTime: NET_DVR_TIME_EX;  //录像开始的时间
    struEndTime: NET_DVR_TIME_EX;  //录像停止的时间
    wSearchType: WORD;  //智能查找类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-异常行为检测
    byRes1: array[0..2-1] of BYTE;  
    uSmartSearchCond: NET_DVR_SMARTSEARCH_PIC_UNION;  //智能查找条件
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cStartTimeDifferenceH: AnsiChar;  //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cStartTimeDifferenceM: AnsiChar;  //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    cStopTimeDifferenceH: AnsiChar;  //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    cStopTimeDifferenceM: AnsiChar;  //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_SMART_SEARCH_PIC_PARA = ^NET_DVR_SMART_SEARCH_PIC_PARA;

//人体特征识别结果
type
  NET_DVR_FACE_SUB_PIC_INFO = record 
    dwSimilarity: DWORD;  //相似度 0-100
    struVcaRect: NET_VCA_RECT;  //人脸区域，归一化坐标
    byRes2: array[0..236-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_SUB_PIC_INFO = ^NET_DVR_FACE_SUB_PIC_INFO;


type
  NET_DVR_BEHAVIOR_INFO = record 
    struVcaRect: NET_VCA_RECT;  
    wPeopleNum: WORD;  //区域人数，仅图片类型（NET_DVR_SMART_SEARCH_PIC_RET 中wPicType）为态势分析时有效
    byRes2: array[0..238-1] of BYTE;  //保留
  end;
  LPNET_DVR_BEHAVIOR_INFO = ^NET_DVR_BEHAVIOR_INFO;

type
  NET_DVR_PIC_FEATURE_UNION = record 
    case Byte of
    0: (byLen: array[0..256-1] of BYTE);  //联合体长度
    1: (struPlateInfo: NET_DVR_PLATE_INFO);  //车辆检索信息
    2: (struFaceSubInfo: NET_DVR_FACE_SUB_PIC_INFO);  //人脸子图信息
    3: (struBehavior: NET_DVR_BEHAVIOR_INFO);  //异常行为检测对应的子图信息
  end;
  LPNET_DVR_PIC_FEATURE_UNION = ^NET_DVR_PIC_FEATURE_UNION;

type
  NET_DVR_SMART_SEARCH_PIC_RET = record 
    sFileName: array[0..PICTURE_NAME_LEN-1] of AnsiChar;  //文件名
    struTime: NET_DVR_TIME_EX;  //图片的抓图时间
    dwFileSize: DWORD;  //文件的大小
    wPicType: WORD;  //图片类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-穿越警戒线，4-区域入侵， 5-物品遗留， 6-物品拿取， 7-进入区域， 8-离开区域， 9-非法停车，10-徘徊，11-人员聚集，12-快速移动,13-人员奔跑，14-剧烈运动，15-人员倒地，16-人数异常，17-离岗检测，18-人员滞留，19-态势分析  20-玩手机
    byRes1: array[0..2-1] of BYTE;  //保留
    uPicFeature: NET_DVR_PIC_FEATURE_UNION;  //图片属性
    byISO8601: BYTE;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， 正数表示东时区
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_SMART_SEARCH_PIC_RET = ^NET_DVR_SMART_SEARCH_PIC_RET;

type
  NET_DVR_T1TEST_SEND_DATA_BUZZER = record 
    byHearSound: BYTE;  //是否听到声音 0-未听到，1-听到
    byRes: array[0..31-1] of BYTE;  //保留
  end;
  LPNET_DVR_T1TEST_SEND_DATA_BUZZER = ^NET_DVR_T1TEST_SEND_DATA_BUZZER;


type
  NET_DVR_T1TEST_DATA_UNION = record 
    case Byte of
    0: (byUnionLen: array[0..32-1] of BYTE);  
    1: (struBuzzer: NET_DVR_T1TEST_SEND_DATA_BUZZER);  //蜂鸣器
    2: (struCurTime: NET_DVR_TIME_V30);  //当前PC机时间
  end;
  LPNET_DVR_T1TEST_DATA_UNION = ^NET_DVR_T1TEST_DATA_UNION;


type
  NET_DVR_T1TEST_SEND_DATA = record 
    dwSize: DWORD;  //结构体大小
    byDataType: BYTE;  //数据类型 0-蜂鸣器，1-pc本地时间
    byRes1: array[0..3-1] of BYTE;  
    uSendData: NET_DVR_T1TEST_DATA_UNION;  //发送的数据内容
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_T1TEST_SEND_DATA = ^NET_DVR_T1TEST_SEND_DATA;

type
  NET_DVR_PIC_MODEL_CFG = record //图像建模参数配置
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_PIC_MODEL_CFG = ^NET_DVR_PIC_MODEL_CFG;

type
  NET_DVR_MOUSE_EVENT_PARAM = record //鼠标信息配置
    dwSize: DWORD;  //结构体大小
    byMouseEvent: BYTE;  //鼠标事件类型， 0-鼠标左键单击，1-鼠标左键双击，2-鼠标右键，3-滚轮上滚，4-滚轮下滚
    byRes1: array[0..3-1] of BYTE;  //保留
    struPoint: NET_VCA_POINT;  //鼠标点位置坐标，归一化处理
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_MOUSE_EVENT_PARAM = ^NET_DVR_MOUSE_EVENT_PARAM;

type
  NET_DVR_AUTO_LIMIT_WAVE_CFG = record 
    byFBCEnable: BYTE;  //FBC开关 0-不开启，1-开启
    byMode: BYTE;  //模式, 0-快速, 1-普通,2-慢速
    byFilterQValue: BYTE;  //自适应滤波器Q值，单位Oct, 0-1/40,1-1/10, 默认值为1/40 Oct
    byStaticFilterNum: BYTE;  //静态滤波器数量，取值范围0-12
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_AUTO_LIMIT_WAVE_CFG = ^NET_DVR_AUTO_LIMIT_WAVE_CFG;

type
  NET_DVR_DSP_PARAMETER_CFG = record 
    byFBCEnable: BYTE;  //FBC开关 0-不开启，1-开启
    byVolume: BYTE;  //输入音量 取值范围0~255
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_DSP_PARAMETER_CFG = ^NET_DVR_DSP_PARAMETER_CFG;


type
  NET_DVR_MIX_AUDIOIN_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwHighPassFilter: DWORD;  //高通滤波器 取值范围 0-127, 具体索引代表含义以能力集为准
    dwNoiseMargin: DWORD;  //噪声门限，取值范围 0-127, 具体索引代表含义以能力集为准
    struLimitWave: NET_DVR_AUTO_LIMIT_WAVE_CFG;  //自动限波控制参数，当音频输入源为macIn时有效
    struDSPParameter: NET_DVR_DSP_PARAMETER_CFG;  //数字信号处理芯片参数
    byRes: array[0..40-1] of BYTE;  
  end;
  LPNET_DVR_MIX_AUDIOIN_CFG = ^NET_DVR_MIX_AUDIOIN_CFG;

type
  NET_DVR_MIX_AUDIOOUT_CFG = record 
    dwSize: DWORD;  //结构体大小
    byModulatorEnbale: BYTE;  //是否启用相位调制器
    byPostFilter: BYTE;  //Post Filter开关，0-关闭，1-开启，默认开启
    byLimitPressure: BYTE;  //输出压限开关 0-关闭，1-开启，默认开启
    byRes1: BYTE;  //保留
    wModulatorValue: WORD;  //相位调制量 取值范围 0-127, 具体索引代表含义以能力集为准，默认10
    wTriggerTime: WORD;  //压限触发时间，取值范围 0-127, 具体索引代表含义以能力集为准
    wFreeTime: WORD;  //压限释放时间，取值范围 0-127, 具体索引代表含义以能力集为准
    byCompressThreshold: BYTE;  //压缩门限 0-1X,1-2X,2-4X,3-8X  X表示倍，比如2X表示2倍
    byCompressMode: BYTE;  //压缩方式，0-硬压缩，1-软压缩，默认为硬压缩
    byCompressRate: BYTE;  //压缩率
    byRecoveryGain: BYTE;  //回复增益 0-1X,1-2X,2-4X,3-8X
    byOutputGain: BYTE;  //输出增益 0 ~100（负值）
    byOutputMute: BYTE;  //输出静音，0-关闭，1-开启
    iOutputGainEx: INT;  //输出增益扩展，返回正值为放大，负值为缩小
    bySoundQualityHanding: BYTE;  //音质处理，0-关闭，1-开启
    byRes: array[0..55-1] of BYTE;  
  end;
  LPNET_DVR_MIX_AUDIOOUT_CFG = ^NET_DVR_MIX_AUDIOOUT_CFG;

const
  MAX_AUDIOOUT_PRO_TYPE = 8;    //音频输出处理方式
type
  NET_DVR_VOLUME_CFG = record 
    dwSize: DWORD;  //结构体大小
    wVolume: array[0..MAX_AUDIOOUT_PRO_TYPE-1] of WORD;  //音量大小 取值范围 0-127, 具体索引代表含义以能力集为准
    byPhantomPowerSupply: BYTE;  //是否使用幻象电源供电(音频输入通道为MIC时有效)，0-无意义，1-不供电，2-供电
    byEnableAEC: BYTE;  //是否启用全局的回声消除,0-不启用，1-启用
    wTalkVolume: WORD;  //支持对讲的设备，对讲时音量大小
    byEnableFBC: array[0..MAX_AUDIOOUT_PRO_TYPE-1] of BYTE;  //是否启用FBC(啸叫抑制),0-不启用，1-启用
    wVolumeEx: array[0..MAX_AUDIOOUT_PRO_TYPE-1] of WORD;  //音量大小扩展 取值范围 0-127, 具体索引代表含义以能力集为准
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_VOLUME_CFG = ^NET_DVR_VOLUME_CFG;

type
  NET_DVR_VIDEOOUT_RESOLUTION_CFG = record //视频输出口分辨率配置
    dwSize: DWORD;  //结构体大小
    byResolution: BYTE;  //分辨率 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080, 5-3840*2160
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOOUT_RESOLUTION_CFG = ^NET_DVR_VIDEOOUT_RESOLUTION_CFG;

type
  NET_DVR_ADDR_DOMAIN_INFO = record 
    szDomainAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有'.'则认为是域名,否则为IP地址  
    wPort: WORD;  
    byRes: array[0..2-1] of BYTE;  
  end;
  LPNET_DVR_ADDR_DOMAIN_INFO = ^NET_DVR_ADDR_DOMAIN_INFO;

const
  MAX_CENTERNUM_V40 = 6;    //报警中心地址个数

//报警中心网络配置
type
  NET_DVR_ALARMCENTER_NETCFG = record 
    dwSize: DWORD;  
    byAuxiliaryAlarmAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  // 辅报警主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有’.’则认为是域名,否则为IP地址 
    wAuxiliaryAlarmPort: WORD;  // 辅报警主机端口号 
    struHostAddr: array[0..MAX_CENTERNUM_V40-1] of NET_DVR_ADDR_DOMAIN_INFO;  //报警中心地址信息
    byRes: array[0..172-1] of BYTE;  
  end;
  LPNET_DVR_ALARMCENTER_NETCFG = ^NET_DVR_ALARMCENTER_NETCFG;

//报警联动参数结构
type
  NET_DVR_ALARM_LINKAGE_PARAM = record 
    dwSize: DWORD;  
    wChanRec: WORD;  //联动录像的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不录像，1-录像
    byRes1: array[0..2-1] of BYTE;  
    wRecTime: array[0..MAX_LINKAGE_CHAN_NUM-1] of WORD;  //录像的时间，按字节表示，例如byRecTime[0]表示通道1的录像时间，byRecTime[15]表示通道16的录像时间
    wChanPic: WORD;  //联动抓图的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不抓图，1-抓图
    byRes2: array[0..2-1] of BYTE;  
    byPicNum: array[0..MAX_LINKAGE_CHAN_NUM-1] of BYTE;  //抓图的个数，按字节表示，例如byPicNum[0]表示通道1的抓图个数，byPicNum[15]表示通道16的抓图个数
    byTriggerEnabled: array[0..ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //变量联动触发器，0-不联动，1-联动
    bySensorJointAlarmOut: array[0..ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //遥信值按类型联动触发器，该值为byTriggerEnabled的扩充。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    byRes3: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARM_LINKAGE_PARAM = ^NET_DVR_ALARM_LINKAGE_PARAM;


//雷达调试报警上传 抓拍机4.0新增
type
  NET_DVR_ALARM_RADARINFO = record 
    dwSize: DWORD;  
    dwRadarTriggerTimeSecond: DWORD;  //雷达触发时间，秒
    dwRadarTriggerTimeMSecond: DWORD;  //雷达触发时间，毫秒
    dwVedioTriggerTimeSecond: DWORD;  //视频触发时间，秒
    dwVedioTriggerTimeMSecond: DWORD;  //视频触发时间，毫秒
    dwVedioRadarDiffTimeMSecond: DWORD;  //雷达视频触发时间差，毫秒
    dwRadarSpeed: DWORD;  //雷达速度
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_RADARINFO = ^NET_DVR_ALARM_RADARINFO;

const
  MAX_FINGER_PRINT_LEN = 768;    //最大指纹长度
type
  NET_DVR_FINGER_PRINT_CFG = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    dwFingerPrintLen: DWORD;  //指纹数据长度
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //需要下发指纹的读卡器，按数组表示，0-不下发该读卡器，1-下发到该读卡器
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹
    byRes1: array[0..30-1] of BYTE;  
    byFingerData: array[0..MAX_FINGER_PRINT_LEN-1] of BYTE;  //指纹数据内容
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FINGER_PRINT_CFG = ^NET_DVR_FINGER_PRINT_CFG;

type
  NET_DVR_FINGER_PRINT_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byCardReaderRecvStatus: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹
    byTotalStatus: BYTE;  //下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    byRes1: BYTE;  
    byErrorMsg: array[0..ERROR_MSG_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    dwCardReaderNo: DWORD;  //非0表示错误信息byErrMsg有效，其值代表byErrMsg对应的读卡器编号（具体什么错误查看byCardReaderRecvStatus对应编号的值）。0时表示无错误信息
    byRes: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_FINGER_PRINT_STATUS = ^NET_DVR_FINGER_PRINT_STATUS;


type
  NET_DVR_FINGER_PRINT_INFO_COND = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹的读卡器信息，按数组表示
    dwFingerPrintNum: DWORD;  //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    byFingerPrintID: BYTE;  //手指编号，有效值范围为-10   0xff表示该卡所有指纹
    byCallbackMode: BYTE;  //设备回调方式，0-设备所有读卡器下完了范围，1-在时间段内下了部分也返回
    byRes1: array[0..26-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_INFO_COND = ^NET_DVR_FINGER_PRINT_INFO_COND;

type
  NET_DVR_FINGER_PRINT_CFG_V50 = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    dwFingerPrintLen: DWORD;  //指纹数据长度
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //需要下发指纹的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
    byRes1: array[0..30-1] of BYTE;  
    byFingerData: array[0..MAX_FINGER_PRINT_LEN-1] of BYTE;  //指纹数据内容
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byLeaderFP: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //对门是否有首次认证功能（按字节表示）：0-无首次认证功能，1-有首次认证功能
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FINGER_PRINT_CFG_V50 = ^NET_DVR_FINGER_PRINT_CFG_V50;

type
  NET_DVR_FINGER_PRINT_STATUS_V50 = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byCardReaderRecvStatus: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置，10-指纹读卡器版本过低（无法支持工号）
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
    byTotalStatus: BYTE;  //下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    byRecvStatus: BYTE;  //主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
    byErrorMsg: array[0..ERROR_MSG_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    dwCardReaderNo: DWORD;  //当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byErrorEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的工号（人员ID）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FINGER_PRINT_STATUS_V50 = ^NET_DVR_FINGER_PRINT_STATUS_V50;

type
  NET_DVR_FINGER_PRINT_INFO_COND_V50 = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号（该字段获取时有效，设置时无效）
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹的读卡器是否有效，0-无效，1-有效
    dwFingerPrintNum: DWORD;  //设置或获指纹数量，获取时置为0xffffffff表示获取所有指纹信息
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10   0xff表示该卡所有指纹
    byCallbackMode: BYTE;  //设备回调方式，0-设备所有读卡器下完了返回，1-在时间段内下了部分也返回
    byRes2: array[0..2-1] of BYTE;  //保留
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byRes1: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_INFO_COND_V50 = ^NET_DVR_FINGER_PRINT_INFO_COND_V50;

type
  NET_DVR_FINGER_PRINT_BYCARD = record 
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹的读卡器信息，按数组表示
    byFingerPrintID: array[0..MAX_FINGER_PRINT_NUM{10}-1] of BYTE;  //需要获取的指纹信息，按数组下标，值表示0-不删除，1-删除该指纹
    byRes1: array[0..34-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_BYCARD = ^NET_DVR_FINGER_PRINT_BYCARD;

type
  NET_DVR_FINGER_PRINT_BYREADER = record 
    dwCardReaderNo: DWORD;  //按值表示，指纹读卡器编号
    byClearAllCard: BYTE;  //是否删除所有卡的指纹信息，0-按卡号删除指纹信息，1-删除所有卡的指纹信息
    byRes1: array[0..3-1] of BYTE;  //保留
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byRes: array[0..548-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_BYREADER = ^NET_DVR_FINGER_PRINT_BYREADER;

type
  NET_DVR_DEL_FINGER_PRINT_MODE = record 
    case Byte of
    0: (uLen: array[0..588-1] of BYTE);  //联合体长度
    1: (struByCard: NET_DVR_FINGER_PRINT_BYCARD);  //按卡号的方式删除
    2: (struByReader: NET_DVR_FINGER_PRINT_BYREADER);  //按读卡器的方式删除
  end;
  LPNET_DVR_DEL_FINGER_PRINT_MODE = ^NET_DVR_DEL_FINGER_PRINT_MODE;

type
  NET_DVR_FINGER_PRINT_INFO_CTRL = record 
    dwSize: DWORD;  
    byMode: BYTE;  //删除方式，0-按卡号方式删除，1-按读卡器删除
    byRes1: array[0..3-1] of BYTE;  //保留
    struProcessMode: NET_DVR_DEL_FINGER_PRINT_MODE;  //处理方式
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_INFO_CTRL = ^NET_DVR_FINGER_PRINT_INFO_CTRL;

type
  NET_DVR_FINGER_PRINT_BYCARD_V50 = record 
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byEnableCardReader: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //指纹的读卡器信息，按位表示
    byFingerPrintID: array[0..MAX_FINGER_PRINT_NUM{10}-1] of BYTE;  //需要删除的手指编号，按数组下标，值表示0-不删除，1-删除该指纹
    byRes1: array[0..2-1] of BYTE;  
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
  end;
  LPNET_DVR_FINGER_PRINT_BYCARD_V50 = ^NET_DVR_FINGER_PRINT_BYCARD_V50;

type
  NET_DVR_FINGER_PRINT_BYREADER_V50 = record 
    dwCardReaderNo: DWORD;  //按值表示，指纹读卡器编号
    byClearAllCard: BYTE;  //是否删除所有卡的指纹信息，0-按卡号（人员ID）删除指纹信息，1-删除所有卡（人员ID）的指纹信息
    byRes1: array[0..3-1] of BYTE;  //保留
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE;  //工号（人员ID）
    byRes: array[0..516-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_BYREADER_V50 = ^NET_DVR_FINGER_PRINT_BYREADER_V50;

type
  NET_DVR_DEL_FINGER_PRINT_MODE_V50 = record 
    case Byte of
    0: (uLen: array[0..588-1] of BYTE);  //联合体长度
    1: (struByCard: NET_DVR_FINGER_PRINT_BYCARD_V50);  //按卡号（人员ID）的方式删除
    2: (struByReader: NET_DVR_FINGER_PRINT_BYREADER_V50);  //按读卡器的方式删除
  end;
  LPNET_DVR_DEL_FINGER_PRINT_MODE_V50 = ^NET_DVR_DEL_FINGER_PRINT_MODE_V50;

type
  NET_DVR_FINGER_PRINT_INFO_CTRL_V50 = record 
    dwSize: DWORD;  
    byMode: BYTE;  //删除方式，0-按卡号（人员ID）方式删除，1-按读卡器删除
    byRes1: array[0..3-1] of BYTE;  //保留
    struProcessMode: NET_DVR_DEL_FINGER_PRINT_MODE_V50;  //处理方式
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_INFO_CTRL_V50 = ^NET_DVR_FINGER_PRINT_INFO_CTRL_V50;

type
  NET_DVR_FINGER_PRINT_INFO_STATUS_V50 = record 
    dwSize: DWORD;  
    dwCardReaderNo: DWORD;  //按值表示，指纹读卡器编号
    byStatus: BYTE;  //状态：0-无效，1-处理中，2-删除失败，3-成功
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_FINGER_PRINT_INFO_STATUS_V50 = ^NET_DVR_FINGER_PRINT_INFO_STATUS_V50;

type
  ACS_DEV_SUBEVENT_ENUM =  
  (  
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,  //主机防拆报警
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,  //离线事件满90%报警
    EVENT_ACS_NET_BROKEN,  //网络断开
    EVENT_ACS_NET_RESUME,  //网络恢复
    EVENT_ACS_LOW_BATTERY,  //蓄电池电压低
    EVENT_ACS_BATTERY_RESUME,  //蓄电池电压恢复正常
    EVENT_ACS_AC_OFF,  //交流电断电
    EVENT_ACS_AC_RESUME,  //交流电恢复
    EVENT_ACS_SD_CARD_FULL,  //SD卡存储满报警
    EVENT_ACS_LINKAGE_CAPTURE_PIC,  //联动抓拍事件报警
    EVENT_ACS_IMAGE_QUALITY_LOW,  //人脸图像画质低
    EVENT_ACS_FINGER_PRINT_QUALITY_LOW,  //指纹图像画质低
    EVENT_ACS_BATTERY_ELECTRIC_LOW,  //电池电压低(仅人脸设备使用)
    EVENT_ACS_BATTERY_ELECTRIC_RESUME,  //电池电压恢复正常(仅人脸设备使用)
    EVENT_ACS_FIRE_IMPORT_SHORT_CIRCUIT,  //消防输入短路报警
    EVENT_ACS_FIRE_IMPORT_BROKEN_CIRCUIT,  //消防输入断路报警
    EVENT_ACS_FIRE_IMPORT_RESUME,  //消防输入恢复
    EVENT_ACS_MASTER_RS485_LOOPNODE_BROKEN,  //主控RS485环路节点断开
    EVENT_ACS_MASTER_RS485_LOOPNODE_RESUME,  //主控RS485环路节点恢复
    EVENT_ACS_LOCAL_CONTROL_OFFLINE,  //就地控制器掉线
    EVENT_ACS_LOCAL_CONTROL_RESUME,  //就地控制器掉线恢复
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN,  //就地下行RS485环路断开
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME,  //就地下行RS485环路恢复
    EVENT_ACS_DISTRACT_CONTROLLER_ONLINE,  //分控器在线
    EVENT_ACS_DISTRACT_CONTROLLER_OFFLINE,  //分控器离线
    EVENT_ACS_FIRE_BUTTON_TRIGGER,  //消防按钮触发
    EVENT_ACS_FIRE_BUTTON_RESUME,  //消防按钮恢复
    EVENT_ACS_MAINTENANCE_BUTTON_TRIGGER,  //维护按钮触发
    EVENT_ACS_MAINTENANCE_BUTTON_RESUME,  //维护按钮恢复
    EVENT_ACS_EMERGENCY_BUTTON_TRIGGER,  //紧急按钮触发
    EVENT_ACS_EMERGENCY_BUTTON_RESUME,  //紧急按钮恢复
    EVENT_ACS_RES,  
    EVENT_ACS_SUBMARINEBACK_COMM_BREAK,  //与反潜回服务器通信断开
    EVENT_ACS_SUBMARINEBACK_COMM_RESUME,  //与反潜回服务器通信恢复
    EVENT_ACS_REMOTE_ACTUAL_GUARD,  //远程实时布防
    EVENT_ACS_REMOTE_ACTUAL_UNGUARD,  //远程实时撤防
    EVENT_ACS_MOTOR_SENSOR_EXCEPTION,  //电机或传感器异常
    EVENT_ACS_CAN_BUS_EXCEPTION,  //CAN总线异常
    EVENT_ACS_CAN_BUS_RESUME,  //CAN总线恢复
    EVENT_ACS_GATE_TEMPERATURE_OVERRUN,  //闸机腔体温度超限
    EVENT_ACS_IR_EMITTER_EXCEPTION,  //红外对射异常
    EVENT_ACS_IR_EMITTER_RESUME,  //红外对射恢复
    EVENT_ACS_LAMP_BOARD_COMM_EXCEPTION,  //灯板通信异常
    EVENT_ACS_LAMP_BOARD_COMM_RESUME,  //灯板通信恢复
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_EXCEPTION,  //红外转接板通信异常
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_RESUME,  //红外转接板通信恢复
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_ALARM,  //通道控制器防拆报警
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_RESUME,  //通道控制器防拆报警恢复
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM,  //通道控制器消防输入报警
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME,  //通道控制器消防输入报警恢复
    EVENT_ACS_STAY_EVENT,  //逗留事件
    EVENT_ACS_LEGAL_EVENT_NEARLY_FULL,  //离线合法事件满90%报警
    EVENT_ACS_FIRE_IMPORT_ALARM = 52,  //消防输入报警
    EVENT_ACS_NOMASK_ALARM,  //未带口罩报警
    EVENT_ACS_FIREMATRIX_EVENT,  //消防矩阵事件上传
    EVENT_ACS_HEALTH_INFO_ABNORMAL_LOCK,  //健康信息异常锁定
    EVENT_ACS_HEALTH_INFO_ABNORMAL_UNLOCK,  //健康信息异常解锁
    EVENT_ACS_IPC_EVENT  //IPC事件上传
  );

type
  ACS_ALARM_SUBEVENT_ENUM =  
  (  
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,  //防区短路报警
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,  //防区断路报警
    EVENT_ACS_ALARMIN_EXCEPTION,  //防区异常报警
    EVENT_ACS_ALARMIN_RESUME,  //防区报警恢复
    EVENT_ACS_CASE_SENSOR_ALARM,  //事件输入报警
    EVENT_ACS_CASE_SENSOR_RESUME  //事件输入恢复
  );

type
  ACS_DOOR_SUBEVENT_ENUM =  
  (  
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN = 0,  //首卡开门开始
    EVENT_ACS_LEADER_CARD_OPEN_END,  //首卡开门结束
    EVENT_ACS_ALWAYS_OPEN_BEGIN,  //常开状态开始
    EVENT_ACS_ALWAYS_OPEN_END,  //常开状态结束
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,  //常关状态开始
    EVENT_ACS_ALWAYS_CLOSE_END,  //常关状态结束
    EVENT_ACS_LOCK_OPEN,  //门锁打开
    EVENT_ACS_LOCK_CLOSE,  //门锁关闭
    EVENT_ACS_DOOR_BUTTON_PRESS,  //开门按钮按下
    EVENT_ACS_DOOR_BUTTON_RELEASE,  //开门按钮放开
    EVENT_ACS_DOOR_OPEN_NORMAL,  //正常开门（门磁）
    EVENT_ACS_DOOR_CLOSE_NORMAL,  //正常关门（门磁）
    EVENT_ACS_DOOR_OPEN_ABNORMAL,  //门异常打开（门磁）
    EVENT_ACS_DOOR_OPEN_TIMEOUT,  //门打开超时（门磁）
    EVENT_ACS_REMOTE_OPEN_DOOR,  //远程开门
    EVENT_ACS_REMOTE_CLOSE_DOOR,  //远程关门
    EVENT_ACS_REMOTE_ALWAYS_OPEN,  //远程常开
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,  //远程常关
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,  //卡不属于多重认证群组
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,  //卡不在多重认证时间段内
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,  //多重认证模式超级密码认证失败
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,  //多重认证模式远程认证失败
    EVENT_ACS_MULTI_VERIFY_SUCCESS,  //多重认证成功
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,  //多重多重认证需要远程开门
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,  //多重认证超级密码认证成功事件
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,  //多重认证重复认证失败
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,  //多重认证超时失败
    EVENT_ACS_REMOTE_CAPTURE_PIC,  //远程抓拍
    EVENT_ACS_DOORBELL_RINGING,  //门铃响
    EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM,  //门控安全模块防拆报警
    EVENT_ACS_CALL_CENTER,  //呼叫中心事件
    EVENT_ACS_FIRSTCARD_AUTHORIZE_BEGIN,  //首卡授权开始
    EVENT_ACS_FIRSTCARD_AUTHORIZE_END,  //首卡授权结束
    EVENT_ACS_DOORLOCK_INPUT_SHORT_CIRCUIT,  //门锁输入短路报警
    EVENT_ACS_DOORLOCK_INPUT_BROKEN_CIRCUIT,  //门锁输入断路报警
    EVENT_ACS_DOORLOCK_INPUT_EXCEPTION,  //门锁输入异常报警
    EVENT_ACS_DOORCONTACT_INPUT_SHORT_CIRCUIT,  //门磁输入短路报警
    EVENT_ACS_DOORCONTACT_INPUT_BROKEN_CIRCUIT,  //门磁输入断路报警
    EVENT_ACS_DOORCONTACT_INPUT_EXCEPTION,  //门磁输入异常报警
    EVENT_ACS_OPENBUTTON_INPUT_SHORT_CIRCUIT,  //开门按钮输入短路报警
    EVENT_ACS_OPENBUTTON_INPUT_BROKEN_CIRCUIT,  //开门按钮输入断路报警
    EVENT_ACS_OPENBUTTON_INPUT_EXCEPTION,  //开门按钮输入异常报警
    EVENT_ACS_DOORLOCK_OPEN_EXCEPTION,  //门锁异常打开
    EVENT_ACS_DOORLOCK_OPEN_TIMEOUT,  //门锁打开超时
    EVENT_ACS_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE,  //首卡未授权开门失败
    EVENT_ACS_CALL_LADDER_RELAY_BREAK,  //呼梯继电器断开
    EVENT_ACS_CALL_LADDER_RELAY_CLOSE,  //呼梯继电器闭合
    EVENT_ACS_AUTO_KEY_RELAY_BREAK,  //自动按键继电器断开
    EVENT_ACS_AUTO_KEY_RELAY_CLOSE,  //自动按键继电器闭合
    EVENT_ACS_KEY_CONTROL_RELAY_BREAK,  //按键梯控继电器断开
    EVENT_ACS_KEY_CONTROL_RELAY_CLOSE,  //按键梯控继电器闭合
    EVENT_ACS_REMOTE_VISITOR_CALL_LADDER,  //访客呼梯
    EVENT_ACS_REMOTE_HOUSEHOLD_CALL_LADDER,  //住户呼梯
    EVENT_ACS_LEGAL_MESSAGE,  //合法短信
    EVENT_ACS_ILLEGAL_MESSAGE,  //非法短信
    EVENT_ACS_TRAILING,  //尾随通行
    EVENT_ACS_REVERSE_ACCESS,  //反向闯入
    EVENT_ACS_FORCE_ACCESS,  //外力冲撞
    EVENT_ACS_CLIMBING_OVER_GATE,  //翻越
    EVENT_ACS_PASSING_TIMEOUT,  //通行超时
    EVENT_ACS_INTRUSION_ALARM,  //误闯报警
    EVENT_ACS_FREE_GATE_PASS_NOT_AUTH,  //闸机自由通行时未认证通过
    EVENT_ACS_DROP_ARM_BLOCK,  //摆臂被阻挡
    EVENT_ACS_DROP_ARM_BLOCK_RESUME,  //摆臂阻挡消除
    EVENT_ACS_REMOTE_CONTROL_CLOSE_DOOR,  //遥控器关门
    EVENT_ACS_REMOTE_CONTROL_OPEN_DOOR,  //遥控器开门
    EVENT_ACS_REMOTE_CONTROL_ALWAYS_OPEN_DOOR  //遥控器常开门
  );

type
  ACS_CARD_READER_SUBEVENT_ENUM =  
  (  
    EVENT_ACS_STRESS_ALARM = 0,  //胁迫报警
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,  //读卡器防拆报警
    EVENT_ACS_LEGAL_CARD_PASS,  //合法卡认证通过
    EVENT_ACS_CARD_AND_PSW_PASS,  //刷卡加密码认证通过
    EVENT_ACS_CARD_AND_PSW_FAIL,  //刷卡加密码认证失败
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,  //刷卡加密码认证超时
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,  //读卡器认证失败超次
    EVENT_ACS_CARD_NO_RIGHT,  //卡未分配权限
    EVENT_ACS_CARD_INVALID_PERIOD,  //卡当前时段无效
    EVENT_ACS_CARD_OUT_OF_DATE,  //卡号过期
    EVENT_ACS_INVALID_CARD,  //无此卡号
    EVENT_ACS_ANTI_SNEAK_FAIL,  //反潜回认证失败
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,  //互锁门未关闭
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,  //指纹比对通过
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,  //指纹比对失败
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,  //刷卡加指纹认证通过
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,  //刷卡加指纹认证失败
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,  //刷卡加指纹认证超时
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,  //刷卡加指纹加密码认证通过
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,  //刷卡加指纹加密码认证失败
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,  //刷卡加指纹加密码认证超时
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,  //指纹加密码认证通过
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,  //指纹加密码认证失败
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,  //指纹加密码认证超时
    EVENT_ACS_FINGERPRINT_INEXISTENCE,  //指纹不存在
    EVENT_ACS_FACE_VERIFY_PASS,  //人脸认证通过
    EVENT_ACS_FACE_VERIFY_FAIL,  //人脸认证失败
    EVENT_ACS_FACE_AND_FP_VERIFY_PASS,  //人脸加指纹认证通过
    EVENT_ACS_FACE_AND_FP_VERIFY_FAIL,  //人脸加指纹认证失败
    EVENT_ACS_FACE_AND_FP_VERIFY_TIMEOUT,  //人脸加指纹认证超时
    EVENT_ACS_FACE_AND_PW_VERIFY_PASS,  //人脸加密码认证通过
    EVENT_ACS_FACE_AND_PW_VERIFY_FAIL,  //人脸加密码认证失败
    EVENT_ACS_FACE_AND_PW_VERIFY_TIMEOUT,  //人脸加密码认证超时
    EVENT_ACS_FACE_AND_CARD_VERIFY_PASS,  //人脸加刷卡认证通过
    EVENT_ACS_FACE_AND_CARD_VERIFY_FAIL,  //人脸加刷卡认证失败
    EVENT_ACS_FACE_AND_CARD_VERIFY_TIMEOUT,  //人脸加刷卡认证超时
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_PASS,  //人脸加密码加指纹认证通过
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_FAIL,  //人脸加密码加指纹认证失败
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT,  //人脸加密码加指纹认证超时
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_PASS,  //人脸加刷卡加指纹认证通过
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_FAIL,  //人脸加刷卡加指纹认证失败
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_TIMEOUT,  //人脸加刷卡加指纹认证超时
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_PASS,  //工号加指纹认证通过
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_FAIL,  //工号加指纹认证失败
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT,  //工号加指纹认证超时
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS,  //工号加指纹加密码认证通过
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL,  //工号加指纹加密码认证失败
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT,  //工号加指纹加密码认证超时
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_PASS,  //工号加人脸认证通过
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_FAIL,  //工号加人脸认证失败
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT,  //工号加人脸认证超时
    EVENT_ACS_FACE_RECOGNIZE_FAIL,  //人脸识别失败
    EVENT_ACS_EMPLOYEENO_AND_PW_PASS,  //工号加密码认证通过
    EVENT_ACS_EMPLOYEENO_AND_PW_FAIL,  //工号加密码认证失败
    EVENT_ACS_EMPLOYEENO_AND_PW_TIMEOUT,  //工号加密码认证超时
    EVENT_ACS_HUMAN_DETECT_FAIL,  //真人检测失败
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_PASS,  //人证比对通过
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_FAIL,  //人证比对失败
    EVENT_ACS_DOOR_OPEN_OR_DORMANT_FAIL,  //门状态常闭或休眠状态认证失败
    EVENT_ACS_AUTH_PLAN_DORMANT_FAIL,  //认证计划休眠模式认证失败
    EVENT_ACS_CARD_ENCRYPT_VERIFY_FAIL,  //卡加密校验失败
    EVENT_ACS_SUBMARINEBACK_REPLY_FAIL,  //反潜回服务器应答失败
    EVENT_ACS_PASSWORD_MISMATCH,  //密码不匹配
    EVENT_ACS_EMPLOYEE_NO_NOT_EXIST,  //工号不存在
    EVENT_ACS_COMBINED_VERIFY_PASS,  //组合认证通过
    EVENT_ACS_COMBINED_VERIFY_TIMEOUT,  //组合认证超时
    EVENT_ACS_VERIFY_MODE_MISMATCH,  //认证方式不匹配
    EVENT_ACS_PSW_ERROR_OVER_TIMES,  //密码认证超次  67
    EVENT_ACS_PSW_VERIFY_PASS,  //密码认证通过
    EVENT_ACS_PSW_VERIFY_FAIL,  //密码认证失败
    EVENT_ACS_ORCODE_VERIFY_PASS,  //二维码认证通过
    EVENT_ACS_ORCODE_VERIFY_FAIL,  //二维码认证失败
    EVENT_ACS_HOUSEHOLDER_AUTHORIZE_PASS,  //户主授权认证通过
    EVENT_ACS_BLUETOOTH_VERIFY_PASS,  //蓝牙认证通过
    EVENT_ACS_BLUETOOTH_VERIFY_FAIL,  //蓝牙认证失败 74
    EVENT_ACS_INFORMAL_M1_CARD_VERIFY_FAIL,  //非正规M1卡认证失败
    EVENT_ACS_CPU_CARD_ENCRYPT_VERIFY_FAIL,  //CPU卡加密校验失败
    EVENT_ACS_NFC_DISABLE_VERIFY_FAIL,  //NFC功能关闭验证失败
    EVENT_ACS_EM_CARD_RECOGNIZE_NOT_ENABLED,  //EM卡识别未启用
    EVENT_ACS_M1_CARD_RECOGNIZE_NOT_ENABLED,  //M1卡识别未启用
    EVENT_ACS_CPU_CARD_RECOGNIZE_NOT_ENABLED,  //CPU卡识别未启用
    EVENT_ACS_ID_CARD_RECOGNIZE_NOT_ENABLED,  //身份证识别未启用
    EVENT_ACS_CARD_SET_SECRET_KEY_FAIL,  //卡灌装密钥失败
    EVENT_ACS_DESFIRE_CARD_ENCRYPT_VERIFY_FAIL,  //Desfire卡加密校验失败
    EVENT_ACS_DESFIRE_CARD_RECOGNIZE_NOT_ENABLED,  //Desfire卡识别未启用
    EVENT_ACS_IRIS_VERIFY_PASS,  //虹膜认证通过
    EVENT_ACS_IRIS_VERIFY_FAIL,  //虹膜认证失败
    EVENT_ACS_IRIS_BIOASSAY_FAIL,  //虹膜活体检测失败
    EVENT_ACS_FELICA_CARD_RECOGNIZE_NOT_ENABLED,  //Felica卡识别未启用
    EVENT_ACS_ORCODE_RECOGNIZE_PASS,  //二维码识别成功（纯二维码事件，不带任何认证）
    EVENT_ACS_VP_ANTI_SPOOFING_FAIL,  //声纹活体检测失败
    EVENT_ACS_VP_VERIFY_FAIL,  //声纹认证失败
    EVENT_ACS_ESD_OK,  //ESD合格开门
    EVENT_ACS_ESD_NOT_OK_OPEN_DOOR,  //ESD不合格但开门
    EVENT_ACS_ESD_NOT_OK,  //ESD不合格不开门
    EVENT_ACS_ESD_OVERTIME  //ESD检测超时
  );

type
  NET_DVR_EVENT_LINKAGE_INFO = record 
    wMainEventType: WORD;  //事件主类型，0-设备事件，1-报警输入事件，2-门事件，3-读卡器事件
    wSubEventType: WORD;  //事件次类型
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_LINKAGE_INFO = ^NET_DVR_EVENT_LINKAGE_INFO;

type
  NET_DVR_EVETN_CARD_LINKAGE_UNION = record 
    case Byte of
    0: (byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE);  //卡号
    1: (struEventLinkage: NET_DVR_EVENT_LINKAGE_INFO);  //事件联动时参数
    2: (byMACAddr: array[0..MACADDR_LEN-1] of BYTE);  //物理MAC地址
    3: (byEmployeeNo: array[0..NET_SDK_EMPLOYEE_NO_LEN-1] of BYTE);  //工号（人员ID）
  end;
  LPNET_DVR_EVETN_CARD_LINKAGE_UNION = ^NET_DVR_EVETN_CARD_LINKAGE_UNION;

type
  NET_DVR_EVENT_CARD_LINKAGE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byProMode: BYTE;  //联动方式，0-事件，1-卡号
    byRes1: array[0..3-1] of BYTE;  
    dwEventSourceID: DWORD;  //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID
    uLinkageInfo: NET_DVR_EVETN_CARD_LINKAGE_UNION;  //联动方式参数
    byAlarmout: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联的报警输出号，按数组表示，为0表示不关联，为1表示关联
    byRes2: array[0..32-1] of BYTE;  //保留
    byOpenDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否联动开门，0-不联动，1-联动
    byCloseDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否联动关门，0-不联动，1-联动
    byNormalOpen: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否联动常开，0-不联动，1-联动
    byNormalClose: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按数组表示,是否联动常关，0-不联动，1-联动
    byMainDevBuzzer: BYTE;  //主机蜂鸣器   0-不联动，1-联动输出
    byCapturePic: BYTE;  //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    byRecordVideo: BYTE;  //是否联动录像，0-不联动录像，1-联动录像
    byRes3: array[0..29-1] of BYTE;  //保留
    byReaderBuzzer: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //联动读卡器蜂鸣器，按数组表示，0-不联动，1-联动
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_EVENT_CARD_LINKAGE_CFG = ^NET_DVR_EVENT_CARD_LINKAGE_CFG;

type
  NET_DVR_EVENT_CARD_LINKAGE_CFG_V50 = record 
    dwSize: DWORD;  //结构体大小
    byProMode: BYTE;  //联动方式，0-事件，1-卡号, 2-MAC地址
    byRes1: array[0..3-1] of BYTE;  
    dwEventSourceID: DWORD;  //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
    uLinkageInfo: NET_DVR_EVETN_CARD_LINKAGE_UNION;  //联动方式参数
    byAlarmout: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联的报警输出号，按位表示，为0表示不关联，为1表示关联
    byRes2: array[0..32-1] of BYTE;  //保留
    byOpenDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动开门，0-不联动，1-联动
    byCloseDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动关门，0-不联动，1-联动
    byNormalOpen: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动常开，0-不联动，1-联动
    byNormalClose: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动常关，0-不联动，1-联动
    byMainDevBuzzer: BYTE;  //主机蜂鸣器   0-不联动，1-联动输出
    byCapturePic: BYTE;  //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    byRecordVideo: BYTE;  //是否联动录像，0-不联动录像，1-联动录像
    byRes3: array[0..29-1] of BYTE;  //保留
    byReaderBuzzer: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
    byAlarmOutClose: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
    byAlarmInSetup: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //关联防区布防，按字节表示，为0表示不关联，为1表示关联
    byAlarmInClose: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //关联防区撤防，按字节表示，为0表示不关联，为1表示关联
    byRes: array[0..500-1] of BYTE;  //保留
  end;
  LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50 = ^NET_DVR_EVENT_CARD_LINKAGE_CFG_V50;

type
  NET_DVR_EVENT_CARD_LINKAGE_CFG_V51 = record 
    dwSize: DWORD;  //结构体大小
    byProMode: BYTE;  //联动方式，0-事件，1-卡号，2-MAC地址，3-工号（人员ID）
    byRes1: array[0..3-1] of BYTE;  
    dwEventSourceID: DWORD;  //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
    uLinkageInfo: NET_DVR_EVETN_CARD_LINKAGE_UNION;  //联动方式参数
    byAlarmout: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联的报警输出号，按位表示，为0表示不关联，为1表示关联
    byRes2: array[0..32-1] of BYTE;  //保留
    byOpenDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动开门，0-不联动，1-联动
    byCloseDoor: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动关门，0-不联动，1-联动
    byNormalOpen: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动常开，0-不联动，1-联动
    byNormalClose: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //按位表示,是否联动常关，0-不联动，1-联动
    byMainDevBuzzer: BYTE;  //主机蜂鸣器   0-不联动，1-联动输出
    byCapturePic: BYTE;  //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    byRecordVideo: BYTE;  //是否联动录像，0-不联动录像，1-联动录像
    byMainDevStopBuzzer: BYTE;  //主机停止蜂鸣   0-不联动，1-联动输出
    wAudioDisplayID: WORD;  //联动语音播放ID：0-不联动，目前范围1-32
    byAudioDisplayMode: BYTE;  //联动语音播放模式：0-关闭，1-单次播放，2-循环播放
    byRes3: array[0..25-1] of BYTE;  //保留
    byReaderBuzzer: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
    byAlarmOutClose: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
    byAlarmInSetup: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //关联防区布防，按字节表示，为0表示不关联，为1表示关联
    byAlarmInClose: array[0..MAX_ALARMHOST_ALARMIN_NUM-1] of BYTE;  //关联防区撤防，按字节表示，为0表示不关联，为1表示关联
    byReaderStopBuzzer: array[0..MAX_CARD_READER_NUM_512-1] of BYTE;  //联动读卡器停止蜂鸣，按字节表示，0-不联动，1-联动
    byRes: array[0..512-1] of BYTE;  //保留
  end;
  LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V51 = ^NET_DVR_EVENT_CARD_LINKAGE_CFG_V51;

type
  NET_DVR_EVENT_CARD_LINKAGE_COND = record 
    dwSize: DWORD;  
    dwEventID: DWORD;  //事件ID
    wLocalControllerID: WORD;  //就地控制器序号[1,64]
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_EVENT_CARD_LINKAGE_COND = ^NET_DVR_EVENT_CARD_LINKAGE_COND;

type
  NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM = record 
    dwSize: DWORD;  
    dwFileSize: DWORD;  //文件大小，单位：字节（上传音频文件时有效，下载音频文件时无效）
    dwAudioID: DWORD;  //音频ID（0xffffffff代表上传/下载全部音频文件，目前设备仅支持全量上传/下载，不支持单个音频ID上传/下载）
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM = ^NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM;

//客户标定文件结构体
type
  NET_DVR_CLIENT_CALIBFILE_PARAM = record 
    dwSize: DWORD;  
    dwFileLen: DWORD;  //文件大小
    byChannel: BYTE;  //通道号
    byFileType: BYTE;  //0-3200W标定文件,1-800W标定文件
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_CLIENT_CALIBFILE_PARAM = ^NET_DVR_CLIENT_CALIBFILE_PARAM;

type
  NET_DVR_RATIOSTITCHING_PARAM = record 
    dwSize: DWORD;  
    dwFileLen: DWORD;  //文件大小
    byChannel: BYTE;  // 多个senor拼接后通道号
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_RATIOSTITCHING_PARAM = ^NET_DVR_RATIOSTITCHING_PARAM;

//电视墙素材文件
type
  NET_DVR_VIDEOWALL_MATERIAL_COND = record 
    dwSize: DWORD;  
    byWallNo: BYTE;  //电视墙墙号，从1开始
    byWindowType: BYTE;  //窗口类型，0-图文窗口,1-字幕窗口
    byFileType: BYTE;  //文件类型，0-图片
    byRes1: BYTE;  //保留字节
    dwWindowNo: DWORD;  //窗口编号，从1开始
    dwMaterialNo: DWORD;  //素材编号，从1开始
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VIDEOWALL_MATERIAL_COND = ^NET_DVR_VIDEOWALL_MATERIAL_COND;

//3200W矫正表结构体
type
  NET_DVR_CORRECT_TABLE_3200W_PARAM = record 
    dwSize: DWORD;  
    dwFileLen: DWORD;  //文件大小
    byChannel: BYTE;  //通道号
    byFileType: BYTE;  //0-3200W标定文件,1-800W标定文件
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_CORRECT_TABLE_3200W_PARAM = ^NET_DVR_CORRECT_TABLE_3200W_PARAM;

//四通道抓图文件结构体
type
  NET_DVR_FOUR_CAMERAS_PICTURES = record 
    dwSize: DWORD;  
    dwFileLen: DWORD;  //文件大小
    byChannel: BYTE;  //通道号
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_FOUR_CAMERAS_PICTURES = ^NET_DVR_FOUR_CAMERAS_PICTURES;

// 导出指定型号标定文件结构体
type
  NET_DVR_DEVTYPE_CALIBFILE_PARAM = record 
    dwSize: DWORD;  
    dwFileLen: DWORD;  //文件长度
    byChannel: BYTE;  //通道号
    byFileType: BYTE;  //0-3200W标定文件,1-800W标定文件
    byRes: array[0..22-1] of BYTE;  
  end;
  LPNET_DVR_DEVTYPE_CALIBFILE_PARAM = ^NET_DVR_DEVTYPE_CALIBFILE_PARAM;

type
  NET_DVR_ANTI_SNEAK_HOST_INFO = record 
    struDVRIP: NET_DVR_ADDRESS;  //主机IP地址
    byIsStartAddr: BYTE;  //是否为开始地址，0-否，1-是
    byHostNo: BYTE;  //主机编号，1-8，主要用于读卡器顺序设置
    byRes: array[0..34-1] of BYTE;  //保留
  end;
  LPNET_DVR_ANTI_SNEAK_HOST_INFO = ^NET_DVR_ANTI_SNEAK_HOST_INFO;

type
  NET_DVR_ANTI_SNEAK_HOST_READER_INFO = record 
    byAntiSnealHostNo: BYTE;  //反潜回主机编号
    byRes: array[0..5-1] of BYTE;  //保留
    wFollowUpCardReader: WORD;  //该反潜回主机下的读卡器编号
  end;
  LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO = ^NET_DVR_ANTI_SNEAK_HOST_READER_INFO;

type
  NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否加入反潜回路径，1-加入，0-不加入
    byRes1: array[0..3-1] of BYTE;  
    struSneakHost: array[0..MAX_SNEAK_PATH_NODE-1] of NET_DVR_ANTI_SNEAK_HOST_INFO;  //后续主机地址信息
    struStartReader: NET_DVR_ANTI_SNEAK_HOST_READER_INFO;  //起始读卡器编号 当该内容全为0时，表示不关注从哪个读卡器开始
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG = ^NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

type
  NET_DVR_ANTI_SNEAK_READER_CFG = record 
    byEnable: BYTE;  //是否加入反潜回路径，1-加入，0-不加入
    byAntiSnealHostNo: BYTE;  //反潜回主机编号
    wReaderID: WORD;  //读卡器ID
    struSneakReaderInfo: array[0..MAX_SNEAK_PATH_NODE-1] of NET_DVR_ANTI_SNEAK_HOST_READER_INFO;  //后续主机读卡器编号
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_ANTI_SNEAK_READER_CFG = ^NET_DVR_ANTI_SNEAK_READER_CFG;

type
  NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG = record 
    dwSize: DWORD;  
    struReaderCfg: array[0..MAX_READER_ROUTE_NUM-1] of NET_DVR_ANTI_SNEAK_READER_CFG;  //读卡器信息
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG = ^NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

type
  NET_DVR_ACS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byRS485Backup: BYTE;  //是否启用下行RS485通信备份功能，0-不启用，1-启用
    byShowCapPic: BYTE;  //是否显示抓拍图片， 0-不显示，1-显示
    byShowCardNo: BYTE;  //是否显示卡号，0-不显示，1-显示
    byShowUserInfo: BYTE;  //是否显示用户信息，0-不显示，1-显示
    byOverlayUserInfo: BYTE;  //是否叠加用户信息，0-不叠加，1-叠加
    byVoicePrompt: BYTE;  //是否启用语音提示，0-不启用，1-启用
    byUploadCapPic: BYTE;  //联动抓拍是否上传图片，0-不上传，1-上传
    bySaveCapPic: BYTE;  //是否保存抓拍图片，0-不保存，1-保存
    byInputCardNo: BYTE;  //是否是否允许按键输入卡号，0-不允许，1-允许
    byEnableWifi: BYTE;  //是否启动wifi，0-不启动，1-启动
    byEnable3G4G: BYTE;  //3G4G使能，0-不使能，1-使能
    byProtocol: BYTE;  //读卡器通信协议类型，0-私有协议（默认），1-OSDP协议
    byRes: array[0..500-1] of BYTE;  
  end;
  LPNET_DVR_ACS_CFG = ^NET_DVR_ACS_CFG;

type
  NET_DVR_PLATFORM_VERIFY_CFG = record 
    dwSize: DWORD;  
    dwDoorNo: DWORD;  //门编号
    byResultType: BYTE;  //认证结果类型，0：非法，1：合法
    byRes1: array[0..3-1] of BYTE;  
    byScreenDisplay: array[0..MAX_SCREEN_DISPLAY_LEN-1] of BYTE;  //LED屏幕显示，用于显示认证相关信息
    byRes: array[0..300-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_PLATFORM_VERIFY_CFG = ^NET_DVR_PLATFORM_VERIFY_CFG;

type
  NET_DVR_PERSON_STATISTICS_CFG = record 
    dwSize: DWORD;  
    byEnableStatistics: BYTE;  //是否开启人数统计，0：不开启；1：开启；
    byEnableOfflineStatistics: BYTE;  //是否开启离线人数统计，0：不开启；1：开启；
    byCountSignalStatisticalStandard: BYTE;  //计数信号统计标准，0：无效；1：红外检测通行统计；2：认证数量统计
    byRes: array[0..605-1] of BYTE;  
  end;
  LPNET_DVR_PERSON_STATISTICS_CFG = ^NET_DVR_PERSON_STATISTICS_CFG;

type
  NET_DVR_ACS_SCREEN_DISPLAY_CFG = record 
    dwSize: DWORD;  
    dwFontSize: DWORD;  //字体大小，[1,10]；
    dwRowSpacing: DWORD;  //行间距，单位：像素点；
    dwColumnSpacing: DWORD;  //列间距，单位：像素点；
    dwFirstRowPosition: DWORD;  //起始行位置在屏幕哪一个分块，0：0、 1：1/8:、 2：2/8、 3：3/8、 4：4/8、 5：5/8、 6：6/8:、 7：7/8；
    byDegree: BYTE;  //字符显示方向角度，0-0度（正常），1-90度（侧着）；
    byScreenType: BYTE;  //屏幕类型，0-DC48270RS043_01T，1-DC80480B070_03T；
    byRes: array[0..306-1] of BYTE;  
  end;
  LPNET_DVR_ACS_SCREEN_DISPLAY_CFG = ^NET_DVR_ACS_SCREEN_DISPLAY_CFG;

type
  NET_DVR_GATE_TIME_CFG = record 
    dwSize: DWORD;  
    dwHoldOnALarmTime: DWORD;  //延续报警器蜂鸣时间，单位ms
    dwHoldOnGateOpenTime: DWORD;  //闸门收到关闭命令前继续保持打开状态时间，单位ms
    dwPostponeIntrusionAlarmTime: DWORD;  //推迟触发闯入欺骗行为报警时间，单位ms
    dwNoLaneAccessTimeLimitTime: DWORD;  //通道收到有效通行认证信号，但无人通行超时报警时间，单位s
    dwSafetyZoneStayTime: DWORD;  //通道收到有效通行认证信号，乘客到达安全区后滞留通道超时报警时间，单位s
    byIRTriggerTimeoutTime: BYTE;  //红外触发超时时间，单位：秒（0-255）
    byRes: array[0..299-1] of BYTE;  
  end;
  LPNET_DVR_GATE_TIME_CFG = ^NET_DVR_GATE_TIME_CFG;


type
  NET_DVR_CARD_PASSWD_CFG = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    byCardPassword: array[0..CARD_PASSWORD_LEN-1] of BYTE;  //卡密码
    dwErrorCode: DWORD;  //获取卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
    byCardValid: BYTE;  //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    byRes2: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_CARD_PASSWD_CFG = ^NET_DVR_CARD_PASSWD_CFG;

type
  NET_DVR_CARD_PASSWD_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    dwErrorCode: DWORD;  //发送卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_CARD_PASSWD_STATUS = ^NET_DVR_CARD_PASSWD_STATUS;

//条件结构
type
  NET_DVR_VEHICLE_RECOG_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_RECOG_COND = ^NET_DVR_VEHICLE_RECOG_COND;

//参数结构
type
  NET_DVR_VEHICLE_RECOG_CFG = record 
    dwSize: DWORD;  
    //数据流水号 和（上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段sDataIndex对应）
    sDataIndex: array[0..DATA_INDEX_LEN-1] of AnsiChar;  
    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应)
    wTaskNo: WORD;  
    byRes1: array[0..2-1] of BYTE;  
    struPlateRect: NET_VCA_RECT;  //车牌位置
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    {
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别；
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    bit13-挂件：0-不启用识别，1-启用识别；
    bit14-危险品车: 0-不启用识别，1-启用识别；
    bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
    }
    dwRecogOperate: DWORD;  
    {
    车辆图片数据上传
    bit0-车牌图片：0-不上传，1-上传；
    bit1-车辆图片：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带子图(主驾驶)：0-不上传，1-上传；
    bit5-安全带子图(副驾驶)：0-不上传，1-上传；
    }
    dwDataUploadType: DWORD;  
    dwPostID: DWORD;  //卡口ID。
    struPostTime: NET_DVR_TIME_V30;  //过车时间
    dwJsonLen: DWORD;  //Json透传数据长度
    pJsonBuffer: PBYTE;  //Json数据指针,参考4.2.4Json数据格式
    byRes: array[0..107-1] of BYTE;  
    byPicDataType: BYTE;  //图片数据类型，0-图片数据，1-URL
    //图片数据
    //当byPicDataType == 0的时候，该字段内的数据无效，图片数据在结构体后面
    //当byPicDataType == 1的时候，是指定的图片的URL信息
    sPicDataPath: array[0..256-1] of AnsiChar;  
  end;
  LPNET_DVR_VEHICLE_RECOG_CFG = ^NET_DVR_VEHICLE_RECOG_CFG;

type
  NET_DVR_VEHICLERECOG_TASK_RESULT = record 
    dwSize: DWORD;  
    //设备数据流水号,每次提交任务，设备会自行生成唯一的流水号返回给上层。
    sDevDataIndex: array[0..MAX_DEV_DATAINDEX_LEN{64}-1] of AnsiChar;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLERECOG_TASK_RESULT = ^NET_DVR_VEHICLERECOG_TASK_RESULT;

//条件结构
type
  NET_DVR_VEHICLE_RECOG_TASK_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    sDataIndex: array[0..DATA_INDEX_LEN-1] of AnsiChar;  //数据流水号    全0的时候表示获取全部
    wTaskNo: WORD;  //任务处理号         值为0的时候表示全部任务
                  {
                  任务状态
                  bit0-完成状态的任务：0-不查询，1-查询；
                  bit1-执行中的任务：0-不查询，1-查询；
                  bit2-等待中的任务：0-不查询，1-查询；
    }
    byTask: BYTE;  
    byRes1: BYTE;  
    //设备数据流水号查询,每次提交任务，设备会自行生成唯一的流水号。
    sDevDataIndex: array[0..MAX_DEV_DATAINDEX_LEN{64}-1] of AnsiChar;  
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_RECOG_TASK_COND = ^NET_DVR_VEHICLE_RECOG_TASK_COND;

//参数结构
type
  NET_DVR_VEHICLE_RECOG_TASK_INFO = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    sDataIndex: array[0..DATA_INDEX_LEN-1] of AnsiChar;  //数据流水号
    wTaskNo: WORD;  //任务处理号
    wTaskProgress: WORD;  //任务执行进度（实际进度*1000）
    byTaskState: BYTE;  //任务状态，0-等待中，1-执行中，2-完成
    byRes1: array[0..3-1] of BYTE;  
    {
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别；
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    bit13-挂件：0-不启用识别，1-启用识别；
    bit14-危险品车: 0-不启用识别，1-启用识别；
    bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
    }
    dwRecogOperate: DWORD;  
    dwPostID: DWORD;  //卡口ID。
    struPostTime: NET_DVR_TIME_V30;  //过车时间
    dwJsonLen: DWORD;  //Json透传数据长度（预留，JSON内容暂不实现）
    pJsonBuffer: PBYTE;  //Json数据指针, （预留，JSON内容暂不实现）
    byRes: array[0..104-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_RECOG_TASK_INFO = ^NET_DVR_VEHICLE_RECOG_TASK_INFO;

type
  NET_DVR_VEHICLE_RECOG_RESULT = record 
    dwSize: DWORD;  //结构
    //数据流水号 和（任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段sDataIndex对应）
    sDataIndex: array[0..DATA_INDEX_LEN-1] of AnsiChar;  
    //任务处理号 和 (任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段wTaskNo对应)
    wTaskNo: WORD;  
    byRes: array[0..2-1] of BYTE;  
    struPlateRect: NET_VCA_RECT;  //车牌位置
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    byVehicleType: BYTE;  //车辆类型，参考VTR_RESULT
    byColorDepth: BYTE;  //车身颜色深浅，参考 0-深色，1-浅色
    byColor: BYTE;  //车身颜色,  参考VCR_CLR_CLASS
    byVehicleLogoRecog: BYTE;  //车辆主品牌
    byVehicleSubLogoRecog: BYTE;  //车辆子品牌
    byPilotSafebelt: BYTE;  //0-表示未知,1-不系安全带,2-系安全带
    byCopilotSafebelt: BYTE;  //0-表示未知,1-不系安全带,2-系安全带
    byPilotSunVisor: BYTE;  //0-表示未知,1-不打开遮阳板,2-打开遮阳板
    byCopilotSunVisor: BYTE;  //0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    byVehicleModel: BYTE;  // 参考文档  车辆子品牌年款
    wVehicleLogoRecog: WORD;  //车辆主品牌，参考"车辆主品牌.xlsx"
    byRes1: array[0..251-1] of BYTE;  
    // 0-数据直接上传; 1-云存储服务器URL原先的图片数据变成URL数据，图片长度变成URL长度
    byDataType: BYTE;  
    {
    上传图片类型信息:
    bit0-车辆图：0-不上传，1-上传；
    bit1-车牌图：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带识别(主驾驶)：0-不上传，1-上传；
    bit5-安全带识别(副驾驶)：0-不上传，1-上传；
    }
    dwPicType: DWORD;  //0:无图片信息;: 车辆图;:车牌图;
    pVehicleBuffer: PBYTE;  //车辆图片数据指针
    dwVehicleBufferLen: DWORD;  // 车辆图片数据长度
    pPlateBuffer: PBYTE;  //车牌图片数据指针
    dwPlateBufferLen: DWORD;  // 车牌图片数据长度
    pPilotFaceBuffer: PBYTE;  //人脸子图(主驾驶)图片数据指针
    dwPilotFaceBufferLen: DWORD;  // 人脸子图(主驾驶)图片数据长度
    pCopilotFaceBuffer: PBYTE;  //人脸子图(副驾驶)图片数据指针
    dwCopilotFaceBufferLen: DWORD;  // 人脸子图(副驾驶)图片数据长度
    pPilotSafebeltBuffer: PBYTE;  //安全带识别(主驾驶)图片数据指针
    dwPilotSafebeltBufferLen: DWORD;  // 安全带识别(主驾驶)图片数据长度
    pCopilotSafebeltBuffer: PBYTE;  // 安全带识别(副驾驶)图片数据指针
    dwCopilotSafebeltBufferLen: DWORD;  // 安全带识别(副驾驶)图片数据长度
    struVehicleRect: NET_VCA_RECT;  //车身矩形坐标
    struPilotRect: NET_VCA_RECT;  //主驾驶矩形坐标
    struCopilotRect: NET_VCA_RECT;  //副驾驶矩形坐标
    pJsonBuffer: PBYTE;  //Json数据指针,参考JSON数据格式
    dwJsonBufferLen: DWORD;  // Json数据长度
    dwPostID: DWORD;  //卡口ID
    struPostTime: NET_DVR_TIME_V30;  //过车时间
    Res2: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_RECOG_RESULT = ^NET_DVR_VEHICLE_RECOG_RESULT;

const
  MAX_ZONE_LINKAGE_CHAN_NUM = 4;    // 防区关联最大通道数

type
  NET_DVR_CENTER_SERVER_CFG = record 
    dwSize: DWORD;  
    byAddressType: BYTE;  //0 - ipv4/ipv6地址，1 - 域名
    byRes1: BYTE;  
    wServerPort: WORD;  //服务器端口
    unionServer: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  
        byRes2: array[0..80-1] of BYTE;  
      end);  //服务器域名
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  
      end);  //IP地址
    end;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    wInterval: WORD;  //报警间隔时间,0-30s
    byRes3: array[0..514-1] of BYTE;  
  end;
  LPNET_DVR_CENTER_SERVER_CFG = ^NET_DVR_CENTER_SERVER_CFG;

type
  NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG = record 
    byDDNSType: BYTE;  //域名服务器类型：0 - 无效，1 - IPServer(私有DNS)，2 - hiDDNS
    byRes1: BYTE;  
    wDDNSPort: WORD;  //域名服务器端口号
    byServerAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //域名服务器地址
    byDevName: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //设备名称
    byDevSerialNum: array[0..SERIALNO_LEN-1] of BYTE;  //设备序列号
    byAddressType: BYTE;  //0 - ipv4/ipv6地址，1 - 域名
    byRes2: BYTE;  
    wDevPort: WORD;  //设备端口号
    unionDevAddr: record 
      case Byte of
      0: (struDomain: record
        szDomain: array[0..MAX_DOMAIN_NAME-1] of BYTE;  
        byRes2: array[0..80-1] of BYTE;  
      end);  //域名
      1: (struAddrIP: record
        struIp: NET_DVR_IPADDR;  
      end);  //IP地址
    end;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    sUserName: array[0..NAME_LEN{32}-1] of BYTE;  //用户名
    sPassword: array[0..PASSWD_LEN{16}-1] of BYTE;  //密码
    dwChannel: DWORD;  //联动通道号
    byRes3: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG = ^NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

type
  NET_DVR_ZONE_CHANNEL_LINKAGE_CFG = record 
    dwSize: DWORD;  
    struLinkChannels: array[0..MAX_ZONE_LINKAGE_CHAN_NUM-1] of NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;  // 每个防区可以关联四个视频通道
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG = ^NET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

type
  NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG = record 
    byDevSerialNo: array[0..SERIALNO_LEN-1] of BYTE;  //设备序列号
    dwChannel: DWORD;  //联动通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG = ^NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG;

type
  NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG = record 
    wZoneNo: WORD;  
    byRes1: array[0..2-1] of BYTE;  
    struSingleChanCfg: array[0..MAX_ZONE_LINKAGE_CHAN_NUM-1] of NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG;  
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG = ^NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG;

type
  NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST = record 
    dwSize: DWORD;  
    struAssociatedChanCfg: array[0..MAX_MAX_ALARMIN_NUM-1] of NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST = ^NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST;

type
  NET_DVR_LCD_ALARM = record 
    dwSize: DWORD;  
    dwScreenID: DWORD;  //屏幕索引号
    byOnOffLine: BYTE;  //屏幕是否在线，0-离线，1-在线，当屏幕离线时，本结构后续参数无效
    byTempState: BYTE;  //板卡温度状态，0-正常，1-异常
    byFanState: BYTE;  //风扇状态，0-关，1-开
    byFanException: BYTE;  //风扇异常状态，0-不支持 1-正常，2-异常
    byTemperature: BYTE;  //屏幕板卡温度，单位：摄氏度
    byRes: array[0..27-1] of BYTE;  
  end;
  LPNET_DVR_LCD_ALARM = ^NET_DVR_LCD_ALARM;

//传感器上传信息
type
  NET_DVR_SENSOR_INFO_UPLOAD = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME_V30;  
    szSensorName: array[0..MAX_SENSORNAME_LEN-1] of AnsiChar;  //传感器名称
    szSensorChan: array[0..MAX_SENSORCHAN_LEN-1] of AnsiChar;  //传感器通道
    byReboot: BYTE;  //之前是否重启过（一般是重启的后的第一条数据带有这个标志）0-表示没有重启，1-有过重启
    byPowerSupply: BYTE;  //是否正常供电 0-不在供电，1-正在供电
    byStatusType: BYTE;  //设备状态:0:正常、1：异常、2、报警
    bySensorType: BYTE;  //参考传感器枚举类型SENSOR_TYPE
    fVoltageValue: FLOAT;  //电压值； 精确到0.001
    fCurrentValue: FLOAT;  //电流值；精确到0.001
    fActualValue: FLOAT;  //模拟信号转换后的数值；精确到0.001
    szDescription: array[0..MAX_DESCRIPTION_LEN{ 32}-1] of AnsiChar;  //描述信息;当设备状态（byStatusType）为非0时生效。
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_INFO_UPLOAD = ^NET_DVR_SENSOR_INFO_UPLOAD;

//抓拍图片上传
type
  NET_DVR_CAPTURE_UPLOAD = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME_V30;  
    dwChannel: DWORD;  //通道号
    szDevName: array[0..MAX_DEVNAME_LEN_EX-1] of AnsiChar;  
    dwPicLen: DWORD;  //图片长度
    pBuffer: PBYTE;  //图片数据指针
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_UPLOAD = ^NET_DVR_CAPTURE_UPLOAD;

//全景联动到位上传
type
  NET_DVR_PANORAMIC_LINKAGE = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byType: BYTE;  //图片类型，0-无意义，1-全景联动到位图片
    byRes1: array[0..3-1] of BYTE;  
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  //mac地址
    byRes2: array[0..2-1] of BYTE;  
    struDevIP: NET_DVR_IPADDR;  //设备IP地址
    dwPicLen: DWORD;  //全景联动到位抓拍图片长度
    pPicBuff: PAnsiChar;  //全景联动到位抓拍图片指针
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PANORAMIC_LINKAGE = ^NET_DVR_PANORAMIC_LINKAGE;

const
  MAX_MASK_AREA_NUM = 8;    //马赛克区域个数

type
  NET_DVR_AREA_MASK_CFG = record //区域马赛克
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用马赛克   0-否，1-是
    byMaskThick: BYTE;  //马赛克厚度 0-薄码，1-中码，2-厚码，薄码的区块大小为8*8，中码16*16，厚码32*32。默认为中码
    byAutoMask: BYTE;  //是否启用自动马赛克   0-否，1-是
    byRes1: BYTE;  
    struRegion: array[0..MAX_MASK_AREA_NUM-1] of NET_VCA_RECT;  //马赛克区域范围
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_AREA_MASK_CFG = ^NET_DVR_AREA_MASK_CFG;

type
  NET_DVR_AUDIO_DIACRITICAL_CFG = record //音频变音
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用变音 0-不启用，1-启用
    byBassValue: AnsiChar;  //高低音值，范围为-12-12 值越大声音越细，反之越小，0-表示不变音
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_DIACRITICAL_CFG = ^NET_DVR_AUDIO_DIACRITICAL_CFG;

type
  NET_DVR_RESOLUTION_SWITCH = record 
    dwSize: DWORD;  
    byResolutionType: BYTE;  //0-all,1-20:9,2-20:6,3-原始码流模式
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_RESOLUTION_SWITCH = ^NET_DVR_RESOLUTION_SWITCH;

type
  NET_DVR_WIFI_DHCP_ADDR_CFG = record //wifi模式下DHCP范围配置
    dwSize: DWORD;  
    struStartAddr: NET_DVR_IPADDR;  //开始IP地址
    struEndAddr: NET_DVR_IPADDR;  //结束IP地址
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_WIFI_DHCP_ADDR_CFG = ^NET_DVR_WIFI_DHCP_ADDR_CFG;


type
  NET_DVR_WIFI_CLIENT_INFO = record //音频变音
    dwSize: DWORD;  
    struAddress: NET_DVR_IPADDR;  //IP地址
    byMACAddr: array[0..MACADDR_LEN-1] of BYTE;  
    wConnSpeed: WORD;  //连接速度 单位KB
    byRSSIValue: BYTE;  //接收到的信号强度，取值为负值，传输时不带赋值，范围为0~-110dbm,值越大，代表信号越强
    byRes1: BYTE;  //保留
    wBandwidth: WORD;  //网络带宽  单位KB
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WIFI_CLIENT_INFO = ^NET_DVR_WIFI_CLIENT_INFO;

type
  NET_DVR_MULTISTREAM_RELATION_CHAN_CFG = record //多码流关联通道
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //关联的编码通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG = ^NET_DVR_MULTISTREAM_RELATION_CHAN_CFG;

type
  NET_DVR_RING_PORT_PROPERTY = record 
    byPort: BYTE;  //端口
    byMasterSlaveProperty: BYTE;  //端口主从属性  1-主  2-从
    byPortEthernetType: BYTE;  //端口类型，1-百兆端口，2-千兆端口
    byRes: array[0..9-1] of BYTE;  
  end;
  LPNET_DVR_RING_PORT_PROPERTY = ^NET_DVR_RING_PORT_PROPERTY;
type
  NET_DVR_NS_RING_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用， 0-不启用， !0-启用
    byProtoType: BYTE;  //协议类型， 1-光端机组网协议(私有)，2-综合平台组网协议（私有），3-G8032协议（公有）
    byBandWidth: BYTE;  //环网带宽类型，1-百兆，2-千兆
    byRes1: BYTE;  //保留字段
    struRingPort: array[0..PER_RING_PORT_NUM-1] of NET_DVR_RING_PORT_PROPERTY;  //环网端口
    byRes2: array[0..60-1] of BYTE;  //保留字段
  end;
  LPNET_DVR_NS_RING_CFG = ^NET_DVR_NS_RING_CFG;
type
  NET_DVR_NS_RING_STATUS = record //
    dwSize: DWORD;  //结构体大小
    byStatus: BYTE;  //环网状态，1-正常 2-断开
    byMasterSlaveProperty: BYTE;  //光纤板主从属性 1-主  2-从
    byRes: array[0..62-1] of BYTE;  //保留字段
  end;
  LPNET_DVR_NS_RING_STATUS = ^NET_DVR_NS_RING_STATUS;

//火点检测报警
type
  NET_DVR_FIREDETECTION_ALARM = record 
    dwSize: DWORD;  //结构大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    wPanPos: WORD;  
    wTiltPos: WORD;  
    wZoomPos: WORD;  
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes1: BYTE;  
    dwPicDataLen: DWORD;  //报警抓拍图片长度
    pBuffer: PBYTE;  //数据指针
    struRect: NET_VCA_RECT;  //火点框
    struPoint: NET_VCA_POINT;  //火点框内最高温度点坐标
    wFireMaxTemperature: WORD;  //火点最高温度[300℃~4000℃]
    wTargetDistance: WORD;  //目标距离[100m ~ 10000m]
    byStrategyType: BYTE;  //策略类型；0~任意报警，1~协同报警，2~多系统报警，3~指定火点报警，4~指定烟雾报警
    byAlarmSubType: BYTE;  //报警子类型。0~火点检测报警，1~烟雾检测报警，2~烟火报警
    {是否启用PTZ坐标扩展，
    0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。
    1~启用，PTZ坐标值以struPtzPosEx为准。但是新老PTZ都需返回。struPtzPosEx的值需转化为wPanPos、wTiltPos、wZoomPos值。
    }
    byPTZPosExEnable: BYTE;  
    byRes2: BYTE;  
    struPtzPosEx: NET_PTZ_INFO;  // ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
    dwVisiblePicLen: DWORD;  //可见光图片长度
    pVisiblePicBuf: PBYTE;  //可见光图片数据指针
    // pSmokeBuf参数当byAlarmSubType报警子类型为1（烟雾检测报警）、2（烟火报警）时生效。
    pSmokeBuf: PBYTE;  //烟雾检测报警数据指针，指向一个NET_DVR_SMOKEDETECTION_ALARM结构体
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byRes3: BYTE;  
    byFireScanWaitMode: BYTE;  //火点扫描等待模式 0-自动   1-手动
    dwVisibleChannel: DWORD;  //可见光通道通道号
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    byRes: array[0..49-1] of BYTE;  
  end;
  LPNET_DVR_FIREDETECTION_ALARM = ^NET_DVR_FIREDETECTION_ALARM;

//火点检测配置
type
  NET_DVR_SMOKEDETECTION_CFG = record 
    byEnable: BYTE;  //使能
    bySensitivity: BYTE;  //检测灵敏度: 1~100默认50
    byPatrolSensitivity: BYTE;  //巡航检测灵敏度: 1~100默认50
    byDoubleCheckSensitivity: BYTE;  //二次过滤灵敏度: 1~100默认50
    byRes: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_SMOKEDETECTION_CFG = ^NET_DVR_SMOKEDETECTION_CFG;

type
  NET_DVR_ALARMSTRATEGY_PARAM = record 
    byStrategyType: BYTE;  //策略类型；0~任意报警，1~协同报警，2~多系统报警, 3~指定火点报警，4~指定烟雾报警
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_ALARMSTRATEGY_PARAM = ^NET_DVR_ALARMSTRATEGY_PARAM;

type
  NET_DVR_FIREDETECTION_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    bySensitivity: BYTE;  //检测灵敏度: 1~100默认5s
    byFireComfirmTime: BYTE;  //发现火点等待时间: 0-120秒 默认5s
    byFireRegionOverlay: BYTE;  //码流叠加火点框: 0- 否，1- 是
    byDetectionMode: BYTE;  // 火点检测模式：0~二次判别，1~单帧检测。
    byFireFocusMode: BYTE;  //火点聚焦模式：0~自动模式,1~ 巡航模式。
    byFireZoomMode: BYTE;  //火点光学变倍模式：0~为自动模式，1~为手动模式。
    byFirezoomLevel: BYTE;  //火点光学变倍倍率，1~100。当光学变倍模式为手动模式时生效
    bySmokeFireEnabled: BYTE;  //烟火检测总使能：0―不启用，1-启用
    {
    火点手动等待使能，为1时代表开启。开启后，火点等待时间参数byFireComfirmTime无效。
    开启后，当设备发现火点时，云台一直停留在发现火点位置，可通过继续火点扫描命令解除该等待模式，继续火点扫描。
    当火点手动等待使能为0时，设备为自动等待模式，该模式下可根据byFireComfirmTime字段所配置的等待时间进行火点等待，超过该等待时间后设备自动进行火点扫描。
    }
    byFireManualWaitEnabled: BYTE;  // 火点手动等待使能，0~为自动等待模式，1~手动等待模式
    byCancelRepeatedAlarmEnabled: BYTE;  // 取消重复报警使能 0-关闭 1-开启
    byApplicationSceneMode: BYTE;  //应用场景模式：0-保留，1-森林防火, 2-秸秆燃烧,3-城市制高点, 4-室内或周界
    dwInstallationHeight: DWORD;  // 安装高度
    byFireSourceDetection: BYTE;  // 火点搜索模式 0-动态火点 1-吸烟模式
    bySmokeAuxiliaryDetectionEnabled: BYTE;  // 烟雾辅助判断启用使能,检测模式是二次判别时生效 0-否 1-是
    byverificationSensitivity: BYTE;  //二次确认灵敏度，范围1~100s，默认50s
    byFireAlgorithmMode: BYTE;  //火点算法模式，0：无效，1：模式识别-patternRecognition,:2：机器学习-machineLearning
    byAgriculturalMachineryFilterEnabled: BYTE;  //农机过滤模块使能，0：不启用，1：启用
    byWaterReflectionEnabled: BYTE;  //水面阳光反射模块使能, 0：不启用，1：启用
    byPatrolSensitivity: BYTE;  //巡航检测灵敏度 （针对火点检测）, 范围1~100s，默认50s
    byRes: array[0..33-1] of BYTE;  
    struAlarmStrategy: NET_DVR_ALARMSTRATEGY_PARAM;  //报警策略
    struSmokeCfg: NET_DVR_SMOKEDETECTION_CFG;  //烟雾检测配置
  end;
  LPNET_DVR_FIREDETECTION_CFG = ^NET_DVR_FIREDETECTION_CFG;

type
  NET_DVR_THERMALPOWER_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byPowerSwitch: BYTE;  //开关使能，1为开启，0为关闭
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_THERMALPOWER_PARAM = ^NET_DVR_THERMALPOWER_PARAM;

type
  NET_DVR_PTZABSOLUTEEX_CFG = record 
    dwSize: DWORD;  //结构体大小
    struPTZCtrl: NET_PTZ_INFO;  //设备PTZF信息
    dwFocalLen: DWORD;  //焦距范围：0-100000MM
    fHorizontalSpeed: FLOAT;  //水平转动速度：0.01-1000.00度/S
    fVerticalSpeed: FLOAT;  //垂直转动速度：0.01-1000.00度/S
    //镜头变倍配置类型；absoluteZoom:通过变倍参数进行配置，选择为该类型时struPTZCtrl中的fZoom参数生效。focalLen:通过焦距参数进行配置，选择为该类型时，dwFocalLen参数生效。
    byZoomType: BYTE;  // 镜头变倍配置类型0~ absoluteZoom，1~ focalLen
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_PTZABSOLUTEEX_CFG = ^NET_DVR_PTZABSOLUTEEX_CFG;

const
  MAX_PLAYLIST_NUM = 50;    //最大播放列表数目
  MAX_PLAYPLAN_NUM = 50;    //最大播放计划数目

const
  MAX_LEN_256 = 256;    
  MAX_GROUP_RECORD_NUM = 10;    //最大记录个数
type
  NET_DVR_AREA_MONITOR_COND = record 
    dwSize: DWORD;  
    dwAreaID: DWORD;  //区域ID
    dwMonitorID: DWORD;  //当前开始获取的布防点编号，从1开始
    byIsNeedGroup: BYTE;  //是否查询关联分组信息
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_AREA_MONITOR_COND = ^NET_DVR_AREA_MONITOR_COND;

type
  NET_DVR_DEL_MONITOR_COND = record 
    dwSize: DWORD;  
    byDelType: BYTE;  //删除类型，0-删除指定区域的所有布防点，1-删除指定区域的指定布防点
    dwAreaID: DWORD;  //区域ID
    dwMonitorID: DWORD;  //布防点ID（当byDelType为0时无效，当byDelType为1时有效），从1开始
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_DEL_MONITOR_COND = ^NET_DVR_DEL_MONITOR_COND;

type
  NET_DVR_BLOCKLIST_ALARM_COND = record 
    dwSize: DWORD;  //结构体大小
    byType: BYTE;  //名单标志：- 全部，- 允许名单，- 禁止名单
    byRes1: array[0..3-1] of BYTE;  //保留
    dwFaceID: DWORD;  //人脸名单ID
    dwMaxSnapNum: DWORD;  //最大抓拍张数，0-表示不限制
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_ALARM_COND = ^NET_DVR_BLOCKLIST_ALARM_COND;

type
  NET_DVR_STORAGE_RESOURCE_COND = record 
    dwSize: DWORD;  //结构体大小
    dwStorageID: DWORD;  //从当前编号开始获取剩余资源，从1开始
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_RESOURCE_COND = ^NET_DVR_STORAGE_RESOURCE_COND;

type
  NET_DVR_BLOCKLIST_ALARM_RECORD = record 
    dwSize: DWORD;  //结构体大小
    dwSnapFacePicID: DWORD;  //抓拍人脸ID
    dwRegisterID: DWORD;  //名单注册ID号（只读）
    dwGroupNo: DWORD;  //分组号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_ALARM_RECORD = ^NET_DVR_BLOCKLIST_ALARM_RECORD;

type
  NET_DVR_BLOCKLIST_GROUP_INFO = record //名单分组信息
    dwSize: DWORD;  //结构体大小
    dwGroupID: DWORD;  //分组编号（获取时有效，添加时无效），从1开始
    dwGroupNo: DWORD;  //名单分组号
    byGroupType: BYTE;  //分组类型，0-禁止名单分组，1-允许名单分组
    byRes1: BYTE;  
    wThreshold: WORD;  //报警阈值，取值范围为0-1000
    dwListNum: DWORD;  //分组名单数
    szGroupName: array[0..NAME_LEN-1] of BYTE;  //分组名称
    szRemark: array[0..MAX_LEN_256-1] of BYTE;  
    byStorageAddr: array[0..MAX_DOMAIN_NAME-1] of BYTE;  //存储IP地址信息
    wStoragePort: WORD;  //存储IP对应的端口号
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_GROUP_INFO = ^NET_DVR_BLOCKLIST_GROUP_INFO;


type
  NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD = record 
    dwSize: DWORD;  //结构体大小
    dwGroupRecordID: DWORD;  //分组记录ID，修改和查询时有效，增加时无效，从1开始
    dwGroupNo: DWORD;  //名单分组号
    dwFaceDBID: DWORD;  //人脸库ID
    dwFaceRecordID: DWORD;  //人脸记录ID
    byAlarmLevel: BYTE;  //报警等级，0-high,1-medium,2-low
    byRes1: array[0..3-1] of BYTE;  //保留
    struStorageAddr: NET_DVR_ADDR_DOMAIN_INFO;  //存储IP地址信息
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD = ^NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD;

type
  NET_DVR_BLOCKLIST_GROUP_RECORD_COND = record 
    dwSize: DWORD;  //结构体大小
    dwRecordID: DWORD;  //从当前编号开始获取，从1开始
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_GROUP_RECORD_COND = ^NET_DVR_BLOCKLIST_GROUP_RECORD_COND;

type
  NET_DVR_BLOCKLIST_GROUP_RECORD_CFG = record //名单分组记录信息
    dwSize: DWORD;  //结构体大小
    dwRecordNum: DWORD;  //记录总个数
    struRecord: array[0..MAX_GROUP_RECORD_NUM-1] of NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD;  //记录参数
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_GROUP_RECORD_CFG = ^NET_DVR_BLOCKLIST_GROUP_RECORD_CFG;

type
  NET_DVR_BLOCKLIST_GROUP_CFG = record //名单分组记录信息
    dwSize: DWORD;  //结构体大小
    dwGroupNum: DWORD;  //分组总个数
    struGroup: array[0..MAX_GROUP_RECORD_NUM-1] of NET_DVR_BLOCKLIST_GROUP_INFO;  //记录参数
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_GROUP_CFG = ^NET_DVR_BLOCKLIST_GROUP_CFG;

type
  NET_DVR_BLOCKLIST_GROUP_COND = record 
    dwSize: DWORD;  //结构体大小
    dwGroupID: DWORD;  //从当前编号开始获取，从1开始
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_GROUP_COND = ^NET_DVR_BLOCKLIST_GROUP_COND;



type
  NET_DVR_SENSOR_VALUE = record 
    fMinValue: FLOAT;  //最小值；精确到0.001，若为0xfffffffff表示查询所有
    fMaxValue: FLOAT;  //最大值；精确到0.001，若为0xfffffffff表示查询所有
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_VALUE = ^NET_DVR_SENSOR_VALUE;

type
  NET_DVR_HISTORICAL_QUERY_PARAM = record //历史数据查询条件子结构
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    struVoltageValue: NET_DVR_SENSOR_VALUE;  //电压参数; 单位伏特
    struCurrentValue: NET_DVR_SENSOR_VALUE;  //电流参数; 单位毫安
    struTemperatureValue: NET_DVR_SENSOR_VALUE;  //温度参数，单位摄氏度
    struHumidityValue: NET_DVR_SENSOR_VALUE;  //湿度参数
    bySwitchStatus: BYTE;  //通电状态， 0~未通电，1~通电，0xff查询所有
    bySensorStatus: BYTE;  //传感器状态； 0-正常、1-异常、2-报警；0xff查询所有
    byRes: array[0..66-1] of BYTE;  
  end;
  LPNET_DVR_HISTORICAL_QUERY_PARAM = ^NET_DVR_HISTORICAL_QUERY_PARAM;

type
  NET_DVR_SENSOR_COND = record //条件结构
    dwSize: DWORD;  
    byQueryType: BYTE;  //查询方式；0~实时数据查询，1~历史数据查询
    byDeviceType: BYTE;  //设备类型;0~未知,1~模拟量传感器, 2~上电端子,3~上电插座，0xff表示查询所有
    byDeviceID: BYTE;  //设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2，0xff表示查询所有
    byRes1: BYTE;  
    // INTER_HISTORICAL_QUERY_PARAM子结构，在byQueryType为1时生效
    struHistoricalQueryParam: NET_DVR_HISTORICAL_QUERY_PARAM;  //历史数据查询参数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_COND = ^NET_DVR_SENSOR_COND;

type
  NET_DVR_SENSOR_CFG = record //配置结构
    dwSize: DWORD;  
    byEnable: BYTE;  //当前查询的传感器是否使能，0-不使能，1-使能；
    byDeviceType: BYTE;  //设备类型;0~未知,1~模拟量传感器, 2~上电端子,3~上电插座
    byDeviceID: BYTE;  //设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
    byRes1: BYTE;  
    struTime: NET_DVR_TIME_V30;  //时间
    byIsFirst: BYTE;  //是否是启动后第一条数据(检测是否有重启)，0-否, 1-是；
    byIsSwitchOn: BYTE;  //是否通电，0-否, 1-是；
    bySensorStatus: BYTE;  //传感器状态； 0-正常、1-异常、2-报警；
    bySensorType: BYTE;  //传感器类型；参照 SENSOR_TYPE
    fVoltage: FLOAT;  //电压；单位伏特，精确到0.001。若为0xff表示无效值
    fCurrent: FLOAT;  //电流；单位毫安，精确到0.001。若为0xff表示无效值
    fTemperatureValue: FLOAT;  //温度值；单位摄氏度，精确到0.001。若为0xff表示无效值
    fHumidityValue: FLOAT;  //湿度值，精确到0.001。若为0xff表示无效值
    bySensorName: array[0..SENSORNAME_LEN{32}-1] of BYTE;  //传感器名称
    byDescription: array[0..MAX_SENSORDESCR_LEN{64}-1] of BYTE;  //传感器数据的描述信息，statusType为正常时，description可以为空
    fActualValue: FLOAT;  //模拟信号转换后的数值；精确到0.0001
    byUnit: array[0..SENSORUNIT_LEN{32}-1] of BYTE;  //单位字符串
    byRes: array[0..220-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_CFG = ^NET_DVR_SENSOR_CFG;

type
  NET_DVR_SENSOR_SWITCH_COND = record 
    dwSize: DWORD;  //结构体大小
    byDeviceType: BYTE;  //设备类型;0~未知, 1~上电端子Terminal,2~上电插座Socket
    byDeviceID: BYTE;  //设备ID；Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
    bySwitch: BYTE;  //开关，0-断电, 1-上电，2-重启
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_SWITCH_COND = ^NET_DVR_SENSOR_SWITCH_COND;

type
  NET_DVR_GB28181_SERVICE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byServerID: array[0..DEV_ID_LEN-1] of BYTE;  //SIP服务器ID；
    wPort: WORD;  //SIP服务器端口号
    byRes1: array[0..2-1] of BYTE;  //保留
    byAuthPasswd: array[0..PASSWD_LEN-1] of BYTE;  
    dwRegisterValid: DWORD;  //存活期周期，单位：秒，默认：3600
    byMaxHeartbeatTimeOut: BYTE;  //最大心跳超时次数，默认：3次
    byAutoAddIpc: BYTE;  //是否启用自动添加ipc,0-不启用，1-启用
    byAuthPasswdEx: array[0..MAX_PASSWD_LEN_EX-1] of BYTE;  //密码扩展为64位，设置时，byAuthPasswdEx为非空，此参数有效，byAuthPasswd无效，获取时，byAuthPasswdEx和byAuthPasswd都返回
    byRes: array[0..190-1] of BYTE;  //保留
  end;
  LPNET_DVR_GB28181_SERVICE_CFG = ^NET_DVR_GB28181_SERVICE_CFG;
type
  NET_DVR_ACTIVATECFG = record 
    dwSize: DWORD;  //结构体大小
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //初始密码
    byLoginMode: BYTE;  //0-Private 1-ISAPI
    byHttps: BYTE;  //0-不使用https，1-使用https
    byRes: array[0..106-1] of BYTE;  
  end;
  LPNET_DVR_ACTIVATECFG = ^NET_DVR_ACTIVATECFG;

type
  NET_DVR_IPDEVICE_ACTIVATE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byMode: BYTE;  //0-按通道激活，1-按地址激活
    bySelfDefinePassword: BYTE;  //是否自定义密码,0-否,1-是,2-是,且为IPC的自定义密码
    sPassword: array[0..PASSWD_LEN-1] of BYTE;  //自定义密码
    sUserName: array[0..NAME_LEN-1] of BYTE;  //用户名
    byRes: array[0..78-1] of BYTE;  
    unActivateDeviceInfo: record 
      case Byte of
      0: (byLen: array[0..512-1] of BYTE);  //union大小
      1: (struChannelInfo: record
        dwChannelNo: DWORD;  //通道号
        byRes: array[0..508-1] of BYTE;  
      end);  //通道信息
      2: (struAddrInfo: record
        struIp: NET_DVR_IPADDR;  //IP地址
        wPort: WORD;  //端口号
        sProtocolDesc: array[0..DESC_LEN-1] of BYTE;  //协议类型
        byMacAddr: array[0..MACADDR_LEN-1] of BYTE;  //mac地址
        byRes: array[0..344-1] of BYTE;  
      end);  //IP地址，来自NET_DVR_SADPINFO
    end;  //使用联合体结构，通过byMode字段表示是按通道还是按地址
  end;
  LPNET_DVR_IPDEVICE_ACTIVATE_CFG = ^NET_DVR_IPDEVICE_ACTIVATE_CFG;

type
  NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS = record 
    dwSize: DWORD;  
    byDigitalChanPasswordStatus: array[0..MAX_CHANNUM_V30*4-1] of BYTE;  //0-保留,1-IPC未激活，2-风险密码，3-密码强度弱，4-密码强度中，5-密码强度强;byDigitalChanPasswordStatus[0]表示第一个数字通道
    byRes: array[0..1140-1] of BYTE;  
  end;
  LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS = ^NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

type
  NET_DVR_CAMERACHAN_SERIALCFG = record 
    dwSize: DWORD;  
    dwBaudRate: DWORD;  //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
    byDataBit: BYTE;  //数据有几位：0-5位，1-6位，2-7位，3-8位
    byStopBit: BYTE;  //停止位：0-1位，1-2位
    byParity: BYTE;  //是否校验：0-无校验，1-奇校验，2-偶校验
    byFlowcontrol: BYTE;  // 是否流控：0-无，1-软流控,2-硬流控
    wPTZProtocol: WORD;  //控球协议类型，索引值
    byRes1: array[0..6-1] of BYTE;  
    dwSerialPort: DWORD;  //串口号,最高位为0，表示前面板串口，最高位为1，表示后面板串口
    bySerialAddress: BYTE;  //串口地址0~255
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_CAMERACHAN_SERIALCFG = ^NET_DVR_CAMERACHAN_SERIALCFG;

const
  MAX_MATRIX_SUBBOARD_NUM = 16;    //综合平台最大子板数
  MAX_MATRIX_SUBBOARD_NUM_V51 = 32;    //综合平台最大子板数
  MAX_BOARD_SUBSYSTEM_NUM = 12;    //每个子板最大系统数
type
  NET_DVR_SUBSYSTEM_STATUS = record 

    {子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，
    11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板 ，15-多相机拼接子系统，16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-音频子系统，0-NULL}
    bySubSystemType: BYTE;  
    bySubSystemNo: BYTE;  //子系统号，即所在子板上的编号
    byOnlineStatus: BYTE;  //网络连接状态， 1-在线 2-不在线
    byRes: array[0..49-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEM_STATUS = ^NET_DVR_SUBSYSTEM_STATUS;


type
  NET_DVR_MATRIX_SUBBOARD = record 
    byBoardNo: BYTE;  //子板号
    byPcieConnectStatus: BYTE;  //pcie连接状态， 1-连接 2-断开
    byRes: array[0..2-1] of BYTE;  
    dwHardwareVersion: DWORD;  //子板硬件版本
    dwPcieBandwidth: DWORD;  //pcie Link 带宽
    dwTemperature: DWORD;  //子板温度  单位：摄氏度
    struSubsystemStatus: array[0..MAX_BOARD_SUBSYSTEM_NUM-1] of NET_DVR_SUBSYSTEM_STATUS;  //子系统状态
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_SUBBOARD = ^NET_DVR_MATRIX_SUBBOARD;
type
  NET_DVR_MATRIX_STATUS = record 
    dwSize: DWORD;  
    byMainFrameType: BYTE;  //机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
    bySoltNum: BYTE;  //槽位数
    byBoardNum: BYTE;  //子板数
    byRes: BYTE;  
    struMatrixSubboard: array[0..MAX_MATRIX_SUBBOARD_NUM-1] of NET_DVR_MATRIX_SUBBOARD;  
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_STATUS = ^NET_DVR_MATRIX_STATUS;


type
  NET_DVR_MATRIX_SUBBOARD_V50 = record 
    byBoardNo: BYTE;  //子板号
    byPcieConnectStatus: BYTE;  //pcie连接状态， 1-连接 2-断开
    byRes: BYTE;  
    byTemperatureAlarm: BYTE;  //温度报警，0-此字段无效，1-温度正常，2-温度超上限报警，3-温度超下限报警
    dwHardwareVersion: DWORD;  //子板硬件版本
    dwPcieBandwidth: DWORD;  //pcie Link 带宽
    dwTemperature: DWORD;  //子板温度  单位：摄氏度
    struSubsystemStatus: array[0..MAX_BOARD_SUBSYSTEM_NUM-1] of NET_DVR_SUBSYSTEM_STATUS;  //子系统状态
    bySubboardModel: array[0..32-1] of BYTE;  //子板型号
    byRes1: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_SUBBOARD_V50 = ^NET_DVR_MATRIX_SUBBOARD_V50;

type
  NET_DVR_MATRIX_STATUS_V50 = record 
    dwSize: DWORD;  
    byMainFrameType: BYTE;  //机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
    bySoltNum: BYTE;  //槽位数
    byBoardNum: BYTE;  //子板数
    byLCDPanelStatus: BYTE;  //液晶面板连接状态，1-正常，2-异常
    struMatrixSubboard: array[0..MAX_MATRIX_SUBBOARD_NUM-1] of NET_DVR_MATRIX_SUBBOARD_V50;  
    dwFanSequence: DWORD;  //风扇编号，按位表示，最低位不使用，例如0xffffff04表示编号为1的风扇，当对应风扇被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
    dwFanConnectStatus: DWORD;  //风扇连接状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇连接正常，0xffffff04表示编号为1的风扇连接异常
    dwFanOperationStatus: DWORD;  //风扇运行状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇运行状态正常，0xffffff04表示编号为1的风扇运行异常
    byDeviceModel: array[0..32-1] of BYTE;  //设备型号
    byPowerNums: BYTE;  //电源数量
    byMainBoardNums: BYTE;  //主控数量
    byHotStandbyMode: BYTE;  // byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_STATUS_V50 = ^NET_DVR_MATRIX_STATUS_V50;

type
  NET_DVR_MATRIX_SUBBOARD_V51 = record 
    byBoardNo: BYTE;  //子板号
    byPcieConnectStatus: BYTE;  //pcie连接状态，1-连接，2-断开
    byRes1: BYTE;  
    byTemperatureAlarm: BYTE;  //温度报警，0-此字段无效，1-温度正常，2-温度超上限报警，3-温度超下限报警
    dwHardwareVersion: DWORD;  //子板硬件版本
    dwPcieBandwidth: DWORD;  //pcie Link带宽
    dwTemperature: DWORD;  //子板温度，单位：摄氏度
    struSubsystemStatus: array[0..MAX_BOARD_SUBSYSTEM_NUM-1] of NET_DVR_SUBSYSTEM_STATUS;  //子系统状态
    bySubboardModel: array[0..32-1] of BYTE;  //子板型号
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_SUBBOARD_V51 = ^NET_DVR_MATRIX_SUBBOARD_V51;

type
  NET_DVR_MATRIX_STATUS_V51 = record 
    dwSize: DWORD;  
    byMainFrameType: BYTE;  //机箱类型 1-18U机箱（V1.0），2-18U机箱，3-14U机箱，4-11U机箱，5-8U机箱，6-7U机箱
    bySoltNum: BYTE;  //槽位数
    byBoardNum: BYTE;  //子板数
    byLCDPanelStatus: BYTE;  //液晶面板连接状态，1-正常，2-异常
    struMatrixSubboard: array[0..MAX_MATRIX_SUBBOARD_NUM_V51-1] of NET_DVR_MATRIX_SUBBOARD_V51;  
    dwFanSequence: DWORD;  //风扇编号，按位表示，例如0x00000001表示设备只有一个风扇，编号为1，0x00000101表示设备有两个风扇，编号分别为1和9，当对应风扇编号被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
    dwFanConnectStatus: DWORD;  //风扇连接状态，按位表示，例如0x00000001表示编号为1的风扇连接状态异常，0x00000101表示编号为1和9的风扇连接状态均异常
    dwFanOperationStatus: DWORD;  //风扇运行状态，按位表示，例如0x00000001表示编号为1的风扇运行状态异常，0x00000101表示编号为1和9的风扇运行状态均异常
    byDeviceModel: array[0..32-1] of BYTE;  //设备型号
    byFanSpeed: array[0..32-1] of BYTE;  //风扇转速，按字节表示，例如byFanSpeed[0]表示编号为1的风扇的转速，转速等级范围为[1,3]
    byMainMemUsed: BYTE;  //主控内存使用率，单位：百分比
    byMainCpuUsed: BYTE;  //主控CPU使用率，单位：百分比
    byNetwordUsed: BYTE;  //交换板网络使用率，单位：百分比
    byRes1: BYTE;  
    dwMainSoftwareVer: DWORD;  //主控软件版本
    byPowerNums: BYTE;  //电源数量
    byMainBoardNums: BYTE;  //主控数量
    byHotStandbyMode: BYTE;  // byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
    byRes2: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_MATRIX_STATUS_V51 = ^NET_DVR_MATRIX_STATUS_V51;

type
  NET_DVR_SUBWIND_INFO = record 
    dwSize: DWORD;  
    dwSubWndNo: DWORD;  //子窗口号
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_SUBWIND_INFO = ^NET_DVR_SUBWIND_INFO;


type
  NET_DVR_FUSION_SCALE = record 
    dwSize: DWORD;  
    wWidth: WORD;  //图像融合宽(横向图像数目)
    wHeight: WORD;  //图像融合高(纵向图像数目)
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FUSION_SCALE = ^NET_DVR_FUSION_SCALE;

type
  NET_DVR_FUSION_CFG = record 
    dwSize: DWORD;  
    byFusion: BYTE;  //是否融合，0-未融合或取消融合，非0-融合
    byUseHistoryMap: BYTE;  //是否使用历史融合映射表，0-不使用，非0-使用
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_FUSION_CFG = ^NET_DVR_FUSION_CFG;

type
  NET_DVR_MULTIFUNCTION_SERIALCFG = record 
    dwSize: DWORD;  
    byVariable: BYTE;  //串口是否可变，1-不可变  2-可变 （只获取）
    bySerialWorkMode: BYTE;  //工作模式，1-RS485, 2-RS232（只在可变情况下，修改工作模式）
    byFunType: BYTE;  //串口功能， 1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    byDataBit: BYTE;  // 数据位 0－5位，1－6位，2－7位，3－8位;
    byStopBit: BYTE;  // 停止位 0－1位，1－2位;
    byParity: BYTE;  // 校验 0－无校验，1－奇校验，2－偶校验;
    byFlowcontrol: BYTE;  // 0－无，1－软流控,2-硬流控
    byRes1: BYTE;  
    dwBaudRate: DWORD;  //波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    wProtocol: WORD;  //串口协议  不同串口功能对应串口协议不一样
    byRes: array[0..34-1] of BYTE;  
  end;
  LPNET_DVR_MULTIFUNCTION_SERIALCFG = ^NET_DVR_MULTIFUNCTION_SERIALCFG;

type
  NET_DVR_PTZ_3D_SPEED_CONTROL = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byPSpeed: BYTE;  // X轴控制速度  （取值1－64）
    byTSpeed: BYTE;  // Y轴控制速度   （取值1－64）
    byZSpeed: BYTE;  // Z速度
    byPDirect: BYTE;  // P方向， 1-左， 2-右
    byTDirect: BYTE;  // T方向， 1-上， 2-下
    byZDirect: BYTE;  //Z方向，  1-ZOOM+,  2-ZOOM-
    byRes: array[0..18-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PTZ_3D_SPEED_CONTROL = ^NET_DVR_PTZ_3D_SPEED_CONTROL;

//Sensor信息
type
  NET_DVR_SENSOR_PARAM = record 
    bySensorType: BYTE;  //SensorType:0-CCD,1-CMOS
    byRes: array[0..31-1] of BYTE;  
    fHorWidth: FLOAT;  //水平宽度 精确到小数点后两位 *10000
    fVerWidth: FLOAT;  //垂直宽度 精确到小数点后两位 *10000
    fFold: FLOAT;  //zoom=1没变时的焦距 精确到小数点后两位 *100
  end;
  LPNET_DVR_SENSOR_PARAM = ^NET_DVR_SENSOR_PARAM;

//转向流量信息
type
  NET_DVR_TURN_DIRECTION_PARAM = record 
    byLine: BYTE;  //转向线编号
    byStatus: BYTE;  //转向线状态，0-未知，1-进入，2-离开
    byRes: array[0..38-1] of BYTE;  
  end;
  LPNET_DVR_TURN_DIRECTION_PARAM = ^NET_DVR_TURN_DIRECTION_PARAM;
//停止线信息
type
  NET_DVR_STOP_LINE_PARAM = record 
    byStatus: BYTE;  //停止线状态，0-未知，1-进入，2-离开
    byRes: array[0..39-1] of BYTE;  
  end;
  LPNET_DVR_STOP_LINE_PARAM = ^NET_DVR_STOP_LINE_PARAM;

//TPS附加信息
type
  NET_DVR_TPS_ADDINFO = record 
    struFirstLLPos: NET_DVR_LLPOS_PARAM;  //车流量第一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
    struLastLLPos: NET_DVR_LLPOS_PARAM;  //车流量最后一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号
    struTurnDirection: NET_DVR_TURN_DIRECTION_PARAM;  //转向流量信息
    struStopLine: NET_DVR_STOP_LINE_PARAM;  //停止线信息
    byRes: array[0..884-1] of BYTE;  
  end;
  LPNET_DVR_TPS_ADDINFO = ^NET_DVR_TPS_ADDINFO;

//车辆附加信息
type
  NET_DVR_VEHICLE_ADDINFO = record 
    struLLPos: NET_DVR_LLPOS_PARAM;  //车辆当前经纬度位置信息
    sVehicleNo: array[0..LEN_64-1] of AnsiChar;  //上传的车辆唯一标识,最大长度为64
    byVehicleMonitorTaskID: array[0..64-1] of BYTE;  //车辆智能布防任务ID,64位字符串,创建任务时由上层下发给设备,上层确保ID唯一性
    byUUID: array[0..LEN_64-1] of BYTE;  //通用唯一识别码,64位字符串,设备确保唯一性，用于跨服务器关联同一次抓拍,vehicleMonitor，manualVehicleMonitor，dailyVehicleMonitor报警中的linkageANPRUUID有关
    byRes: array[0..832-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLE_ADDINFO = ^NET_DVR_VEHICLE_ADDINFO;

//烟雾报警
type
  NET_DVR_SMOKEDETECTION_ALARM = record 
    struPTZPos: NET_PTZ_INFO;  //可见光设备PTZF位置
    struThermalPTZPos: NET_PTZ_INFO;  //热成像设备PTZF位置
    struLLPos: NET_DVR_LLPOS_PARAM;  //设备经纬度位置
    struSmokePos: NET_VCA_RECT;  //画面中烟雾区域位置
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SMOKEDETECTION_ALARM = ^NET_DVR_SMOKEDETECTION_ALARM;

//球机位置信息
type
  NET_DVR_PTZPOS_PARAM = record 
    fPanPos: FLOAT;  //水平参数，精确到小数点后1位
    fTiltPos: FLOAT;  //垂直参数，精确到小数点后1位
    fZoomPos: FLOAT;  //变倍参数，精确到小数点后1位
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PTZPOS_PARAM = ^NET_DVR_PTZPOS_PARAM;

//GIS信息上传
type
  NET_DVR_GIS_UPLOADINFO = record 
    dwSize: DWORD;  //结构体大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备
    fAzimuth: FLOAT;  //电子罗盘的方位信息；方位角[0.00°,360.00°)
    byLatitudeType: BYTE;  //纬度类型，0-北纬，1-南纬
    byLongitudeType: BYTE;  // 经度类型，0-东度，1-西度
    byRes1: array[0..2-1] of BYTE;  
    struLatitude: NET_DVR_LLI_PARAM;  //纬度
    struLongitude: NET_DVR_LLI_PARAM;  //经度
    fHorizontalValue: FLOAT;  //水平视场角，精确到小数点后面两位
    fVerticalValue: FLOAT;  //垂直视场角，精确到小数点后面两位
    fVisibleRadius: FLOAT;  //当前可视半径，精确到小数点后面两位
    fMaxViewRadius: FLOAT;  //最大可视半径，精确到小数点后面0位（预留处理）
    struSensorParam: NET_DVR_SENSOR_PARAM;  //Sensor信息
    struPtzPos: NET_DVR_PTZPOS_PARAM;  //ptz坐标
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_GIS_UPLOADINFO = ^NET_DVR_GIS_UPLOADINFO;

//防破坏报警信息上传
type
  NET_DVR_VANDALPROOF_ALARM = record 
    dwSize: DWORD;  //结构体大小
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_VANDALPROOF_ALARM = ^NET_DVR_VANDALPROOF_ALARM;

//集中布防参数配置
type
  NET_DVR_CENTRALIZEDCTRL_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //0-结束，1-开始
    byLatitudeType: BYTE;  //纬度类型，0-北纬，1-南纬
    byLongitudeType: BYTE;  // 经度类型，0-东经，1-西经
    byRes1: BYTE;  
    struLatitude: NET_DVR_LLI_PARAM;  //纬度
    struLongitude: NET_DVR_LLI_PARAM;  //经度
    dwTimeOut: DWORD;  //超时时间 [60s, 6*60*60s]
    byControlType: BYTE;  //集中布防方式 0-强制布防，1-非强制布防
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_CENTRALIZEDCTRL_CFG = ^NET_DVR_CENTRALIZEDCTRL_CFG;

//球机的GIS信息数据
type
  NET_DVR_GIS_INFO = record 
    dwSize: DWORD;  //结构体大小
    fAzimuth: FLOAT;  //电子罗盘的方位信息；方位角[0.00°,360.00°)
    fHorizontalValue: FLOAT;  //水平视场角，精确到小数点后面两位
    fVerticalValue: FLOAT;  //垂直视场角，精确到小数点后面两位
    fVisibleRadius: FLOAT;  //当前可视半径，精确到小数点后面两位
    fMaxViewRadius: FLOAT;  //最大可视半径，精确到小数点后面0位（预留处理）
    byLatitudeType: BYTE;  //纬度类型，0-北纬，1-南纬
    byLongitudeType: BYTE;  // 经度类型，0-东经，1-西经
    byPTZPosExEnable: BYTE;  //是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以struPtzPos 为准。1~启用，PTZ坐标值以struPtzPosEx为准。
    byRes1: BYTE;  
    struLatitude: NET_DVR_LLI_PARAM;  //纬度
    struLongitude: NET_DVR_LLI_PARAM;  //经度
    struPtzPos: NET_DVR_PTZPOS_PARAM;  //ptz坐标
    struSensorParam: NET_DVR_SENSOR_PARAM;  //Sensor信息
    struPtzPosEx: NET_PTZ_INFO;  // ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
    fMinHorizontalValue: FLOAT;  //最小水平视场角，精确到小数点后面两位；0.0-360.00
    fMaxHorizontalValue: FLOAT;  //最大水平视场角，精确到小数点后面两位；0.0-360.00
    fMinVerticalValue: FLOAT;  //最小垂直视场角，精确到小数点后面两位；0.0-360.00
    fMaxVerticalValue: FLOAT;  //最大垂直视场角，精确到小数点后面两位；0.0-360.00
    byRes: array[0..220-1] of BYTE;  
  end;
  LPNET_DVR_GIS_INFO = ^NET_DVR_GIS_INFO;

//设备巡航模式
type
  NET_DVR_CRUISE_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byCruiseMode: BYTE;  // 巡航模式，0~连续，1~预置点
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_CRUISE_PARAM = ^NET_DVR_CRUISE_PARAM;

//获取设备环境温湿度信息结构体
type
  NET_DVR_TEMP_HUMI_INFO = record 
    dwSize: DWORD;  
    struCurrentTime: NET_DVR_TIME_V30;  // 当前时间
    fTemperature: FLOAT;  //设备环境温度，精确到小数点后两位，（-273 C 1000摄氏度）
    fHumidity: FLOAT;  // 设备环境湿度，精确到小数点后两位。单位为：%
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_TEMP_HUMI_INFO = ^NET_DVR_TEMP_HUMI_INFO;

type
  NET_SDK_POINT_THERMOMETRY = record 
    fPointTemperature: FLOAT;  //点测温当前温度, 当标定为0-点时生效。精确到小数点后一位(-40-1000),（浮点数+100）*10 
    struPoint: NET_VCA_POINT;  //点测温坐标（当规则标定类型为“点”的时候生效）
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_SDK_POINT_THERMOMETRY = ^NET_SDK_POINT_THERMOMETRY;


type
  NET_SDK_REGION_THERMOMETRY = record 
    fMaxTemperature: FLOAT;  //最高温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 }
    fMinTemperature: FLOAT;  //最低温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 }
    fAverageTemperature: FLOAT;  //平均温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 }
    fTemperatureDiff: FLOAT;  //温差,精确到小数点后一位(-40-1000),（浮点数+100）*10 }
    struRegion: NET_VCA_POLYGON;  //区域、线（当规则标定类型为“框”或者“线”的时候生效）
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_SDK_REGION_THERMOMETRY = ^NET_SDK_REGION_THERMOMETRY;

type
  NET_SDK_MANUALTHERM_RULE = record 
    byRuleID: BYTE;  //规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
    byEnable: BYTE;  //是否启用
    byRes1: array[0..2-1] of BYTE;  
    szRuleName: array[0..NAME_LEN{32}-1] of AnsiChar;  //规则名称
    byRuleCalibType: BYTE;  //规则标定类型 0-点，1-框，2-线
    byRes2: array[0..3-1] of BYTE;  
    struPointTherm: NET_SDK_POINT_THERMOMETRY;  //点测温，当标定为0-点时生效
    struRegionTherm: NET_SDK_REGION_THERMOMETRY;  //区域测温，当标定为1-框、2-线时生效。
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_SDK_MANUALTHERM_RULE = ^NET_SDK_MANUALTHERM_RULE;

type
  NET_SDK_MANUAL_THERMOMETRY = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    dwRelativeTime: DWORD;  // 相对时标（只读）
    dwAbsTime: DWORD;  // 绝对时标（只读）
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    byDataType: BYTE;  //数据状态类型:0-检测中，1-开始，2-结束（只读）
    byRes1: array[0..6-1] of BYTE;  
    struRuleInfo: NET_SDK_MANUALTHERM_RULE;  
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_SDK_MANUAL_THERMOMETRY = ^NET_SDK_MANUAL_THERMOMETRY;

type
  NET_SDK_MANUALTHERM_BASICPARAM = record 
    dwSize: DWORD;  
    wDistance: WORD;  //距离(m)[0, 10000]
    byDistanceUnit: BYTE;  //距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
    byRes1: array[0..1-1] of BYTE;  //保留
    fEmissivity: FLOAT;  //发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_SDK_MANUALTHERM_BASICPARAM = ^NET_SDK_MANUALTHERM_BASICPARAM;

type
  NET_SDK_FIRESHIELDMASK_REGION = record 
    dwSize: DWORD;  
    byMaskID: BYTE;  //区域ID，1~24
    byEnabled: BYTE;  // 单个火点屏蔽区域使能，0~不启用，1~启用
    byShieldZoom: BYTE;  //屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
    byMaskType: BYTE;  //屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
    byRegionType: BYTE;  //区域类型（预留）0-四边形
    byShowEnabled: BYTE;  //区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
    byRes1: array[0..2-1] of BYTE;  //保留
    szMaskName: array[0..NAME_LEN{32}-1] of AnsiChar;  //屏蔽标题
    struRegion: NET_VCA_POLYGON;  //屏蔽区域
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_SDK_FIRESHIELDMASK_REGION = ^NET_SDK_FIRESHIELDMASK_REGION;

const
  MAX_FIRESHIELDMASK_REGION = 24;    
type
  NET_SDK_FIRESHIELDMASK_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  // 火点区域屏蔽使能，0~不启用，1~启用
    byShieldAreaTransparency: BYTE;  //屏蔽区域透明度 0-不透明 1-透明 2-半透明
    byDisplayShieldAreaEnabled: BYTE;  //码流叠加屏蔽区域使能
    byRes1: array[0..1-1] of BYTE;  //保留
    struMaskRegion: array[0..MAX_FIRESHIELDMASK_REGION{24}-1] of NET_SDK_FIRESHIELDMASK_REGION;  //火点屏蔽区域
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_SDK_FIRESHIELDMASK_CFG = ^NET_SDK_FIRESHIELDMASK_CFG;

type
  NET_SDK_SMOKESHIELDMASK_REGION = record 
    dwSize: DWORD;  
    byMaskID: BYTE;  //区域ID，1~24
    byEnabled: BYTE;  // 单个烟雾屏蔽区域使能，0~不启用，1~启用
    byShieldZoom: BYTE;  //屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
    byMaskType: BYTE;  //屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
    byRegionType: BYTE;  //区域类型（预留）0-四边形
    byShowEnabled: BYTE;  // 区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
    byRes1: array[0..2-1] of BYTE;  //保留
    szMaskName: array[0..NAME_LEN{32}-1] of AnsiChar;  //屏蔽标题
    struRegion: NET_VCA_POLYGON;  //屏蔽区域
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_SDK_SMOKESHIELDMASK_REGION = ^NET_SDK_SMOKESHIELDMASK_REGION;

const
  MAX_SMOKESHIELDMASK_REGION = 24;    
type
  NET_SDK_SMOKESHIELDMASK_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  // 烟雾区域屏蔽使能，0~不启用，1~启用
    byShieldAreaTransparency: BYTE;  //屏蔽区域透明度 0-不透明 1-透明 2-半透明
    byDisplayShieldAreaEnabled: BYTE;  //码流叠加屏蔽区域使能
    byRes1: array[0..1-1] of BYTE;  //保留
    struMaskRegion: array[0..MAX_SMOKESHIELDMASK_REGION{24}-1] of NET_SDK_SMOKESHIELDMASK_REGION;  //烟雾屏蔽区域
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_SDK_SMOKESHIELDMASK_CFG = ^NET_SDK_SMOKESHIELDMASK_CFG;

type
  NET_SDK_AREASCAN_CFG = record 
    dwSize: DWORD;  
    byScanState: BYTE;  //区域扫描当前设置状态，0为未设置，1为已设置（该参数为只读）
    byRes: array[0..259-1] of BYTE;  //保留
  end;
  LPNET_SDK_AREASCAN_CFG = ^NET_SDK_AREASCAN_CFG;

type
  NET_SDK_FIRESHIELDMASK_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRegionID: BYTE;  //区域ID，1~24.
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_SDK_FIRESHIELDMASK_COND = ^NET_SDK_FIRESHIELDMASK_COND;

type
  NET_SDK_SMOKESHIELDMASK_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRegionID: BYTE;  //区域ID，1~24.
    byRes: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_SDK_SMOKESHIELDMASK_COND = ^NET_SDK_SMOKESHIELDMASK_COND;

//子罗盘关联防破坏参数
type
  NET_DVR_VANDALPROOFALARM_CFG = record 
    dwSize: DWORD;  //结构体大小
    bySensitivity: BYTE;  //灵敏度[1,100] (支持灵敏度配置，灵敏度值大，越容易触发，值越小，越难触发)
    byUploadEnabled: BYTE;  //启用防破坏报警上传使能 0-不启用，1-启用
    byVoiceWarningEnabled: BYTE;  //启用防破坏报警语音提示使能 0-不启用，1-启用
    byEnable: BYTE;  // 启用检测防破坏报警 0-关闭，1-开始
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_VANDALPROOFALARM_CFG = ^NET_DVR_VANDALPROOFALARM_CFG;

type
  NET_DVR_AZIMUTHINFO = record 
    dwSize: DWORD;  //结构体大小
    fDegree: FLOAT;  //方位角度数(精确到小数点后两位)
    byAzimuth: BYTE;  //方位角信息 0-东北,1-西北,2-东南,3-西南,4-东,5-西,6-南,7-北
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_AZIMUTHINFO = ^NET_DVR_AZIMUTHINFO;

//电子罗盘矫正、指向正北控制条件结构
type
  NET_DVR_COMPASS_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_COMPASS_COND = ^NET_DVR_COMPASS_COND;

type
  NET_DVR_POSITION_CFG = record 
    dwSize: DWORD;  //结构体大小
    bySoftWorkMode: BYTE;  //工作模式 0-自动，1-手动
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_POSITION_CFG = ^NET_DVR_POSITION_CFG;

type
  NET_DVR_STREAMING_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byStreamType: BYTE;  //码流类型0-主码流，1-子码流，2-码流3
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_STREAMING_COND = ^NET_DVR_STREAMING_COND;

//卫星定位参数配置
type
  NET_DVR_SATELLITETIME_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //卫星定位校时使能 0-不开启，1-开启
    byRes: BYTE;  
    wTimeInterval: WORD;  //校时时间间隔(s)
    byRes1: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_SATELLITETIME_CFG = ^NET_DVR_SATELLITETIME_CFG;

const
  MAX_SIGNAL_JOINT_NUM = 64;    //最大的拼接规模
type
  NET_DVR_SIGNAL_JOINT_CFG = record 
    dwSize: DWORD;  
    sCamName: array[0..NAME_LEN-1] of BYTE;  //拼接后信号源名称
    byEnable: BYTE;  //使能，0-不使能  !0-使能
    byCamMode: BYTE;  //拼接后信号源类型，NET_DVR_CAM_JOINT
    byRows: BYTE;  //拼接行数
    byColumns: BYTE;  //拼接列数
    dwSignalNo: array[0..MAX_SIGNAL_JOINT_NUM-1] of DWORD;  //信号源号,前byRows* byColumns项有效
    dwJointNo: DWORD;  //拼接编号（获取有效）
    dwSignalNoJoint: DWORD;  //拼接后的信号源号（获取有效）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SIGNAL_JOINT_CFG = ^NET_DVR_SIGNAL_JOINT_CFG;

type
  NET_DVR_SIGNAL_CUTPARAM = record 
    dwSize: DWORD;  
    dwSignalNo: DWORD;  //信号源号
    dwCutTop: DWORD;  //上方裁剪像素值,0代表还原
    dwCutBottom: DWORD;  //下方裁剪像素值,0代表还原
    dwCutLeft: DWORD;  //左边裁剪像素值,0代表还原
    dwCutRight: DWORD;  //右边裁剪像素值,0代表还原
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SIGNAL_CUTPARAM = ^NET_DVR_SIGNAL_CUTPARAM;

type
  NET_DVR_WALL_RELATION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //关联， 0-不关联 !0-关联
    byRealWallNo: BYTE;  //物理墙号
    byRes: array[0..14-1] of BYTE;  
  end;
  LPNET_DVR_WALL_RELATION_CFG = ^NET_DVR_WALL_RELATION_CFG;


type
  NET_DVR_INPUTSTREAMCFG_V40 = record 
    dwSize: DWORD;  
    byValid: BYTE;  //
    byCamMode: BYTE;  //见NET_DVR_CAM_MODE
    wInputNo: WORD;  //信号源序号
    sCamName: array[0..NAME_LEN-1] of BYTE;  
    struVideoEffect: NET_DVR_VIDEOEFFECT;  //视频参数
    struPuStream: NET_DVR_PU_STREAM_CFG;  //ip输入时使用
    wBoardNum: WORD;  //信号源所在的板卡号，只能获取
    wInputIdxOnBoard: WORD;  //信号源在板卡上的位置，只能获取
    dwResolution: DWORD;  //分辨率
    byVideoFormat: BYTE;  //视频制式，见VIDEO_STANDARD
    byStatus: BYTE;  //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常
    sGroupName: array[0..NAME_LEN{32}-1] of BYTE;  //网络信号源分组 组名
    byJointMatrix: BYTE;  //关联矩阵，0-不关联  1-关联，当输入信号源为NET_DVR_CAM_BNC，NET_DVR_CAM_VGA，NET_DVR_CAM_DVI，NET_DVR_CAM_HDMI,中的一种时，该参数有效。
    byJointNo: BYTE;  //拼接信号源的拼接编号(只能获取)
    byColorMode: BYTE;  //色彩模式， 0-自定义 1-锐利 2-普通 3-柔和，当为自定义时，使用struVideoEffect设置
    byScreenServer: BYTE;  //关联屏幕服务器，0-不联，1-关联
    byDevNo: BYTE;  //设备号
    byRes1: BYTE;  
    dwInputSignalNo: DWORD;  //输入信号源编号（新）
    byVideoEnctype: BYTE;  //视频编码类型，0-默认，1-Smart264
    byAudioEnctype: BYTE;  //音频编码类，0-默认，1-AUDIO_G711_A，2-AUDIO_G711_U，3- AUDIO_G722_1
    byWallStatus: BYTE;  //信号源上墙状态，0-无效 1-有上墙 2- 无上墙
    byRes: array[0..117-1] of BYTE;  
  end;
  LPNET_DVR_INPUTSTREAMCFG_V40 = ^NET_DVR_INPUTSTREAMCFG_V40;

type
  NET_DVR_AUDIO_CONTROL_INFO = record 
    dwSize: DWORD;  
    dwMonId: DWORD;  //显示器全局编号
    bySubWindowNum: BYTE;  //显示器对应子窗口号
    byWallNo: BYTE;  //墙号
    byEnable: BYTE;  //音频开关，0-关，1-开
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_CONTROL_INFO = ^NET_DVR_AUDIO_CONTROL_INFO;



type
  NET_DVR_INPUTSTREAM_PTZCFG_PARAM = record 
    dwSize: DWORD;  
    wPTZProtocol: WORD;  //控球协议类型，索引值
    byRes: array[0..34-1] of BYTE;  
  end;
  LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM = ^NET_DVR_INPUTSTREAM_PTZCFG_PARAM;

//公路货车轴型定义 参照《2016治超分类1133.xlsx》
type
  TRUCK_AXLE_MODEL =  
  (  
    AXLE_TYPE_UNKNOWN = $0000,  //未知
    //2轴
    AXLE_TYPE_2AXLE_12 = $0200,  //2轴载货汽车
    //3轴
    AXLE_TYPE_3AXLE_122_1 = $0300,  //3轴中置轴挂车列车
    AXLE_TYPE_3AXLE_122_2,  //3轴铰接列车
    AXLE_TYPE_3AXLE_15,  //3轴载货汽车
    AXLE_TYPE_3AXLE_112,  //3轴载货汽车
    //4轴
    AXLE_TYPE_4AXLE_125_1 = $0400,  //4轴中置轴挂车列车
    AXLE_TYPE_4AXLE_152,  //4轴中置轴挂车列车
    AXLE_TYPE_4AXLE_125_2,  //4轴铰接列车
    AXLE_TYPE_4AXLE_1222,  //4轴全挂汽车列车
    AXLE_TYPE_4AXLE_115,  //4轴载货汽车
    //5轴
    AXLE_TYPE_5AXLE_155_1 = $0500,  //5轴中置轴挂车列车
    AXLE_TYPE_5AXLE_1125_1,  //5轴中置轴挂车列车
    AXLE_TYPE_5AXLE_155_2,  //5轴铰链列车
    AXLE_TYPE_5AXLE_1125_2,  //5轴铰链列车
    AXLE_TYPE_5AXLE_129,  //5轴铰链列车
    AXLE_TYPE_5AXLE_1522,  //5轴全挂汽车列车
    AXLE_TYPE_5AXLE_11222,  //5轴全挂汽车列车
    //6轴
    AXLE_TYPE_6AXLE_159_1 = $0600,  //6轴中置轴挂车列车
    AXLE_TYPE_6AXLE_159_2,  //6轴中置轴挂车列车
    AXLE_TYPE_6AXLE_1155_1,  //6轴中置轴挂车列车
    AXLE_TYPE_6AXLE_1155_2,  //6轴中置轴挂车列车
    AXLE_TYPE_6AXLE_159_3,  //6轴铰链列车
    AXLE_TYPE_6AXLE_159_4,  //6轴铰链列车
    AXLE_TYPE_6AXLE_1129,  //6轴铰链列车
    AXLE_TYPE_6AXLE_11522_1,  //6轴全挂车
    AXLE_TYPE_6AXLE_11522_2  //6轴全挂车
  );

//收费公路车辆通行费车型分类
type
  TOOLWAY_VEHICLE_TYPE =  
  (  
    TOOLWAY_RESULT_OTHER = 0,  //未知
    TOOLWAY_PASSENGER_VEHICLE_CLASS_1_MINI = 1,  //1类客车微型
    TOOLWAY_PASSENGER_VEHICLE_CLASS_1_SMALL = 2,  //1类客车小型
    TOOLWAY_PASSENGER_VEHICLE_CLASS_2_MIDDLE = 3,  //2类客车中型
    TOOLWAY_PASSENGER_VEHICLE_CLASS_2_TRAILER = 4,  //2类客车乘用车列车
    TOOLWAY_PASSENGER_VEHICLE_CLASS_3_LARGR = 5,  //3类客车大型
    TOOLWAY_PASSENGER_VEHICLE_CLASS_4_LARGR = 6,  //4类客车大型
    TOOLWAY_GOODS_VEHICLE_CLASS_1 = 7,  //1类货车2轴
    TOOLWAY_GOODS_VEHICLE_CLASS_2 = 8,  //2类货车2轴
    TOOLWAY_GOODS_VEHICLE_CLASS_3 = 9,  //3类货车3轴
    TOOLWAY_GOODS_VEHICLE_CLASS_4 = 10,  //4类货车4轴
    TOOLWAY_GOODS_VEHICLE_CLASS_5 = 11,  //5类货车5轴
    TOOLWAY_GOODS_VEHICLE_CLASS_6 = 12,  //6类货车6轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_1 = 13,  //1类作业车2轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_2 = 14,  //2类作业车2轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_3 = 15,  //3类作业车3轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_4 = 16,  //4类作业车4轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_5 = 17,  //5类作业车5轴
    TOOLWAY_MOTOR_VEHICLE_CLASS_6 = 18  //6类作业车大于等于6轴
  );

//车辆称重
type
  NET_DVR_VEHICLE_WEIGHT_RESULT = record 
    byIsOverWeight: BYTE;  //是否超限
    byAxleNum: BYTE;  //轴数
    wAxleModel: WORD;  //参考 enum TRUCK_AXLE_MODEL,可以根据类型解析出轴的个数
    fOverWeight: FLOAT;  //超限重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    fWeight: FLOAT;  //车身重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    fLimitWeight: FLOAT;  //限制重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    fAxleLen: FLOAT;  //轴距(米)，实际值扩大100倍传输（实际值精确到小数点后两位）
    sDevDescInfo: array[0..MAX_DEVDESC_LEN{64}-1] of AnsiChar;  //设备描述信息
    wAxleWeight: array[0..MAX_TRUCK_AXLE_NUM{10}-1] of WORD;  //车轴重量，单位千克（kg）第i个元素表示第i个轴重
    wAxleDistance: array[0..MAX_TRUCK_AXLE_NUM{10}-1] of WORD;  //车轴间距，单位毫米(mm).第i个元素表示第i轴和第i+1轴的间距
    dwLength: DWORD;  //车长，单位cm
    dwWidth: DWORD;  //车宽，单位cm
    dwHeight: DWORD;  //车高，单位cm
    byTollwayVehicleType: BYTE;  //收费公路车型，参考TOOLWAY_VEHICLE_TYPE
    byRes2: array[0..11-1] of BYTE;  //预留
  end;
  LPNET_DVR_VEHICLE_WEIGHT_RESULT = ^NET_DVR_VEHICLE_WEIGHT_RESULT;

// 车牌检测结果
type
  NET_DVR_PLATE_RESULT_V50 = record 
    dwSize: DWORD;  //结构长度
    dwMatchNo: DWORD;  //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    byGroupNum: BYTE;  //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    byPicNo: BYTE;  //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    bySecondCam: BYTE;  //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    byFeaturePicNo: BYTE;  //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    byDriveChan: BYTE;  //触发车道号
    byVehicleType: BYTE;  //车辆类型，参考VTR_RESULT
    byDetSceneID: BYTE;  //检测场景号[1,4], IPC默认是0
    //车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    //该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
    byVehicleAttribute: BYTE;  
    wIllegalType: WORD;  //违章类型采用国标定义
    byIllegalSubType: array[0..8-1] of BYTE;  //违章子类型
    byPostPicNo: BYTE;  //违章时取第几张图片作为卡口图,0xff-表示不取
    byChanIndex: BYTE;  //通道号（保留）
    wSpeedLimit: WORD;  //限速上限（超速时有效）
    byChanIndexEx: BYTE;  //byChanIndexEx*256+byChanIndex表示真实通道号。
    byVehiclePositionControl: BYTE;  {车辆位置布防标志,0~为普通车牌识别报警,1~为车辆位置布防触发报警
                                       (即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)}
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byDeviceID: array[0..48-1] of BYTE;  //设备编号
    byDir: BYTE;  //显示方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    byDetectType: BYTE;  //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    byRelaLaneDirectionType: BYTE;  
    byCarDirectionType: BYTE;  //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    dwCustomIllegalType: DWORD;  //违章类型定义(用户自定义)
    {为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
    为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码}
    pIllegalInfoBuf: PBYTE;  //违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO
    byIllegalFromatType: BYTE;  //违章信息格式类型； 0~数字格式， 1~字符格式
    byPendant: BYTE;  // 0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
    byDataAnalysis: BYTE;  //0-数据未分析, 1-数据已分析
    byYellowLabelCar: BYTE;  //0-表示未知, 1-非黄标车,2-黄标车
    byDangerousVehicles: BYTE;  //0-表示未知, 1-非危险品车,2-危险品车
    //以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
    byPilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byCopilotSafebelt: BYTE;  //0-表示未知,1-系安全带,2-不系安全带
    byPilotSunVisor: BYTE;  //0-表示未知,1-不打开遮阳板,2-打开遮阳板
    byCopilotSunVisor: BYTE;  //0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    byPilotCall: BYTE;  // 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据名单匹配后，是否开闸成功的标志)
    byBarrierGateCtrlType: BYTE;  
    byAlarmDataType: BYTE;  //0-实时数据，1-历史数据
    struSnapFirstPicTime: NET_DVR_TIME_V30;  //端点时间(ms)（抓拍第一张图片的时间）
    dwIllegalTime: DWORD;  //违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    dwPicNum: DWORD;  //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
    struPicInfo: array[0..6-1] of NET_ITS_PICTURE_INFO;  //图片信息,单张回调，最多6张图，由序号区分
    struWeightResult: NET_DVR_VEHICLE_WEIGHT_RESULT;  //车辆称重
    byRes: array[0..256-1] of BYTE;  //预留
  end;
  LPNET_DVR_PLATE_RESULT_V50 = ^NET_DVR_PLATE_RESULT_V50;


type
  NET_DVR_NORMAL_SCHEDTIME = record 
    struTime: NET_DVR_SCHEDTIME;  
    byAlarmType: BYTE;  //0-外出布防，1-留守布防，2-即时布防
    byRes: array[0..3-1] of BYTE;  
  end;
  LPNET_DVR_NORMAL_SCHEDTIME = ^NET_DVR_NORMAL_SCHEDTIME;

type
  NET_DVR_SUBSYSTEM_ALARM = record 
    dwSize: DWORD;  
    struNormalSchedtime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_NORMAL_SCHEDTIME;  
    //日常计划布防时间段
    byNormalSchedTimeOn: BYTE;  //日常计划是否启用
    byMandatoryAlarm: BYTE;  //0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_SUBSYSTEM_ALARM = ^NET_DVR_SUBSYSTEM_ALARM;


const
  MAX_ALLOWLIST_PHONE_NUM = 16;    

type
  NET_DVR_ALARM_PHONECFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用 0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    byPhoneNumber: array[0..MAX_PHONE_NUM{32}-1] of BYTE;  
    dwArmRight: DWORD;  //布防权限，按位，bit0为1表示对子系统1有布防权限，依此类推
    dwDisArmRight: DWORD;  //撤防权限，按位，bit0为1表示对子系统1有撤防权限，依此类推
    dwClearAlarmRight: DWORD;  //消警权限，按位，bit0为1表示对子系统1有消警权限，依此类推
    byZoneReport: array[0..MAX_ALARMHOST_ALARMIN_NUM{512}-1] of BYTE;  //防区报告类型，0-不上传，1-上传
    dwNonZoneReport: DWORD;  //非防区报警报告 bit0-软防区报告 bit1-系统状态报告 bit2-取消报告 bit3-测试报告,bit4-布防报告 bit5-撤防报告 bit6-挟持报告 bit7-报警恢复报告 bit8-旁路报告 bit9-旁路恢复报告,bit10-探测器连接状态报告（上线、离线）,bit11-探测器电量状态报告（电压正常、欠压）,bit12-视频报警报告
    byIntervalTime: BYTE;  //0-0s,1-10s,2-30s,3-1min,4-5min,5-10min,6-自定义（1~5999s）
    byRes2: BYTE;  
    wDefineIntervalTime: WORD;  //当byIntervalTime为6时有效，自定义时间（1~5999s）
    byRes3: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_PHONECFG = ^NET_DVR_ALARM_PHONECFG;

type
  NET_DVR_MODULE_INFO = record 
    dwSize: DWORD;  
    byModuleType: BYTE;  //外接触发器类型，1-键盘，2-触发器，3-防区 ，4-网络模块
    byKeyBoardType: BYTE;  //1-LCD,2-LED
    byTriggerType: BYTE;  // 1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，5-32路触发器
    byZoneType: BYTE;  //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器
    wModuleAddress: WORD;  //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    byRes2: array[0..2-1] of BYTE;  //保留
    sModelInfo: array[0..32-1] of AnsiChar;  //模块信息
    sDeviceVersionInfo: array[0..32-1] of AnsiChar;  //版本信息
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_MODULE_INFO = ^NET_DVR_MODULE_INFO;

type
  NET_DVR_ALARMHOST_DETECTOR_INFO = record 
    dwSize: DWORD;  
    byDetectorSerialNo: array[0..16-1] of BYTE;  //探测器序列号
    dwAlarmIn: DWORD;  //防区号
    wDetectorType: WORD;  // 探测器类型，DETECTOR_TYPE
    byRes: array[0..126-1] of BYTE;  //保留
  end;
  LPNET_DVR_ALARMHOST_DETECTOR_INFO = ^NET_DVR_ALARMHOST_DETECTOR_INFO;

type
  NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 = record 
    byEnable: BYTE;  // 0- 否，1- 是
    byRes1: array[0..3-1] of BYTE;  
    struDate: NET_DVR_SCHEDDATE;  
    struOutputSchedule: array[0..MAX_TIMESEGMENT_V30{8}-1] of NET_DVR_OUTPUT_SCHEDULE;  
    byTriggerIndex: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //下标表示触发器号，值0-不启用，1-启用
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 = ^NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;
//时控输出规则参数
type
  NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40 = record 
    dwSize: DWORD;  //结构体大小
    struOutputRule: array[0..MAX_RULE_NUM{8}-1] of NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;  //最多支持8个日期区段的规则配置，对于定时开/关触发器只需要使用一个日期区段就可以了
    byRes: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40 = ^NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

//单个时控输出规则配置
type
  NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40 = record 
    dwSize: DWORD;  
    struOutputRule: NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;  
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40 = ^NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

type
  NET_DVR_ALARM_CAPTRUE_CFG = record 
    dwSize: DWORD;  
    byBeforeAlarmPic: BYTE;  //对应分辨率下可设置报警前图片最大数4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    byAfterAlarmPic: BYTE;  //对应分辨率下可设置报警后图片最大数 4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    wInterval: WORD;  //间隔时间 单位s
    byResolution: BYTE;  //图片分辨率1-CIF，2-2CIF，3-4CIF，4-QCIF，5-WD1，6-VGA,7-XVGA，8-720P，9-1080P
    byRes: array[0..63-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_ALARM_CAPTRUE_CFG = ^NET_DVR_ALARM_CAPTRUE_CFG;

const
  PRIOR_SCHEDTIME = 30;    

type
  NET_DVR_PRIOR_SCHEDTIME = record 
    dwSize: DWORD;  
    struData: NET_DVR_SCHEDDATE;  
    struOneDayTime: array[0..8-1] of NET_DVR_NORMAL_SCHEDTIME;  
    byEnable: BYTE;  //是否启用 0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    bySubSystem: array[0..32-1] of BYTE;  //子系统，下标表示子系统号 0-不支持，1-支持
    byMandatoryAlarm: BYTE;  //0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_PRIOR_SCHEDTIME = ^NET_DVR_PRIOR_SCHEDTIME;

type
  NET_DVR_TAMPER_ALARMIN_PARAM = record 
    dwSize: DWORD;  
    byTamperType: BYTE;  // 0-无,1-常开，2-常闭
    byUploadAlarmRecoveryReport: BYTE;  //是否上传防区报警恢复报告，0-不上传，1-上传
    byRes1: array[0..2-1] of BYTE;  
    byAssociateAlarmOut: array[0..MAX_ALARMHOST_ALARMOUT_NUM-1] of BYTE;  //防区关联触发器    BYTE            byAssociateSirenOut[8];        //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    byAssociateSirenOut: array[0..8-1] of BYTE;  //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    byTamperResistor: BYTE;  //防拆电阻，单位千欧 ， 0-无效 1-2.2 ，2--3.3, 3-4.7 ，4-5.6 ， 5-8.2 ，0xff-自定义
    byRes2: array[0..3-1] of BYTE;  
    fTamperResistorManual: FLOAT;  //防拆手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byTamperResistor为0xff时有效
    byRes3: array[0..36-1] of BYTE;  // 保留字节
  end;
  LPNET_DVR_TAMPER_ALARMIN_PARAM = ^NET_DVR_TAMPER_ALARMIN_PARAM;


type
  NET_DVR_REMOTECONTROLLER_PERMISSION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  
    byAssociateNetUser: BYTE;  //关联的网络用户编号
    wRemoteCtrllerID: WORD;  //遥控器号 从1开始
    sDevSn: array[0..16-1] of BYTE;  //产品序列号
    byArmRight: BYTE;  //0-无布防权限，1-有布防权限
    byDisArmRight: BYTE;  //0-无撤防权限，1-有撤防权限
    byArmReportRight: BYTE;  //0-无传布防报告权限，1-有传布防报告权限
    byDisArmReportRight: BYTE;  //0-无上传撤防报告权限，1-有上传撤防报告权限
    byClearAlarmRight: BYTE;  //0-无消警权限，1-有消警权限
    bySubSystemID: BYTE;  // 设备(遥控器)子系统号,1~8 
    byKeyboardAddr: BYTE;  // 接收键盘的地址,在配对时设置 
    byEnableDel: BYTE;  //删除遥控器用户，0-禁用删除，1-启用删除
    byAlwaysOpenRight: BYTE;  //是否允许常开：0-无效，1-不允许，2-允许
    byOpeningDirection: BYTE;  //开门方向：0-无效，1-进门方向，2-出门方向
    byRes3: array[0..2-1] of BYTE;  
    byName: array[0..NAME_LEN-1] of BYTE;  //遥控器名称
    byRes2: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG = ^NET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


type
  NET_DVR_KEYBOARD_CFG = record 
    dwSize: DWORD;  
    byEnableLock: BYTE;  //是否启用键盘锁定,0--不启用, 1--启用
    byErrorTimes: BYTE;  //输入键盘用户密码错误次数（锁定键盘）
    wLockTime: WORD;  //锁定键盘时间，单位秒
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_KEYBOARD_CFG = ^NET_DVR_KEYBOARD_CFG;


type
  NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND = record 
    dwSize: DWORD;  
    byCommOperatorNum: array[0..NAME_LEN{32}-1] of BYTE;  //通信运营商号码
    byQueryCode: array[0..16-1] of BYTE;  //业务查询代码
    byBusinessType: BYTE;  //业务类型 0-话费，1-流量
    byRes: array[0..35-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND = ^NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

type
  NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO = record 
    dwSize: DWORD;  
    by3GBusiness: array[0..1024-1] of BYTE;  //3G业务通过短信查询
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO = ^NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

type
  NET_DVR_PREVIEW_DELAY_CFG = record 
    dwSize: DWORD;  
    wdelayTime: WORD;  //延迟预览时间，单位：秒
    byRes: array[0..130-1] of BYTE;  
  end;
  LPNET_DVR_PREVIEW_DELAY_CFG = ^NET_DVR_PREVIEW_DELAY_CFG;

type
  NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM = record 
    dwSize: DWORD;  
    dwDevNo: DWORD;  //设备号
    byDevType: BYTE;  //升级设备类型 0-键盘,1-机芯,2-网络模块,3-路由器 ，4-防区，5-RS485无线扩展模块，6-温控模块，7-电锁模块,8-网口供电模块
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM = ^NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

type
  NET_DVR_CALL_ROOM_CFG = record 
    dwSize: DWORD;  
    nFloorNumber: SHORT;  //层号
    wRoomNumber: WORD;  //房间号
    byManageCenter: BYTE;  //是否呼叫管理中心
    byRes1: array[0..3-1] of BYTE;  
    byCalledName: array[0..64-1] of BYTE;  //标准sip模式下有效，被叫用户名, 支持数字、字母、“@”和“.”
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_CALL_ROOM_CFG = ^NET_DVR_CALL_ROOM_CFG;

type
  NET_DVR_VIDEO_CALL_COND = record 
    dwSize: DWORD;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_VIDEO_CALL_COND = ^NET_DVR_VIDEO_CALL_COND;

//审讯案件信息
type
  NET_DVR_INQUEST_CASE_INFO = record 
    dwSize: DWORD;  
    sCaseNo: array[0..INQUEST_CASE_NO_LEN-1] of BYTE;  //案件编号
    sCaseName: array[0..INQUEST_CASE_NAME_LEN-1] of BYTE;  //案件名称；
    sCustomInfo1: array[0..CUSTOM_INFO_LEN-1] of BYTE;  //自定义信息1；
    sCustomInfo2: array[0..CUSTOM_INFO_LEN-1] of BYTE;  //自定义信息2；
    sCustomInfo3: array[0..CUSTOM_INFO_LEN-1] of BYTE;  //自定义信息3
    byShowCaseInfoTime: BYTE;  // 案件信息显示时间,单位秒, 取值范围1~60秒
    byShowCaseInfo: BYTE;  //案件开始是否显示案件信息，0-不显示，1-显示
    byPosition: BYTE;  //案件显示位置，0-左上，1-左下
    byRes1: BYTE;  //保留
    byCustomInfo4: array[0..CUSTOM_INFO_LEN-1] of BYTE;  //自定义信息4，案件编号有内容时该字段无效
    byCustomInfo5: array[0..CUSTOM_INFO_LEN-1] of BYTE;  //自定义信息5，案件名称有内容时该字段无效
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_CASE_INFO = ^NET_DVR_INQUEST_CASE_INFO;

type
  NET_DVR_CASE_INFO_CTRL_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //审讯通道号
    byShowCaseInfoTime: BYTE;  //显示持续时间
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_CASE_INFO_CTRL_PARA = ^NET_DVR_CASE_INFO_CTRL_PARAM;

type
  NET_DVR_INQUEST_USER_RIGHT_CFG = record 
    dwSize: DWORD;  
    //数组0: 审讯记录删除权限
    byLocalRight: array[0..MAX_RIGHT-1] of BYTE;  // 本地权限 
    //数组0: 远程音频预览权限
    byRemoteRight: array[0..MAX_RIGHT-1] of BYTE;  // 远程权限 
    byNetAudioRight: array[0..MAX_CHANNUM_V40-1] of BYTE;  // 远程音频预览权限，数组下标表示通道，值表示有无权限，0-无权限，1-有权限
    byRes: array[0..512*9-1] of BYTE;  //保留9种权限可扩展
  end;
  LPNET_DVR_INQUEST_USER_RIGHT_CFG = ^NET_DVR_INQUEST_USER_RIGHT_CFG;

type
  NET_DVR_INQUEST_MIX_AUDIOIN_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用混音，0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  //保留
    dwMixCnt: DWORD;  //混音的通道数
    bySrcChan: array[0..MAX_MIX_CHAN_NUM-1] of BYTE;  //数组下标表示混音通道号（模拟通道、IP通道）,数值0表示不混，数值1表示混入
    byLineIn: array[0..MAX_LINE_IN_CHAN_NUM-1] of BYTE;  //数组下标表示混入Line In通道号,数值0表示不混，数值1表示混入
    byMic: array[0..MAX_MIC_CHAN_NUM-1] of BYTE;  //数组下标表示混入Mic通道号,数值0表示不混，数值1表示混入
    byMixAudioDelay: BYTE;  //混音延迟，单位：帧，范围0-63
    byRes2: array[0..127-1] of BYTE;  //保留
  end;
  LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG = ^NET_DVR_INQUEST_MIX_AUDIOIN_CFG;

type
  NET_DVR_FACECAPTURE_STATISTICS_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    byReportType: BYTE;  //统计报表类型：1-日报表，2-周报表，3-月报表，4-年报表
    byStatType: BYTE;  //数据类型统计：Bit0-段，Bit1-性别，Bit2-人数
    byEnableProgramStatistics: BYTE;  //是否按节目统计，0-否，1-是
    byRes1: BYTE;  
    dwPlayScheduleNo: DWORD;  //按节目统计时关联的日程号
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_FACECAPTURE_STATISTICS_COND = ^NET_DVR_FACECAPTURE_STATISTICS_COND;

type
  NET_DVR_FILECOND_MEDICAL = record 
    lChannel: LONG;  //通道号
    dwFileType: DWORD;  //录象文件类型
    //不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    //带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    dwIsLocked: DWORD;  //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    dwUseCardNo: DWORD;  //是否使用卡号
    sCardNumber: array[0..32-1] of BYTE;  //卡号
    struStartTime: NET_DVR_TIME_SEARCH_COND;  //开始时间
    struStopTime: NET_DVR_TIME_SEARCH_COND;  //结束时间
    szPatientID: array[0..64-1] of AnsiChar;  
    dwBigFileType: DWORD;  // 0为普通片段搜索，1为大文件搜索
    byRes: array[0..252-1] of BYTE;  
  end;
  LPNET_DVR_FILECOND_MEDICAL = ^NET_DVR_FILECOND_MEDICAL;

type
  NET_DVR_FIND_PICTURE_MEDICAL_PARAM = record 
    dwSize: DWORD;  // 结构体大小
    lChannel: LONG;  // 通道号
    { 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
    3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
    9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
    0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
    0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
    0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
    0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
    0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
    0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警, 0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,0xff- 全部类型}
    byFileType: BYTE;  
    byNeedCard: BYTE;  // 是否需要卡号
    {
    0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
    8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
    15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
    22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
    29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
    }
    byProvince: BYTE;  //省份索引值
    byRes1: BYTE;  //查找结果中是否要求返回人脸坐标信息，0-不返回，1-返回
    struStartTime: NET_DVR_TIME;  //查找图片的开始时间
    struStopTime: NET_DVR_TIME;  // 查找图片的结束时间
    szPatientID: array[0..64-1] of AnsiChar;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_FIND_PICTURE_MEDICAL_PARAM = ^NET_DVR_FIND_PICTURE_MEDICAL_PARAM;

type
  NET_DVR_SEXGROUP_PARAM = record 
    dwMale: DWORD;  //男（人数）
    dwFemale: DWORD;  //女（人数）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SEXGROUP_PARAM = ^NET_DVR_SEXGROUP_PARAM;

type
  NET_DVR_FACECAPTURE_STATISTICS_RESULT = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_EX;  //间隔开始时间
    struEndTime: NET_DVR_TIME_EX;  //间隔结束时间
    byStatType: BYTE;  //数据类型统计：Bit0-段有效，Bit1-性别有效，Bit2-人数有效
    byRes: array[0..7-1] of BYTE;  
    dwPeopleNum: DWORD;  //人数统计
    byRes2: array[0..80-1] of BYTE;  
    struSexGroupParam: NET_DVR_SEXGROUP_PARAM;  //性别人数统计
    struProgramInfo: NET_DVR_PROGRAM_INFO;  //节目信息
    byRes1: array[0..76-1] of BYTE;  
  end;
  LPNET_DVR_FACECAPTURE_STATISTICS_RESULT = ^NET_DVR_FACECAPTURE_STATISTICS_RESULT;

//获取交通数据条件结构
type
  NET_DVR_TRAFFIC_DATA_QUERY_COND = record 
    dwSize: DWORD;  
    {
    Bit0-通道有效
    Bit1-时间有效
    Bit2-车牌号有效
    Bit3-车牌类型有效
    Bit4-车牌颜色有效
    Bit5-车身颜色有效
    Bit6-车辆类型有效
    Bit7-车辆品牌有效
    Bit8-车道号有效
    Bit9-显示方向有效
    Bit10-最低速度有效
    Bit11-最高速度有效
    Bit12-数据类型有效
    Bit13-布防方式类型有效
    Bit14-违法取证有效
    Bit15-事件类型有效
    Bit16-取证类型有效
    }
    dwQueryCond: DWORD;  //查询条件 0表示无效，1表示有效
    dwChannel: DWORD;  //默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //(设备支持模糊查询, GB2312编码)
    {
    Bit0-未知（其他）
    Bit1-标准民用车与特种车
    Bit2-02式民用车牌
    Bit3-武警车
    Bit4-警车
    Bit5-民用车双行尾牌
    Bit6-使馆车牌
    Bit7-农用车
    Bit8-摩托车
    }
    dwPlateType: DWORD;  //车牌类型（支持按位表示，可以复选）
    {
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色
    }
    dwPlateColor: DWORD;  //车牌颜色（支持按位表示，可以复选）
    {
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色
    Bit13-深灰色
    }
    dwVehicleColor: DWORD;  //车身颜色（支持按位表示，可以复选）
    {
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    Bit9-SUV/MPV
    Bit10-中型客车
    }
    dwVehicleType: DWORD;  //车辆类型（支持按位表示，可以复选）
     {*
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带
    }
    dwIllegalType: DWORD;  
    {*
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-禁止名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞
    }
    dwEventType: DWORD;  
    {*
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    }
    dwForensiceType: DWORD;  
    wVehicleLogoRecog: WORD;  //车辆主品牌，参考"车辆主品牌.xlsx" （仅单选）
    byLaneNo: BYTE;  //车道号（0~255,0号车道 表示 车道号未知）
    byDirection: BYTE;  //显示方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南
    wMinSpeed: WORD;  //最低速度（0~999）单位km/h
    wMaxSpeed: WORD;  //最高速度（0~999）单位km/h
    byDataType: BYTE;  //数据类型 0-卡口数据，1-违法数据，2-交通事件，3-取证数据 （仅单选）
    byExecuteCtrl: BYTE;  //布防 0-允许名单，1-禁止名单，0xff-其他
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_TRAFFIC_DATA_QUERY_COND = ^NET_DVR_TRAFFIC_DATA_QUERY_COND;

//交通图片参数子结构
type
  NET_DVR_TRAFFIC_PICTURE_PARAM = record 
    struRelativeTime: NET_DVR_TIME_V30;  //抓拍相对时标
    struAbsTime: NET_DVR_TIME_V30;  //抓拍绝对时标
    szPicName: array[0..PICTURE_NAME_LEN{64}-1] of AnsiChar;  
    byPicType: BYTE;  //图片类型 0-车牌图，1-抓拍原图，2-合成图，3-特写图
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_TRAFFIC_PICTURE_PARAM = ^NET_DVR_TRAFFIC_PICTURE_PARAM;

//交通数据结构体
type
  NET_DVR_TRAFFIC_DATA_QUERY_RESULT = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //默认是1（[1~32]）
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  
    {
    Bit0-未知（其他）
    Bit1-标准民用车与特种车
    Bit2-02式民用车牌
    Bit3-武警车
    Bit4-警车
    Bit5-民用车双行尾牌
    Bit6-使馆车牌
    Bit7-农用车
    Bit8-摩托车
    }
    dwPlateType: DWORD;  //车牌类型
    {
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色
    }
    dwPlateColor: DWORD;  //车牌颜色
    {
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色
    Bit13-深灰色
    }
    dwVehicleColor: DWORD;  //车身颜色
    {
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    Bit9-SUV/MPV
    Bit10-中型客车
    Bit11-机动车
    Bit12-非机动车
    Bit13-小型轿车
    Bit14-微型轿车
    Bit15-皮卡车
    Bit16-集装箱卡车
    Bit17-微卡，栏板卡
    Bit18-渣土车
    Bit19-吊车，工程车
    Bit20-油罐车
    Bit21-混凝土搅拌车
    Bit22-平板拖车
    Bit23-两厢轿车
    Bit24-三厢轿车
    Bit25-轿跑
    Bit26-小型客车
    }
    dwVehicleType: DWORD;  //车辆类型
    {*
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带
    }
    dwIllegalType: DWORD;  
    {*
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-禁止名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞
    }
    dwEventType: DWORD;  
    {*
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    }
    dwForensiceType: DWORD;  
    wVehicleLogoRecog: WORD;  //车辆主品牌，参考"车辆主品牌.xlsx"
    byLaneNo: BYTE;  //车道号（0~255,0号车道 表示 车道号未知）
    byDirection: BYTE;  //显示方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南
    wSpeed: WORD;  //速度（0~999）单位km/h
    byDataType: BYTE;  //数据类型: 0-卡口 1-违法 2-事件 3-取证
    byRes: array[0..253-1] of BYTE;  
    struTrafficPic: array[0..MAX_TRAFFIC_PICTURE_NUM{8}-1] of NET_DVR_TRAFFIC_PICTURE_PARAM;  
  end;
  LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT = ^NET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//长连接获取交通流量条件结构
type
  NET_DVR_TRAFFIC_FLOW_QUERY_COND = record 
    dwSize: DWORD;  
    {*
    Bit0-通道有效
    Bit1-时间有效
    Bit2-车道号有效
    }
    dwQueryCond: DWORD;  //查询条件 0-无条件
    dwChannel: DWORD;  //默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    dwResChan: array[0..10-1] of DWORD;  //预留可扩展的通道号
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    byLaneNo: BYTE;  //车道号（0~255,0号车道 表示 车道号未知）
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_TRAFFIC_FLOW_QUERY_COND = ^NET_DVR_TRAFFIC_FLOW_QUERY_COND;

//长连接获取交通流量结构
type
  NET_DVR_TRAFFIC_FLOW_QUERY_RESULT = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    dwChannel: DWORD;  //默认是1（[1~32]）
    dwFlow: DWORD;  //车流量
    byLaneNo: BYTE;  //车道号（0~255,0号车道 表示 车道号未知）
    byRes: array[0..511-1] of BYTE;  
  end;
  LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT = ^NET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

//图片参数
type
  NET_DVR_PIC_INFO = record 
    byPicType: BYTE;  //图片类型，0-jpg
    byRes1: array[0..3-1] of BYTE;  //保留
    dwPicWidth: DWORD;  //图片宽度
    dwPicHeight: DWORD;  //图片高度
    dwPicDataLen: DWORD;  //图片数据大小
    byPicDataBuff: PAnsiChar;  //图片数据缓冲区
    byRes2: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_PIC_INFO = ^NET_DVR_PIC_INFO;

type
  NET_DVR_VCA_RULE_COLOR_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //规则是否启用， 0-不启用，1-启用
    byRuleID: BYTE;  //关联的规则ID
    byColorBlockNo: BYTE;  //颜色块序号，从1开始
    byRes1: BYTE;  //保留
    struPicInfo: NET_DVR_PIC_INFO;  //图片颜色信息
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VCA_RULE_COLOR_CFG = ^NET_DVR_VCA_RULE_COLOR_CFG;

type
  NET_DVR_VCA_RULE_COLOR_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byRuleID: BYTE;  //关联的规则ID  0表示不关联
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_VCA_RULE_COLOR_COND = ^NET_DVR_VCA_RULE_COLOR_COND;

//LLDP参数
type
  NET_DVR_LLDP_PORT_CFG = record 
    byCardNo: BYTE;  //卡号
    byPortNo: BYTE;  //端口号
    byEnabledTx: BYTE;  //使能发送lldp包，0-不使能，1-使能
    byEnabledRx: BYTE;  //使能接收lldp包，0-不使能，1-使能
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_LLDP_PORT_CFG = ^NET_DVR_LLDP_PORT_CFG;

type
  NET_DVR_LLDP_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //使能LLDP功能，0-不使能，1-使能
    byRes1: array[0..3-1] of BYTE;  
    dwHoldTime: DWORD;  //保持时间，单位：秒
    dwReiniTime: DWORD;  //重新初始化时间，单位：秒
    dwPacketTime: DWORD;  //打包时间，单位：秒
    struLLDPPortCfg: array[0..MAX_PORT_NUM-1] of NET_DVR_LLDP_PORT_CFG;  //各端口LLDP参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LLDP_CFG = ^NET_DVR_LLDP_CFG;

//光纤收发器基本信息
type
  NET_DVR_CARD_PORT_INFO = record 
    dwPortNo: DWORD;  //端口号，0-无效
    byPortName: array[0..NAME_LEN-1] of BYTE;  //端口名
    byWorkMode: BYTE;  //工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    byBandWidth: BYTE;  //带宽，1-100M，2-1G，3-10G
    byPortType: BYTE;  //端口类型，1-电口，2-光口，3-光电复用口
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_CARD_PORT_INFO = ^NET_DVR_CARD_PORT_INFO;

type
  NET_DVR_NETMGR_CARD_INFO = record 
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //型号名称
    bySerialNo: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    bySoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本
    struIPAddr: NET_DVR_IPADDR;  //IP地址
    dwSlotNo: DWORD;  //网管卡槽位号（主槽位）
    byStructureType: BYTE;  //结构类型，1-2U，2-4U
    byRes1: array[0..3-1] of BYTE;  
    struNetPortInfo: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_INFO;  //各网口信息
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_NETMGR_CARD_INFO = ^NET_DVR_NETMGR_CARD_INFO;

type
  NET_DVR_FUNC_CARD_INFO = record 
    dwCardNo: DWORD;  //卡号，从1开始
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //型号名称
    bySerialNo: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    bySoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本
    dwMainSlot: DWORD;  //主槽位，从1开始
    byStructureType: BYTE;  //结构类型，1-2U，2-4U
    byRes1: array[0..3-1] of BYTE;  
    struFuncPortInfo: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_INFO;  //各端口参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FUNC_CARD_INFO = ^NET_DVR_FUNC_CARD_INFO;

type
  NET_DVR_FIBER_CONVERT_BASIC = record 
    dwSize: DWORD;  
    byPowerType: BYTE;  //电源类型，1-单电源，2-双电源
    byRes1: array[0..3-1] of BYTE;  
    dwSlotNum: DWORD;  //网管卡槽位号（主槽位）
    struNetCardInfo: NET_DVR_NETMGR_CARD_INFO;  //网管卡信息
    struFuncCardInfo: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_FUNC_CARD_INFO;  //功能卡信息
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_BASIC = ^NET_DVR_FIBER_CONVERT_BASIC;

//光纤收发器工作状态信息
type
  NET_DVR_CARD_PORT_STATE = record 
    byValid: BYTE;  //是否有效，0-无效，1-有效
    byPortType: BYTE;  //端口类型，1-电口，2-光口，3-光电复用口
    byLinkState: BYTE;  //连接状态，0-未连接，1-已连接
    byRes1: BYTE;  
    dwSendBytes: DWORD;  //发送的字节数
    dwRecvBytes: DWORD;  //接收数据包数
    dwRecvLostPackets: DWORD;  //接收丢包数
    dwRecvCrcErrPackets: DWORD;  //接收CRC校验错误包数
    dwRecvFragmentPackets: DWORD;  //接收碎片、冲突及过短字节包数（包长度均小于64字节）
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_CARD_PORT_STATE = ^NET_DVR_CARD_PORT_STATE;

type
  NET_DVR_NET_CARD_STATE = record 
    struNetPortState: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_STATE;  //各端口状态
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_NET_CARD_STATE = ^NET_DVR_NET_CARD_STATE;

type
  NET_DVR_FUNC_CARD_STATE = record 
    byEnabled: BYTE;  //此结构是否有效，0-无效，1-有效
    byRes1: array[0..3-1] of BYTE;  
    dwCardNo: DWORD;  //卡号
    struFuncCardPortState: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_STATE;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FUNC_CARD_STATE = ^NET_DVR_FUNC_CARD_STATE;

type
  NET_DVR_FIBER_CONVERT_STATE = record 
    dwSize: DWORD;  
    struNetCardState: NET_DVR_NET_CARD_STATE;  //网管卡状态
    struFuncCardState: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_FUNC_CARD_STATE;  //功能卡状态
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_STATE = ^NET_DVR_FIBER_CONVERT_STATE;

//远端网管收发器1.0 基本信息
type
  NET_DVR_NETMGR_CARD_INFO_V50 = record 
    byMainSlotNo: BYTE;  //网管卡槽位号（主槽位）
    byRes1: array[0..3-1] of BYTE;  
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //型号名称
    bySerialNo: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    bySoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本
    byHardwareVersion: array[0..VERSION_LEN-1] of BYTE;  //硬件版本
    struIPAddr: NET_DVR_IPADDR;  //IP地址
    struMask: NET_DVR_IPADDR;  //子网掩码
    struGateway: NET_DVR_IPADDR;  //默认网关
    byMacAddr: array[0..6-1] of BYTE;  //MAC地址
    bySlotNums: BYTE;  //槽位数
    byStructureType: BYTE;  //结构类型，1-2U，2-4U
    struPortInfo: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_INFO;  //各端口信息
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_NETMGR_CARD_INFO_V50 = ^NET_DVR_NETMGR_CARD_INFO_V50;

type
  NET_DVR_FUNC_CARD_INFO_V50 = record 
    byCardNo: BYTE;  //接收卡卡号
    byMainSlotNo: BYTE;  //接收卡槽位号（主槽位）
    byRes1: array[0..2-1] of BYTE;  
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //型号名称
    bySerialNo: array[0..SERIALNO_LEN-1] of BYTE;  //序列号
    bySoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本
    byIsVerMismatch: BYTE;  //软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
    byRes2: array[0..3-1] of BYTE;  
    byNewestSoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //最新的软件版本，版本不匹配时有效
    byHardwareVersion: array[0..VERSION_LEN-1] of BYTE;  //硬件版本
    bySlotNums: BYTE;  //槽位数
    byStructureType: BYTE;  //结构类型，1-2U，2-4U
    byRes3: array[0..2-1] of BYTE;  
    struPortInfo: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_INFO;  //各端口信息
    byRes4: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FUNC_CARD_INFO_V50 = ^NET_DVR_FUNC_CARD_INFO_V50;

type
  NET_DVR_REMOTE_SEND_CARD_INFO_V50 = record 
    byCardNo: BYTE;  //卡号，发送机连接的接收卡的卡号
    byMainSlotNo: BYTE;  //槽位号，发送机连接的接收卡的主槽位号
    byRes1: array[0..2-1] of BYTE;  
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //型号名称
    bySoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //软件版本
    byIsVerMismatch: BYTE;  //软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
    byRes2: array[0..3-1] of BYTE;  
    byNewestSoftwareVersion: array[0..VERSION_LEN-1] of BYTE;  //最新的软件版本，版本不匹配时有效
    byHardwareVersion: array[0..VERSION_LEN-1] of BYTE;  //硬件版本
    struPortInfo: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_INFO;  //各端口信息
    byRes3: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_REMOTE_SEND_CARD_INFO_V50 = ^NET_DVR_REMOTE_SEND_CARD_INFO_V50;

type
  NET_DVR_FIBER_CONVERT_BASIC_V50 = record 
    dwSize: DWORD;  
    byPowerType: BYTE;  //电源类型，1-单电源，2-双电源
    byRes1: array[0..3-1] of BYTE;  
    dwSlotNum: DWORD;  //机箱总槽位数
    struNetCardInfo: NET_DVR_NETMGR_CARD_INFO_V50;  //网管卡信息
    struFuncCardInfo: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_FUNC_CARD_INFO_V50;  //接收卡信息
    struRemoteSendCardInfo: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_REMOTE_SEND_CARD_INFO_V50;  //发送机信息
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_BASIC_V50 = ^NET_DVR_FIBER_CONVERT_BASIC_V50;

//远端网管收发器1.0 状态信息
type
  NET_DVR_CARD_PORT_STATE_V50 = record 
    byPortNo: BYTE;  //端口号，从1开始
    byPortType: BYTE;  //端口类型，1-电口，2-光口，3-光电复用口
    byLinkState: BYTE;  //连接状态，0-未连接，1-已连接
    byPortSpeed: BYTE;  //带宽，0-无效，1-自动，2-100M，3-1000M，4-10G
    byPortDuplexMode: BYTE;  //端口双工模式，0-无效，1-自动，2-全双工，3-半双工
    byRes1: array[0..3-1] of BYTE;  
    byPortName: array[0..NAME_LEN-1] of BYTE;  //端口名称
    dwSendBytes: DWORD;  //发送的字节数
    dwSendByteSpeed: DWORD;  //发送字节速率，单位：bps
    dwSendPackets: DWORD;  //发送的字节数
    dwSendPacketSpeed: DWORD;  //发包速率，单位：个/秒
    dwRecvBytes: DWORD;  //接收的字节数
    dwRecvByteSpeed: DWORD;  //接收字节速率，单位：bps
    dwRecvPackets: DWORD;  //接收的包数
    dwRecvPacketSpeed: DWORD;  //收包速率，单位：个/秒
    dwRecvLostPackets: DWORD;  //接收丢包数
    dwRecvCrcErrPackets: DWORD;  //接收CRC校验错误包数
    dwRecvFragmentPackets: DWORD;  //接收碎片、冲突及过短字节包数（包长度均小于64字节）
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_CARD_PORT_STATE_V50 = ^NET_DVR_CARD_PORT_STATE_V50;

type
  NET_DVR_NET_CARD_STATE_V50 = record 
    byMainSlotNo: BYTE;  //网管卡主槽位号
    byRes1: array[0..3-1] of BYTE;  
    struPortState: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_STATE_V50;  //网管卡端口状态
    byRes2: array[0..344-1] of BYTE;  
  end;
  LPNET_DVR_NET_CARD_STATE_V50 = ^NET_DVR_NET_CARD_STATE_V50;

type
  NET_DVR_FUNC_CARD_STATE_V50 = record 
    byCardNo: BYTE;  //接收卡卡号
    byMainSlotNo: BYTE;  //接收卡主槽位号
    byRes1: array[0..2-1] of BYTE;  
    struPortState: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_STATE_V50;  //接收卡端口状态
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FUNC_CARD_STATE_V50 = ^NET_DVR_FUNC_CARD_STATE_V50;

type
  NET_DVR_REMOTE_SEND_CARD_STATE_V50 = record 
    byCardNo: BYTE;  //发送机连接的接收卡的卡号
    byMainSlotNo: BYTE;  //发送机连接的接收卡的主槽位号
    byRes1: array[0..2-1] of BYTE;  
    struPortState: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_CARD_PORT_STATE_V50;  //接收卡端口状态
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_REMOTE_SEND_CARD_STATE_V50 = ^NET_DVR_REMOTE_SEND_CARD_STATE_V50;

type
  NET_DVR_FIBER_CONVERT_STATE_V50 = record 
    dwSize: DWORD;  
    struNetCardState: NET_DVR_NET_CARD_STATE_V50;  //网管卡状态
    struFuncCardState: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_FUNC_CARD_STATE_V50;  //接收卡状态
    struRemoteSendCardState: array[0..MAX_FUNC_CARD_NUM-1] of NET_DVR_REMOTE_SEND_CARD_STATE_V50;  //发送机状态
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_STATE_V50 = ^NET_DVR_FIBER_CONVERT_STATE_V50;

//光纤收发器拓扑信息
type
  NET_DVR_FC_PORT_TOPOLOGY = record 
    dwPortNo: DWORD;  //端口号，0-无效，非0为功能卡端口号
    byPortType: BYTE;  //端口类型，1-电口，2-光口，3-光电复用口
    byLocalWorkMode: BYTE;  //本地工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    byLocalBandWidth: BYTE;  //本地带宽，1-100M，2-1G，3-10G
    byRes1: array[0..1-1] of BYTE;  
    byPeerTypeName: array[0..NAME_LEN-1] of BYTE;  //对端设备类型名称
    byPeerMac: array[0..MACADDR_LEN-1] of BYTE;  //对端MAC地址
    dwPeerPortNo: DWORD;  //对端端口号
    byPeerWorkMode: BYTE;  //对端工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    byPeerBandWidth: BYTE;  //对端带宽，1-100M，2-1G，3-10G
    byRes2: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_FC_PORT_TOPOLOGY = ^NET_DVR_FC_PORT_TOPOLOGY;

type
  NET_DVR_FC_CARD_TOPOLOGY = record 
    byEnable: BYTE;  //此结构体是否有效，0-无效，非0-有效
    byRes1: array[0..3-1] of BYTE;  
    dwCardNo: DWORD;  //卡号，0-网管卡，大于0-功能卡
    dwSlotNum: DWORD;  //卡占用的槽位数
    byTypeName: array[0..NAME_LEN-1] of BYTE;  //卡类型名称
    byLocalMac: array[0..MACADDR_LEN-1] of BYTE;  //本地MAC地址
    struFCPortTopology: array[0..MAX_SINGLE_CARD_PORT_NO-1] of NET_DVR_FC_PORT_TOPOLOGY;  //各端口拓扑信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FC_CARD_TOPOLOGY = ^NET_DVR_FC_CARD_TOPOLOGY;

type
  NET_DVR_FIBER_CONVERT_TOPOLOGY = record 
    dwSize: DWORD;  
    struFCCardTopology: array[0..MAX_FC_CARD_NUM-1] of NET_DVR_FC_CARD_TOPOLOGY;  //各卡拓扑信息
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_TOPOLOGY = ^NET_DVR_FIBER_CONVERT_TOPOLOGY;

//光纤收发器端口注释信息
type
  NET_DVR_FC_COND = record 
    dwSize: DWORD;  
    dwSlotNo: DWORD;  //槽位号
    dwPortNo: DWORD;  //端口号
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FC_COND = ^NET_DVR_FC_COND;

type
  NET_DVR_FC_PORT_REMARKS = record 
    dwSize: DWORD;  
    byLocalRemarks: array[0..MAX_REMARKS_LEN-1] of BYTE;  //本地端口注释信息
    byPeerRemarks: array[0..MAX_REMARKS_LEN-1] of BYTE;  //对端端口注释信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_FC_PORT_REMARKS = ^NET_DVR_FC_PORT_REMARKS;

type
  EN_FIBER_CONVERT_ALARM =  
  (  
    FC_OPTICAL_PORT_LOST = 1,  
    FC_ELECTRICAL_PORT_LOST,  
    FC_FUNC_CARD_LOST,  
    FC_CARD_DISCONNECTED,  //卡断线告警
    FC_MAX_TEMP_LIMITED,  //温度超上限告警
    FC_MIN_TEMP_LIMITED,  //温度超下限告警
    FC_MAX_VOLTAGE_LIMITED,  //电压超上限告警
    FC_MIN_VOLTAGE_LIMITED  //电压超下限告警
  );

type
  EN_FIBER_CONVERT_NOTIFICATION =  
  (  
    FC_OPTICAL_PORT_CONNECTED = 1,  
    FC_ELECTRICAL_PORT_CONNECTED,  
    FC_FUNC_CARD_INSERT,  
    FC_CARD_CONNECTED,  //卡上线通知
    FC_TEMP_RECOVERY,  //温度恢复通知
    FC_VOLTAGE_RECOVERY  //电压恢复通知
  );

type
  NET_DVR_FIBER_CONVERT_ALARM = record 
    dwSize: DWORD;  
    dwEventType: DWORD;  //事件类型，1-告警，2-通知
    dwEvent: DWORD;  //具体事件，告警时参考枚举FIBER_CONVERT_ALARM，通知时参考枚举FIBER_CONVERT_NOTIFICATION
    bySlotNum: BYTE;  //槽位号，当卡类型为发送机时，槽位号为该发送机连接的接收卡的槽位号，机箱告警及通知时无效
    byCardType: BYTE;  //卡类型，0-无效，1-网管卡，2-接收卡，3-发送机，4-机箱
    byPortNo: BYTE;  //端口号，从1开始，机箱告警及通知时无效
    byCurTemperature: BYTE;  //触发事件的温度，温度告警及通知时有效，单位：摄氏度
    wCurVoltage: WORD;  //触发事件的电压（实际电压*10），电压告警及通知时有效，单位：伏特
    byRes1: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_FIBER_CONVERT_ALARM = ^NET_DVR_FIBER_CONVERT_ALARM;

//交换机告警事件上传
type
  EN_SWITCH_CONVERT_ALARM =  
  (  
    SC_OPTICAL_PORT_LOST = 1,  
    SC_NETWORK_PORT_LOST,  
    SC_WIRELESS_SPEED_UP_EXCEPTION,  //无线上行速率异常
    SC_WIRELESS_SHUTDOWN,  //无线连接断开事件
    SC_DEVICE_POE_MAX,  //POE-MAX告警
    SC_PORT_POE_POWER_OFF  //端口POE掉电告警
  );

type
  EN_SWITCH_CONVERT_NOTIFICATION =  
  (  
    SC_OPTICAL_PORT_CONNECTED = 1,  
    SC_NETWORK_PORT_CONNECTED,  
    SC_DEVICE_POE_MAX_RECOVERY,  //POE-MAX告警恢复
    SC_PORT_POE_POWER_ON,  //端口POE上电通知
    SC_WIRELESS_CONNECTED  //无线连接事件
  );

type
  NET_DVR_SWITCH_CONVERT_ALARM = record 
    dwSize: DWORD;  
    byPortNo: BYTE;  //接口索引，从1开始，表示索引低8位
    byPortNoEx: BYTE;  //接口索引，索引大于255时，该字段表示索引的高8位
    byRes1: array[0..2-1] of BYTE;  
    dwEventType: DWORD;  //事件类型，1-告警，2-通知
    dwEvent: DWORD;  //具体事件，告警时参考枚举EN_SWITCH_CONVERT_ALARM，通知时参考枚举EN_SWITCH_CONVERT_NOTIFICATION
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SWITCH_CONVERT_ALARM = ^NET_DVR_SWITCH_CONVERT_ALARM;

type
  NET_DVR_SWITCH_LAMP_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //规则是否启用， 0-不启用，1-启用
    byTriggerMode: BYTE;  // 1-持续触发，2-单次触发
    byUploadPic: BYTE;  //0-不上传图片，1-上传图片
    byRes1: BYTE;  //保留
    dwTimeInterval: DWORD;  //持续触发报警时间间隔，范围[0,3600]，单位：秒
    struHandleType: NET_DVR_HANDLEEXCEPTION_V30;  //处理方式
    byRelRecordChan: array[0..MAX_IVMS_IP_CHANNEL-1] of BYTE;  //报警触发的录象通道：1表示触发该通道；0表示不触发
    struAlarmTime: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;  //检测时间
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SWITCH_LAMP_CFG = ^NET_DVR_SWITCH_LAMP_CFG;

type
  NET_DVR_SWITCH_LAMP_ALARM = record 
    dwSize: DWORD;  //结构体大小
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    struTime: NET_DVR_TIME_EX;  //报警时间
    byLampStatus: BYTE;  //开关灯状态，0-已关闭  1-已打开
    byRes1: array[0..3-1] of BYTE;  //保留
    dwPicDataLen: DWORD;  //图片数据长度，非0表示有图片上传
    pPicData: PAnsiChar;  //图片数据
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SWITCH_LAMP_ALARM = ^NET_DVR_SWITCH_LAMP_ALARM;

//防护舱级联配置
type
  NET_DVR_RS485_CASCADE_CFG = record 
    dwSize: DWORD;  
    byDevAddr: BYTE;  //设备地址，0-主机，1-15为从机
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_RS485_CASCADE_CFG = ^NET_DVR_RS485_CASCADE_CFG;

//私有关键信息上传配置
type
  NET_DVR_PRIVATE_PROTOCOL_CFG = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  //消息上传的IP地址
    wPort: WORD;  //消息上传的端口号
    byEnable: BYTE;  //使能,  0-保留，1-不启用，2-启用
    byRes: BYTE;  
    dwInterval: DWORD;  //消息上传间隔(0-无时间间隔限制，以设备为准; >=0,以秒为单位的时间间隔)
    byServerType: BYTE;  //服务类型 0-无，1-公安
    byEcryptedSMSEnable: BYTE;  //0-不加密，1-加密
    byAlgorithm: BYTE;  //加密算法，0-无，1-RSA
    byAcauisitionMode: BYTE;  //采集模式，0-基本信息，1-虚拟身份信息，2-基本信息+虚拟身份信息
    dwDistanceLimit: DWORD;  //距离限制，单位：m
    byPKModeEnable: BYTE;  //PK模式使能,  0-保留，1-不启用，2-启用
    byMACAddrReductionEnable: BYTE;  //MAC地址还原使能,  0-保留，1-不启用，2-启用
    byRes1: array[0..214-1] of BYTE;  
    szIndexCode: array[0..MAX_INDEX_CODE_LEN-1] of AnsiChar;  
    dwSecretKeyLen: DWORD;  //秘钥长度
    szSecretKey: array[0..MAX_SECRETKEY_LEN{512}-1] of AnsiChar;  //秘钥
  end;
  LPNET_DVR_PRIVATE_PROTOCOL_CFG = ^NET_DVR_PRIVATE_PROTOCOL_CFG;

//调试命令
type
  NET_DVR_DEBUG_CMD = record 
    dwSize: DWORD;  
    szDebugCMD: array[0..MAX_DEBUGCMD_LEN{1024}-1] of AnsiChar;  
    byRes: array[0..400-1] of BYTE;  
  end;
  LPNET_DVR_DEBUG_CMD = ^NET_DVR_DEBUG_CMD;

//调试信息
type
  NET_DVR_DEBUG_INFO = record 
    dwSize: DWORD;  
    szDebugInfo: array[0..MAX_DEBUGINFO_LEN{1400}-1] of AnsiChar;  
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DEBUG_INFO = ^NET_DVR_DEBUG_INFO;



const
  MAX_SSID_LEN = 32;    //SSID号长度
  MAX_WS_PASSWD_LEN = 64;    //密码长度
type
  NET_DVR_WIRELESSSERVER = record 
    dwSize: DWORD;  //结构体大小
    byWLanShare: BYTE;  //WLan热点使能 0-关闭，1-使能
    byBroadcastSSID: BYTE;  //SSID广播使能 0-关闭，1-使能
    bySecurityMode: BYTE;  //安全模式 0- not-encrypted，1-WPA，2-WPA2(暂时只支持2)
    byAlgorithmType: BYTE;  //加密模式 1-TKIP，2-AES
    szSSID: array[0..MAX_SSID_LEN{32}-1] of AnsiChar;  //SSID号信息
    szPassWord: array[0..MAX_WS_PASSWD_LEN{64}-1] of AnsiChar;  
    byDefaultPassword: BYTE;  //是否是默认密码 0-否，1-是
    byWifiApModeType: BYTE;  //启用WlanAP热点模式，0-关闭，1-开启，2-自动
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSSERVER = ^NET_DVR_WIRELESSSERVER;

type
  NET_DVR_CONNECTDEV_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CONNECTDEV_COND = ^NET_DVR_CONNECTDEV_COND;

type
  NET_DVR_CONNECTDEV_CFG = record 
    dwSize: DWORD;  
    byID: BYTE;  //序列号
    byRes: array[0..1-1] of BYTE;  
    byMACAddr: array[0..MACADDR_LEN{6}-1] of BYTE;  // 物理地址
    struDVRIP: NET_DVR_IPADDR;  //设备IP
    struConnectTime: NET_DVR_TIME;  //接入时间
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CONNECTDEV_CFG = ^NET_DVR_CONNECTDEV_CFG;

type
  NET_DVR_GIS_SERVER_INFO = record 
    byUserName: array[0..NAME_LEN-1] of BYTE;  
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  
    struServerIP: NET_DVR_IPADDR;  //GIS服务器IP地址
    wPort: WORD;  //GIS服务器端口
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_GIS_SERVER_INFO = ^NET_DVR_GIS_SERVER_INFO;

type
  NET_DVR_BASEMAP_CONTROL_CFG_V40 = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否显示，1-显示，0-隐藏
    byBaseMapType: BYTE;  //底图类型，1-图片底图，2-超高清输入底图，3-GIS底图
    byRes1: array[0..2-1] of BYTE;  
    dwBaseMapNo: DWORD;  //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    struGisServer: NET_DVR_GIS_SERVER_INFO;  //GIS服务器信息,当底图类型为GIS底图时有效
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_BASEMAP_CONTROL_CFG_V40 = ^NET_DVR_BASEMAP_CONTROL_CFG_V40;

type
  NET_DVR_VIDEO_IMG_DB_CFG = record 
    dwSize: DWORD;  //NET_DVR_VIDEO_IMG_DB_CFG结构体大小
    i64Capacity: INT64;  //视图库总容量，低位，单位：MB
    i64UsedSpace: INT64;  //只读，已用空间，低位，单位：MB
    i64AvailableSpace: INT64;  //只读，可用空间，低位，单位：MB
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_IMG_DB_CFG = ^NET_DVR_VIDEO_IMG_DB_CFG;

type
  NET_DVR_FILE_QUERY_INFO = record 
    dwSize: DWORD;  //NET_DVR_FILE_QUERY_INFO结构体大小
    i64FileLen: INT64;  //文件大小
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_FILE_QUERY_INFO = ^NET_DVR_FILE_QUERY_INFO;

type
  NET_DVR_FILE_INFO_IN = record 
    szFileID: array[0..MAX_FILE_ID_LEN-1] of AnsiChar;  //上传之后，设备分配的文件ID
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_FILE_INFO_IN = ^NET_DVR_FILE_INFO_IN;

type
  NET_DOWNLOAD_CB_INFO = record 
    dwType: DWORD;  //类型, 0-数据信息,1-单个图片信息(云存储批量下载),2-图片总体信息(云存储批量下载)
    pData: PBYTE;  //数据指针
    dwDataLen: DWORD;  //数据长度
    pFileInfo: PVOID;  //文件信息结构体(云存储批量下载时有效)
    dwFileInfoLen: DWORD;  //文件信息结构体长度(云存储批量下载时有效)
    byRes: array[0..120-1] of BYTE;  //保留
  end;
  LPNET_DOWNLOAD_CB_INFO = ^NET_DOWNLOAD_CB_INFO;

type
  DOWNLOAD_DATA_CB = function(lHandle: LONG; pCBInfo: LPNET_DOWNLOAD_CB_INFO; pUserData: PVOID): BOOL; stdcall;

type
  NET_DVR_DOWNLOAD_CB_PARAM = record 
    fnDownloadDataCB: DOWNLOAD_DATA_CB;  //下载数据回调函数
    pUserData: PVOID;  //用户参数, 在fnPreviewDataCB回调出来
    i64Offset: INT64;  //下载文件的偏移量，用于断点续传
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_CB_PARAM = ^NET_DVR_DOWNLOAD_CB_PARAM;

type
  NET_DVR_UPLOAD_DB_IN = record 
    i64FileLen: INT64;  //上传新文件，需要给出文件长度，文件续传可以不给
    byContinueUpload: BYTE;  //0-新文件上传，1-老文件续传，文件名必须给出
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_DB_IN = ^NET_DVR_UPLOAD_DB_IN;


type
  NET_DVR_UPLOAD_DB_OUT = record 
    szFileID: array[0..MAX_FILE_ID_LEN-1] of AnsiChar;  //上传之后，设备分配的文件ID
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_DB_OUT = ^NET_DVR_UPLOAD_DB_OUT;

type
  NET_DVR_SEND_PARAM_IN = record 
    pSendData: PBYTE;  //发送的缓冲区,PicURL == 1 的时候，内存中存储的是 URL 字符串,byUploadModeling == 1 的时候，内存中存储的是 建模base64加密数据
    dwSendDataLen: DWORD;  //发送数据长度,PicURL == 1 的时候，表示的 URL 字符串的长度,byUploadModeling == 1 的时候，表示为建模数据base64后的加密长度
    struTime: NET_DVR_TIME_V30;  //图片时间
    byPicType: BYTE;  //图片格式,1-jpg,2-bmp,3-png,4-SWF,5-GIF
    byPicURL: BYTE;  //图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
    {是否上传建模数据；
    0- 二进制图片数据方式(pSendData指向二进制图片数据, dwPicDataLen为图片二进制数据长度)，
    1- 直接上传建模数据(pSendData指向建模base64加密数据, dwPicDataLen为建模数据base64后的加密长度)。
    注：建模数据采用base64加密方式,选择为建模数据上传后，byPicURL 无需。
    当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportUploadModeling能力节点时，支持上传建模数据. }
    byUploadModeling: BYTE;  
    byRes1: BYTE;  
    dwPicMangeNo: DWORD;  //图片管理号
    sPicName: array[0..NAME_LEN-1] of BYTE;  //图片名称
    dwPicDisplayTime: DWORD;  //图片播放时长，单位秒
    pSendAppendData: PBYTE;  //发送图片的附加信息缓冲区，对应FaceAppendData 的XML描述；
    dwSendAppendDataLen: DWORD;  //发送图片的附加信息数据长度  FaceAppendData  XML的长度；
    byRes: array[0..192-1] of BYTE;  
  end;
  LPNET_DVR_SEND_PARAM_IN = ^NET_DVR_SEND_PARAM_IN;


type
  NET_DVR_DOWNLOAD_QOS = record 
    dwMaxSpeed: DWORD;  //流控最大速度，单位kbps
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_QOS = ^NET_DVR_DOWNLOAD_QOS;


const
  NET_SDK_MAX_FILE_NAME = 100;    //最大文件名称

type
  NET_DVR_UPLOAD_FILEVOLUME_PRARAM = record 
    dwSize: DWORD;  
    byFileType: BYTE;  //文件类型 0-录像，1-音频
    byFileVolnumeID: BYTE;  //文件卷ID（可以通过NET_DVR_GET_HDVOLUME_CFG 获取）
    byArchive: BYTE;  //0-不归档，1-归档
    byRes1: BYTE;  
    dwFileSize: DWORD;  //文件大小
    szFileName: array[0..NET_SDK_MAX_FILE_NAME{100}-1] of AnsiChar;  //文件名称
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_FILEVOLUME_PRARAM = ^NET_DVR_UPLOAD_FILEVOLUME_PRARAM;

type
  NET_DVR_DOWNLOAD_FILEVOLUME_PARAM = record 
    dwSize: DWORD;  
    sUrl: array[0..MAX_UPLOADFILE_URL_LEN{240}-1] of BYTE;  //url
    byRes: array[0..248-1] of BYTE;  
    fnDownloadDataCB: DOWNLOAD_DATA_CB;  //下载数据回调函数
    pUserData: PVOID;  //用户参数, 在fnPreviewDataCB回调出来
  end;
  LPNET_DVR_DOWNLOAD_FILEVOLUME_PARAM = ^NET_DVR_DOWNLOAD_FILEVOLUME_PARAM;


//电影模式参数
type
  NET_DVR_FILM_MODE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byScreenType: BYTE;  //画面类型，0-单画面，1-两画面，2-画中画
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_FILM_MODE_CFG = ^NET_DVR_FILM_MODE_CFG;

//导播策略配置
type
  NET_DVR_DIRECTED_STRATEGY_CFG = record 
    dwSize: DWORD;  //结构体大小
    byDirectedStrategyType: BYTE;  //导播策略类型，0-常态导播策略，1-精品导播策略,2-精品导播1替2,3-精品导播策略1替3
    byRes: array[0..255-1] of BYTE;  //保留
  end;
  LPNET_DVR_DIRECTED_STRATEGY_CFG = ^NET_DVR_DIRECTED_STRATEGY_CFG;

//边框子结构
type
  NET_DVR_FRAME = record 
    byFrameWide: BYTE;  //边框宽度合法取值范围为[0,14]，并且只能取偶数值
    byRed: BYTE;  //边框颜色为RGB 模式，R，G，B，分别对应位于如下
    byGreen: BYTE;  
    byBlue: BYTE;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_FRAME = ^NET_DVR_FRAME;

//配置画面边框
type
  NET_DVR_FRAME_CFG = record 
    dwSize: DWORD;  //结构体大小
    struTopFrame: NET_DVR_FRAME;  //上边框
    struBottomFrame: NET_DVR_FRAME;  //下边框
    struLeftFrame: NET_DVR_FRAME;  //左边框
    struRightFrame: NET_DVR_FRAME;  //右边框
    byFrameEnable: BYTE;  //叠加边框0-不叠加1-叠加边框
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_FRAME_CFG = ^NET_DVR_FRAME_CFG;

//配置画面边框条件
type
  NET_DVR_FRAME_COND = record 
    dwSize: DWORD;  
    dwPicNo: DWORD;  //画面编号
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_FRAME_COND = ^NET_DVR_FRAME_COND;

//音频优化参数
type
  NET_DVR_AUDIO_EFFECTIVE_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwCheckDelay: DWORD;  //检测时延，单位s，0表示不自动优化
    byThreshold: BYTE;  //阈值[0,100]
    byVolumePercent: BYTE;  //音量 [0,100]
    byPriority: BYTE;  //等级，[0，100]
    byRes: array[0..301-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_EFFECTIVE_CFG = ^NET_DVR_AUDIO_EFFECTIVE_CFG;

//录制视频参数
type
  NET_DVR_RECORD_VIDEO_CFG = record 
    dwSize: DWORD;  //结构体大小
    byExportType: BYTE;  //阈值0-MP4 1-AVI
    byRes: array[0..255-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_RECORD_VIDEO_CFG = ^NET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
type
  NET_DVR_RTMP_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byStreamType: BYTE;  //码流类型，1-主码流，2-子码流，3-码流三
    byRes: array[0..303-1] of BYTE;  
  end;
  LPNET_DVR_RTMP_COND = ^NET_DVR_RTMP_COND;

//RTMP Cfg
type
  NET_DVR_RTMP_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用RTMP，0-不启用，1-启用
    byRes1: array[0..3-1] of BYTE;  
    dwPacketLen: DWORD;  //RTMP包长
    szURL: array[0..RTMP_URL_LEN-1] of AnsiChar;  //RTMP URL
    byRes: array[0..256-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_RTMP_CFG = ^NET_DVR_RTMP_CFG;

//文件发布
type
  NET_DVR_RECORDING_PUBLISH_FILE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byFileID: array[0..MAX_ID_LEN_128{128}-1] of BYTE;  //发布文件ID
    struStartTime: NET_DVR_TIME_EX;  //课程开始时间
    struEndTime: NET_DVR_TIME_EX;  //课程结束时间
    byCmdType: BYTE;  //发布命令类型  1--开始发布 2--取消发布
    byFileType: BYTE;  //发布文件类型  0―保留 1―定时课程 2―手动课程
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_RECORDING_PUBLISH_FILE_CFG = ^NET_DVR_RECORDING_PUBLISH_FILE_CFG;

//文件发布进度条件
type
  NET_DVR_PUBLISH_PROGRESS_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byFileID: array[0..MAX_ID_LEN_128{128}-1] of BYTE;  //发布文件ID
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_PUBLISH_PROGRESS_COND = ^NET_DVR_PUBLISH_PROGRESS_COND;

//文件发布进度参数
type
  NET_DVR_PUBLISH_PROGRESS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byPublishPercent: BYTE;  //发布百分比 0-100
    byPublishStatus: BYTE;  //发布状态  0-发布成功 1--正在发布 2--等待发布 3-连不上FTP  4--没有找到此文件 5--发布失败（其他错误）
    byRes: array[0..302-1] of BYTE;  
  end;
  LPNET_DVR_PUBLISH_PROGRESS_CFG = ^NET_DVR_PUBLISH_PROGRESS_CFG;

//删除视图库中的文件
type
  NET_DVR_BACKGROUND_PIC_COND = record 
    dwSize: DWORD;  
    szFileID: array[0..MAX_ID_LEN_128{128}-1] of AnsiChar;  //上传之后，设备分配的文件ID, 指背景图片名
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_BACKGROUND_PIC_COND = ^NET_DVR_BACKGROUND_PIC_COND;

//查询背景图片文件
type
  NET_DVR_BACKGROUND_PIC_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwPicSize: DWORD;  //背景图片大小
    dwPicType: DWORD;  //图片类型，YUV:0 JPEG:1
    wPicWidth: WORD;  //图片宽
    wPicHeight: WORD;  //图片高
    byPicName: array[0..MAX_PIC_NAME_LEN{128}-1] of BYTE;  //图片名称
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_BACKGROUND_PIC_CFG = ^NET_DVR_BACKGROUND_PIC_CFG;

type
  NET_DVR_BACKGROUND_PIC_INFO = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用背景图片叠加，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    byPicID: array[0..MAX_ID_LEN_128{128}-1] of BYTE;  
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BACKGROUND_PIC_INFO = ^NET_DVR_BACKGROUND_PIC_INFO;


//上传背景图片文件
type
  NET_DVR_BACKGROUND_PIC_PRARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //导播通道
    dwPicSize: DWORD;  //背景图片大小
    wPicWidth: WORD;  //图片宽
    wPicHeight: WORD;  //图片高
    szPicName: array[0..MAX_PIC_NAME_LEN{128}-1] of AnsiChar;  //图片名称
    byPicType: BYTE;  //图片类型，YUV:0 JPEG:1
    byRes: array[0..303-1] of BYTE;  
  end;
  LPNET_DVR_BACKGROUND_PIC_PRARAM = ^NET_DVR_BACKGROUND_PIC_PRARAM;

//低功耗配置
type
  NET_DVR_LOWPOWER = record 
    dwSize: DWORD;  //结构体大小
    byMode: BYTE;  //补光灯模式 0-手动，1-定时
    byEnabled: BYTE;  //手动模式下的使能开关 0-关闭，1-开启
    byRes: array[0..6-1] of BYTE;  
    struSchedTime: NET_DVR_SCHEDULE_DAYTIME;  //定时时间段
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_LOWPOWER = ^NET_DVR_LOWPOWER;

type
  NET_DVR_POINT = record 
    dwX: DWORD;  //X轴坐标
    dwY: DWORD;  //Y坐标
  end;
  LPNET_DVR_POINT = ^NET_DVR_POINT;

//变倍联动配置
type
  NET_DVR_ZOOMLINKAGE = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //使能 0-关，1-开
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_ZOOMLINKAGE = ^NET_DVR_ZOOMLINKAGE;

type
  NET_DVR_ONLINEUPGRADE_STATUS = record 
    dwSize: DWORD;  
    byUpgradeStatus: BYTE;  //0-未开始升级,1-正在升级,2-升级成功,3-包语言不匹配,4-写falsh失败,5-包类型不匹配,6-包版本不匹配,7-网络不可达,8-升级服务器出错,
                            //9-读取升级包文件出错,10-没有找到升级文件,11-升级文件有错,12-设备内存不足,0xff-未知错误
    byProgress: BYTE;  //升级进度,0~100
    byRes: array[0..250-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUPGRADE_STATUS = ^NET_DVR_ONLINEUPGRADE_STATUS;

type
  NET_DVR_FIRMWARECODE_COND = record 
    dwSize: DWORD;  
    dwStartIndex: DWORD;  //起始索引号
    dwMaxNum: DWORD;  //单次最大个数，32
    byRes: array[0..52-1] of BYTE;  
  end;
  LPNET_DVR_FIRMWARECODE_COND = ^NET_DVR_FIRMWARECODE_COND;

type
  NET_DVR_FIRMWARECODE = record 
    wIndex: WORD;  
    wCodeLen: WORD;  //识别码长度，上层应用开发的时候做一个判断，如果本字段大于128，请报错，提示用户更新工具/客户端版本
    byCode: array[0..MAX_IDCODE_LEN-1] of BYTE;  //识别码
    byVersion: array[0..MAX_VERSIIN_LEN-1] of BYTE;  //版本
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_FIRMWARECODE = ^NET_DVR_FIRMWARECODE;

type
  NET_DVR_FIRMWARECODE_LIST = record 
    dwSize: DWORD;  
    dwValidCodeNum: DWORD;  //有效个数
    struCode: array[0..MAX_IDCODE_NUM-1] of NET_DVR_FIRMWARECODE;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FIRMWARECODE_LIST = ^NET_DVR_FIRMWARECODE_LIST;

type
  NET_DVR_ONLINEUPGRADE_SERVER = record 
    dwSize: DWORD;  
    byConnectStatus: BYTE;  //0-未连接,1-已连接
    byRes: array[0..1019-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUPGRADE_SERVER = ^NET_DVR_ONLINEUPGRADE_SERVER;

type
  NET_DVR_ONLINEUPGRADE_VERSION_COND = record 
    dwSize: DWORD;  
    byCheckFromSvr: BYTE;  //是否需要从服务器检测，0-不需要，仅返回设备周期性检查的结果;1-需要，设备会即时连接服务器检测是否有新版本
    byRes: array[0..59-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUPGRADE_VERSION_COND = ^NET_DVR_ONLINEUPGRADE_VERSION_COND;

type
  NET_DVR_ONLINEUPGRADE_VERSION_RET = record 
    dwSize: DWORD;  
    byNewVersionAvailable: BYTE;  //是否有新版本,0-否,1-是
    byNewVersion: array[0..MAX_VERSIIN_LEN-1] of BYTE;  //新版本的版本号
    byChangeLog: array[0..SDK_LEN_2048-1] of BYTE;  //新版本更新的内容
    byRes: array[0..971-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUPGRADE_VERSION_RET = ^NET_DVR_ONLINEUPGRADE_VERSION_RET;

type
  NET_DVR_RECOMMEN_VERSION_COND = record 
    dwSize: DWORD;  
    byFirmwareCode: array[0..MAX_IDCODE_LEN-1] of BYTE;  
    byFirmwareVersion: array[0..MAX_VERSIIN_LEN-1] of BYTE;  
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_RECOMMEN_VERSION_COND = ^NET_DVR_RECOMMEN_VERSION_COND;

type
  NET_DVR_RECOMMEN_VERSION_RET = record 
    dwSize: DWORD;  
    byRecommenUpgrade: BYTE;  //推荐升级,0-否,1-是
    byRes: array[0..123-1] of BYTE;  
  end;
  LPNET_DVR_RECOMMEN_VERSION_RET = ^NET_DVR_RECOMMEN_VERSION_RET;

//温湿度配置
type
  NET_DVR_THSCREEN = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //启用定时使能
    byTHOSDDisplay: BYTE;  //温湿度显示OSD显示是否启用,  0-否，1-是
    byRes: array[0..2-1] of BYTE;  // 保留字节
    struTHOSDPoint: NET_VCA_POINT;  //温湿度显示OSD显示左上角坐标
    byTimingMode: BYTE;  //校时模式 0-手动，1-自动
    byRes1: BYTE;  
    wInterval: WORD;  //校时定时模式下，间隔时间设置[1,10080]m
    byRes2: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_THSCREEN = ^NET_DVR_THSCREEN;

type
  NET_DVR_SENSOR_ADJUSTMENT = record 
    dwSize: DWORD;  //结构体大小
    byType: BYTE;  //调整模式：0-上下，1-左右，2-旋转，3-图像视场角，4-RGB调整, 5-亮度, 6-RGB_Ex调整
    bySensorNo: BYTE;  //Sensor 号[1,8]
    byRes: array[0..2-1] of BYTE;  
    iAdjustMentRange: INT;  //调整幅度 [-100,100] 旋转的时候[-30,30] 图像视场角[-10,10]
    byR: BYTE;  //RGB参数，R（红色），范围0-100
    byG: BYTE;  //RGB参数，G（绿色），范围0-100
    byB: BYTE;  //RGB参数，B（蓝色），范围0-100
    byRgbType: BYTE;  //RGB类型，0-保留，1-产线模式，2-手动模式
    byBrightness: BYTE;  //亮度，范围0-100,默认值50
    byRes1: array[0..3-1] of BYTE;  
    wRex: WORD;  //RGB参数(扩展)，R（红色），范围0-2048
    wGex: WORD;  //RGB参数(扩展)，G（绿色），范围0-2048
    wBex: WORD;  //RGB参数(扩展)，B（蓝色），范围0-2048
    byRes2: array[0..114-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_ADJUSTMENT = ^NET_DVR_SENSOR_ADJUSTMENT;

type
  NET_DVR_SENSOR_ADJUSTMENT_INFO = record 
    dwSize: DWORD;  //结构体大小
    iPan: INT;  //左右值
    iTilt: INT;  //上下值
    iRotation: INT;  //旋转值
    iFieldAngle: INT;  //图像视场角值
    byR: BYTE;  //RGB参数，R（红色），范围0-100
    byG: BYTE;  //RGB参数，G（绿色），范围0-100
    byB: BYTE;  //RGB参数，B（蓝色），范围0-100
    byRgbType: BYTE;  //RGB类型，0-保留，1-产线模式，2-手动模式
    byBrightness: BYTE;  //亮度，范围0-100,默认值50
    byRes: array[0..3-1] of BYTE;  
    wRex: WORD;  //RGB参数(扩展)，R（红色），范围0-2048
    wGex: WORD;  //RGB参数(扩展)，G（绿色），范围0-2048
    wBex: WORD;  //RGB参数(扩展)，B（蓝色），范围0-2048
    byRes1: array[0..114-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_ADJUSTMENT_INFO = ^NET_DVR_SENSOR_ADJUSTMENT_INFO;

type
  NET_DVR_SENSOR_RESET = record 
    dwSize: DWORD;  //结构体大小
    bySensorNo: BYTE;  //Sensor号[1,8];当Sensor No为0的时候，表示全部清除；其他情况下表示单个清除
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_SENSOR_RESET = ^NET_DVR_SENSOR_RESET;

type
  NET_DVR_PANORAMAIMAGE = record 
    dwSize: DWORD;  //结构体大小
    byFusionMode: BYTE;  //模式：0-原始图像，1-全景图像
    byPreviewMode: BYTE;  //模式：1-目标，2-固定显示
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_PANORAMAIMAGE = ^NET_DVR_PANORAMAIMAGE;

type
  NET_DVR_RELOCATE_INFO = record 
    dwSize: DWORD;  //结构体大小
    byTakeOverAddr: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //接管设备的地址
    wPort: WORD;  //设备端口号
    byRes: array[0..254-1] of BYTE;  //保留
  end;
  LPNET_DVR_RELOCATE_INFO = ^NET_DVR_RELOCATE_INFO;

type
  NET_DVR_CONFERENCE_REGION = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //是否启用会议区域，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    struRegion: array[0..RECT_POINT_NUM-1] of NET_DVR_POINT;  //会议区域，矩形，起始点为左下角，顺时针方向
    dwOutputWidth: DWORD;  //单输出口基准宽，只能获取
    dwOutputHeight: DWORD;  //单输出口基准高，只能获取
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CONFERENCE_REGION = ^NET_DVR_CONFERENCE_REGION;

type
  NET_DVR_TERMINAL_CALL_CFG = record 
    dwSize: DWORD;  
    byAnswerType: BYTE;  //会议呼叫响应方式，1-自动接听，2-自动拒接，3-手动接听
    byProtocolType: BYTE;  //使用的协议类型，1-SIP，2-H232
    byTransmissionProtocol: BYTE;  //传输协议类型，0-无效，1-TCP，2-UDP
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_CALL_CFG = ^NET_DVR_TERMINAL_CALL_CFG;

type
  NET_DVR_TERMINAL_CALL_INFO = record 
    byTermianlURL: array[0..MAX_URL_LEN-1] of BYTE;  
    dwCallRate: DWORD;  //呼叫速率，范围为：32~6144，单位Kbps  (连接速率)
    byRes: array[0..124-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_CALL_INFO = ^NET_DVR_TERMINAL_CALL_INFO;

type
  NET_DVR_TERMINAL_AUDIO_CTRL = record 
    byMute: BYTE;  //是否静音，0-否，1-是
    byVolume: BYTE;  //音量，非静音时有效，1-100
    byAudioInputDisabled: BYTE;  //禁止音频输入，0-允许音频输入，1-禁止音频输入
    byAudioInputVolume: BYTE;  //音频输入音量，允许音频输入时有效，1-100
    byRes: array[0..636-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_AUDIO_CTRL = ^NET_DVR_TERMINAL_AUDIO_CTRL;

type
  NET_DVR_HOWLING_SUPPRESSION = record 
    byEnabled: BYTE;  //是否使能啸叫抑制
    byHsSensibility: BYTE;  //啸叫抑制灵敏度
    byHsMode: BYTE;  //啸叫抑制模式，0-默认，1-慢速，2-快速
    byRes1: BYTE;  
    dwHsTime: DWORD;  //啸叫抑制时间，单位：ms
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_HOWLING_SUPPRESSION = ^NET_DVR_HOWLING_SUPPRESSION;

type
  NET_DVR_TERMINAL_INPUT_AUDIO = record 
    dwChannel: DWORD;  //通道号
    byGainType: BYTE;  //增益类型，1-数字增益，2-模拟增益,3-两者
    byEnableSimulate: BYTE;  //是否启用模拟增益，0-否，1-是
    byVolumeSimulate: BYTE;  //模拟音量，启用时有效，1-100
    byEnableDigital: BYTE;  //是否启用数字增益，0-否，1-是
    byVolumeDigital: BYTE;  //数字音量，启用时有效，1-100
    byRes1: array[0..3-1] of BYTE;  
    struHsParam: NET_DVR_HOWLING_SUPPRESSION;  //啸叫抑制参数
    byRes: array[0..604-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_INPUT_AUDIO = ^NET_DVR_TERMINAL_INPUT_AUDIO;


type
  NET_DVR_TERMINAL_DETAIL_CTRL_PARAM = record 
    case Byte of
    0: (byRes: array[0..640-1] of BYTE);  
    1: (struCallInfo: NET_DVR_TERMINAL_CALL_INFO);  
    2: (struAudioCtrl: NET_DVR_TERMINAL_AUDIO_CTRL);  
    3: (struInputAudio: NET_DVR_TERMINAL_INPUT_AUDIO);  
  end;
  LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM = ^NET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

type
  NET_DVR_TERMINAL_CTRL_PARAM = record 
    dwSize: DWORD;  
    byOperateType: BYTE;  //操作类型，1-接听，2-拒接，3-呼叫，4-音频调节，5-挂断，6-双流开，7-双流关
    byRes1: array[0..3-1] of BYTE;  
    struCtrlParam: NET_DVR_TERMINAL_DETAIL_CTRL_PARAM;  //具体控制参数
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_CTRL_PARAM = ^NET_DVR_TERMINAL_CTRL_PARAM;

type
  NET_DVR_POS_INFO_OVERLAY = record 
    dwSize: DWORD;  
    byPosInfoOverlayEnable: BYTE;  // Pos信息码流叠加控制，0-不叠加，1-叠加
    byOverlayType: BYTE;  //0-叠加进入和离开，1-叠加进入、离开、PASS、ID、高度
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_POS_INFO_OVERLAY = ^NET_DVR_POS_INFO_OVERLAY;


type
  NET_DVR_CAMERA_WORK_MODE = record 
    dwSize: DWORD;  
    byWorkMode: BYTE;  //工作模式，0-正常模式，1-工厂标定模式
    byPreviewImageMode: BYTE;  //预览图像模式，0-左眼图像，1-右眼图像，2-左右叠加图像
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_CAMERA_WORK_MODE = ^NET_DVR_CAMERA_WORK_MODE;

type
  NET_DVR_VCA_VERSION_LIST = record 
    dwSize: DWORD;  //结构体长度
    struVcaVersion: array[0..NET_SDK_VERSION_LIST_LEN{64}-1] of NET_DVR_VCA_VERSION;  //算法库版本信息
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_VCA_VERSION_LIST = ^NET_DVR_VCA_VERSION_LIST;

type
  NET_DVR_SETUP_CALIB_COND = record 
    dwSize: DWORD;  
    byCalibrateType: BYTE;  //标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
    byRes1: array[0..3-1] of BYTE;  
    fTiltAngle: FLOAT;  //俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
    fHeelAngle: FLOAT;  //倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
    fHeight: FLOAT;  //高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
    struAutoCalibPolygon: NET_VCA_POLYGON;  //自动标定区域，当byCalibrateType为1时有效
    byIntelligentType: BYTE;  //标定的智能类型，0-保留， 1-客流，2-人体属性，3-异常行为检测；只有在标定客流时NET_DVR_SETUP_CALIB_RESULT返回的数据才有效
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_SETUP_CALIB_COND = ^NET_DVR_SETUP_CALIB_COND;

type
  NET_DVR_SETUP_CALIB_RESULT = record 
    dwSize: DWORD;  
    byCalibrateType: BYTE;  //标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
    byRes1: array[0..3-1] of BYTE;  
    fTiltAngle: FLOAT;  //俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
    fHeelAngle: FLOAT;  //倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
    fHeight: FLOAT;  //高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
    struCountPolygon: NET_VCA_POLYGON;  //计数区域
    struEnterDirection: NET_DVR_PDC_ENTER_DIRECTION;  // 流量进入方向
    struLine: NET_VCA_LINE;  //检测线
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SETUP_CALIB_RESULT = ^NET_DVR_SETUP_CALIB_RESULT;

type
  NET_DVR_CALL_QUERY_COND = record 
    dwSize: DWORD;  
    bySearchID: array[0..MAX_SEARCH_ID_LEN-1] of BYTE;  //搜索标识符
    struStartTime: NET_DVR_TIME;  //搜索起始时间
    struEndTime: NET_DVR_TIME;  //搜索结束时间
    byCallType: BYTE;  //呼叫类型，1-已接，2-未接，3-已拨，4-所有类型
    byRes1: array[0..3-1] of BYTE;  
    dwMaxResults: DWORD;  //本次查找最多返回个数
    dwSearchPos: DWORD;  //查找起始索引
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CALL_QUERY_COND = ^NET_DVR_CALL_QUERY_COND;

type
  NET_DVR_CALL_QUERY_SINGLE = record 
    dwSize: DWORD;  
    byCallType: BYTE;  //呼叫类型，1-已接，2-未接，3-已拨
    byRes1: array[0..3-1] of BYTE;  
    byTerminalName: array[0..TERMINAL_NAME_LEN-1] of BYTE;  //终端名
    byAddressURL: array[0..MAX_URL_LEN-1] of BYTE;  //对端URL地址
    struStartTime: NET_DVR_TIME;  //呼叫开始时间
    struEndTime: NET_DVR_TIME;  //呼叫结束时间
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CALL_QUERY_SINGLE = ^NET_DVR_CALL_QUERY_SINGLE;


type
  CALL_QUERY_RESULT_STATUS =  
  (  
    CALL_QUERY_RESULT_OK = 0,  //成功查询所有
    CALL_QUERY_RESULT_FAIL,  //查询失败，未知错误
    CALL_QUERY_RESULT_MORE,  //成功查询 还有更多没有返回
    CALL_QUERY_RESULT_NOMATCH,  //没有查询到匹配的
    CALL_QUERY_RESULT_PARAMERROR,  //查询条件参数错误
    CALL_QUERY_RESULT_INVALIDTIME,  //查询条件时间无效
    CALL_QUERY_RESULT_TIMEOUT  //查询超时
  );

type
  NET_DVR_CALL_QUERY_RESULT = record 
    dwSize: DWORD;  
    bySearchID: array[0..MAX_SEARCH_ID_LEN-1] of BYTE;  //搜索标识符
    byStatus: BYTE;  //查询状态  参考CALL_QUERY_RESULT_STATUS结构体
    byRes: array[0..3-1] of BYTE;  //保留
    dwCount: DWORD;  //实际查询到的结果个数
    pResults: PBYTE;  //结果内容，dwCount个NET_DVR_CALL_QUERY_SINGLE,需要调用者预先分屏好内存
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CALL_QUERY_RESULT = ^NET_DVR_CALL_QUERY_RESULT;

type
  NET_DVR_CONFERENCE_CALL_INFO = record 
    byConferenceID: array[0..MAX_ID_LEN-1] of BYTE;  //会议ID
    byConferenceName: array[0..NAME_LEN-1] of BYTE;  //会议名称
    struStartTime: NET_DVR_TIME;  //会议开始时间
    struEndTime: NET_DVR_TIME;  //会议结束时间
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_CONFERENCE_CALL_INFO = ^NET_DVR_CONFERENCE_CALL_INFO;

type
  NET_DVR_CALL_INFO = record 
    case Byte of
    0: (byRes: array[0..640-1] of BYTE);  
    1: (struTerminalCallInfo: NET_DVR_TERMINAL_CALL_INFO);  //终端点对点呼叫信息
    2: (struConferenceCallInfo: NET_DVR_CONFERENCE_CALL_INFO);  //会议呼叫信息
  end;
  LPNET_DVR_CALL_INFO = ^NET_DVR_CALL_INFO;

type
  NET_DVR_CONFERENCE_CALL_ALARM = record 
    dwSize: DWORD;  
    byAlarmType: BYTE;  //报警类型，1-会议呼叫， 2-呼叫状态切换，3-终端提问
    byCallType: BYTE;  //呼叫类型，报警类型为1时有效，1-终端点对点呼叫，2-会议呼叫
    byAutoAnswer: BYTE;  //是否已自动接听，0-否，1-是
    byCallStatusSwitch: BYTE;  //呼叫状态切换类型，当报警类型为2时有效，1-开始呼叫，2-呼叫成功，3-呼叫结束，4-对端挂断
    struCallInfo: NET_DVR_CALL_INFO;  //呼叫信息
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_CONFERENCE_CALL_ALARM = ^NET_DVR_CONFERENCE_CALL_ALARM;

type
  NET_DVR_TERMINAL_INPUT_CFG = record 
    dwSize: DWORD;  
    dwInputNo: DWORD;  //作为视频会议输入的输入口编号
    byStreamType: BYTE;  //码流类型：0-主码流，1-子码流，2-三码流
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_INPUT_CFG = ^NET_DVR_TERMINAL_INPUT_CFG;

type
  NET_DVR_AUDIO_STATUS = record 
    byMute: BYTE;  //是否静音，0-否，1-是
    byVolume: BYTE;  //会议音量，1-100，非静音时有效
    byAudioInputDisabled: BYTE;  //禁用音频输入，0-否，1-是
    byAudioInputVolume: BYTE;  //音频输入音量，1-100，允许音频输入时有效
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_AUDIO_STATUS = ^NET_DVR_AUDIO_STATUS;

type
  NET_DVR_TERMINAL_CONFERENCE_STATUS = record 
    dwSize: DWORD;  
    byConferenceState: BYTE;  //会议状态，0-空闲，1-忙碌（会议中），2-呼叫中，3-被呼叫中
    byConferenceType: BYTE;  //会议类型，1-点对点，2-MCU发起会议
    byDualStreamEnabled: BYTE;  //是否开启双流，0-未开启，1-开启
    byMicPowerEnabled: BYTE;  //麦克风电源是否开启，0-未开启，1-开启
    dwInputNo: DWORD;  //使用的音频输入口号
    struCallInfo: NET_DVR_CALL_INFO;  //会议信息
    struAudioStatus: NET_DVR_AUDIO_STATUS;  //音频相关状态
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_CONFERENCE_STATUS = ^NET_DVR_TERMINAL_CONFERENCE_STATUS;

//终端注册GK信息
type
  NET_DVR_TERMINAL_GK_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用
    byRegisterState: BYTE;  //注册状态，0-未注册，1-已注册，只读
    byRes1: array[0..2-1] of BYTE;  
    struGKIP: NET_DVR_IPADDR;  //GK IP
    wGKPort: WORD;  //GK端口号
    byRes2: array[0..2-1] of BYTE;  
    byRegisterName: array[0..REGISTER_NAME_LEN-1] of BYTE;  //终端注册到GK的名字
    byPassword: array[0..PASSWD_LEN-1] of BYTE;  //终端注册到GK的密码
    byRes3: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_TERMINAL_GK_CFG = ^NET_DVR_TERMINAL_GK_CFG;

//解码器漫游开关参数
type
  NET_DVR_WIN_ROAM_SWITCH_CFG = record 
    dwSize: DWORD;  
    byEnableRoam: BYTE;  //是否允许窗口漫游，0-否，非0-是
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_WIN_ROAM_SWITCH_CFG = ^NET_DVR_WIN_ROAM_SWITCH_CFG;

type
  NET_DVR_LED_OUTPUT_CFG = record 
    dwSize: DWORD;  
    byEnableZoom: BYTE;  //是否缩放，0-否，1-是
    byAutoCutBlackEdge: BYTE;  //是否自动裁剪黑边，0-否，1-是
    byRes1: array[0..2-1] of BYTE;  
    wLEDWidth: WORD;  //分辨率宽
    wLEDHeight: WORD;  //分辨率高
    dwRefreshRate: DWORD;  //刷新频率
    dwInputNO: DWORD;  //关联的输入通道号
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_OUTPUT_CFG = ^NET_DVR_LED_OUTPUT_CFG;

type
  NET_DVR_LED_OUTPUT_PORT_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //是否使能，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    dwPortNum: DWORD;  //包含的端口个数
    dwPortNo: array[0..MAX_OUTPUT_PORT_NUM-1] of DWORD;  //包含的端口号
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LED_OUTPUT_PORT_CFG = ^NET_DVR_LED_OUTPUT_PORT_CFG;

type
  NET_DVR_LINE_COLUMN_INFO = record 
    wLine: WORD;  //行号
    wColumn: WORD;  //列号
  end;
  LPNET_DVR_LINE_COLUMN_INFO = ^NET_DVR_LINE_COLUMN_INFO;

type
  NET_DVR_LED_DISPLAY_AREA = record 
    dwSize: DWORD;  
    struLCInfo: NET_DVR_LINE_COLUMN_INFO;  //显示区域的起始位置(接收卡行列号)
    wWidth: WORD;  //横向接收卡数
    wHeight: WORD;  //竖向接收卡数
    wRecvCardWidth: WORD;  //接收卡宽度大小，为0则使用端口参数中接收卡大小参数
    wRecvCardHeigt: WORD;  //接收卡高度大小，为0则使用端口参数中接收卡大小参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_DISPLAY_AREA = ^NET_DVR_LED_DISPLAY_AREA;

type
  NET_DVR_LED_RECV_CARD_INFO = record 
    struPos: NET_DVR_LINE_COLUMN_INFO;  //接收卡位置
    wRecvCardWidth: WORD;  //接收卡宽度大小
    wRecvCardHeigt: WORD;  //接收卡高度大小
  end;
  LPNET_DVR_LED_RECV_CARD_INFO = ^NET_DVR_LED_RECV_CARD_INFO;

type
  NET_DVR_LED_PORT_BACKUP = record 
    byEnabled: BYTE;  //是否启用端口备份，0-否，1-是
    byPortMode: BYTE;  //端口模式，1-主口，2-备份口
    byRes1: array[0..2-1] of BYTE;  
    dwPairPort: DWORD;  //配对端口号，当端口为主口时，此参数为备份口端口号，当端口为备份口时，此参数为主口端口号
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_LED_PORT_BACKUP = ^NET_DVR_LED_PORT_BACKUP;

type
  NET_DVR_LED_PORT_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //是否启用该端口，0-否，1-是
    byRes1: array[0..3-1] of BYTE;  
    struLedPortBackup: NET_DVR_LED_PORT_BACKUP;  //端口备份参数
    dwRecvCardNum: DWORD;  //本端口连接的接收卡数
    struRecvCard: array[0..MAX_SINGLE_PORT_RECVCARD_NUM-1] of NET_DVR_LED_RECV_CARD_INFO;  //各接收卡的信息
    dwPortNo: DWORD;  //端口号，获取所有端口参数时有效
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LED_PORT_CFG = ^NET_DVR_LED_PORT_CFG;

type
  NET_DVR_LED_DISPLAY_CFG = record 
    dwSize: DWORD;  
    struColorTemp: NET_DVR_COLOR_TEMPERATURE_CFG;  //色温参数
    struVoutCfg: NET_DVR_VIDEO_OUT_CFG;  //显示效果参数
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_DISPLAY_CFG = ^NET_DVR_LED_DISPLAY_CFG;

type
  NET_DVR_LED_TEST_SIGNAL_CFG = record 
    dwSize: DWORD;  
    byEnabled: BYTE;  //是否启用测试信号，0-不启用，1-启用
    bySignalType: BYTE;  //测试信号类型，1-彩条，2-波纹，3-格状彩条，4-方格，5-水平和垂直灰阶联合体，6-棋盘，0xff-自定义颜色
    byRes1: array[0..2-1] of BYTE;  
    struSignalColor: NET_DVR_RGB_COLOR;  //测试信号颜色，测试信号类型为0xff时有效
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_TEST_SIGNAL_CFG = ^NET_DVR_LED_TEST_SIGNAL_CFG;

type
  NET_DVR_LED_NOSIGNAL_CFG = record 
    dwSize: DWORD;  
    byNoSignalMode: BYTE;  //无信号显示模式，1-黑屏，2-显示厂家LOGO，3-显示自定义图片
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_LED_NOSIGNAL_CFG = ^NET_DVR_LED_NOSIGNAL_CFG;

type
  NET_DVR_LED_INPUT_CFG = record 
    dwSize: DWORD;  
    dwResolutionWidth: DWORD;  //输入分辨率宽，只读
    dwResolutionHeight: DWORD;  //输入分辨率高，只读
    dwRefreshRate: DWORD;  //输入信号刷新频率，只读
    struVgaCfg: NET_DVR_SCREEN_VGA_CFG;  //VGA信号调整参数，VGA输入时可调
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_INPUT_CFG = ^NET_DVR_LED_INPUT_CFG;

type
  NET_DVR_LED_RECV_CARD_CFG_COND = record 
    dwSize: DWORD;  
    dwOutputNo: DWORD;  //输出编号
    struPosStart: NET_DVR_LINE_COLUMN_INFO;  //接收卡起始位置
    struPosEnd: NET_DVR_LINE_COLUMN_INFO;  //接收卡结束位置
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_RECV_CARD_CFG_COND = ^NET_DVR_LED_RECV_CARD_CFG_COND;

type
  NET_DVR_LED_GAMMA_CFG_COND = record 
    dwSize: DWORD;  
    dwOutputNo: DWORD;  //输出编号;
    struPosStart: NET_DVR_LINE_COLUMN_INFO;  //接收卡起始位置
    struPosEnd: NET_DVR_LINE_COLUMN_INFO;  //接收卡结束位置
    byGammaType: BYTE;  //Gamma表类型，Gamma表配置时有效，0-RGB混合Gamma表，1-红色Gamma表，2-绿色Gamma表，3-蓝色Gamma表
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_LED_GAMMA_CFG_COND = ^NET_DVR_LED_GAMMA_CFG_COND;

type
  NET_DVR_LED_GAMMA_CFG = record 
    dwSize: DWORD;  
    wGammaValue: array[0..MAX_GAMMA_X_VALUE-1] of WORD;  //GAMMA表Y取值，每个元素取值0-65535，自定义模式时有效
    byGammaModel: BYTE;  //GAMMA表模式，0-自定义模式，1-夜模式1，2-夜模式2，3-正常模式，4-日照模式1，5-日照模式2
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_LED_GAMMA_CFG = ^NET_DVR_LED_GAMMA_CFG;

type
  NET_DVR_LED_CLOCK_CFG = record 
    dwDclkRate: DWORD;  //传输时钟dclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    dwGclkRate: DWORD;  //刷新时钟gclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    dwGclkCountNum: DWORD;  //300ns gclk计数值
    byDclkDutyRatio: BYTE;  //dclk时钟占空比，取值：25，50，75
    byDclkPhase: BYTE;  //dclk相位，取值：0,1,2,3
    byGclkNum: BYTE;  //刷新1行需要的有效gclk个数，0-255
    byRes: array[0..17-1] of BYTE;  
  end;
  LPNET_DVR_LED_CLOCK_CFG = ^NET_DVR_LED_CLOCK_CFG;

type
  NET_DVR_LED_RECV_CFG = record 
    dwSize: DWORD;  
    struClockCfg: NET_DVR_LED_CLOCK_CFG;  //时钟相关参数
    byGrayLevel: BYTE;  //灰度等级，取值13，14
    byRefreshRate: BYTE;  //刷新倍率，取值1-6
    byLineScanNum: BYTE;  //行扫数，0-255
    byRefreshCompleteGrayNum: BYTE;  //刷新完整灰阶数，0-255
    dwHBlank: DWORD;  //行消隐时间，单位：gclk时钟个数，取值1-65535
    dwAfterglowCtrl: DWORD;  //余晖控制结束时间，单位：gclk时钟个数，取值1-65535
    dwLineFeedTime: DWORD;  //换行时间，单位：gclk时钟个数，取值1-65535
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LED_RECV_CFG = ^NET_DVR_LED_RECV_CFG;

type
  NET_DVR_LED_REGISTOR_VALUE = record 
    byChip1High: BYTE;  //芯片1高字节
    byChip1Low: BYTE;  //芯片1低字节
    byChip2High: BYTE;  //芯片2高字节
    byChip2Low: BYTE;  //芯片2低字节
    byChip3High: BYTE;  //芯片3高字节
    byChip3Low: BYTE;  //芯片3低字节
    byChip4High: BYTE;  //芯片4高字节
    byChip4Low: BYTE;  //芯片4低字节
    byChip5High: BYTE;  //芯片5高字节
    byChip5Low: BYTE;  //芯片5低字节
    byChip6High: BYTE;  //芯片6高字节
    byChip6Low: BYTE;  //芯片6低字节
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_LED_REGISTOR_VALUE = ^NET_DVR_LED_REGISTOR_VALUE;

type
  NET_DVR_LED_RECV_REGISTOR = record 
    byEliminateGhostShadowLevel: BYTE;  //下鬼影消除等级，0-5
    byEliminateShadowy: BYTE;  //第一扫偏暗消除等级，0-15
    byGrayEqualize1: BYTE;  //低灰偏色补偿1，0-3
    byGrayEqualize2: BYTE;  //低灰偏色补偿2，0-15
    byEnableGrayUniformity: BYTE;  //低灰均匀性提升是否开启，0-关，1-开
    byDisableHGrayStripes: BYTE;  //低灰横条纹消除是否开启，0-关，1-开
    byGhostShadowEnhancedMode1: BYTE;  //下鬼影消除增强模式1是否开启，0-关，1-开
    byGhostShadowEnhancedMode2: BYTE;  //下鬼影消除增强模式2是否开启，0-关，1-开
    byClearBadPoint: BYTE;  //去除坏点使能，0-非使能，1-使能
    byEnableSelfDefineRegistor: BYTE;  //是否启用自定义寄存器值，0-否，1-是
    byRes1: array[0..2-1] of BYTE;  
    struRegistorValue: NET_DVR_LED_REGISTOR_VALUE;  //自定义寄存器参数
    byEnabledExGradientOptimition: BYTE;  //渐变过度优化开关，0-关闭，!0-开启
    byDummyGClockCycle: BYTE;  //Dummy GClock周期，开启渐变过度优化时有效，单位：个gclk
    byDummyGClockHighTime: BYTE;  //Dummy GClock高电平时间，开启渐变过度优化时有效，单位：8ns
    byFirstGClockExtendedTime: BYTE;  //第一个GClock展宽时间，开启渐变过度优化时有效，单位：8ns
    byRes: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_LED_RECV_REGISTOR = ^NET_DVR_LED_RECV_REGISTOR;

type
  NET_DVR_LED_RECV_ADVANCED_CFG = record 
    dwSize: DWORD;  
    struFirstRegistor: NET_DVR_LED_RECV_REGISTOR;  //第一组接收卡高级参数，自定义寄存器值为红芯片寄存器值
    struSecondRegistor: NET_DVR_LED_RECV_REGISTOR;  //第二组接收卡高级参数，自定义寄存器值为绿芯片寄存器值
    struThirdRegistor: NET_DVR_LED_RECV_REGISTOR;  //第三组接收卡高级参数，自定义寄存器值为蓝芯片寄存器值
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LED_RECV_ADVANCED_CFG = ^NET_DVR_LED_RECV_ADVANCED_CFG;

type
  NET_DVR_LED_CHECK_COND = record 
    dwSize: DWORD;  
    dwOutputNo: DWORD;  //输入编号
    struPosStart: NET_DVR_LINE_COLUMN_INFO;  //接收卡起始位置
    byStartPosType: BYTE;  //起始位置类型，0-使用接收卡起始位置，1-使用坐标位置
    byRes1: array[0..3-1] of BYTE;  
    dwXCoordinate: DWORD;  //矩形左上角起始点X坐标
    dwYCoordinate: DWORD;  //矩形左上角Y坐标
    dwWidth: DWORD;  //区域宽度
    dwHeight: DWORD;  //区域高度
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_LED_CHECK_COND = ^NET_DVR_LED_CHECK_COND;

//查询方式
type
  ADDR_QUERY_TYPE = 
  (  
    QUERYSVR_BY_COUNTRYID = 0,  //按国家编号查询服务器地址
    QUERYSVR_BY_SERVERTYPE = 1,  //保留
    QUERYDEV_BY_NICKNAME_DDNS = 2,  //按昵称从hiDDNS上查询设备信息
    QUERYDEV_BY_SERIAL_DDNS = 3,  //按序列号从hiDDNS上查询设备信息
    CHECKDEV_BY_NICKNAME_DDNS = 4,  //按昵称从hiDDNS诊断设备信息
    CHECKDEV_BY_SERIAL_DDNS = 5,  //按序列号从hiDDNS诊断设备信息
    QUERYDEV_BY_NICKNAME_IPSERVER = 6,  //按昵称从IPServer上查询设备信息
    QUERYDEV_BY_SERIAL_IPSERVER = 7  //按昵称从IPServer上查询设备信息
  );
const
  CLIENT_VERSION_LEN = 64;    
//按国家编号查询的条件结构体
type
  NET_DVR_QUERY_COUNTRYID_COND = record 
    wCountryID: WORD;  //国家编号,取值详见附件一
    szSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //服务器地址,表示去哪个服务器上查询目标服务器的信息
    szClientVersion: array[0..CLIENT_VERSION_LEN-1] of AnsiChar;  //客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    byRes: array[0..382-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_COUNTRYID_COND = ^NET_DVR_QUERY_COUNTRYID_COND;

//按国家编号查询的返回结构体
type
  NET_DVR_QUERY_COUNTRYID_RET = record 
    szResolveSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //解析服务器地址(即设备注册服务器)
    szAlarmSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //报警服务器地址
    byRes: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_COUNTRYID_RET = ^NET_DVR_QUERY_COUNTRYID_RET;

//按服务器类型查询的条件结构体
type
  NET_DVR_QUERY_SERVERTYPE_COND = record 
    wSvrType: WORD;  //服务器类型, 6-手机推送服务器
    szSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //服务器地址,表示去哪个服务器上查询目标服务器的信息
    szClientVersion: array[0..CLIENT_VERSION_LEN-1] of AnsiChar;  //客户端版本信息
    byRes: array[0..382-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_SERVERTYPE_COND = ^NET_DVR_QUERY_SERVERTYPE_COND;

//按服务器类型查询的返回结构体
type
  NET_DVR_QUERY_SERVERTYPE_RET = record 
    szSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //服务器地址
    wSvrPort: WORD;  //服务器端口
    byRes: array[0..446-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_SERVERTYPE_RET = ^NET_DVR_QUERY_SERVERTYPE_RET;

//从hiDDNS上查询或诊断的条件结构体
type
  NET_DVR_QUERY_DDNS_COND = record 
    szResolveSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //解析服务器地址
    szDevNickName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //设备在解析服务器上的别名
    szDevSerial: array[0..SERIALNO_LEN-1] of AnsiChar;  //设备序列号
    szClientVersion: array[0..CLIENT_VERSION_LEN-1] of AnsiChar;  //客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    byRes: array[0..272-1] of BYTE;  //保留
  end;
  LPNET_DVR_QUERY_DDNS_COND = ^NET_DVR_QUERY_DDNS_COND;

//从hiDDNS上查询返回的结构体
type
  NET_DVR_QUERY_DDNS_RET = record 
    szDevIP: array[0..SDK_MAX_IP_LEN-1] of AnsiChar;  //设备IP地址
    wCmdPort: WORD;  //控制端口（SDK连接端口）
    wHttpPort: WORD;  //http端口
    byRes: array[0..460-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_DDNS_RET = ^NET_DVR_QUERY_DDNS_RET;

//从hiDDNS上诊断返回的结构体
type
  NET_DVR_CHECK_DDNS_RET = record 
    byDevStatus: BYTE;  //设备状态,0-正常,1-找不到,2-设备不在线,3-设备不在当前区域
    byRes1: BYTE;  
    struQueryRet: NET_DVR_QUERY_DDNS_RET;  //地址信息
    wRegionID: WORD;  //当前设备注册区域编号[1美国,2南美,3亚太,4中国,5欧洲,6其它]
    byRes2: array[0..508-1] of BYTE;  
  end;
  LPNET_DVR_CHECK_DDNS_RET = ^NET_DVR_CHECK_DDNS_RET;

//从IPServer上查询的条件结构体
type
  NET_DVR_QUERY_IPSERVER_COND = record 
    szResolveSvrAddr: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //解析服务器地址
    wResolveSvrPort: WORD;  //解析服务器端口
    szDevNickName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  //设备在解析服务器上的别名
    szDevSerial: array[0..SERIALNO_LEN-1] of AnsiChar;  //设备序列号
    byRes: array[0..334-1] of BYTE;  //保留
  end;
  LPNET_DVR_QUERY_IPSERVER_COND = ^NET_DVR_QUERY_IPSERVER_COND;

//从IPServer上查询返回的结构体
type
  NET_DVR_QUERY_IPSERVER_RET = record 
    szDevIP: array[0..SDK_MAX_IP_LEN-1] of AnsiChar;  //设备IP地址
    wCmdPort: WORD;  //控制端口（SDK连接端口）
    byRes: array[0..462-1] of BYTE;  
  end;
  LPNET_DVR_QUERY_IPSERVER_RET = ^NET_DVR_QUERY_IPSERVER_RET;

type
  NET_DVR_CURRENT_VALID_PORT = record 
    dwSize: DWORD;  
    wHTTPPort: WORD;  
    byRes: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_CURRENT_VALID_PORT = ^NET_DVR_CURRENT_VALID_PORT;

type
  NET_DVR_AUDIO_CHANNEL = record 
    dwChannelNum: DWORD;  //通道号
    byres: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_AUDIO_CHANNEL = ^NET_DVR_AUDIO_CHANNEL;

//码流加密条件结构
type
  NET_DVR_STREAMENCRYPTION_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChan: DWORD;  //预览通道号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_STREAMENCRYPTION_COND = ^NET_DVR_STREAMENCRYPTION_COND;

//码流加密信息结构
type
  NET_DVR_STREAMENCRYPTION_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //启用码流加密，0~关闭，1~开启
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_STREAMENCRYPTION_CFG = ^NET_DVR_STREAMENCRYPTION_CFG;

//校准的GPS经纬度参数
type
  NET_DVR_REVISE_GPS_CFG = record 
    dwSize: DWORD;  //结构体大小
    byLatitudeType: BYTE;  //纬度类型，0-北纬，1-南纬
    byLongitudeType: BYTE;  // 经度类型，0-东度，1-西度
    byMode: BYTE;  //模式 0-默认，1-自动，2-手动
    byRes: BYTE;  
    struLatitude: NET_DVR_LLI_PARAM;  //纬度
    struLongitude: NET_DVR_LLI_PARAM;  //经度
    byRes1: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_REVISE_GPS_CFG = ^NET_DVR_REVISE_GPS_CFG;

type
  NET_DVR_PDC_RECOMMEND = record 
    dwSize: DWORD;  
    wWidth: WORD;  //推荐宽度值[0, 1000]
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_PDC_RECOMMEND = ^NET_DVR_PDC_RECOMMEND;

type
  NET_DVR_FLASHSTORAGE_REMOVE = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byPDCRemoveEnable: BYTE;  //清除客流数据使能 0-不清除，1-清除
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_FLASHSTORAGE_REMOVE = ^NET_DVR_FLASHSTORAGE_REMOVE;

//*******************************DS-TME4XX控制机开发 Begin***************************
type
  NET_DVR_PARKING_CARD = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //默认是1（后续兼容多通道设备）
    szCardNo: array[0..MAX_CARDNO_LEN{48}-1] of AnsiChar;  //卡号
    byCardType: BYTE;  //卡片类型 0-临时卡，1-固定卡
    byCardStatus: BYTE;  //卡片状态 0-正常，1-挂失，2-注销
    byChargeRuleID: BYTE;  //收费规则ID
    byDelete: BYTE;  //是否删除 0-不删除，1-删除
    struStartTime: NET_DVR_TIME_V30;  //有效开始时间
    struEndTime: NET_DVR_TIME_V30;  //有效结束时间
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PARKING_CARD = ^NET_DVR_PARKING_CARD;

//出入口卡片信息上传
type
  NET_DVR_GATE_CARDINFO = record 
    dwSize: DWORD;  
    struDevInfo: NET_VCA_DEV_INFO;  
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    szCardNo: array[0..MAX_CARDNO_LEN{48}-1] of AnsiChar;  //卡号
    szPassVehicleID: array[0..MAX_VEHICLE_ID_LEN-1] of AnsiChar;  //唯一标识
    szInVehicleID: array[0..MAX_VEHICLE_ID_LEN-1] of AnsiChar;  //出口时的入口唯一标识
    struSwipeTime: NET_DVR_TIME_V30;  //刷卡时间
    struCardTime: NET_DVR_TIME_V30;  //卡片存的时间，即入场时写入的时间，只对出口票箱有用，0表示无入场时间
    byLetPass: BYTE;  //出入口放行方式 0-不放行(当CardType == 纸票)需要收费，1-放行，2-中心收费放行
    byCardType: BYTE;  //卡类型 0-固定卡，1-临时卡，2-纸票
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_GATE_CARDINFO = ^NET_DVR_GATE_CARDINFO;

//月台作业数据上传
type
  NET_LOADING_DOCK_OPERATEINFO = record 
    dwSize: DWORD;  //结构长度
    byAbsTime: array[0..32-1] of BYTE;  //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    byParkingNo: array[0..MAX_PARKNO_LEN{16}-1] of BYTE;  //车位编号
    dwIndex: DWORD;  //车辆序号
    sLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
    byCurrentWorkerNumber: BYTE;  //当前作业人数
    byCurrentGoodsLoadingRate: BYTE;  //当前货物装载率 0-空 1-少 2-中 3-多 4-满
    byDoorsStatus: BYTE;  //车门状态 0-车门关闭 1-车门开启
    byRes1: BYTE;  //保留字节
    dwBackPicDataLength: DWORD;  //背景图片长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64)) //win64及linux64下指针为8字节
    pBackPicDataBuffer: PBYTE;  //背景图片数据指针
{$ELSE}
    pBackPicDataBuffer: PBYTE;  // 背景图片数据指针
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    dwChannel: DWORD;  //通道号，0-不支持（存在老的设备不支持通道号返回）
    byRes: array[0..508-1] of BYTE;  
  end;
  LPNET_LOADING_DOCK_OPERATEINFO = ^NET_LOADING_DOCK_OPERATEINFO;

//出入口付费信息上传(COMM_GATE_CHARGEINFO_UPLOAD)
type
  NET_DVR_GATE_CHARGEINFO = record 
    dwSize: DWORD;  
    struDevInfo: NET_VCA_DEV_INFO;  
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    sLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌
    szCardNo: array[0..48-1] of AnsiChar;  
    struEntranceTime: NET_DVR_TIME_V30;  
    struDepartureTime: NET_DVR_TIME_V30;  
    szDepartureID: array[0..32-1] of AnsiChar;  //出场唯一过车标示
    szEntranceID: array[0..32-1] of AnsiChar;  //入场唯一过车标示
    dwTotalCost: DWORD;  //实际收费金额*100
    szOperateName: array[0..32-1] of AnsiChar;  //脱机下为"offline"
    byChargeRuleId: BYTE;  //收费规则centerId
    byVehicleType: BYTE;  //车辆类型，0-其他车辆，1-小型车，2-大型车
    byRes: array[0..127-1] of BYTE;  //预留
  end;
  LPNET_DVR_GATE_CHARGEINFO = ^NET_DVR_GATE_CHARGEINFO;

//停车场停车卡控制结构体
type
  NET_DVR_PARKING_CARD_CTRL_PARAM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byCardType: BYTE;  //卡片类型 0-临时卡
    byDeleteALL: BYTE;  //是否全部删除 0-不删除，1-删除
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_PARKING_CARD_CTRL_PARAM = ^NET_DVR_PARKING_CARD_CTRL_PARAM;


//TME车辆抓图上传
type
  NET_DVR_TME_VEHICLE_RESULT = record 
    dwSize: DWORD;  
    wLaneid: WORD;  //车道号1～32（索引车道号，可以跳跃）
    byCamLaneId: BYTE;  //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    byRes1: BYTE;  //保留
    dwChanIndex: DWORD;  //通道号
    struPlateInfo: NET_DVR_PLATE_INFO;  //车牌信息结构
    struVehicleInfo: NET_DVR_VEHICLE_INFO;  //车辆信息
    byMonitoringSiteID: array[0..48-1] of BYTE;  //显示点编号
    byDeviceID: array[0..48-1] of BYTE;  //设备编号
    byDir: BYTE;  //显示方向，0-其它 1 入场，2 出场
    byRes2: BYTE;  
    wBackList: WORD;  //标记为是否报警数据 0 表示为正常过车数据  1 表示禁止名单
    dwPicNum: DWORD;  //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
    struPicInfo: array[0..4-1] of NET_ITS_PICTURE_INFO;  //图片信息,暂定最多4张图
    byPassVehicleID: array[0..32-1] of BYTE;  //车辆唯一ID
    byCardNo: array[0..48-1] of BYTE;  // 卡号
    bySwipeTime: array[0..32-1] of BYTE;  //增加刷卡时间  时间格式为yyyymmddhh24missfff
    dwCharge: DWORD;  //收费金额 （分）
    byHistory: BYTE;  //是否是历史数据  0-否  1-是
    byLetPass: BYTE;  //是否已放行，0-未放行，1-放行  2-未知
    byRes3: array[0..186-1] of BYTE;  
  end;
  LPNET_DVR_TME_VEHICLE_RESULT = ^NET_DVR_TME_VEHICLE_RESULT;

//地磁管理器注册消息
type
  NET_DVR_MVMRegisterInfo = record 
    dwSize: DWORD;  //结构体大小
    sDetectorID: array[0..16-1] of AnsiChar;  //检测器ID
    sManagerID: array[0..16-1] of AnsiChar;  //管理器ID
    sSim: array[0..20-1] of AnsiChar;  //卡号信息
    dwLocalIP: DWORD;  //本地IPv4地址，例如dwLocalIP=0x01020304,则IP地址为1.2.3.4
    dwLocalIPMask: DWORD;  //本地网络子网掩码，格式同dwLocalIP
    dwLocalGateway: DWORD;  //本地网关，格式同dwLocalIP
    dwDstIP: DWORD;  //目标IP，格式同dwLocalIP
    byMACAddr: array[0..6-1] of BYTE;  //本地mac地址
    wLocalPort: WORD;  //本地端口
    wFirmwareYear: WORD;  //软件版本年份
    byFirmwareMonth: BYTE;  //软件版本月份
    byFirmwareDay: BYTE;  //软件版本日
    byMajorVersion: BYTE;  //版本小数点前
    byMinorVersion: BYTE;  //版本小数点后
    byRes: array[0..170-1] of BYTE;  
  end;
  LPNET_DVR_MVMRegisterInfo = ^NET_DVR_MVMRegisterInfo;

//地磁状态信息
type
  NET_DVR_SingleMagneticStatus = record 
    dwSize: DWORD;  //结构体大小
    sDetectorID: array[0..16-1] of AnsiChar;  //检测器ID
    sManagerID: array[0..16-1] of AnsiChar;  //管理器ID
    sParkNum: array[0..16-1] of AnsiChar;  //车位编号
    struDetectorTime: NET_DVR_TIME_V30;  //检测时间
    dwRssi: DWORD;  //接收信号强度，实际值范围-137~0dbm，此处没有符号，为实际值的绝对值
    byParkinglotState: BYTE;  //车位状态，0-无车，1-有车
    byBatteryState: BYTE;  //电池状态，0-100%，1-75%，2-50%，3-25%，4-小于5%
    byDeviceState: BYTE;  //设备状态 0-正常，1-故障
    byCMD: BYTE;  //0-车位变化报警，1-检测器心跳报警
    byRes: array[0..184-1] of BYTE;  
  end;
  LPNET_DVR_SingleMagneticStatus = ^NET_DVR_SingleMagneticStatus;

//车辆信息同步
type
  NET_DVR_PARKING_VEHICLE = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //默认是1（后续兼容多通道设备）
    szLicense: array[0..MAX_LICENSE_LEN{16}-1] of AnsiChar;  //车牌号码
    szRelateCardNo: array[0..MAX_CARDNO_LEN{48}-1] of AnsiChar;  //关联卡号
    struStartTime: NET_DVR_TIME_V30;  //有效开始时间
    struEndTime: NET_DVR_TIME_V30;  //有效结束时间
    byVehicleType: BYTE;  //车辆类型：0-其他车辆，1-小型车，2-大型车
    byPlateColor: BYTE;  //车牌颜色，参考 VCA_PLATE_COLOR
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_PARKING_VEHICLE = ^NET_DVR_PARKING_VEHICLE;

//缴费金额信息
type
  NET_DVR_CHARGEACCOUNT_CFG = record 
    dwSize: DWORD;  //结构体大小
    fAccount: FLOAT;  //实际收费金额
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CHARGEACCOUNT_CFG = ^NET_DVR_CHARGEACCOUNT_CFG;

//停车场票箱从属设备多角度参数配置
type
  NET_DVR_PXMULTICTRL_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwMultiChansWaitTime: DWORD;  //多角度抓拍匹配时间（1~300s）
    byMultiChansCapEnabled: BYTE;  //是否启用多角度抓拍 0-否，1-是
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_PXMULTICTRL_CFG = ^NET_DVR_PXMULTICTRL_CFG;

//停车场票箱脱机下参数配置
type
  NET_DVR_PXOFFLINE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否启用票箱脱机模式：0-不启用 1-启用
    byChargeEnabled: BYTE;  //是否脱机收费 0-否，1-是
    byAlarmEnabled: BYTE;  //是否启用脱机报警 0-否，1-是
    byRecordSource: BYTE;  //记录产生依据 0-牌识 1-读卡
    dwTimeWait: DWORD;  //票箱进入脱机模式前的等待时间（1-300秒）
    {*
     realeaseMode&(0x1<<0) 固定车放行
     realeaseMode&(0x1<<1) 固定卡放行
     realeaseMode&(0x1<<2) 临时车放行
     realeaseMode&(0x1<<3) 临时卡放行
     realeaseMode&(0x1<<4) 无车牌放行
     realeaseMode&(0x1<<5) 固定车若免费则自动放行
     realeaseMode&(0x1<<6) 临时车若免费则自动放行
    }
    dwRealeaseMode: DWORD;  //放行方式，按位表示
    byVehCardmatch: BYTE;  //车卡一致  0-否，1-是
    bySingleInSingleOut: BYTE;  //单进单出 0-否，1-是
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_PXOFFLINE_CFG = ^NET_DVR_PXOFFLINE_CFG;

type
  NET_DVR_PARKINGSAPCE_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwTotalParkingLot: DWORD;  //总停车位数
    dwCurrParkingLot: DWORD;  //当前剩余停车位数
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PARKINGSAPCE_CFG = ^NET_DVR_PARKINGSAPCE_CFG;

type
  NET_DVR_PAPERCHARGEINFO_CFG = record 
    dwSize: DWORD;  //结构体大小
    szBarCode: array[0..LEN_16-1] of AnsiChar;  //条形码（16位字符串）
    szLicense: array[0..MAX_LICENSE_LEN-1] of AnsiChar;  //车牌号码
    szVehicleInTime: array[0..LEN_32-1] of AnsiChar;  //入场时间（32位字符串 YYYY-MM-DD HH:MM:SS）
    szPaymentTime: array[0..LEN_32-1] of AnsiChar;  //缴费时间（32位字符串 YYYY-MM-DD HH:MM:SS）
    fPaymentAmount: FLOAT;  //缴费金额
    dwPaymentOutFailureTime: DWORD;  //缴费出场失效时间（DWORD）
    byVehicleOutEnabled: BYTE;  //是否出场: 0- 否，1- 是
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PAPERCHARGEINFO_CFG = ^NET_DVR_PAPERCHARGEINFO_CFG;

//停车场票箱参数
type
  NET_DVR_ILLEGALCARDFILTERING_CFG = record 
    dwSize: DWORD;  //结构体大小
    sLEDDefaultInfo: array[0..MAX_LED_INFO_LEN{512}-1] of AnsiChar;  // LED默认显示内容
    byillegalCardFilteringEnabled: BYTE;  //启用非法卡过滤,0~不启用，1~启用
    bySendCardSensingCoilEnabled: BYTE;  //发卡机是否关联地感线圈
    byWiegendSensingCoilEnabled: BYTE;  //远距离卡是否关联地感线圈
    byGateSwitchEnabled: BYTE;  //是否有道闸开关信息
    byVerifyKeyWriteCardEnabled: BYTE;  //是否验证密钥和写卡
    byNoplateTakeCardEnabled: BYTE;  // 是否启用无车牌取凭据放行
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_ILLEGALCARDFILTERING_CFG = ^NET_DVR_ILLEGALCARDFILTERING_CFG;


//停车场出入口车卡收费规则规则条件结构
type
  NET_DVR_TME_CHARGERULE_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    szCardNo: array[0..32-1] of AnsiChar;  //卡号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_TME_CHARGERULE_COND = ^NET_DVR_TME_CHARGERULE_COND;

//LED屏幕显示参数
type
  NET_DVR_LEDDISPLAY_CFG = record 
    dwSize: DWORD;  //结构体大小
    sDisplayInfo: array[0..MAX_LED_INFO_LEN{512}-1] of AnsiChar;  // LED显示内容
    byDisplayMode: BYTE;  //显示方式:0~左移,1~右移,2~立即显示
    bySpeedType: BYTE;  //速度类型:0~快,1~中,2~慢
    byShowPlateEnable: BYTE;  //显示车牌使能，0~关闭，1~启用
    byRes1: BYTE;  
    dwShowTime: DWORD;  //显示时长，1~60秒
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LEDDISPLAY_CFG = ^NET_DVR_LEDDISPLAY_CFG;

//语音播报控制参数
type
  NET_DVR_VOICEBROADCAST_CFG = record 
    dwSize: DWORD;  //结构体大小
    sInfo: array[0..MAX_VOICE_INFO_LEN{128}-1] of AnsiChar;  //语音播报内容
    byBroadcastNum: BYTE;  // 语音播报次数， 1~10次
    byIntervalTime: BYTE;  // 语音播报间隔时间,1~5s
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_VOICEBROADCAST_CFG = ^NET_DVR_VOICEBROADCAST_CFG;

//纸票打印格式参数
type
  NET_DVR_PAPERPRINTFORMAT_CFG = record 
    dwSize: DWORD;  //结构体大小
    sTitleInfo: array[0..MAX_LITLE_INFO_LEN{64}-1] of AnsiChar;  //纸票标题内容
    sCustomInfo: array[0..MAX_CUSTOM_INFO_LEN{64}-1] of AnsiChar;  //纸票自定义信息内容
    sPhoneNum: array[0..MAX_PHONE_NUM_LEN{16}-1] of AnsiChar;  //联系电话
    byPrintInTimeEnabled: BYTE;  //是否打印入场时间
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_PAPERPRINTFORMAT_CFG = ^NET_DVR_PAPERPRINTFORMAT_CFG;


//智能锁闸时间段
type
  NET_DVR_LOCKGATE_TIME_CFG = record 
    sBeginTime: array[0..LEN_32-1] of AnsiChar;  //开始时间（32位字符串 HH:MM:SS）
    sEndTime: array[0..LEN_32-1] of AnsiChar;  //结束时间（32位字符串 HH:MM:SS）
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_LOCKGATE_TIME_CFG = ^NET_DVR_LOCKGATE_TIME_CFG;

//智能锁闸参数
type
  NET_DVR_LOCKGATE_CFG = record 
    dwSize: DWORD;  //结构体大小
    struTime: array[0..LOCKGATE_TIME_NUM-1] of NET_DVR_LOCKGATE_TIME_CFG;  //智能锁闸时间段
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LOCKGATE_CFG = ^NET_DVR_LOCKGATE_CFG;

//数据同步状态
type
  NET_DVR_PARKING_DATASTATE_INFO = record 
    dwSize: DWORD;  
    szAppSerialNum: array[0..MAX_APP_SERIALNUM_LEN{32}-1] of AnsiChar;  //应用序列号, 代表当前所连接的应用
    dwParkingNum: DWORD;  //当前停车场号
    dwUpdataSerialNum: DWORD;  //更新序列号; 代表最后更新的序列号。
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_PARKING_DATASTATE_INFO = ^NET_DVR_PARKING_DATASTATE_INFO;

//联动EPTZ参数
type
  NET_DVR_EPTZ_CFG = record 
    dwSize: DWORD;  
    byEnableEPTZ: BYTE;  //是否启用EPTZ, 0-不启用，1 -启用
    byRes: array[0..503-1] of BYTE;  
  end;
  LPNET_DVR_EPTZ_CFG = ^NET_DVR_EPTZ_CFG;

//中心点参数
type
  NET_DVR_CENTER_POINT_CFG = record 
    dwSize: DWORD;  
    struRegion: NET_VCA_POLYGON;  //区域范围
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_CENTER_POINT_CFG = ^NET_DVR_CENTER_POINT_CFG;

//*******************************DS-TME4XX控制机开发 End***************************

//*******************************IPC FF车牌 Start***************************
type
  NET_DVR_FTPUPLOAD_PARAM = record 
    szRuleTypeItem: array[0..MAX_SINGLE_FTPPICNAME_LEN{20}-1] of AnsiChar;  
    szCameraName: array[0..MAX_CAMNAME_LEN{32}-1] of AnsiChar;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_FTPUPLOAD_PARAM = ^NET_DVR_FTPUPLOAD_PARAM;

//char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
//里面内容是固定字符串  capture_time,plate_No,alarm_type,camera_name
//数组下标表示先后顺序

//char szCameraName[MAX_CAMNAME_LEN/*32*/];
//依赖于szRuleTypeItem中字段表示内容为 camera_name 的情况

type
  NET_DVR_FTPUPLOADCFG = record 
    dwSize: DWORD;  
    byEventType: BYTE;  //事件类型，0-默认，1-车辆检测
    byMode: BYTE;  //图片命名模式，0-默认，1-自定义
    byRes: array[0..62-1] of BYTE;  
    struCustomVehicle: array[0..MAX_FTPNAME_NUM{12}-1] of NET_DVR_FTPUPLOAD_PARAM;  
    byRes1: array[0..1024-1] of BYTE;  
  end;
  LPNET_DVR_FTPUPLOADCFG = ^NET_DVR_FTPUPLOADCFG;

//*******************************IPC FF车牌 End***************************

//信息发布终端升级
type
  NET_DVR_PUBLISH_UPGRADE_COND = record 
    dwSize: DWORD;  
    dwUpgradeType: DWORD;  //升级类型，1-按终端升级，2-按终端组升级
    dwTerminalNum: DWORD;  //升级的终端格式，按终端升级时有效
    pTerminalNo: PDWORD;  //需要升级的终端号，按终端升级时有效
    dwGroupNo: DWORD;  //终端组号，按终端组升级时有效
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PUBLISH_UPGRADE_COND = ^NET_DVR_PUBLISH_UPGRADE_COND;
//WEP加密密钥
type
  NET_DVR_WEP_KEY_CFG = record 
    csWEPKey: array[0..WEP_KEY_MAX_SIZE{32}-1] of AnsiChar;  //加密密钥，
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_WEP_KEY_CFG = ^NET_DVR_WEP_KEY_CFG;

type
  NET_DVR_SUB_UPGRADE_PROGRESS = record 
    dwTerminalNo: DWORD;  //终端号
    dwProgress: DWORD;  //终端升级进度，0-100，101表示此终端升级出现异常,,102-终端解压失败，103-升级包版本不匹配，104-非升级文件，105-非法签名升级包
  end;
  LPNET_DVR_SUB_UPGRADE_PROGRESS = ^NET_DVR_SUB_UPGRADE_PROGRESS;

type
  NET_DVR_UPGRADE_PROGRESS_RESULT = record 
    dwSize: DWORD;  
    dwMainProgress: DWORD;  //主进度，0-100
    dwSubProgressNum: DWORD;  //子进度个数
    lpStruSubProgress: LPNET_DVR_SUB_UPGRADE_PROGRESS;  //各终端升级的子进度，dwSubProgressNum个NET_DVR_SUB_UPGRADE_PROGRESS内容
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_UPGRADE_PROGRESS_RESULT = ^NET_DVR_UPGRADE_PROGRESS_RESULT;

//信息发布服务器日程发布进度
type
  NET_DVR_SCHEDULE_PROGRESS_COND = record 
    dwSize: DWORD;  
    dwScheduleNo: DWORD;  //日程号
    byProgressType: BYTE;  //获取的进度类型，1-按组获取进度，2-按终端获取进度，3-按组织获取进度
    byRes1: array[0..3-1] of BYTE;  
    dwGroupNo: DWORD;  //终端组号或组织，进度类型为1，3时有效
    dwTerminalNo: DWORD;  //终端号，进度类型为2时有效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SCHEDULE_PROGRESS_COND = ^NET_DVR_SCHEDULE_PROGRESS_COND;

type
  NET_DVR_SUB_SCHEDULE_PROGRESS = record 
    dwTerminalNo: DWORD;  //终端号
    dwProgress: DWORD;  //终端日程发布进度，0-100，101表示此终端日程发布出现异常,102表示此终端存储空间不足,103-终端不在线，104-终端拒绝，105-服务器和终端网络中断
  end;
  LPNET_DVR_SUB_SCHEDULE_PROGRESS = ^NET_DVR_SUB_SCHEDULE_PROGRESS;

type
  NET_DVR_SCHEDULE_PROGRESS_RESULT = record 
    dwSize: DWORD;  
    dwMainProgress: DWORD;  //主进度，0-100，按组获取进度时为整组日程发布进度，按终端获取进度时为单个终端日程发布进度
    dwSubProgressNum: DWORD;  //子进度个数，按组获取时有效，表示组下各终端进度个数
    lpStruSubProgress: LPNET_DVR_SUB_SCHEDULE_PROGRESS;  //各终端日程发布的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_SCHEDULE_PROGRESS内容
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SCHEDULE_PROGRESS_RESULT = ^NET_DVR_SCHEDULE_PROGRESS_RESULT;

//信息发布插播进度
type
  NET_DVR_INSERTPLAY_PROGRESS_COND = record 
    dwSize: DWORD;  
    byInsertType: BYTE;  //插播类型，1-素材，2-节目
    byRes3: array[0..3-1] of BYTE;  
    dwInsertNo: DWORD;  //如果插播类型是素材，为素材编号，如果插播类型是节目，为节目编号
    byProgressType: BYTE;  //获取的进度类型，1-按组获取进度，2-按终端获取进度
    byRes1: array[0..3-1] of BYTE;  
    dwGroupNo: DWORD;  //终端组号，进度类型为1时有效
    dwTerminalNo: DWORD;  //终端号，进度类型为2时有效
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_INSERTPLAY_PROGRESS_COND = ^NET_DVR_INSERTPLAY_PROGRESS_COND;

type
  NET_DVR_SUB_INSERTPLAY_PROGRESS = record 
    dwTerminalNo: DWORD;  //终端号
    dwProgress: DWORD;  //终端插播进度，0-100，101表示此终端插播出现异常,102表示此终端存储空间不足,103表示取消插播,104插播素材被替换
  end;
  LPNET_DVR_SUB_INSERTPLAY_PROGRESS = ^NET_DVR_SUB_INSERTPLAY_PROGRESS;

type
  NET_DVR_INSERTPLAY_PROGRESS_RESULT = record 
    dwSize: DWORD;  
    dwMainProgress: DWORD;  //主进度，0-100，按组获取进度时为整组插播进度，按终端获取进度时为单个终端插播进度
    dwSubProgressNum: DWORD;  //子进度个数，按组获取时有效，表示组下各终端进度个数
    lpStruSubProgress: LPNET_DVR_SUB_INSERTPLAY_PROGRESS;  //各终端插播的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_INSERTPLAY_PROGRESS内容
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_INSERTPLAY_PROGRESS_RESULT = ^NET_DVR_INSERTPLAY_PROGRESS_RESULT;




//WEP参数
type
  NET_DVR_WEP_CFG = record 
    byAuthenticationType: BYTE;  //身份验证类型；0~开启验证；1~共享密钥；2~自动验证
    byDefaultTransmitKeyIndex: BYTE;  //默认传输密钥个数，1~4个。对应到struEncryptionKeyCfg加密密钥的个数。
    {
    当为64位密钥时，ASCII码密钥字符长度为5个。
    当为128位密钥时，ASCII码密钥字符长度为13个。
    }
    byWepKeyLenType: BYTE;  //密钥类型；0~   64位密钥，1~  128位密钥。
    byKeyType: BYTE;  // 密钥类型；0~   ASCII码，1~  16进制。
    struWEPKeyCfg: array[0..WEP_KEY_MAX_NUM{4}-1] of NET_DVR_WEP_KEY_CFG;  // WEP加密密钥，最大支持4个。
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_WEP_CFG = ^NET_DVR_WEP_CFG;

//WPA参数
type
  NET_DVR_WPA_CFG = record 
    byAlgorithmType: BYTE;  //算法类型；0~TKIP, 1~AES, 2~TKIP/AES
    byWPAKeyLen: BYTE;  // WPA共享密钥长度，区间为8~63，对应到csSharedKey参数的字符长度
    byDefaultPassword: BYTE;  //是否启用默认WPA密钥
    byRes1: BYTE;  
    csSharedKey: array[0..WPA_KEY_MAX_SIZE{64}-1] of AnsiChar;  //WPA共享密钥,为8-63个ASCII字符
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_WPA_CFG = ^NET_DVR_WPA_CFG;


type
  NET_DVR_WIRELESS_SECURITY_CFG = record 
    bySecurityMode: BYTE;  //安全模式；0~禁用,1~WEP,2~WPA-personal, 3~WPA2-personal
    struWEPCfg: NET_DVR_WEP_CFG;  //当安全模式选择为WEP时生效。
    struWPACfg: NET_DVR_WPA_CFG;  //当安全模式选择为WPA-personal、WPA2-personal时生效。
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESS_SECURITY_CFG = ^NET_DVR_WIRELESS_SECURITY_CFG;

//wifi热点参数配置(完整版)
type
  NET_DVR_WIRELESSSERVER_FULLVERSION_CFG = record 
    dwSize: DWORD;  //结构体大小
    byWifiAPEnabled: BYTE;  //是否启用无线AP：0-否，1- 是
    byBroadcastEnabled: BYTE;  // 是否启用广播，0-否，1-是
    byWlanShareEnabled: BYTE;  //是否启用共享，0-否，1-是
    byDHCPEnabled: BYTE;  //是否启用DHCP，0-否，1-是
    bySSID: array[0..IW_ESSID_MAX_SIZE-1] of BYTE;  //SSID
    byRes1: array[0..11-1] of BYTE;  
    byIPType: BYTE;  //IP地址类型，0-IPv4,1-IPv6
    struIPAddr: NET_DVR_IPADDR;  //IP地址
    struIPMask: NET_DVR_IPADDR;  //掩码地址
    struGatewayIPMask: NET_DVR_IPADDR;  //网关地址
    struStartIPAddrPool: NET_DVR_IPADDR;  //IP段起始地址
    struEndIPAddrPool: NET_DVR_IPADDR;  // IP段结束地址
    struDNSServerIpAddr: array[0..MAX_DNS_SERVER_NUM-1] of NET_DVR_IPADDR;  //DNS地址
    struWirelessSecurityCfg: NET_DVR_WIRELESS_SECURITY_CFG;  //无线安全加密参数
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG = ^NET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

type
  NET_DVR_OPTICAL_DEV_CHAN_INFO = record 
    dwChannel: DWORD;  //通道号，0为无效
    byChannelName: array[0..NAME_LEN-1] of BYTE;  
    bySignal: BYTE;  //是否有信号，0-无，1-有，只读
    bySignalType: BYTE;  //信号源类型，1-标清，2-高清，有信号时有效，只读
    byRes: array[0..10-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_DEV_CHAN_INFO = ^NET_DVR_OPTICAL_DEV_CHAN_INFO;

type
  NET_DVR_OPTICAL_DEV_NODE = record 
    byValid: BYTE;  //是否有效，0-无效，1-有效
    byRes1: array[0..3-1] of BYTE;  
    dwDevNo: DWORD;  //光端机号
    byDevName: array[0..NAME_LEN-1] of BYTE;  //节点光端机名称
    byDevID: array[0..MAX_ID_LEN-1] of BYTE;  //光端机物理ID，设备唯一标识，只读
    struChannel: array[0..MAX_CHANNUM-1] of NET_DVR_OPTICAL_DEV_CHAN_INFO;  
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_DEV_NODE = ^NET_DVR_OPTICAL_DEV_NODE;

const
  MAX_OPTICAL_DEV_NODE = 32;    //最多节点光端机数

type
  NET_DVR_OPTICAL_PORT_INFO = record 
    dwSize: DWORD;  
    byValid: BYTE;  //是否有信号接入，0-无，1-有，只读
    byLinkType: BYTE;  //链路类型，1-环网，2-链网，只读
    byPortWorkMode: BYTE;  //端口工作模式，0-无效，1-主口，2-辅口，当链路类型为环网时有效，只读
    byRes1: array[0..1-1] of BYTE;  
    dwPairPort: DWORD;  //配对光口号，链路类型为环网时有效，主口时此参数为辅口号，辅口时，此参数为主口号
    struDevInfo: array[0..MAX_OPTICAL_DEV_NODE-1] of NET_DVR_OPTICAL_DEV_NODE;  //节点光端机设备信息
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_PORT_INFO = ^NET_DVR_OPTICAL_PORT_INFO;

type
  NET_DVR_OPTICAL_CHAN_RELATE_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否关联光端机输入，0-否，非0-是
    byRes1: array[0..3-1] of BYTE;  
    dwDevNo: DWORD;  //光端机号
    dwOpticalPort: DWORD;  //光口号
    byDevID: array[0..MAX_ID_LEN-1] of BYTE;  //光端机物理ID
    dwInputChanNo: DWORD;  //光端机输入通道号
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_OPTICAL_CHAN_RELATE_CFG = ^NET_DVR_OPTICAL_CHAN_RELATE_CFG;

type
  NET_DVR_START_FILE_TO_CLOUD_COND = record 
    dwSize: DWORD;  
    aCameraID: array[0..MAX_CAMERAID_LEN-1] of BYTE;  //编码器ID
    dwPoolID: DWORD;  //存储池ID
    dwRepPoolID: DWORD;  //冗余池ID
    wReplication: WORD;  //冗余份数
    byRes: array[0..178-1] of BYTE;  
  end;
  LPNET_DVR_START_FILE_TO_CLOUD_COND = ^NET_DVR_START_FILE_TO_CLOUD_COND;

type
  NET_DVR_START_PICTURE_FROM_CLOUD_COND = record 
    dwSize: DWORD;  
    aCameraID: array[0..MAX_CAMERAID_LEN-1] of BYTE;  //编码器ID
    struBeginTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    dwPicType: DWORD;  //图片类型，按位表示
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    byRes1: array[0..3-1] of BYTE;  
    byZoomType: BYTE;  //0-不缩放,1-按比例,2-按大小,3-按分辨率
    uZoomParam: record 
      case Byte of
      0: (uLen: array[0..32-1] of BYTE);  
      1: (struScale: record
        byScale: BYTE;  //1~99
      end);  
      2: (struQuality: record
        byQuality: BYTE;  //1~99
      end);  
      3: (struResolution: record
        dwWidth: DWORD;  
        dwHeight: DWORD;  
      end);  //目标分辨率
    end;  
    fnDownloadFileCallBack: DOWNLOAD_DATA_CB;  //数据回调函数
    pUser: PVOID;  //用户数据指针
    byRes: array[0..372-1] of BYTE;  
  end;
  LPNET_DVR_START_PICTURE_FROM_CLOUD_COND = ^NET_DVR_START_PICTURE_FROM_CLOUD_COND;

type
  NET_DVR_START_PICTURE_FROM_CLOUD_RET = record 
    dwSize: DWORD;  
    dwFileCount: DWORD;  //文件数量
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_START_PICTURE_FROM_CLOUD_RET = ^NET_DVR_START_PICTURE_FROM_CLOUD_RET;

type
  NET_DVR_PICTURE_FROM_CLOUD_RET = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME_V30;  //图片时间
    dwPicLen: DWORD;  //图片长度
    byPicType: BYTE;  //图片格式,1-jpg,2-bmp,3-png
    byRes: array[0..107-1] of BYTE;  
  end;
  LPNET_DVR_PICTURE_FROM_CLOUD_RET = ^NET_DVR_PICTURE_FROM_CLOUD_RET;

type
  NET_DVR_ACS_EXTERNAL_DEV_CFG = record 
    dwSize: DWORD;  
    byIDCardUpMode: BYTE;  //身份证信息上报，0：上传18位身份证号；1：上传全部信息
    byRes1: BYTE;  
    byCardVerifyMode: BYTE;  //刷卡认证模式，0：远程中心认证；1：客户端平台认证；2：刷卡开门
    byACSDevType: BYTE;  //设备型号，1：身份证读卡器，2：IC读卡器，3：二维码读卡器，4：指纹读卡器，5：字符屏+二维码读卡器，6：收卡器，7：字符屏，8：指纹头，9：语音模块；10：人证设备
    byDoorMode: BYTE;  //门出入类型，0：进门，1：出门；
    byRes2: BYTE;  
    wDevDetailType: WORD;  //外设的具体设备型号，0-iDR210，1-IDM10，2-私有身份证阅读器
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_ACS_EXTERNAL_DEV_CFG = ^NET_DVR_ACS_EXTERNAL_DEV_CFG;

type
  NET_DVR_PERSONNEL_CHANNEL_CFG = record 
    dwSize: DWORD;  
    byInMode: BYTE;  //进门模式，0受控；1禁止；2自由；
    byOutMode: BYTE;  //出门模式，0受控；1禁止；2自由；
    byWorkMode: BYTE;  //工作模式，0紧急；1维护；2常闭；3常开；
    byRes: array[0..301-1] of BYTE;  
  end;
  LPNET_DVR_PERSONNEL_CHANNEL_CFG = ^NET_DVR_PERSONNEL_CHANNEL_CFG;

const
  MAX_ID_NUM_LEN = 32;    //最大身份证号长度
  MAX_ID_NAME_LEN = 128;    //最大姓名长度
  MAX_ID_ADDR_LEN = 280;    //最大住址长度
  MAX_ID_ISSUING_AUTHORITY_LEN = 128;    //最大签发机关长度

//身份证信息
type
  NET_DVR_ID_CARD_INFO = record 
    dwSize: DWORD;  //结构长度
    byName: array[0..MAX_ID_NAME_LEN-1] of BYTE;  //姓名
    struBirth: NET_DVR_DATE;  //出生日期
    byAddr: array[0..MAX_ID_ADDR_LEN-1] of BYTE;  //住址
    byIDNum: array[0..MAX_ID_NUM_LEN-1] of BYTE;  //身份证号码
    byIssuingAuthority: array[0..MAX_ID_ISSUING_AUTHORITY_LEN-1] of BYTE;  //签发机关
    struStartDate: NET_DVR_DATE;  //有效开始日期
    struEndDate: NET_DVR_DATE;  //有效截止日期
    byTermOfValidity: BYTE;  //是否长期有效， 0-否，1-是（有效截止日期无效）
    bySex: BYTE;  //性别，1-男，2-女
    byNation: BYTE;  
    byRes: array[0..101-1] of BYTE;  
  end;
  LPNET_DVR_ID_CARD_INFO = ^NET_DVR_ID_CARD_INFO;

//身份证信息报警
type
  NET_DVR_ID_CARD_INFO_ALARM = record 
    dwSize: DWORD;  //结构长度
    struIDCardCfg: NET_DVR_ID_CARD_INFO;  //身份证信息
    dwMajor: DWORD;  //报警主类型，参考宏定义
    dwMinor: DWORD;  //报警次类型，参考宏定义
    struSwipeTime: NET_DVR_TIME_V30;  //时间
    byNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    dwCardReaderNo: DWORD;  //读卡器编号，为0无效
    dwDoorNo: DWORD;  //门编号，为0无效
    dwPicDataLen: DWORD;  //图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    byDeviceNo: BYTE;  // 设备编号，为0时无效（有效范围1-255）
    byMask: BYTE;  //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    byCurrentEvent: BYTE;  //是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
    dwFingerPrintDataLen: DWORD;  // 指纹数据大小，不为0是表示后面带数据
    pFingerPrintData: PAnsiChar;  
    dwCapturePicDataLen: DWORD;  // 抓拍图片数据大小，不为0是表示后面带数据
    pCapturePicData: PAnsiChar;  
    dwCertificatePicDataLen: DWORD;  //证件抓拍图片数据大小，不为0是表示后面带数据
    pCertificatePicData: PAnsiChar;  
    byCardReaderKind: BYTE;  //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    byHelmet: BYTE;  //可选，是否戴安全帽：0-保留，1-未知，2-不戴安全, 3-戴安全帽
    byRes3: BYTE;  
    byIDCardInfoExtend: BYTE;  //pIDCardInfoExtend是否有效：0-无效，1-有效
    pIDCardInfoExtend: PAnsiChar;  //byIDCardInfoExtend为1时，表示指向一个NET_DVR_ID_CARD_INFO_EXTEND结构体
    dwSerialNo: DWORD;  //事件流水号，为0无效
    byRes: array[0..168-1] of BYTE;  
  end;
  LPNET_DVR_ID_CARD_INFO_ALARM = ^NET_DVR_ID_CARD_INFO_ALARM;

//扩展结构体信息
type
  NET_DVR_ID_CARD_INFO_EXTEND = record 
    byRemoteCheck: BYTE;  //是否需要远程核验（0-无效，1-不需要（默认），2-需要）
    byThermometryUnit: BYTE;  //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    byIsAbnomalTemperature: BYTE;  //人脸抓拍测温是否温度异常：1-是，0-否
    byRes2: BYTE;  
    fCurrTemperature: FLOAT;  //人脸温度（精确到小数点后一位）
    struRegionCoordinates: NET_VCA_POINT;  //人脸温度坐标
    dwQRCodeInfoLen: DWORD;  //二维码信息长度，不为0是表示后面带数据
    dwVisibleLightDataLen: DWORD;  //热成像相机可见光图片长度，不为0是表示后面带数据
    dwThermalDataLen: DWORD;  //热成像图片长度，不为0是表示后面带数据
    pQRCodeInfo: PAnsiChar;  //二维码信息指针
    pVisibleLightData: PAnsiChar;  //热成像相机可见光图片指针
    pThermalData: PAnsiChar;  //热成像图片指针
    wXCoordinate: WORD;  //x坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wYCoordinate: WORD;  //y坐标，人脸框左上角相对于图片的归一化坐标，范围0-1000
    wWidth: WORD;  //人脸框宽度，范围0-1000
    wHeight: WORD;  //人脸框高度，范围0-1000
    byHealthCode: BYTE;  //健康码状态, 0-保留, 1-未请求, 2-未申领, 3-绿码, 4-黄码, 5-红码, 6-无此人员, 7-其他错误信息（如接口异常导致查询失败）, 8-查询健康码超时
    byNADCode: BYTE;  //核酸检测结果, 0-保留, 1-未查询到核酸检测结果, 2-核酸检测阴性（代表正常）, 3-核酸检测阳性（代表确诊）, 4-核酸检测有效期已过
    byTravelCode: BYTE;  //行程编码, 0-保留, 1-14天内一直在当地, 2-14天内离开过当地, 3-14天内到过疫区, 4-其他
    byVaccineStatus: BYTE;  //打疫苗状态, 0-保留, 1-未打疫苗, 2-部分注射疫苗, 3-打过疫苗
    byRes: array[0..1012-1] of BYTE;  
  end;
  LPNET_DVR_ID_CARD_INFO_EXTEND = ^NET_DVR_ID_CARD_INFO_EXTEND;

//身份证信息禁止名单条件结构
type
  NET_DVR_ID_CARD_BLOCKLIST_COND = record 
    dwSize: DWORD;  
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_ID_CARD_BLOCKLIST_COND = ^NET_DVR_ID_CARD_BLOCKLIST_COND;

//身份证信息禁止名单参数
type
  NET_DVR_ID_CARD_BLOCKLIST_CFG = record 
    dwSize: DWORD;  
    struIDCardCfg: NET_DVR_ID_CARD_INFO;  // 身份证信息
    dwFingerPrintDataLen: DWORD;  // 身份证指纹数据大小，不为0是表示后面带数据
    pFingerPrintData: PAnsiChar;  
    dwPicDataLen: DWORD;  // 身份证图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ID_CARD_BLOCKLIST_CFG = ^NET_DVR_ID_CARD_BLOCKLIST_CFG;

//A =字母字符 [a..z, A..Z]，N = 数字字符 [0..9]，S = 特殊字符 [‘<’]，B=二进制数据
type
  NET_DVR_PASSPORT_INFO = record 
    dwSize: DWORD;  //结构长度
    byOCR: BYTE;  //0-电子护照数据，1- OCR识别数据，
    byRes1: array[0..3-1] of BYTE;  //保留
    byType: array[0..MAX_PASSPORT_TYPE_LEN-1] of BYTE;  //证件类型，数据类型A，S
    byCountryIssue: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //签发国或签发机构，数据类型A，S
    byName: array[0..MAX_PASSPORT_NAME_LEN-1] of BYTE;  //姓名，数据类型A，S
    byPassportNo: array[0..MAX_PASSPORT_NUM_LEN-1] of BYTE;  //证件号码，数据类型A，N，S
    byNationality: array[0..MAX_NATIONALITY_LEN-1] of BYTE;  //国籍 ，数据类型A，S
    struBirth: NET_DVR_DATE;  //出生日期
    struExpireDate: NET_DVR_DATE;  //有效截止日期
    bySex: BYTE;  //性别，1-男，2-女
    byRes2: array[0..35-1] of BYTE;  //保留
    byLocalName: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //本国姓名，数据类型B
    byNumber: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //个人号码，数据类型A，N，S
    byPlaceOfBirth: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //出生地，数据类型B
    byAddr: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //地址，数据类型A，N，S，B
    byPhone: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //电话，数据类型N，S
    byJob: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //职业，数据类型B
    byTitle: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //职衔，数据类型B
    byResume: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //简历，数据类型B
    byOtherNumber: array[0..MAX_PASSPORT_INFO_LEN-1] of BYTE;  //其他旅行证件号码，数据类型A，N，S，B
    byMonitoring: array[0..MAX_PASSPORT_MONITOR_LEN-1] of BYTE;  //监护信息，数据类型B
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PASSPORT_INFO = ^NET_DVR_PASSPORT_INFO;

//护照信息上传
type
  NET_DVR_PASSPORT_ALARM = record 
    dwSize: DWORD;  //结构长度
    dwMajor: DWORD;  //报警主类型，参考宏定义
    dwMinor: DWORD;  //报警次类型，参考宏定义
    struSwipeTime: NET_DVR_TIME_V30;  //时间
    byNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    dwCardReaderNo: DWORD;  //读卡器编号，为0无效
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    byRes2: array[0..11-1] of BYTE;  
    struPassportInfo: NET_DVR_PASSPORT_INFO;  //护照信息
    dwFaceDataLen: DWORD;  //人脸数据大小，不为0是表示后面带数据
    pFaceData: PAnsiChar;  
    dwPicDataLen: DWORD;  //公民证件图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  //按照 [ISO/IEC 10918-1] 格式化的公民证件图像
    dwCapturePicDataLen: DWORD;  //抓拍图片数据大小，不为0是表示后面带数据
    pCapturePicData: PAnsiChar;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_PASSPORT_ALARM = ^NET_DVR_PASSPORT_ALARM;

type
  NET_DVR_PASSNUM_INFO_ALARM = record 
    dwSize: DWORD;  //结构长度
    dwAccessChannel: DWORD;  //人员通道号
    struSwipeTime: NET_DVR_TIME_V30;  //时间
    byNetUser: array[0..MAX_NAMELEN-1] of BYTE;  //网络操作的用户名
    struRemoteHostAddr: NET_DVR_IPADDR;  //远程主机地址
    dwEntryTimes: DWORD;  //人员入次数；
    dwExitTimes: DWORD;  //人员出次数；
    dwTotalTimes: DWORD;  //人员出入总次数；
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_PASSNUM_INFO_ALARM = ^NET_DVR_PASSNUM_INFO_ALARM;
type
  NET_DVR_UPLOAD_VIDEO_INFO = record 
    dwSize: DWORD;  
    dwVideoMangeNo: DWORD;  //视频管理号
    byVideoType: BYTE;  //视频格式 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB
    byRes1: array[0..3-1] of BYTE;  //保留
    sVideoName: array[0..NAME_LEN-1] of BYTE;  //视频名称
    struTime: NET_DVR_TIME_V30;  //图片上传时间
    byRes: array[0..132-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_VIDEO_INFO = ^NET_DVR_UPLOAD_VIDEO_INFO;

type
  NET_DVR_DEVICE_FILE_INFO = record 
    dwSize: DWORD;  
    sFileName: array[0..NAME_LEN-1] of BYTE;  //文件名称
    dwManageNo: DWORD;  //(只能获取)
    struTime: NET_DVR_TIME_EX;  //文档上传时间
    byUsed: BYTE;  //是否已存在，0-不存在，1-存在 （只能获取）
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_FILE_INFO = ^NET_DVR_DEVICE_FILE_INFO;

type
  NET_DVR_PLAY_ITEM = record 
    dwSize: DWORD;  
    byItemType: BYTE;  //播放项类型，1-图片 2-视频 3-播放列表
    byRes: array[0..3-1] of BYTE;  //保留
    dwPlayManageNo: DWORD;  //播放管理号
    dwPlayPicTime: DWORD;  //播放图片时间，单位秒, (类型为图片有效)
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_PLAY_ITEM = ^NET_DVR_PLAY_ITEM;

type
  NET_DVR_DEVICE_PLAYLIST = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否有效， 0-无效  !0-有效
    byPlayType: BYTE;  //播放模式，1-循环播放
    byVaildItemNum: BYTE;  //有效播放项数量
    byRes: array[0..1-1] of BYTE;  
    struPlayItem: array[0..PLAYLIST_ITEM_NUM-1] of NET_DVR_PLAY_ITEM;  //播放项，前byVaildItemNum有效
    byPlaylistName: array[0..PLAYLIST_NAME_LEN-1] of BYTE;  //播放列表名称
    dwPlaylistNo: DWORD;  //播放列表号（获取有效）
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_DEVICE_PLAYLIST = ^NET_DVR_DEVICE_PLAYLIST;
type
  NET_DVR_PLAYLIST_ITEM_CTRL = record 
    dwSize: DWORD;  
    byCtrlType: BYTE;  //操作类型， 1-添加播放项  2-删除播放项  3-移动播放项位置
    byPlayIndex: BYTE;  //播放序号， 从1开始
    struPlayItem: NET_DVR_PLAY_ITEM;  //播放项
    byNewPlayIndex: BYTE;  //新播放序号，0无效
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_PLAYLIST_ITEM_CTRL = ^NET_DVR_PLAYLIST_ITEM_CTRL;
type
  NET_DVR_PLAN_ITEM = record 
    struPlanPlayItem: NET_DVR_PLAY_ITEM;  //播放项
    struTimeSegment: NET_DVR_TIME_SEGMENT;  //时间段参数
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PLAN_ITEM = ^NET_DVR_PLAN_ITEM;

type
  NET_DVR_PLAYPLAN_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否使能,  0-不使能 !0-使能
    byPlanMode: BYTE;  //计划模式，1-周计划  2-日计划
    byRes: array[0..2-1] of BYTE;  
    struPlanItem: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_PLAN_ITEM;  
    dwPlayPlanNo: DWORD;  //播放计划号（获取时有效）
    byPlayPlanName: array[0..NAME_LEN-1] of BYTE;  //播放计划名称
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_PLAYPLAN_CFG = ^NET_DVR_PLAYPLAN_CFG;
type
  NET_DVR_WINDOW_PLAYPLAN_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用播放计划， 0-不启用 !0-启用
    byRes: array[0..3-1] of BYTE;  
    dwPlayPlanNo: DWORD;  //播放计划号
    byRes2: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_WINDOW_PLAYPLAN_CFG = ^NET_DVR_WINDOW_PLAYPLAN_CFG;
type
  NET_DVR_DEV_PLAYCTRL = record 
    dwSize: DWORD;  
    byControlType: BYTE;  //控制类型，1-音频开，2-音频关，3-停止播放，4-暂停播放，恢复播放
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_DEV_PLAYCTRL = ^NET_DVR_DEV_PLAYCTRL;

type
  NET_DVR_PLAYITEM_INFO = record 
    case Byte of
    0: (struPlayItem: record
      dwPlayItem: DWORD;  //播放项
      byPlayItemName: array[0..NAME_LEN-1] of BYTE;  //播放项名称
      byRes2: array[0..8-1] of BYTE;  
    end);  
    1: (struPlaylistItem: record
      dwPlaylistNo: DWORD;  //播放列表号
      byPlaylistName: array[0..NAME_LEN-1] of BYTE;  //播放列表名称
      wPlayIndex: WORD;  //播放位置
      byPlayType: BYTE;  //播放列表中正在播放类型 1-图片 2-视频
      byRes: array[0..3-1] of BYTE;  
      dwPlayItem: DWORD;  //播放项
      byPlayItemName: array[0..NAME_LEN-1] of BYTE;  //播放项名称
      byRes2: array[0..16-1] of BYTE;  
    end);  
    2: (struPlayPlanItem: record
      dwPlayPlanNo: DWORD;  //播放计划号
      struTime: NET_DVR_TIME_SEGMENT;  //正在播放时间段
      byPlayType: BYTE;  //播放计划正在播放类型  1-图片 2-视频 3-播放列表
      byRes: array[0..3-1] of BYTE;  
      dwPlaylistNo: DWORD;  //播放列表号
      byPlaylistName: array[0..NAME_LEN-1] of BYTE;  //播放列表名称
      dwPlayItem: DWORD;  //播放项
      byPlayItemName: array[0..NAME_LEN-1] of BYTE;  //播放项名称
      wPlayIndex: WORD;  //播放位置
      byRes2: array[0..18-1] of BYTE;  
    end);  
  end;
  LPNET_DVR_PLAYITEM_INFO = ^NET_DVR_PLAYITEM_INFO;
type
  NET_DVR_PLAYING_INFO = record 
    dwSize: DWORD;  
    byPlayWay: BYTE;  //播放方式， 1-单项播放  2-播放列表  3-播放计划 4-动态解码 5-紧急插播
    byCurPlayType: BYTE;  //正在播放素材类型， 1-图片 2-视频，动态解码和紧急插播时无效
    byPlayState: BYTE;  //播放状态，1-正在播放，2-播放停止，3-播放暂停
    byAudioState: BYTE;  //音频开关状态，0-关，1-开
    struPlayItemInfo: NET_DVR_PLAYITEM_INFO;  //播放项信息
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PLAYING_INFO = ^NET_DVR_PLAYING_INFO;

type
  NET_DVR_ONLINEUSER_COND = record //条件结构
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号（前端默认是1）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUSER_COND = ^NET_DVR_ONLINEUSER_COND;

type
  NET_DVR_ONLINEUSER_CFG = record //配置结构
    dwSize: DWORD;  
    byID: BYTE;  //用户序列号
    byUserType: BYTE;  //用户类型 0-普通用户，1-操作员，2-超级用户
    byDataType: BYTE;  //数据状态类型:0-检测中，1-开始，2-结束
    byRes: BYTE;  
    struIpAddr: NET_DVR_IPADDR;  //IP地址
    struLoginTime: NET_DVR_TIME_V30;  //登陆时间
    szUserName: array[0..NAME_LEN{32}-1] of AnsiChar;  //用户名
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ONLINEUSER_CFG = ^NET_DVR_ONLINEUSER_CFG;

//存储健康状态
type
  NET_DVR_STORAGE_DETECTION = record 
    dwSize: DWORD;  //结构体大小
    byHealthState: BYTE;  //健康状态0-良好，1-差，2-损坏，3-未知
    bySDCardState: BYTE;  //SDcard状态 0-掉线，1-上线,2-未知,3-已锁定
    wAbnormalPowerLoss: WORD;  //异常掉电数
    wBadBlocks: WORD;  //坏块数
    byRemainingLife: BYTE;  //SD卡剩余寿命; 0~100%
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_DETECTION = ^NET_DVR_STORAGE_DETECTION;

//存储智能检测报警上传
type
  NET_DVR_STORAGE_DETECTION_ALARM = record 
    dwSize: DWORD;  
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwCardID: DWORD;  //卡ID
    wAbnormalPowerLoss: WORD;  //异常掉电数
    wBadBlocks: WORD;  //坏块数
    byHealthState: BYTE;  //健康状态0-良好，1-差，2-损坏，3-未知
    byRes1: array[0..3-1] of BYTE;  
    fResidualLife: FLOAT;  //SD卡 预计剩余寿命
    byRes: array[0..118-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_DETECTION_ALARM = ^NET_DVR_STORAGE_DETECTION_ALARM;


//存储侦测的读写锁配置
type
  NET_DVR_STORAGE_RWLOCK = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //使能 0-关闭，1-开启
    byRes: array[0..3-1] of BYTE;  
    szPassWD: array[0..PASSWD_LEN{16}-1] of AnsiChar;  //读写锁新密码
    szOriginalPassWD: array[0..PASSWD_LEN{16}-1] of AnsiChar;  //原始密码
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_RWLOCK = ^NET_DVR_STORAGE_RWLOCK;

//存储侦测的解锁配置
type
  NET_DVR_STORAGE_UNLOCK = record 
    dwSize: DWORD;  //结构体大小
    szPassWD: array[0..PASSWD_LEN{16}-1] of AnsiChar;  //密码
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_STORAGE_UNLOCK = ^NET_DVR_STORAGE_UNLOCK;


type
  NET_DVR_PTZTRACKSTATUS = record 
    dwSize: DWORD;  //结构体大小
    byID: BYTE;  //联动设备的ID (字段byLinkageType非0的时候生效)
    byLinkageType: BYTE;  //联动动作0-不联动，1-联动球机设备
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_PTZTRACKSTATUS = ^NET_DVR_PTZTRACKSTATUS;

const
  MAX_PROXY_COUNT = 32;    

type
  NET_DVR_SOCKS_PROXY_PARA = record 
    byIP: array[0..129-1] of BYTE;  //代理服务器地址
    byAuthType: BYTE;  //认证方式，暂时先不使用该字段
    wPort: WORD;  //代理服务器端口
    byRes2: array[0..64-1] of BYTE;  //如果要使用认证方式，必然需要一些保留字节，先留一些
  end;
  LPNET_DVR_SOCKS_PROXY_PARA = ^NET_DVR_SOCKS_PROXY_PARA;

type
  NET_DVR_SOCKS_PROXYS = record 
    struProxy: array[0..MAX_PROXY_COUNT-1] of NET_DVR_SOCKS_PROXY_PARA;  
  end;
  LPNET_DVR_SOCKS_PROXYS = ^NET_DVR_SOCKS_PROXYS;

type
  NET_DVR_GET_FIGURE_COND = record 
    dwLength: DWORD;  //结构长度
    dwChannel: DWORD;  //通道
    struTimePoint: NET_DVR_TIME_V30;  //时间点
    byID: array[0..STREAM_ID_LEN{32}-1] of BYTE;  //ID数据
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_GET_FIGURE_COND = ^NET_DVR_GET_FIGURE_COND;

type
  NET_DVR_FIGURE_INFO = record 
    dwPicLen: DWORD;  //图片长度
    pPicBuf: PAnsiChar;  //图片数据
  end;
  LPNET_DVR_FIGURE_INFO = ^NET_DVR_FIGURE_INFO;

//手动测距参数
type
  NET_DVR_MANUALRANGING_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否开启手动测距：0- 否，1- 是
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_MANUALRANGING_CFG = ^NET_DVR_MANUALRANGING_CFG;

type
  NET_DVR_VIDEO_INTERCOM_ALARM_CFG = record 
    dwSize: DWORD;  //结构体大小
    byDoorNotCloseAlarm: BYTE;  //是否上传门未关报警，0-不上传，1-上传
    byRes: array[0..603-1] of BYTE;  //保留
  end;
  LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG = ^NET_DVR_VIDEO_INTERCOM_ALARM_CFG;

type
  NET_DVR_PACKET_INFO_EX = record 
    wWidth: WORD;  //width
    wHeight: WORD;  //height
    dwTimeStamp: DWORD;  //lower time stamp
    dwTimeStampHigh: DWORD;  //higher time stamp
    dwYear: DWORD;  //year
    dwMonth: DWORD;  //month
    dwDay: DWORD;  //day
    dwHour: DWORD;  //hour
    dwMinute: DWORD;  //minute
    dwSecond: DWORD;  //second
    dwMillisecond: DWORD;  //millisecond
    dwFrameNum: DWORD;  //frame num
    dwFrameRate: DWORD;  //frame rate,当帧率小于0时，0x80000002:表示1/2帧率，同理可推0x80000010为1/16帧率
    dwFlag: DWORD;  //flag E帧标记
    dwFilePos: DWORD;  //file pos
    dwPacketType: DWORD;  //Packet type:0 -file head，1 -video I frame，2- video B frame， 3- video P frame， 10- audio packet， 11- private packet
    dwPacketSize: DWORD;  //packet size
    pPacketBuffer: PBYTE;  //packet buffer
    byRes1: array[0..4-1] of BYTE;  
    dwPacketMode: DWORD;  //打包方式:0-保留，1-FU_A打包方式
    byRes2: array[0..16-1] of BYTE;  
    dwReserved: array[0..6-1] of DWORD;  //reserved[0] 表示私有数据类型
    //reserved[1] 表示私有裸数据地址高位
    //reserved[2] 表示私有裸数据地址低位
    //reserved[3] 表示私有裸数据长度
    //reserved[4] 私有帧/包的时间间隔\时间戳
    //reserved[5].一bit位标记是否为深P帧，深P：1，不为深P：0;     lizhonghu 20150203
  end;
  LPNET_DVR_PACKET_INFO_EX = ^NET_DVR_PACKET_INFO_EX;

type
  DEV_WORK_STATE_CB = function(pUserdata: PVOID; iUserID: INT; lpWorkState: LPNET_DVR_WORKSTATE_V40): BOOL; stdcall;

type
  NET_DVR_CHECK_DEV_STATE = record 
    dwTimeout: DWORD;  //定时检测设备工作状态，单位ms，为0时，表示使用默认值(30000)。最小值为1000
    fnStateCB: DEV_WORK_STATE_CB;  
    pUserData: PVOID;  
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_CHECK_DEV_STATE = ^NET_DVR_CHECK_DEV_STATE;

const
  COURSE_NAME_LEN_128 = 128;    //课程名称
  INSTRUCTOR_NAME_LEN_64 = 64;    //授课教师
  MAX_UUID_LEN = 64;    //手动课程UUID

//获取条件结构体
type
  NET_DVR_COURSE_LIST_COND = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_V30;  //课程开始时间
    struEndTime: NET_DVR_TIME_V30;  //课程结束时间
    byCourseName: array[0..COURSE_NAME_LEN_128-1] of BYTE;  //课程名称
    byInstructorName: array[0..INSTRUCTOR_NAME_LEN_64-1] of BYTE;  //授课老师
    byCourseType: BYTE;  //课表类型，0-全部，1-手动
    byRes: array[0..603-1] of BYTE;  
  end;
  LPNET_DVR_COURSE_LIST_COND = ^NET_DVR_COURSE_LIST_COND;

type
  NET_DVR_COURSE_CFG = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_V30;  //课程开始时间
    struEndTime: NET_DVR_TIME_V30;  //课程开始时间
    byCourseName: array[0..COURSE_NAME_LEN_128-1] of BYTE;  
    byInstructorName: array[0..INSTRUCTOR_NAME_LEN_64-1] of BYTE;  
    byCourseDescription: array[0..COURSE_DESCRIPTION_LEN{256}-1] of BYTE;  
    byRecUUID: array[0..MAX_UUID_LEN{64}-1] of BYTE;  //手动课表UUID
    byCourseType: BYTE;  //课表类型，0-全部，1-手动课表
    byRes: array[0..303-1] of BYTE;  
  end;
  LPNET_DVR_COURSE_CFG = ^NET_DVR_COURSE_CFG;

type
  NET_DVR_RECORD_STATUS = record 
    dwSize: DWORD;  //结构体大小
    byRecUUID: array[0..MAX_UUID_LEN{64}-1] of BYTE;  //手动课表UUID
    byRecordStatus: BYTE;  //录播状态，0-暂停，1-屏蔽,2-正在录像，3-空闲
    byRes1: array[0..3-1] of BYTE;  //保留字节
    dwRecordingTime: DWORD;  //已录制时长，单位：秒，最大为12*60*60
    byRes: array[0..596-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_RECORD_STATUS = ^NET_DVR_RECORD_STATUS;

type
  NET_DVR_MANUAL_CURRICULUM_CFG = record 
    dwSize: DWORD;  //结构体大小
    byRecUUID: array[0..MAX_UUID_LEN{64}-1] of BYTE;  //手动课表UUID
    byCourseName: array[0..COURSE_NAME_LEN_128-1] of BYTE;  //课程名称
    byInstructorName: array[0..INSTRUCTOR_NAME_LEN_64-1] of BYTE;  //授课老师
    byCourseDescription: array[0..COURSE_DESCRIPTION_LEN{256}-1] of BYTE;  
    byCmdType: BYTE;  //命令，0-开始录像 1-结束 2-暂停 3-继续,4-开始屏蔽，5-结束屏蔽
    byRes: array[0..303-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_MANUAL_CURRICULUM_CFG = ^NET_DVR_MANUAL_CURRICULUM_CFG;

type
  NET_DVR_IMAGE_DIFF_DETECTION_CFG = record 
    dwSize: DWORD;  //结构体大小
    struRegion: NET_VCA_POLYGON;  //区域范围
    byEnabled: BYTE;  //是否启用，0-不启用，1-启用
    byThreshold: BYTE;  //阈值[0,100]
    bySensitivity: BYTE;  //灵敏度 [0,100]
    byVideoInputType: BYTE;  //视频输入口类型，0-自动，1-HDMI，2-VGA
    byRes: array[0..300-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_IMAGE_DIFF_DETECTION_CFG = ^NET_DVR_IMAGE_DIFF_DETECTION_CFG;

type
  NET_DVR_RECORDING_PUBLISH_FILE_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  
    byFileID: array[0..MAX_ID_LEN_128{128}-1] of BYTE;  //发布文件ID
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_RECORDING_PUBLISH_FILE_COND = ^NET_DVR_RECORDING_PUBLISH_FILE_COND;

type
  NET_DVR_RECORDING_PUBLISH_FILE_INFO = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_V30;  //课程开始时间
    struEndTime: NET_DVR_TIME_V30;  //课程开始时间
    byCourseName: array[0..COURSE_NAME_LEN_128-1] of BYTE;  
    byInstructorName: array[0..INSTRUCTOR_NAME_LEN_64-1] of BYTE;  
    byCourseDescription: array[0..COURSE_DESCRIPTION_LEN{256}-1] of BYTE;  
    byRes: array[0..300-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_RECORDING_PUBLISH_FILE_INFO = ^NET_DVR_RECORDING_PUBLISH_FILE_INFO;

//屏幕控制
type
  NET_DVR_SCREEN_POINT = record 
    wX: WORD;  //X坐标
    wY: WORD;  //Y坐标
  end;
  LPNET_DVR_SCREEN_POINT = ^NET_DVR_SCREEN_POINT;

type
  NET_DVR_MOUSE_PARAM = record 
    byMouseEvent: BYTE;  //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                                         //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                                         //10-滚轮松开，11-滚轮向下，12-滚轮向上
    byRes1: array[0..3-1] of BYTE;  
    struMousePoint: NET_DVR_SCREEN_POINT;  //鼠标坐标信息
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_MOUSE_PARAM = ^NET_DVR_MOUSE_PARAM;

type
  NET_DVR_MARK_PARAM = record 
    byMarkEvent: BYTE;  //标注事件，1-正常标注，2-标注结束，3-更新标注工具状态
    byMarkTool: BYTE;  //标注工具，0-无效，1-画笔，2-橡皮擦，标注事件为1时有效
    byLineWidth: BYTE;  //线条粗细，0-无效，1-细，2-中，3-粗，标注事件为1时有效
    byMouseEvent: BYTE;  //鼠标事件，标注事件为1时有效，0-无效，1-鼠标左键按下，2-鼠标左键松开，3-鼠标移动
    struColor: NET_DVR_RGB_COLOR;  //标注颜色，标注工具为画笔时有效
    struPoint: NET_DVR_SCREEN_POINT;  //标注坐标信息
    byRes: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_MARK_PARAM = ^NET_DVR_MARK_PARAM;

type
  NET_DVR_KEYBOARD_PARAM = record 
    dwKeyValue: DWORD;  //符号使用ASCII表中的值，特殊按键待确定
    byRes: array[0..12-1] of BYTE;  
  end;
  LPNET_DVR_KEYBOARD_PARAM = ^NET_DVR_KEYBOARD_PARAM;

type
  NET_DVR_PPT_PARAM = record 
    byPPTAction: BYTE;  //PPT动作，1-打开放映，2-停止放映，3-上一个动画，4-下一个动画，
                                    //5-上一页，6-下一页，7-跳到X页，8-激光笔开，9-激光笔关，10-激光笔移动
    byRes1: array[0..3-1] of BYTE;  
    struPoint: NET_DVR_SCREEN_POINT;  //激光笔坐标信息，PPT动作为10时有效
    dwPPTNo: DWORD;  //PPT页码数，PPT动作为7时有效
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_PPT_PARAM = ^NET_DVR_PPT_PARAM;

type
  NET_DVR_REMOTE_CTRL_PARAM = record 
    byRemoteCtrlCmd: BYTE;  //远程控制命令，1-切换置顶窗口，2-关闭屏幕当前窗口，3-打开文件，4-关闭文件，5-删除文件，6-关机，7-显示桌面，8-表扬
    byRes1: array[0..3-1] of BYTE;  
    dwCtrlParam: DWORD;  //操作参数，当byRemoteCtrlCmd为3、4、5时，表示操作的文件索引；当byRemoteCtrlCmd为8时表示表扬类型，0-无效，1-表扬
    byRes2: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_REMOTE_CTRL_PARAM = ^NET_DVR_REMOTE_CTRL_PARAM;

type
  NET_DVR_SPOTLIGHT_PARAM = record 
    byCmd: BYTE;  //聚光灯命令，0-关闭聚光灯，1-开启聚光灯，2-聚光灯位置移动
    byRes1: array[0..3-1] of BYTE;  
    struPoint: NET_DVR_SCREEN_POINT;  //聚光灯中心点坐标，聚光灯位置移动时有效
    dwRadius: DWORD;  //聚光灯半径
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_SPOTLIGHT_PARAM = ^NET_DVR_SPOTLIGHT_PARAM;

type
  NET_DVR_TOUCHPAD_PARAM = record 
    byMouseEvent: BYTE;  //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                        //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                        //10-滚轮松开，11-滚轮向下，12-滚轮向上
    byRes1: array[0..3-1] of BYTE;  
    iXDisplacement: INT;  //X轴位移，正数表示向右移动，负数表示向左移动，鼠标移动时有效
    iYDisplacement: INT;  //Y轴位移，正数表示向上移动，负数表示向下移动，鼠标移动时有效
    byRes2: array[0..4-1] of BYTE;  
  end;
  LPNET_DVR_TOUCHPAD_PARAM = ^NET_DVR_TOUCHPAD_PARAM;

type
  NET_DVR_MEDIA_LIST_PARAM = record 
    byOperateCmd: BYTE;  //操作命令，1-显示图片素材，2-显示视频素材，3-显示ppt素材，4-关闭多媒体文件夹
    byRes: array[0..15-1] of BYTE;  
  end;
  LPNET_DVR_MEDIA_LIST_PARAM = ^NET_DVR_MEDIA_LIST_PARAM;

type
  NET_DVR_SCREEN_CTRL_PARAM = record 
    case Byte of
    0: (struMouseParam: NET_DVR_MOUSE_PARAM);  //鼠标参数，命令类型为1时有效
    1: (struMarkParam: NET_DVR_MARK_PARAM);  //标注参数，命令类型为2时有效
    2: (struKeyboardInfo: NET_DVR_KEYBOARD_PARAM);  //键盘参数，命令类型为3时有效
    3: (struPPTParam: NET_DVR_PPT_PARAM);  //PPT参数，命令类型为4时有效
    4: (struRemoteCtrlParam: NET_DVR_REMOTE_CTRL_PARAM);  //远程操作参数，命令类型为5时有效
    5: (struSpotLight: NET_DVR_SPOTLIGHT_PARAM);  //聚光灯参数，命令类型为6时有效
    6: (struTouchPadParam: NET_DVR_TOUCHPAD_PARAM);  //触摸板参数，命令参数为7时有效
    7: (struMediaListParam: NET_DVR_MEDIA_LIST_PARAM);  //多媒体参数，命令类型为8时有效
    8: (byRes: array[0..16-1] of BYTE);  
  end;
  LPNET_DVR_SCREEN_CTRL_PARAM = ^NET_DVR_SCREEN_CTRL_PARAM;

type
  NET_DVR_SCREEN_CTRL_CMD = record 
    dwSize: DWORD;  
    byCmdType: BYTE;  //命令类型，1-鼠标，2-标注，3-键盘，4-PPT，5-远程操作，6-聚光灯，7-触控板，8-显示多媒体材料
    byRes1: array[0..3-1] of BYTE;  
    struScreenCtrlParam: NET_DVR_SCREEN_CTRL_PARAM;  //屏幕控制参数
  end;
  LPNET_DVR_SCREEN_CTRL_CMD = ^NET_DVR_SCREEN_CTRL_CMD;

type
  NET_DVR_FILE_RESPONSE_PARAM = record 
    byFileState: BYTE;  //文件操作状态，1-文件不存在，2-打开文件失败，3-打开文件成功
    byRes1: array[0..3-1] of BYTE;  
    dwErrorFileIndex: DWORD;  //文件操作的文件索引值
    byRes2: array[0..24-1] of BYTE;  
  end;
  LPNET_DVR_FILE_RESPONSE_PARAM = ^NET_DVR_FILE_RESPONSE_PARAM;

type
  NET_DVR_PPT_RESPONSE_PARAM = record 
    byCurrentState: BYTE;  //当前PPT状态，1 - 正在放映，2 - 放映停止，3 - PPT已关闭，4 - ppt受保护或生产预览图失败，5 - 打开放映成功，6 - 打开放映失败，7 - ppt内容为空，8 - 缩略图生成失败，9 - 缩略图生成成功
    byRes1: array[0..3-1] of BYTE;  
    dwCurrentPage: DWORD;  //PPT的页数，PPT状态为1,7,8时有效
    dwFileIndex: DWORD;  //PPT文件索引值
    dwTotalPageNum: DWORD;  //PPT总页数，PPT状态为5时有效
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_PPT_RESPONSE_PARAM = ^NET_DVR_PPT_RESPONSE_PARAM;

type
  NET_DVR_SCREEN_RESPONSE_PARAM = record 
    case Byte of
    0: (byRes: array[0..32-1] of BYTE);  
    1: (struPPTParam: NET_DVR_PPT_RESPONSE_PARAM);  //PPT参数
    2: (struFileParam: NET_DVR_FILE_RESPONSE_PARAM);  //文件操作响应参数
  end;
  LPNET_DVR_SCREEN_RESPONSE_PARAM = ^NET_DVR_SCREEN_RESPONSE_PARAM;

type
  NET_DVR_SCREEN_RESPONSE_CMD = record 
    dwSize: DWORD;  
    byResponseCmd: BYTE;  //屏幕响应命令类型，1-PPT，2-文件操作
    byRes1: array[0..3-1] of BYTE;  
    struResonseParam: NET_DVR_SCREEN_RESPONSE_PARAM;  //屏幕响应参数
    byRes2: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_RESPONSE_CMD = ^NET_DVR_SCREEN_RESPONSE_CMD;

type
  NET_DVR_SCREEN_FILE_COND = record 
    dwSize: DWORD;  
    byFileType: BYTE;  //文件类型，1-图片，2-视频，3-文档，0xff-所有文件类型
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_FILE_COND = ^NET_DVR_SCREEN_FILE_COND;

type
  NET_DVR_SCREEN_FILE_INFO = record 
    dwSize: DWORD;  
    dwFileIndex: DWORD;  //文件索引，全局唯一
    byFileType: BYTE;  //文件类型，1-图片，2-视频，3-文档，4-其他
    byPictureFormat: BYTE;  //图片格式，文件类型为图片时有效，1-bmp,2-jpeg,3-png,4-swf,5-gif
    byVideoFormat: BYTE;  //视频格式，文件类型为视频时有效，1-avi,2-wmv,3-mp4,4-flv,5-vod,6-mkv,7-rmvb
    byDocumentFormat: BYTE;  //文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
    byFileName: array[0..NET_SDK_MAX_FILE_PATH-1] of BYTE;  //屏幕文件名
    dwFileSize: DWORD;  //文件大小，单位：字节
    dwPPTPage: DWORD;  //ppt页码值，仅当获取已打开的PPT文件信息时有效
    byOtherFileFormat: array[0..8-1] of BYTE;  //其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
    byRes1: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_FILE_INFO = ^NET_DVR_SCREEN_FILE_INFO;

type
  NET_DVR_SCREEN_CONFIG = record 
    dwSize: DWORD;  
    byVolume: BYTE;  //音量，0-100
    byContrast: BYTE;  //对比度，0-100
    byBrightness: BYTE;  //亮度，0-100
    byScreenShowEnabled: BYTE;  //开启屏幕显示，0-关，非0-开
    byScreenLocked: BYTE;  //锁定屏幕，0-解锁，非0-锁定
    byBlackScreenEnabled: BYTE;  //屏幕黑屏，0-取消黑屏，非0-黑屏
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_DVR_SCREEN_CONFIG = ^NET_DVR_SCREEN_CONFIG;

type
  NET_DVR_SCREEM_FILE_UPLOAD_PARAM = record 
    dwSize: DWORD;  
    byFileType: BYTE;  //文件类型，1-图片，2-视频，3-文档，4-其他
    byPictureFormat: BYTE;  //图片格式，1-BMP，2-JPEG，3-PNG，4-SWF，5-GIF，文件类型为1时有效
    byVideoFormat: BYTE;  //视频格式，1-AVI，2-WMV，3-MP4，4-FLV，5-VOD，6-MKV，7-RMVB，文件类型为2时有效
    byDocumentFormat: BYTE;  //文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
    byFileName: array[0..NET_SDK_MAX_FILE_PATH-1] of BYTE;  //文件名称
    byOtherFileFormat: array[0..8-1] of BYTE;  //其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
    byRes1: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM = ^NET_DVR_SCREEM_FILE_UPLOAD_PARAM;

type
  NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM = record 
    dwSize: DWORD;  
    dwFileIndex: DWORD;  //文件索引
    dwPPTPageNo: DWORD;  //下载PPT页面图片时有效，为0表示下载PPT本身，其他值表示PPT页码值
    byRes2: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM = ^NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;

type
  NET_DVR_TV_SCREEN_COND = record 
    dwSize: DWORD;  //结构长度
    dwChannel: DWORD;  //通道号
    wTVScreenNo: WORD;  //导播屏编号 0-全部导播屏
    byRes: array[0..62-1] of BYTE;  //保留
  end;
  LPNET_DVR_TV_SCREEN_COND = ^NET_DVR_TV_SCREEN_COND;

type
  NET_DVR_TV_SCREEN_CFG = record 
    dwSize: DWORD;  //结构长度
    dwPicStayTime: DWORD;  //画面停留时间 （0~255s）
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_TV_SCREEN_CFG = ^NET_DVR_TV_SCREEN_CFG;

//获取设备抓取图片和附加信息结构体
type
  NET_DVR_BV_CALIB_COND = record 
    dwSize: DWORD;  //结构长度
    dwChannels: DWORD;  //通道号
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_COND = ^NET_DVR_BV_CALIB_COND;

type
  NET_DVR_BV_CALIB_PIC = record 
    dwSize: DWORD;  //结构长度
    dwPicID: DWORD;  
    dwPicLen1: DWORD;  //图片1长度
    dwPicLen2: DWORD;  //图片2长度
    pPicBuffer1: PAnsiChar;  //图片缓存
    pPicBuffer2: PAnsiChar;  //图片缓存
    byRes: array[0..600-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_PIC = ^NET_DVR_BV_CALIB_PIC;


//获取双目外参标定结果
type
  NET_DVR_BV_CALIB_PARAM = record 
    dwPicID: DWORD;  
    struPoint: NET_VCA_POINT;  //眉心坐标
    byRes: array[0..32-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_PARAM = ^NET_DVR_BV_CALIB_PARAM;

type
  NET_DVR_BV_CALIB_INFO = record 
    dwSize: DWORD;  //结构长度
    dwBVCalibNumber: DWORD;  //样本个数
    struBVCalibParam: array[0..12-1] of NET_DVR_BV_CALIB_PARAM;  
    dwHumanHeight: DWORD;  //人体真实身高，单位cm
    dwChannel: DWORD;  //通道号
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_INFO = ^NET_DVR_BV_CALIB_INFO;

type
  NET_DVR_BV_CALIB_RESULT = record 
    dwSize: DWORD;  //结构长度
    dwCameraHeight: DWORD;  //摄像机高度，单位cm
    fPitchAngle: FLOAT;  //摄像机俯视角度[0°, 60°], （浮点数 + 360）* 1000
    fInclineAngle: FLOAT;  //摄像机斜角度[-20°,20°]，（浮点数 + 360） * 1000
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_CALIB_RESULT = ^NET_DVR_BV_CALIB_RESULT;

//获取双目高度矫正数据
type
  NET_DVR_BV_HCORRECTION_COND = record 
    dwSize: DWORD;  //结构长度
    dwChannels: DWORD;  //通道号
    dwPicID: DWORD;  
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_HCORRECTION_COND = ^NET_DVR_BV_HCORRECTION_COND;

type
  NET_DVR_BV_HCORRECTION_CFG = record 
    dwSize: DWORD;  //结构长度
    dwHumanHeight: DWORD;  //人体真实身高，单位cm
    byRes: array[0..300-1] of BYTE;  //保留
  end;
  LPNET_DVR_BV_HCORRECTION_CFG = ^NET_DVR_BV_HCORRECTION_CFG;


//语音参数配置
type
  NET_DVR_TMEVOICE_CFG = record 
    dwSize: DWORD;  //结构体大小
    byVoiceSpeed: BYTE;  //语速 0~100
    byVoicePitch: BYTE;  //语调 0~100
    byVoiceVolum: BYTE;  //音量0~100
    byVoicePlateEnable: BYTE;  //车牌语音播报使能 ,0~关闭，1~启用
    {声音种类；
    3  = Xiaoyan (female, Chinese)
    51 = Jiu Xu (male, Chinese)
    52 = Duo Xu (male, Chinese)
    53 = Xiaoping (female, Chinese)
    54 = Donald Duck (male, Chinese)
    55 = Baby Xu (child, Chinese)
    }
    dwVoiceRole: DWORD;  //声音种类
    sInfo: array[0..MAX_TMEVOICE_LEN{64}-1] of AnsiChar;  //语音播报内容（出入口压线圈播报的语音内容）
    sFileName: array[0..MAX_TMEVOICE_LEN{64}-1] of AnsiChar;  //语音文件名
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_TMEVOICE_CFG = ^NET_DVR_TMEVOICE_CFG;

//输入板参数配置
type
  NET_DVR_INPUT_BOARD_CFG = record 
    dwSize: DWORD;  
    dwSlotNo: DWORD;  //输入板槽位号
    byFullFrameEnable: BYTE;  //是否开启全帧率畅显，0-不开启，1-开启
    byRes: array[0..3-1] of BYTE;  //四字节对齐
    byRes1: array[0..64-1] of BYTE;  //保留
  end;
  LPNET_DVR_INPUT_BOARD_CFG = ^NET_DVR_INPUT_BOARD_CFG;

type
  NET_DVR_INPUT_BOARD_CFG_LIST = record 
    dwSize: DWORD;  
    struBoardList: array[0..MAX_NUM_INPUT_BOARD-1] of NET_DVR_INPUT_BOARD_CFG;  //输入板配置信息列表
  end;
  LPNET_DVR_INPUT_BOARD_CFG_LIST = ^NET_DVR_INPUT_BOARD_CFG_LIST;

//*****************************安全防范视频布防联网信息安全 begin*****************************************
//获取加密设备信息条件结构体
type
  NET_DVR_ENCRYPT_DEVICE_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  //通道号
    byAlgorithm: BYTE;  //加密算法，0-保留，1-RSA,2-SM2
    byModelLen: BYTE;  //模长，0-保留，1-1024位,2-2048位,3-256位
    byCERTSaveLocation: BYTE;  //证书保存位置，根据设备返回的能力集来选择，0-保留，1-加密芯片中(通过USB插入设备),2-设备中
    byRes: array[0..29-1] of BYTE;  
  end;
  LPNET_DVR_ENCRYPT_DEVICE_COND = ^NET_DVR_ENCRYPT_DEVICE_COND;
//获取加密设备信息结构体
type
  NET_DVR_ENCRYPT_DEVICE_INFO = record 
    dwSize: DWORD;  //结构体大小
    byAlgorithm: BYTE;  //加密算法，0-保留，1-RSA,2-SM2
    byModelLen: BYTE;  //模长，0-保留，1-1024位,2-2048位,3-256位
    byRes1: array[0..30-1] of BYTE;  //保留
    dwPublicKeyLen: DWORD;  //公钥长度
    szPublicKey: array[0..MAX_PUBLIC_KEY_LEN-1] of AnsiChar;  //公钥
    szChipSerialNumber: array[0..CHIP_SERIALNO_LEN-1] of AnsiChar;  //芯片序列号
    szDeviceID: array[0..ENCRYPT_DEV_ID_LEN-1] of AnsiChar;  //设备ID
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ENCRYPT_DEVICE_INFO = ^NET_DVR_ENCRYPT_DEVICE_INFO;
//加密证书参数结构体
type
  NET_DVR_ENCRYPT_CERT_PARAM = record 
    dwSize: DWORD;  
    wCertType: WORD;  //证书类型，0-CA根证书，1-签名证书,2-加密证书，3- SM2加密密钥对
    byRes1: array[0..2-1] of BYTE;  //保留
    dwCertLen: DWORD;  //证书长度
    byRes2: array[0..32-1] of BYTE;  
    pCertBuf: PAnsiChar;  //证书缓冲区
  end;
  LPNET_DVR_ENCRYPT_CERT_PARAM = ^NET_DVR_ENCRYPT_CERT_PARAM;
//*****************************安全防范视频布防联网信息安全 end*****************************************
const
  MAX_RING_NAME_LEN_128 = 128;    //铃音名称长度
type
  NET_DVR_RING_UPLOAD_CFG = record 
    dwSize: DWORD;  
    dwRingID: DWORD;  //铃音序号，[1,8]
    byRingName: array[0..MAX_RING_NAME_LEN_128{128}-1] of BYTE;  //铃音名称
    dwRingSize: DWORD;  //文件大小
    byRingType: BYTE;  //铃音类型，0-wav
    byRes: array[0..363-1] of BYTE;  
  end;
  LPNET_DVR_RING_UPLOAD_CFG = ^NET_DVR_RING_UPLOAD_CFG;

type
  NET_DVR_RING_SEARCH_COND = record 
    dwSize: DWORD;  
    dwRingID: DWORD;  //铃音序号，傻瓜式查找，不设置此参数（设为0）表示无视序号查找
    byRes: array[0..300-1] of BYTE;  
  end;
  LPNET_DVR_RING_SEARCH_COND = ^NET_DVR_RING_SEARCH_COND;

type
  NET_DVR_RING_SEARCH_CFG = record 
    dwSize: DWORD;  
    dwRingID: DWORD;  //铃音序号，[1,8]
    byRingName: array[0..MAX_RING_NAME_LEN_128{128}-1] of BYTE;  //铃音名称
    dwRingSize: DWORD;  //文件大小
    byRingType: BYTE;  //铃音类型，0-wav
    byRes: array[0..303-1] of BYTE;  
  end;
  LPNET_DVR_RING_SEARCH_CFG = ^NET_DVR_RING_SEARCH_CFG;

//报警控制
type
  NET_DVR_ALARMCTRL_CFG = record 
    dwSize: DWORD;  
    byListenPicUploadEnabled: BYTE;  //监听图片上传使能
    byRes: array[0..259-1] of BYTE;  
  end;
  LPNET_DVR_ALARMCTRL_CFG = ^NET_DVR_ALARMCTRL_CFG;

type
  NET_DVR_VEHICLEFLOW_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byLane: BYTE;  //车道号，1~6车道,0为所有车道。
    byRes1: array[0..3-1] of BYTE;  
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLEFLOW_COND = ^NET_DVR_VEHICLEFLOW_COND;

type
  NET_DVR_VEHICLEFLOW_INFO = record 
    dwVehicleFlowValue: DWORD;  //为一个时间段内的流量
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLEFLOW_INFO = ^NET_DVR_VEHICLEFLOW_INFO;

type
  NET_DVR_VEHICLEFLOW_CFG = record 
    dwSize: DWORD;  
    struVehFlow: array[0..MAX_VEHICLEFLOW_INFO{24}-1] of NET_DVR_VEHICLEFLOW_INFO;  
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_VEHICLEFLOW_CFG = ^NET_DVR_VEHICLEFLOW_CFG;

//条件结构体
type
  NET_DVR_IPADDR_FILTER_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_IPADDR_FILTER_COND = ^NET_DVR_IPADDR_FILTER_COND;

type
  NET_DVR_TEMPHUMSENSOR = record 
    dwSize: DWORD;  //结构体长度
    byEnable: BYTE;  //使能 0-关，1-开
    byCtrlMode: BYTE;  //控制模式 0-温度阈值控制，1-湿度阈值控制，2-温湿度阈值控制
    byTemperatureValue: BYTE;  //温度阈值，0~100摄氏度,当控制模式为0或者2时生效
    byHumidityValue: BYTE;  //湿度阈值，0~100，当控制模式为1或者2时生效
    byFanSwitch: BYTE;  //风扇开关，0-关，1-开
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)。
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_TEMPHUMSENSOR = ^NET_DVR_TEMPHUMSENSOR;

//雷达测速配置
type
  NET_DVR_POSTRADARSPEED_CFG = record 
    dwSize: DWORD;  //结构体大小
    byLaneType: BYTE;  //道路类型；0~未配置,1~高速公路,2~城市快速路,0xff~其他道路
    byRes1: array[0..3-1] of BYTE;  
    dwInterval: DWORD;  //超速抓拍间隔，单位：ms
    dwSignSpeed: DWORD;  //标志限速(小车)，单位km/h
    dwSpeedLimit: DWORD;  //限速值(小车)，单位km/h
    dwBigCarSignSpeed: DWORD;  //标志限速(大车)，单位km/h
    dwBigCarSpeedLimit: DWORD;  //限速值（大车），单位km/h
    dwLowSpeedLimit: DWORD;  // 小车限低速，单位km/h
    dwBigCarLowSpeedLimit: DWORD;  // 大车限低速，单位km/h
    byCheckPostEnabled: BYTE;  //启用卡口抓拍
    byOverSpeedEnabled: BYTE;  //启用超速抓拍
    byRes: array[0..246-1] of BYTE;  
  end;
  LPNET_DVR_POSTRADARSPEED_CFG = ^NET_DVR_POSTRADARSPEED_CFG;

//雷达参数配置
type
  NET_DVR_POSTRADARPARAM_CFG = record 
    dwSize: DWORD;  //结构体大小
    bySoftWareVersion: array[0..32-1] of BYTE;  //软件版本号 只读参数
    byID: BYTE;  //串口号
    byWorkMode: BYTE;  //工作模式，0~持续,1~触头,2~触尾,3~巡逻车触尾,4~双触,0xff~其他
    bySpeedType: BYTE;  //速度格式，0~单字节,1~双字节,2~四字节,0xff~其他
    byDirectionFilter: BYTE;  //方向过滤，0~不过滤,1~输出来向,2~输出去向
    dwAngleCorrect: DWORD;  //角度修正[0,70]
    dwSensitivity: DWORD;  // 灵敏度[11,240]
    dwSpeedLowLimit: DWORD;  // 测速下限[1,150km/h]
    dwTrigDistance: DWORD;  // 触发距离[0,40m]
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_POSTRADARPARAM_CFG = ^NET_DVR_POSTRADARPARAM_CFG;

type
  NET_DVR_CLOUD_URL_COND = record 
    dwSize: DWORD;  
    byType: BYTE;  //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_CLOUD_URL_COND = ^NET_DVR_CLOUD_URL_COND;

type
  NET_DVR_CLOUD_URL = record 
    dwSize: DWORD;  
    szURL: array[0..256-1] of AnsiChar;  //云存储URL
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CLOUD_URL = ^NET_DVR_CLOUD_URL;

type
  NET_DVR_CLOUD_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //0-不开启，1-开启
    byType: BYTE;  //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    byStatus: BYTE;  //状态，只读 0-保留 1-在线 2-不在线
    byRes1: BYTE;  
    szAuthCode: array[0..CODE_LEN-1] of AnsiChar;  //授权码
    szAlias: array[0..ALIAS_LEN-1] of AnsiChar;  //别名，只读
    i64TotalCapability: INT64;  //总容量，只读，单位：MB
    i64UsedSpace: INT64;  //已用容量，只读，单位：MB
    byRes2: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CLOUD_CFG = ^NET_DVR_CLOUD_CFG;

type
  NET_DVR_CLOUD_UPLOADSTRATEGY_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRes: array[0..254-1] of BYTE;  //为将来使用流ID做保留
  end;
  LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND = ^NET_DVR_CLOUD_UPLOADSTRATEGY_COND;

type
  NET_DVR_CLOUD_UPLOADSTRATEGY = record 
    dwSize: DWORD;  
    byStrategyType: BYTE;  //策略类型0-无意义，1-录像，2-图片
    byRes1: array[0..3-1] of BYTE;  
    dwRecordType: DWORD;  //策略类型byStrategyType 为1时有效，按位表示
    //0x00: 无意义
    //0x01: 全部事件
    //0x02: 移动侦测
    //0x04: 信号量报警类型
    //0x08: 智能类型
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CLOUD_UPLOADSTRATEGY = ^NET_DVR_CLOUD_UPLOADSTRATEGY;

//录像完整性检查条件参数
type
  NET_DVR_RECORD_CHECK_COND = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  
    byCheckType: BYTE;  //检测方式,0--录像是否完整,1--录像是否完整&缺失录像的起止时间
    byRes1: array[0..3-1] of BYTE;  
    struBeginTime: NET_DVR_TIME_EX;  //检测录像的开始时间
    struEndTime: NET_DVR_TIME_EX;  //检测录像的结束时间
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_RECORD_CHECK_COND = ^NET_DVR_RECORD_CHECK_COND;

//录像完整性检查结果
type
  NET_DVR_RECORD_CHECK_RET = record 
    dwSize: DWORD;  
    byRecordNotComplete: BYTE;  //录像是否完整，0--完整,1--不完整
    byRes1: array[0..3-1] of BYTE;  
    struBeginTime: NET_DVR_TIME_EX;  //缺失录像的开始时间，byCheckType、byRecordNotComplete值都为1时有效
    struEndTime: NET_DVR_TIME_EX;  //缺失录像的结束时间，byCheckType、byRecordNotComplete值都为1时有效
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_RECORD_CHECK_RET = ^NET_DVR_RECORD_CHECK_RET;

//添加手动回传任务条件
type
  NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND = ^NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND;

//添加手动回传任务参数
type
  NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG = record 
    dwSize: DWORD;  
    struBeginTime: NET_DVR_TIME_EX;  //回传的录像开始时间
    struEndTime: NET_DVR_TIME_EX;  //回传的录像结束时间
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG = ^NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG;

//回传任务参数
type
  NET_DVR_RECORD_PASSBACK_TASK_CFG = record 
    dwSize: DWORD;  
    dwTaskID: DWORD;  //任务ID
    byRes: array[0..160-1] of BYTE;  
  end;
  LPNET_DVR_RECORD_PASSBACK_TASK_CFG = ^NET_DVR_RECORD_PASSBACK_TASK_CFG;

//获取所有手动回传任务条件参数
type
  NET_DVR_RECORD_PASSBACK_MANUAL_COND = record 
    dwSize: DWORD;  
    byType: BYTE;  //获取方式,0--获取全部剩余任务，1--根据流ID获取剩余任务, 2--获取全部任务，3--根据流ID获取任务，4―根据任务ID获取任务
    byTimeSegmentQuety: BYTE;  //是否启用时间范围查询，0-不启用，1-启用
    byRes1: array[0..2-1] of BYTE;  //保留
    struStreamInfo: NET_DVR_STREAM_INFO;  //流id信息（72字节），根据流ID获取剩余任务时有效
    struBeginTime: NET_DVR_TIME_EX;  //查询开始时间，byTimeSegmentQuety启用时有效
    struEndTime: NET_DVR_TIME_EX;  //查询结束时间，byTimeSegmentQuety启用时有效
    dwTaskID: DWORD;  //任务ID, byType等于4时有效
    byRes: array[0..108-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PASSBACK_MANUAL_COND = ^NET_DVR_RECORD_PASSBACK_MANUAL_COND;

//获取所有手动回传任务参数
type
  NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  //流id信息（72字节），根据流ID获取剩余任务时有效
    dwTaskID: DWORD;  //任务ID
    struStartTime: NET_DVR_TIME_EX;  //回传的录像开始时间
    struStopTime: NET_DVR_TIME_EX;  //回传的录像结束时间
    byTaskStatus: BYTE;  //任务状态，0--未执行，1--暂停中，2--已执行, 3--回传中, 4--回传失败, 5--执行成功，但只回传了部分录像, 6--执行成功，但前端无录像
    byRes1: array[0..3-1] of BYTE;  
    struExecuteStartTime: NET_DVR_TIME_EX;  //任务实际执行开始时间，byTaskStatus为1和2有效
    struExecuteStopTime: NET_DVR_TIME_EX;  //任务实际执行结束时间，byTaskStatus为2有效
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET = ^NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

//控制手动回传任务参数
type
  NET_DVR_RECORD_PASSBACK_MANUAL_CTRL = record 
    dwSize: DWORD;  
    byControlType: BYTE;  //控制方式,0--暂停所有手动任务，1--恢复所有手动任务
    byRes: array[0..131-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL = ^NET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

//删除手动回传任务条件
type
  NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND = record 
    dwSize: DWORD;  
    byDelType: BYTE;  //删除方式,0--根据任务ID删除，1--根据流ID删除任务，2--删除全部任务
    byRes: array[0..131-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND = ^NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

//删除手动回传任务参数
type
  NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG = record 
    dwSize: DWORD;  
    dwTaskID: DWORD;  //手动回传任务ID，根据任务ID删除任务时有效
    struStreamInfo: NET_DVR_STREAM_INFO;  //流id信息（72字节），根据流ID删除任务时有效
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG = ^NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

type
  NET_DVR_PASSBACK_DAY = record 
    byAllDay: BYTE;  //是否启用全天回传
    byRes: array[0..3-1] of BYTE;  //保留
  end;
  LPNET_DVR_PASSBACK_DAY = ^NET_DVR_PASSBACK_DAY;

type
  NET_DVR_PASSBACK_SCHED = record 
    struPassBackTime: NET_DVR_SCHEDTIME;  //回传任务时间段，开始时间-结束时间
    byRes: array[0..4-1] of BYTE;  //保留
  end;
  LPNET_DVR_PASSBACK_SCHED = ^NET_DVR_PASSBACK_SCHED;

//录像回传计划参数
type
  NET_DVR_RECORD_PASSBACK_SCH_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //是否启用，0--不启用，1--启用
    byPassBackWeek: BYTE;  //是否按周回传，0--否，1--是，值为1时struPassBackDay、struPassBackSched无效
    byRes1: array[0..2-1] of BYTE;  //保留
    struPassBackDay: array[0..MAX_DAYS-1] of NET_DVR_PASSBACK_DAY;  //全天回传计划
    struPassBackSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_PASSBACK_SCHED;  //时间段回传计划
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PASSBACK_SCH_CFG = ^NET_DVR_RECORD_PASSBACK_SCH_CFG;

//回传历史录像计划参数
type
  NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG = record 
    dwSize: DWORD;  //版本头
    byEnable: BYTE;  //是否启用，0--不启用，1--启用
    byRes1: array[0..3-1] of BYTE;  //保留
    struPassBackDay: array[0..MAX_DAYS-1] of NET_DVR_PASSBACK_DAY;  //全天回传计划
    struPassBackSched: array[0..MAX_DAYS-1, 0..MAX_TIMESEGMENT_V30-1] of NET_DVR_PASSBACK_SCHED;  //时间段回传计划
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG = ^NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG;

//录像卷参数
type
  NET_DVR_DEV_STORAGE_CFG = record 
    dwSize: DWORD;  
    dwCapacityTotal: DWORD;  //设备存储(CVR表示录像卷)总容量(只读)，单位MB
    dwFreeSpaceTotal: DWORD;  //设备存储(CVR表示录像卷)剩余总空间(只读)，单位MB
    dwLockedRecordSpace: DWORD;  //设备已加锁录像存储(CVR表示录像卷)总容量(只读)，单位MB
    dwUnLockedSpace: DWORD;  //设备未加锁存储(CVR表示录像卷)总容量(只读),包含未加锁录像和剩余存储空间，单位MB
    byRes: array[0..512-1] of BYTE;  //保留
  end;
  LPNET_DVR_DEV_STORAGE_CFG = ^NET_DVR_DEV_STORAGE_CFG;

//一键配置CVR（V50）
type
  NET_DVR_ONE_KEY_CFG_V50 = record 
    dwSize: DWORD;  //结构体大小
    byRaidType: BYTE;  //RAID类型：0-raid5,1-raid6,2-raid95（Vraid）,3-单盘模式，即不创建raid
    bySpareRaidProportion: BYTE;  //热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）
    byPicQuota: BYTE;  //图片卷比例：范围0~100
    byRes: array[0..257-1] of BYTE;  
  end;
  LPNET_DVR_ONE_KEY_CFG_V50 = ^NET_DVR_ONE_KEY_CFG_V50;

type
  NET_DVR_ONE_KEY_RESULT_V51 = record 
    dwState: DWORD;  //状态值，详见备注的状态值
    byProgress: BYTE;  //操作进度，0~100
    byRes: array[0..259-1] of BYTE;  
  end;
  LPNET_DVR_ONE_KEY_RESULT_V51 = ^NET_DVR_ONE_KEY_RESULT_V51;

type
  NET_DVR_ONE_KEY_CFG_SAN_V50 = record 
    dwSize: DWORD;  //结构体大小
    byRaidType: BYTE;  //RAID类型：0-raid5,1-raid6
    bySpareRaidProportion: BYTE;  //热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）
    byRes: array[0..254-1] of BYTE;  
  end;
  LPNET_DVR_ONE_KEY_CFG_SAN_V50 = ^NET_DVR_ONE_KEY_CFG_SAN_V50;

type
  NET_DVR_REC_PASSBACK_BASIC_CFG = record 
    dwSize: DWORD;  //结构体大小
    dwStartTime: DWORD;  //检测窗口开始时间（单位：分钟）
    dwStopTime: DWORD;  //检测窗口结束时间（单位：分钟）
    wMaxTotalConcurrenceNum: WORD;  //并发回传路数上限,针对的是编码器路数，不是回传任务条数
    wMaxDvrConcurrenceNum: WORD;  //单台DVR并发回传通道数上限
    dwSyncSpeed: DWORD;  //回传速率（单位Mbps，上限为12Mbps）
    dwRecordType: DWORD;  //录像类型:  0xffffffff－全部，0－定时，1-移动侦测,2－报警，0xff-其他
    byRes: array[0..248-1] of BYTE;  
  end;
  LPNET_DVR_REC_PASSBACK_BASIC_CFG = ^NET_DVR_REC_PASSBACK_BASIC_CFG;

//设备连接的用户参数
type
  NET_DVR_ONLINE_USER_INFO = record 
    dwSize: DWORD;  
    wOnlineUserCount: WORD;  //登录设备的用户数
    byRes: array[0..514-1] of BYTE;  //保留
  end;
  LPNET_DVR_ONLINE_USER_INFO = ^NET_DVR_ONLINE_USER_INFO;

//查询录像总大小条件参数
type
  NET_DVR_RECORD_SEGMENT_COND = record 
    dwSize: DWORD;  
    struStreanInfo: NET_DVR_STREAM_INFO;  
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struStopTime: NET_DVR_TIME_EX;  //结束时间
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_SEGMENT_COND = ^NET_DVR_RECORD_SEGMENT_COND;

//查询录像总大小返回参数
type
  NET_DVR_RECORD_SEGMENT_RET = record 
    dwSize: DWORD;  
    dwRecordTotalSize: DWORD;  //录像总大小，单位MB
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_RECORD_SEGMENT_RET = ^NET_DVR_RECORD_SEGMENT_RET;
type
  NET_DVR_ACCESSORY_CARD_INFO = record 
    dwSize: DWORD;  
    szAccessoryCardInfo: array[0..MAX_ACCESSORY_CARD{256}-1] of BYTE;  //配件板(智能板和拼控板)型号信息
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_ACCESSORY_CARD_INFO = ^NET_DVR_ACCESSORY_CARD_INFO;
//查询信息条件结构体
type
  NET_DVR_SEARCH_INFO_COND = record 
    dwSize: DWORD;  
    byCommand: BYTE;  //查询条件，0-个人，1-所有
    byRes1: array[0..3-1] of BYTE;  
    dwEmployeeNo: DWORD;  //工号（查询条件配置为0-个人时有效）
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名（查询条件配置为0-个人时有效）
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_SEARCH_INFO_COND = ^NET_DVR_SEARCH_INFO_COND;

//获取排班信息
type
  NET_DVR_SCHEDULE_CHOICE = record 
    byScheduleType: BYTE;  //班次类型，0-不排班、1-普通班、2-工时班
    byScheduleNo: BYTE;  //班次编号
    byRes: array[0..14-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCHEDULE_CHOICE = ^NET_DVR_SCHEDULE_CHOICE;
//  B20 V1.5
type
  NET_DVR_DISPINPUT_CFG = record 
    dwSize: DWORD;  
    dwDispInputNo: DWORD;  //显示输入号
    dwEDIDFileNo: DWORD;  //关联的EDID文件编号
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DISPINPUT_CFG = ^NET_DVR_DISPINPUT_CFG;

//排班计划结构体
type
  NET_DVR_SCHEDULE_PLAN = record 
    dwSize: DWORD;  
    bySchedulePlanNo: BYTE;  //排班计划编号,起始范围根据能力集返回
    bySchedulePlanType: BYTE;  //排班计划类型，0-个人、1-部门
    byEnable: BYTE;  //使能
    byRes1: BYTE;  
    struScheduleChoice: array[0..DAYS_A_WEEK-1] of NET_DVR_SCHEDULE_CHOICE;  //班次选择
    struStartTime: NET_DVR_TIME_V30;  //开始时间
    struEndTime: NET_DVR_TIME_V30;  //结束时间
    byHolidayNo: BYTE;  //假日组编号
    byRes: array[0..63-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCHEDULE_PLAN = ^NET_DVR_SCHEDULE_PLAN;
type
  NET_DVR_DISPINPUT_CFG_LIST = record 
    dwSize: DWORD;  
    dwDispInputNum: DWORD;  //返回的NET_DVR_DISPINPUT_CFG结构的个数
    lpstruBuffer: LPNET_DVR_DISPINPUT_CFG;  //缓冲区指针
    dwBufferSize: DWORD;  //缓冲区大小
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DISPINPUT_CFG_LIST = ^NET_DVR_DISPINPUT_CFG_LIST;

//获取排班信息
type
  NET_DVR_SCHEDULE_INFO_CFG = record 
    dwSize: DWORD;  
    dwEmployeeNo: DWORD;  //工号
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    byDepartmentName: array[0..NAME_LEN-1] of BYTE;  //部门名称
    struSchedulePlan: NET_DVR_SCHEDULE_PLAN;  //排班计划
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_SCHEDULE_INFO_CFG = ^NET_DVR_SCHEDULE_INFO_CFG;

//获取考勤汇总信息
type
  NET_DVR_ATTENDANCE_SUMMARY_CFG = record 
    dwSize: DWORD;  
    dwEmployeeNo: DWORD;  //工号
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    byDepartmentName: array[0..NAME_LEN-1] of BYTE;  //部门名称
    dwWorkStandard: DWORD;  //标准工作时间（分钟）
    dwWorkActual: DWORD;  //实际工作时间（分钟）
    dwLateTimes: DWORD;  //迟到次数
    dwLateMinutes: DWORD;  //迟到累计时间（分钟）
    dwLeaveEarlyTimes: DWORD;  //早退次数
    dwLeaveEarlyMinutes: DWORD;  //早退累计时间（分钟）
    dwOvertimeStandard: DWORD;  //标准加班时间（分钟）
    dwOvertimeActual: DWORD;  //实际加班时间（分钟）
    dwAttendanceStandard: DWORD;  //标准出勤天数（天）
    dwAttendanceActual: DWORD;  //实际出勤天数（天）
    dwAbsentDays: DWORD;  //旷工天数（天）
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_ATTENDANCE_SUMMARY_CFG = ^NET_DVR_ATTENDANCE_SUMMARY_CFG;

//获取考勤记录信息
type
  NET_DVR_ATTENDANCE_RECORD_CFG = record 
    dwSize: DWORD;  
    dwEmployeeNo: DWORD;  //工号
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    byDepartmentName: array[0..NAME_LEN-1] of BYTE;  //部门名称
    struAttendanceTime: NET_DVR_TIME_V30;  //考勤时间
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_ATTENDANCE_RECORD_CFG = ^NET_DVR_ATTENDANCE_RECORD_CFG;

//考勤时间段信息
type
  NET_DVR_ATTENDANCE_TIME = record 
    struOnDutyTime: NET_DVR_TIME_V30;  //上班时间
    struOffDutyTime: NET_DVR_TIME_V30;  //下班时间
  end;
  LPNET_DVR_ATTENDANCE_TIME = ^NET_DVR_ATTENDANCE_TIME;

//获取异常统计信息
type
  NET_DVR_ABNORMAL_CFG = record 
    dwSize: DWORD;  
    dwEmployeeNo: DWORD;  //工号
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    byDepartmentName: array[0..NAME_LEN-1] of BYTE;  //部门名称
    struAttendanceTime: array[0..ABNORMAL_INFO_NUM-1] of NET_DVR_ATTENDANCE_TIME;  //异常时间段
    dwLateMinutes: DWORD;  //迟到时间（分钟）
    dwLeaveEarlyMinutes: DWORD;  //早退时间（分钟）
    dwAbsenceMinutes: DWORD;  //缺勤时间（分钟）
    dwTotalMinutes: DWORD;  //合计时间（分钟）
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_ABNORMAL_CFG = ^NET_DVR_ABNORMAL_CFG;

type
  NET_DVR_CARD_CFG_V50 = record 
    dwSize: DWORD;  
    dwModifyParamType: DWORD;  
    // 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
    // #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
    // #define CARD_PARAM_VALID            0x00000002  //有效期参数
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
    // #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
    // #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
    // #define CARD_PARAM_EMPLOYEE_NO      0x00000400  //工号
    // #define CARD_PARAM_NAME             0x00000800  //姓名
    // #define CARD_PARAM_DEPARTMENT_NO    0x00001000  //部门编号
    // #define CARD_SCHEDULE_PLAN_NO       0x00002000  //排班计划编号
    // #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //排班计划类型
    // #define CARD_ROOM_NUMBER            0x00008000  //房间号
    // #define CARD_SIM_NO                 0x00010000  //SIM卡号（手机号）
    // #define CARD_FLOOR_NUMBER           0x00020000  //楼层号
    // #define CARD_USER_TYPE              0x00040000  //用户类型
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    byCardValid: BYTE;  //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    byCardType: BYTE;  //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，9-员工卡，10-应急卡，11-应急管理卡（用于授权临时卡权限，本身不能开门），12-ESD全检卡，13-ESD免检卡，14-ESD足检卡，15-ESD手检卡，默认普通卡
    byLeaderCard: BYTE;  //是否为首卡，1-是，0-否
    byUserType: BYTE;  // 0 C 普通用户1 - 管理员用户;
    byDoorRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  //门权限(楼层权限、锁权限)，按位表示，1为有权限，0为无权限，从低位到高位表示对门（锁）1-N是否有权限
    struValid: NET_DVR_VALID_PERIOD_CFG;  //有效期参数
    byBelongGroup: array[0..MAX_GROUP_NUM_128-1] of BYTE;  //所属群组，按字节表示，1-属于，0-不属于
    byCardPassword: array[0..CARD_PASSWORD_LEN-1] of BYTE;  //卡密码
    wCardRightPlan: array[0..MAX_DOOR_NUM_256-1, 0..MAX_CARD_RIGHT_PLAN_NUM-1] of WORD;  //卡权限计划，取值为计划模板编号，同个门（锁）不同计划模板采用权限或的方式处理
    dwMaxSwipeTime: DWORD;  //最大刷卡次数，0为无次数限制（开锁次数）
    dwSwipeTime: DWORD;  //已刷卡次数
    wRoomNumber: WORD;  //房间号
    wFloorNumber: SHORT;  //层号
    dwEmployeeNo: DWORD;  //工号（用户ID）
    byName: array[0..NAME_LEN-1] of BYTE;  //姓名
    wDepartmentNo: WORD;  //部门编号
    wSchedulePlanNo: WORD;  //排班计划编号
    bySchedulePlanType: BYTE;  //排班计划类型：0-无意义、1-个人、2-部门
    byRightType: BYTE;  //下发权限类型：0-普通发卡权限、1-二维码权限、2-蓝牙权限（可视对讲设备二维码权限配置项：房间号、卡号（虚拟卡号）、最大刷卡次数（开锁次数）、有效期参数；蓝牙权限：卡号（萤石APP账号）、其他参数配置与普通发卡权限一致）
    byRes2: array[0..2-1] of BYTE;  
    dwLockID: DWORD;  //锁ID
    byLockCode: array[0..MAX_LOCK_CODE_LEN-1] of BYTE;  //锁代码
    byRoomCode: array[0..MAX_DOOR_CODE_LEN-1] of BYTE;  //房间代码
    //按位表示，0-无权限，1-有权限
    //第0位表示：弱电报警
    //第1位表示：开门提示音
    //第2位表示：限制客卡
    //第3位表示：通道
    //第4位表示：反锁开门
    //第5位表示：巡更功能
    dwCardRight: DWORD;  //卡权限
    dwPlanTemplate: DWORD;  //计划模板(每天)各时间段是否启用，按位表示，0--不启用，1-启用
    dwCardUserId: DWORD;  //持卡人ID
    byCardModelType: BYTE;  //0-空，1- M1 S50，2- M1 S70，3- FM1208 CPU卡，4- FM1216 CPU卡，5-国密CPU卡，6-身份证，7- NFC
    byRes3: array[0..51-1] of BYTE;  
    bySIMNum: array[0..NAME_LEN{32}-1] of BYTE;  //SIM卡号（手机号）
  end;
  LPNET_DVR_CARD_CFG_V50 = ^NET_DVR_CARD_CFG_V50;

type
  NET_DVR_CAPTURE_FINGERPRINT_COND = record 
    dwSize: DWORD;  
    byFingerPrintPicType: BYTE;  //图片类型：0-无意义
    byFingerNo: BYTE;  //手指编号，范围1-10
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_FINGERPRINT_COND = ^NET_DVR_CAPTURE_FINGERPRINT_COND;

type
  NET_DVR_CAPTURE_FINGERPRINT_CFG = record 
    dwSize: DWORD;  
    dwFingerPrintDataSize: DWORD;  //指纹数据大小
    byFingerData: array[0..MAX_FINGER_PRINT_LEN-1] of BYTE;  //指纹数据内容
    dwFingerPrintPicSize: DWORD;  //指纹图片大小，等于0时，代表无指纹图片数据
    pFingerPrintPicBuffer: PAnsiChar;  //指纹图片缓存
    byFingerNo: BYTE;  //手指编号，范围1-10
    byFingerPrintQuality: BYTE;  //指纹质量，范围1-100
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_FINGERPRINT_CFG = ^NET_DVR_CAPTURE_FINGERPRINT_CFG;

type
  NET_DVR_CAPTURE_FACE_COND = record 
    dwSize: DWORD;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_FACE_COND = ^NET_DVR_CAPTURE_FACE_COND;

type
  NET_DVR_FACE_FEATURE = record 
    struFace: NET_VCA_RECT;  //人脸子图区域
    struLeftEye: NET_VCA_POINT;  // 左眼坐标
    struRightEye: NET_VCA_POINT;  // 右眼坐标
    struLeftMouth: NET_VCA_POINT;  // 嘴左边坐标
    struRightMouth: NET_VCA_POINT;  // 嘴右边坐标
    struNoseTip: NET_VCA_POINT;  // 鼻子坐标
  end;
  LPNET_DVR_FACE_FEATURE = ^NET_DVR_FACE_FEATURE;


type
  NET_DVR_CAPTURE_FACE_CFG = record 
    dwSize: DWORD;  
    dwFaceTemplate1Size: DWORD;  //人脸模板1数据大小，等于0时，代表无人脸模板1数据
    pFaceTemplate1Buffer: PAnsiChar;  //人脸模板1数据缓存（不大于2.5k）
    dwFaceTemplate2Size: DWORD;  //人脸模板2数据大小，等于0时，代表无人脸模板2数据
    pFaceTemplate2Buffer: PAnsiChar;  //人脸模板2数据缓存（不大于2.5K）
    dwFacePicSize: DWORD;  //人脸图片数据大小，等于0时，代表无人脸图片数据
    pFacePicBuffer: PAnsiChar;  //人脸图片数据缓存
    byFaceQuality1: BYTE;  //人脸质量，范围1-100
    byFaceQuality2: BYTE;  //人脸质量，范围1-100
    byCaptureProgress: BYTE;  //采集进度，目前只有两种进度值：0-未采集到人脸，100-采集到人脸（只有在进度为100时，才解析人脸信息）
    byFacePicQuality: BYTE;  //人脸图片中人脸质量
    dwInfraredFacePicSize: DWORD;  //红外人脸图片数据大小，等于0时，代表无人脸图片数据
    pInfraredFacePicBuffer: PAnsiChar;  //红外人脸图片数据缓存
    byInfraredFacePicQuality: BYTE;  //红外人脸图片中人脸质量
    byRes1: array[0..3-1] of BYTE;  
    struFeature: NET_DVR_FACE_FEATURE;  //人脸抠图特征信息
    byRes: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_FACE_CFG = ^NET_DVR_CAPTURE_FACE_CFG;

//查询手动回传任务可执行性条件参数
type
  NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  //流id信息（72字节）
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND = ^NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND;

//查询手动回传任务可执行性条件参数
type
  NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET = record 
    dwSize: DWORD;  
    struStreamInfo: NET_DVR_STREAM_INFO;  //流id信息（72字节）
    byExecutable: BYTE;  //0-不可立即回传，1-可立即执行回传
    byUnexecutableReason: BYTE;  //不可立即回传原因, 0-需要排队，1-编码器无连接，2-流ID不存在，3-CVR异常，4-无输入视频, 5-编码器用户名或密码错, 6-前端设备不兼容, 7-其他原因
    byRes: array[0..254-1] of BYTE;  //保留
  end;
  LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET = ^NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET;

type
  NET_DVR_STREAM_MEDIA_CFG = record 
    dwSize: DWORD;  
    sUrl: array[0..MAX_URL_LEN-1] of BYTE;  
    struDMSIP: NET_DVR_IPADDR;  // dms IP地址 
    wDMSPort: WORD;  //dms 端口号 
    byRes1: array[0..2-1] of BYTE;  
    dwDomainID: DWORD;  //域ID，用来支持多网域，由平台管理
    byRes: array[0..360-1] of BYTE;  //保留
  end;
  LPNET_DVR_STREAM_MEDIA_CFG = ^NET_DVR_STREAM_MEDIA_CFG;

//船只检测单个区域配置
type
  NET_DVR_SHIPSDETECTION_REGION_CFG = record 


    byRuleID: BYTE;  
    byEnable: BYTE;  //使能
    bySensitivity: BYTE;  //灵敏度参数，范围[1,100]
    byFrameOverlayEnabled: BYTE;  //视频是否叠加检测框
    byRes: array[0..36-1] of BYTE;  
    struPolygon: NET_ITC_POLYGON;  //触发区域
    struTriggerLine: NET_VCA_LINE;  //触发线
  end;
  LPNET_DVR_SHIPSDETECTION_REGION_CFG = ^NET_DVR_SHIPSDETECTION_REGION_CFG;

type
  NET_DVR_SHIPSDETECTION_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byRes1: array[0..3-1] of BYTE;  
    fLookDownUpAngle: FLOAT;  //设备俯仰角度，精确到小数点后一位
    fHorizontalHeight: FLOAT;  //设备水平高度，精确到小数点后一位
    struShipsDetectionRegion: array[0..MAX_SHIPSDETE_REGION_NUM-1] of NET_DVR_SHIPSDETECTION_REGION_CFG;  //船只检测单个区域配置
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SHIPSDETECTION_CFG = ^NET_DVR_SHIPSDETECTION_CFG;

type
  NET_DVR_TEMPERATURE_COLOR = record 

    {
    选择0~高温报警类型时，<highTemperature>字段生效,当高于该温度值时，会有进行颜色标注，
    选择1~低温报警类型时, <lowTemperature>字段生效,当低于该温度值时，会有进行颜色标注。
    选择2~区间报警类型时，<highTemperature>、<lowTemperature>字段生效，当在温度在该温度区间时，会有进行颜色标注。
    选择3~保温报警类型时，<highTemperature>、<lowTemperature>字段生效，当温度不在该温度区间时，会有进行颜色标注。
    选择4~为无报警类型，<nullAlarm>字段生效，关闭报警，}
    byType: BYTE;  //测温报警颜色控制类型，0~无报警类型（关闭），1~高温报警类型，2~低温报警类型，3~区间报警类型，4~保温报警类型
    byRes1: array[0..3-1] of BYTE;  
    iHighTemperature: INT;  //高温值，-273~10000
    iLowTemperature: INT;  //低温值，-273~10000
    byRes: array[0..8-1] of BYTE;  
  end;
  LPNET_DVR_TEMPERATURE_COLOR = ^NET_DVR_TEMPERATURE_COLOR;

type
  NET_DVR_THERMOMETRY_BASICPARAM = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byStreamOverlay: BYTE;  //码流叠加温度信息：0- 否，1- 是
    byPictureOverlay: BYTE;  //抓图叠加温度信息：0- 否，1- 是
    byThermometryRange: BYTE;  //测温范围: 0-默认值,1-(-20~150),2-(0~550)（这里以摄氏度为单位计算）,3-(摄氏度:0-650℃；华氏温度:32-1200H),4-（摄氏度: -40-150℃）,5-(摄氏度: 0~1200℃)（这里以摄氏度为单位计算，根据测温单位设定不同测温范围的显示），6-(摄氏度: -20-120℃,7-(摄氏度:20~350℃), 8-(摄氏度:20~45),9-(摄氏度:30~45),0xff-自动
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)。
    byThermometryCurve: BYTE;  //测温曲线模式显示方式，0-关闭，1-模式1（横向温度趋势线模式），2-模式2（纵向温度趋势线模式）
    byFireImageModea: BYTE;  //消防图像模式，0-保留，1-黑白模式，2-热探测模式，3-火场模式(字段0目前保留，避免与之前接口不兼容)
    byShowTempStripEnable: BYTE;  //显示温度条使能：0- 否，1- 是
    fEmissivity: FLOAT;  //发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
    byDistanceUnit: BYTE;  //距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
    byEnviroHumidity: BYTE;  //环境相对湿度，取值范围：0~100%
    byRes2: array[0..2-1] of BYTE;  
    struTempColor: NET_DVR_TEMPERATURE_COLOR;  //测温报警颜色
    iEnviroTemperature: INT;  //环境温度，取值范围：-273~10000摄氏度
    iCorrectionVolume: INT;  //测温修正量，取值范围：-100~100
    { bit0-中心点测温：0-不显示，1-显示；
    bit1-最高点测温：0-不显示，1-显示；
    bit2-最低点测温：0-不显示，1-显示；
    }
    bySpecialPointThermType: BYTE;  // 特殊测温点显示
    byReflectiveEnabled: BYTE;  //反射温度使能：0- 否，1- 是
    wDistance: WORD;  //距离(m)[0, 10000]
    fReflectiveTemperature: FLOAT;  //反射温度 精确到小数后一位
    fAlert: FLOAT;  //预警温度阈值，-100.0-1000.0度（精确到小数点后一位）
    fAlarm: FLOAT;  //报警温度阈值，-100.0-1000.0度（精确到小数点后一位）
    fThermalOpticalTransmittance: FLOAT;  // 光学透过率, 精确到小数点后3位，范围0.001-1.000，默认1.000
    fExternalOpticsWindowCorrection: FLOAT;  //外部光学温度，默认值20℃，范围为-40.0~80.0℃，实际显示单位以界面显示为准
    byDisplayMaxTemperatureEnabled: BYTE;  // 显示最高温 0-不显示 1-显示
    byDisplayMinTemperatureEnabled: BYTE;  // 显示最低温 0-不显示 1-显示
    byDisplayAverageTemperatureEnabled: BYTE;  // 显示平均温 0-不显示 1-显示
    byThermometryInfoDisplayposition: BYTE;  // 测温信息显示位置 0-保留 1-规则 2-屏幕左上角
    dwAlertFilteringTime: DWORD;  //温度预警等待时间,单位秒
    dwAlarmFilteringTime: DWORD;  //温度报警等待时间,单位秒
    byemissivityMode: BYTE;  //发射率配置类型 1-粗糙，2-较粗糙，3-较光滑, 4-光滑, 0xff-自定义
    bydisplayTemperatureInOpticalChannelEnabled: BYTE;  //可见光显示温度信息使能，0-不启用，1启用
    byDisplayCentreTemperatureEnabled: BYTE;  // 显示中心点温度 0-不显示 1-显示
    byRes: array[0..49-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_BASICPARAM = ^NET_DVR_THERMOMETRY_BASICPARAM;

type
  NET_DVR_THERMOMETRY_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChannel: DWORD;  
    wPresetNo: WORD;  //0-保留
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_COND = ^NET_DVR_THERMOMETRY_COND;

type
  NET_DVR_THERMOMETRY_PRESETINFO_PARAM = record 
    byEnabled: BYTE;  //是否使能：0- 否，1- 是
    byRuleID: BYTE;  //规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
    wDistance: WORD;  //距离(m)[0, 10000]
    fEmissivity: FLOAT;  //发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
    byDistanceUnit: BYTE;  //距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
    byRes: array[0..2-1] of BYTE;  
    byReflectiveEnabled: BYTE;  //反射温度使能：0- 否，1- 是
    fReflectiveTemperature: FLOAT;  //反射温度 精确到小数后2位
    szRuleName: array[0..NAME_LEN{32}-1] of AnsiChar;  //规则名称
    byemissivityMode: BYTE;  //发射率配置类型 1-粗糙，2-较粗糙，3-较光滑, 4-光滑, 0xff-自定义
    byRes1: array[0..62-1] of BYTE;  
    byRuleCalibType: BYTE;  //规则标定类型 0-点，1-框，2-线
    struPoint: NET_VCA_POINT;  //点测温坐标（当规则标定类型为"点"的时候生效）
    struRegion: NET_VCA_POLYGON;  //区域、线（当规则标定类型为"框"或者"线"的时候生效）
  end;
  LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM = ^NET_DVR_THERMOMETRY_PRESETINFO_PARAM;


type
  NET_DVR_THERMOMETRY_PRESETINFO = record 
    dwSize: DWORD;  //结构体大小
    wPresetNo: WORD;  //0-保留
    byRes: array[0..2-1] of BYTE;  
    struPresetInfo: array[0..MAX_THERMOMETRY_REGION_NUM{40}-1] of NET_DVR_THERMOMETRY_PRESETINFO_PARAM;  
  end;
  LPNET_DVR_THERMOMETRY_PRESETINFO = ^NET_DVR_THERMOMETRY_PRESETINFO;


type
  NET_DVR_BASE_STATION_INFO_ALARM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    sNetBarWaCode: array[0..16-1] of AnsiChar;  //场所编号
    sCollectionEquipmentID: array[0..24-1] of AnsiChar;  //采集设备编号
    sMCC: array[0..4-1] of AnsiChar;  //移动国家码
    sMNC: array[0..4-1] of AnsiChar;  //移动网络码
    sLAC: array[0..36-1] of AnsiChar;  //位置区码
    sCI: array[0..36-1] of AnsiChar;  //小区识别码
    sBSCI: array[0..36-1] of AnsiChar;  //基站识别码
    sBCCH: array[0..36-1] of AnsiChar;  //公共广播信道
    sLEV: array[0..36-1] of AnsiChar;  //接收报告电平
    sCollectionEquipmentLongitude: array[0..12-1] of AnsiChar;  //采集设备经度
    sCollectionEquipmentLatitude: array[0..12-1] of AnsiChar;  //采集设备纬度
    sCaptureTime: array[0..20-1] of AnsiChar;  //采集时间 时间格式yyyy-MM-dd hh:mm:ss
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_BASE_STATION_INFO_ALARM = ^NET_DVR_BASE_STATION_INFO_ALARM;


type
  NET_DVR_THERMOMETRY_ALARMRULE_PARAM = record 
    byEnable: BYTE;  
    byRuleID: BYTE;  //规则ID
    byRule: BYTE;  //报警温度比较方式 0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于
    byRes: BYTE;  
    szRuleName: array[0..NAME_LEN-1] of AnsiChar;  //规则名称
    fAlert: FLOAT;  //预警温度
    fAlarm: FLOAT;  //报警温度
    fThreshold: FLOAT;  //门限温度
    dwAlertFilteringTime: DWORD;  //温度预警等待时间,单位秒
    dwAlarmFilteringTime: DWORD;  //温度报警等待时间,单位秒
    byRes1: array[0..56-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM = ^NET_DVR_THERMOMETRY_ALARMRULE_PARAM;

type
  NET_DVR_THERMOMETRY_ALARMRULE = record 
    dwSize: DWORD;  //结构体大小
    struThermometryAlarmRuleParam: array[0..THERMOMETRY_ALARMRULE_NUM-1] of NET_DVR_THERMOMETRY_ALARMRULE_PARAM;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_ALARMRULE = ^NET_DVR_THERMOMETRY_ALARMRULE;


type
  NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM = record 
    byEnable: BYTE;  
    byRuleID: BYTE;  //规则ID,0-表示无效，范围值从1开始
    byAlarmID1: BYTE;  
    byAlarmID2: BYTE;  
    byRule: BYTE;  //报警温度比较方式0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于
    byRes: array[0..3-1] of BYTE;  
    fTemperatureDiff: FLOAT;  //温差值
    dwAlarmFilteringTime: DWORD;  //温度报警等待时间,单位秒
    byRes1: array[0..28-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM = ^NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;

type
  NET_DVR_THERMOMETRY_DIFFCOMPARISON = record 
    dwSize: DWORD;  //结构体大小
    struDiffComparison: array[0..MAX_THERMOMETRY_DIFFCOMPARISON_NUM{8}-1] of NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;  
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_DIFFCOMPARISON = ^NET_DVR_THERMOMETRY_DIFFCOMPARISON;


//实时温度检测条件结构
type
  NET_DVR_REALTIME_THERMOMETRY_COND = record 
    dwSize: DWORD;  
    dwChan: DWORD;  //通道号，从1开始，0xffffffff代表获取全部通道
    byRuleID: BYTE;  //规则ID 0-代表获取全部规则，具体规则ID从1开始
    {
    1-定时模式：设备每隔一秒上传各个规则测温数据的最高温、最低温和平均温度值、温差
    2-温差模式：若上一秒与下一秒的最高温或者最低温或者平均温或者温差值的温差大于等于2摄氏度，则上传最高温、最低温和平均温度值。若大于等于一个小时温差值均小于2摄氏度，则上传最高温、最低温、平均温和温差值
    }
    byMode: BYTE;  //长连接模式， 0-保留（为兼容老设备），1-定时模式，2-温差模式
    wInterval: WORD;  //上传间隔，仅温差模式支持，1~3600S，填0则默认3600S上传一次
    fTemperatureDiff: FLOAT;  //温差
    byRes: array[0..56-1] of BYTE;  //保留
  end;
  LPNET_DVR_REALTIME_THERMOMETRY_COND = ^NET_DVR_REALTIME_THERMOMETRY_COND;

type
  NET_DVR_POINT_THERM_CFG = record 
    fTemperature: FLOAT;  //当前温度
    struPoint: NET_VCA_POINT;  //点测温坐标（当规则标定类型为点的时候生效）
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_POINT_THERM_CFG = ^NET_DVR_POINT_THERM_CFG;

type
  NET_DVR_LINEPOLYGON_THERM_CFG = record 
    fMaxTemperature: FLOAT;  //最高温
    fMinTemperature: FLOAT;  //最低温
    fAverageTemperature: FLOAT;  //平均温
    fTemperatureDiff: FLOAT;  //温差
    struRegion: NET_VCA_POLYGON;  //区域（当规则标定类型为框/线的时候生效）
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LINEPOLYGON_THERM_CFG = ^NET_DVR_LINEPOLYGON_THERM_CFG;

type
  NET_DVR_THERMOMETRY_UPLOAD = record 
    dwSize: DWORD;  
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    szRuleName: array[0..NAME_LEN{32}-1] of AnsiChar;  //规则名称
    byRuleID: BYTE;  //规则ID号
    byRuleCalibType: BYTE;  //规则标定类型 0-点，1-框，2-线
    wPresetNo: WORD;  //预置点号
    struPointThermCfg: NET_DVR_POINT_THERM_CFG;  
    struLinePolygonThermCfg: NET_DVR_LINEPOLYGON_THERM_CFG;  
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    byDataType: BYTE;  //数据状态类型:0-检测中，1-开始，2-结束
    byRes1: BYTE;  
    {
    bit0-中心点测温：0-不支持，1-支持；
    bit1-最高点测温：0-不支持，1-支持；
    bit2-最低点测温：0-不支持，1-支持；
    }
    bySpecialPointThermType: BYTE;  // 是否支持特殊点测温
    fCenterPointTemperature: FLOAT;  //中心点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10 （由bySpecialPointThermType判断是否支持中心点）
    fHighestPointTemperature: FLOAT;  //最高点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最高点）
    fLowestPointTemperature: FLOAT;  //最低点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最低点）
    struHighestPoint: NET_VCA_POINT;  //线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
    struLowestPoint: NET_VCA_POINT;  //线、框测温最低温度位置坐标（当规则标定类型为线、框的时候生效）
    byIsFreezedata: BYTE;  //是否数据冻结 0-否 1-是
    byFaceSnapThermometryEnabled: BYTE;  //人脸抓拍测温使能 1-开启 0-关闭
    byRes2: array[0..2-1] of BYTE;  
    dwChan: DWORD;  //通道号，查询条件中通道号为0xffffffff时该字段生效
    struFaceRect: NET_VCA_RECT;  //人脸子图区域
    dwTimestamp: DWORD;  //DSP时间戳
    byRes: array[0..68-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_UPLOAD = ^NET_DVR_THERMOMETRY_UPLOAD;

//温度报警（检测温度和配置温度比较报警）
type
  NET_DVR_THERMOMETRY_ALARM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRuleID: BYTE;  //规则ID
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    wPresetNo: WORD;  //预置点号
    struPtzInfo: NET_PTZ_INFO;  //ptz坐标信息
    byAlarmLevel: BYTE;  //0-预警 1-报警
    byAlarmType: BYTE;  //报警类型 0-最高温度 1-最低温度 2-平均温度 3-温差 4-温度突升 5-温度突降
    byAlarmRule: BYTE;  //0-大于，1-小于
    byRuleCalibType: BYTE;  //规则标定类型 0-点，1-框，2线
    struPoint: NET_VCA_POINT;  //点测温坐标（当规则标定类型为点的时候生效）
    struRegion: NET_VCA_POLYGON;  //区域（当规则标定类型为框的时候生效）
    fRuleTemperature: FLOAT;  //配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100） 
    fCurrTemperature: FLOAT;  //当前温度,精确到小数点后一位(-40-1000),（浮点数+100） 
    dwPicLen: DWORD;  //可见光图片长度
    dwThermalPicLen: DWORD;  //热成像图片长度
    dwThermalInfoLen: DWORD;  //热成像附加信息长度
    pPicBuff: PAnsiChar;  ///可见光图片指针
    pThermalPicBuff: PAnsiChar;  // 热成像图片指针
    pThermalInfoBuff: PAnsiChar;  //热成像附加信息指针
    struHighestPoint: NET_VCA_POINT;  //线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
    fToleranceTemperature: FLOAT;  // 容差温度,精确到小数点后一位(-40-1000),（浮点数+100） 
    dwAlertFilteringTime: DWORD;  //温度预警等待时间 单位秒 范围为0-200秒，默认为0秒
    dwAlarmFilteringTime: DWORD;  //温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
    dwTemperatureSuddenChangeCycle: DWORD;  //温度突变记录周期，单位秒
    fTemperatureSuddenChangeValue: FLOAT;  //温度突变值,精确到小数点后一位(大于0)
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes1: array[0..3-1] of BYTE;  
    dwVisibleChannel: DWORD;  //可见光通道通道号
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    fAlarmRuleTemperature: FLOAT;  // TMA测温配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100） 
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_ALARM = ^NET_DVR_THERMOMETRY_ALARM;


//温差报警
type
  NET_DVR_THERMOMETRY_DIFF_ALARM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byAlarmID1: BYTE;  //规则AlarmID1
    byAlarmID2: BYTE;  //规则AlarmID2
    wPresetNo: WORD;  //预置点号
    byAlarmLevel: BYTE;  //0-预警 1-报警
    byAlarmType: BYTE;  //报警类型 0-最高温度 1-最低温度 2-平均温度
    byAlarmRule: BYTE;  //0-大于，1-小于
    byRuleCalibType: BYTE;  //规则标定类型 0-点，1-框，2线
    struPoint: array[0..2-1] of NET_VCA_POINT;  //点测温坐标（当规则标定类型为点的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    struRegion: array[0..2-1] of NET_VCA_POLYGON;  //区域（当规则标定类型为框的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    fRuleTemperatureDiff: FLOAT;  //配置规则温差,精确到小数点后一位(-40-1000)）
    fCurTemperatureDiff: FLOAT;  //当前温差,精确到小数点后一位(-40-1000),（浮点数+100） 
    struPtzInfo: NET_PTZ_INFO;  //ptz坐标信息
    dwPicLen: DWORD;  //可见光图片长度
    dwThermalPicLen: DWORD;  //热成像图片长度
    dwThermalInfoLen: DWORD;  //热成像附加信息长度
    pPicBuff: PAnsiChar;  ///可见光图片指针
    pThermalPicBuff: PAnsiChar;  // 热成像图片指针
    pThermalInfoBuff: PAnsiChar;  //热成像附加信息指针
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    byRes1: array[0..2-1] of BYTE;  
    fToleranceTemperature: FLOAT;  //容差温度,精确到小数点后一位(-40-1000),（浮点数+100） 
    dwAlarmFilteringTime: DWORD;  //温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
    dwVisibleChannel: DWORD;  //可见光通道通道号
    byRes: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_DIFF_ALARM = ^NET_DVR_THERMOMETRY_DIFF_ALARM;

type
  NET_DVR_SHIPSCOUNT_COND = record //条件结构
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号（前端默认是1）
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_SHIPSCOUNT_COND = ^NET_DVR_SHIPSCOUNT_COND;


//获取船只计数信息结构
type
  NET_DVR_SHIPSCOUNT_CFG = record 
    dwSize: DWORD;  
    dwUpShipsCount: DWORD;  //上行船只数
    dwDownShipsCount: DWORD;  //下行船只数
    dwLeftShipsCount: DWORD;  //左行船只数
    dwRightShipsCount: DWORD;  //右行船只数
    dwTotalCount: DWORD;  //船只总计数
    dwRelativeTime: DWORD;  //设备侧计数开始计数的相对时标
    dwAbsTime: DWORD;  //设备侧计数开始计数的绝对时标
    byDataType: BYTE;  //数据状态类型:0-检测中，1-开始，2-结束
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_SHIPSCOUNT_CFG = ^NET_DVR_SHIPSCOUNT_CFG;

//船只信息
type
  NET_DVR_SHIPSINFO = record 
    fShipsLength: FLOAT;  //船只长度；1~1000.0m，精确到小数点后一位
    fShipsHeight: FLOAT;  //船只高度；1~1000.0m，精确到小数点后一位
    fShipsWidth: FLOAT;  //船只宽度；1~1000.0m，精确到小数点后一位
    fShipsSpeed: FLOAT;  //船只速度；1~1000.0m/s，精确到小数点后一位
    byShipsDirection: BYTE;  //船只方向；0~up,1~down,2~left,3~right
    byShipsDetState: BYTE;  //船只检测状态；0~正跨越检测线，1~船头检测，2~船尾检测
    byTriggerLineID: BYTE;  //检测线ID
    byRes: array[0..61-1] of BYTE;  
    struShipsRect: NET_VCA_POLYGON;  //船只区域，归一化值，相对于大图（可见光图、热成像图)的分辨率
  end;
  LPNET_DVR_SHIPSINFO = ^NET_DVR_SHIPSINFO;

//船只抓图信息
type
  NET_DVR_SHIPIMAGE_INFO = record 
    dwShipImageLen: DWORD;  //船只抓拍图片二进制数据长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pXmlBuf: PAnsiChar;  //船只抓拍图片二进制数据指针
{$ELSE}
    pXmlBuf: PAnsiChar;  //船只抓拍图片二进制数据指针
    byRes: array[0..4-1] of BYTE;  
{$ENDIF}
  end;
  LPNET_DVR_SHIPIMAGE_INFO = ^NET_DVR_SHIPIMAGE_INFO;

//船只检测报警上传
type
  NET_DVR_SHIPSDETECTION_ALARM = record 
    dwSize: DWORD;  
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    byShipsNum: BYTE;  //船只数；(正跨越检测线的船只数)
    byShipsNumHead: BYTE;  //船只数；(船头检测船只数)
    byShipsNumEnd: BYTE;  //船只数；(船尾检测船只数)
    byPicTransType: BYTE;  //图片数据传输方式: 0-二进制；1-url
    struShipInfo: array[0..MAX_SHIPS_NUM{20}-1] of NET_DVR_SHIPSINFO;  //船只信息；最大支持20艘
    dwPicLen: DWORD;  //可见光图片长度
    dwThermalPicLen: DWORD;  //热成像图片长度
    pPicBuffer: PBYTE;  //可见光图片数据指针
    pThermalPicBuffer: PBYTE;  //热成像图片数据指针
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byTimeDiffFlag: BYTE;  //时差字段是否有效  0-时差无效， 1-时差有效 
    cTimeDifferenceH: AnsiChar;  //与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
    cTimeDifferenceM: AnsiChar;  //与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
    bySID: BYTE;  //场景ID
    byRes1: array[0..2-1] of BYTE;  
    szSceneName: array[0..NAME_LEN-1] of AnsiChar;  //场景名称，不超过32字符
    byRes: array[0..132-1] of BYTE;  
    dwXmlLen: DWORD;  //XML透传数据长度, 即EventNotificationAlert XML Block的数据长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
{$ELSE}
    pXmlBuf: PAnsiChar;  // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    struShipImageInfo: array[0..MAX_SHIPIMAGE_NUM{6}-1] of NET_DVR_SHIPIMAGE_INFO;  //船只抓拍图片信息,数组下标为0时代表为第一张船只抓拍图片，以此类推；最大支持6张图片。
  end;
  LPNET_DVR_SHIPSDETECTION_ALARM = ^NET_DVR_SHIPSDETECTION_ALARM;

type
  NET_DVR_THERMAL_PIP = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用
    byPipMode: BYTE;  // 画中画模式，0~叠加模式，1~融合模式，2-普通模式
    byOverlapType: BYTE;  //叠加类型，选择画中画叠加模式后生效。0~可见光叠加热成像图片，1~热成像叠加可见光图片
    byTransparency: BYTE;  //透明度 0~100
    struPipRegion: NET_VCA_POLYGON;  //画中画区域位置
    byImageFusionRatio: BYTE;  //图像融合比例,融合模式下生效 0-100 默认75
    byBorderFusionRatio: BYTE;  //边缘融合比例,融合模式下生效 0-100 默认100
    byRes1: array[0..2-1] of BYTE;  
    fDistance: FLOAT;  //融合距离,融合模式下生效,范围0.1-4.0米
    byRes: array[0..632-1] of BYTE;  
  end;
  LPNET_DVR_THERMAL_PIP = ^NET_DVR_THERMAL_PIP;

type
  NET_DVR_RULESLINE_CFG = record 
    struRGB: NET_DVR_RGB_COLOR;  // RGB参数：R（红色），G（绿色），B（蓝色） 范围0-255
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_RULESLINE_CFG = ^NET_DVR_RULESLINE_CFG;

type
  NET_DVR_THERMAL_INTELRULE_DISPLAY = record 
    dwSize: DWORD;  //结构体大小
    {
    fontSizeType:为字体大小倍率索引，播放库会根据该倍率以及预览窗口的宽度动态改变字体的大小。公式为：具体倍率值/8*(0.01*预览窗口宽度)
    倍率索引对应如下：
    0~8倍率（小）
    1~12倍率（标准）
    2~16倍率（大）
    3~20倍率（超大）
    4~24倍率（特大）
    }
    byFontSizeType: BYTE;  
    byRes1: array[0..3-1] of BYTE;  
    struNormalRulesLineCfg: NET_DVR_RULESLINE_CFG;  //正常规则线相关属性参数
    struAlertRulesLineCfg: NET_DVR_RULESLINE_CFG;  //预警规则线相关属性参数
    struAlarmRulesLineCfg: NET_DVR_RULESLINE_CFG;  //报警规则线相关属性参数
    byRes: array[0..640-1] of BYTE;  
  end;
  LPNET_DVR_THERMAL_INTELRULE_DISPLAY = ^NET_DVR_THERMAL_INTELRULE_DISPLAY;

type
  NET_DVR_BAREDATAOVERLAY_CFG = record 
    dwSize: DWORD;  
    byEnable: BYTE;  //使能
    byIntervalTime: BYTE;  // 上传的时间间隔可配置：1 2 3 4 5.单位为秒，默认为3秒
    byRes: array[0..258-1] of BYTE;  
  end;
  LPNET_DVR_BAREDATAOVERLAY_CFG = ^NET_DVR_BAREDATAOVERLAY_CFG;

//测温联动条件结构
type
  NET_DVR_THERMOMETRY_TRIGGER_COND = record 
    dwSize: DWORD;  //结构体大小
    dwChan: DWORD;  //通道号
    dwPreset: DWORD;  //预置点号（目前不支持,无需赋值）
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_TRIGGER_COND = ^NET_DVR_THERMOMETRY_TRIGGER_COND;

//手动除冰
type
  NET_DVR_MANUALDEICING_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnabled: BYTE;  //是否启用手动除冰 ，0~关闭，1~启用
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_MANUALDEICING_CFG = ^NET_DVR_MANUALDEICING_CFG;

//小间距LED控制器
type
  NET_DVR_INPUT_SOURCE_TEXT_COND = record 
    dwSize: DWORD;  
    dwInputSourceNo: DWORD;  //输入源编号
    dwTextNo: DWORD;  //文本编号
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SOURCE_TEXT_COND = ^NET_DVR_INPUT_SOURCE_TEXT_COND;

type
  NET_DVR_INPUT_SOURCE_TEXT = record 
    dwSize: DWORD;  
    dwTextNo: DWORD;  //文本编号
    byEnable: BYTE;  //是否使能，0-不使能，1-使能
    byFontSize: BYTE;  //字体大小
    byBkGroudMode: BYTE;  //背景模式，1-透明，2-覆盖
    byRes: array[0..1-1] of BYTE;  
    dwXPosition: DWORD;  //字符显示位置的左上角X坐标，输入源相对坐标
    dwYPosition: DWORD;  //字符显示位置的左上角Y坐标，输入源相对坐标
    struForegroudColor: NET_DVR_RGB_COLOR;  //字符前景色
    struBackgroudColor: NET_DVR_RGB_COLOR;  //字符背景色
    byTextContent: array[0..MAX_LEN_TEXT_CONTENT-1] of BYTE;  //字符内容
    byRes1: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SOURCE_TEXT = ^NET_DVR_INPUT_SOURCE_TEXT;

type
  NET_DVR_INPUT_SOURCE_TEXT_LIST = record 
    dwSize: DWORD;  
    struTextList: array[0..MAX_NUM_INPUT_SOURCE_TEXT-1] of NET_DVR_INPUT_SOURCE_TEXT;  //文本列表
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SOURCE_TEXT_LIST = ^NET_DVR_INPUT_SOURCE_TEXT_LIST;

type
  NET_DVR_INPUT_SOURCE_RESOLUTION = record 
    dwSize: DWORD;  
    dwInputSignalNo: DWORD;  //输入源编号
    byEnabled: BYTE;  //自定义分辨率是否使能
    byRes: BYTE;  
    wImageWidth: WORD;  //图像宽度
    wImageHeight: WORD;  //图像高度
    wRefreshRate: WORD;  //刷新频率
    byColorDepth: BYTE;  //颜色深度，32位、16位、8位三种可选
    byScanType: BYTE;  //扫描类型，1-逐行扫描，2-间隔扫描
    byRes1: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SOURCE_RESOLUTION = ^NET_DVR_INPUT_SOURCE_RESOLUTION;

type
  NET_DVR_INPUT_SOURCE_RESOLUTION_LIST = record 
    dwSize: DWORD;  
    dwInputSignalCnt: DWORD;  //设备输入信号源数量
    lpstruBuffer: LPNET_DVR_INPUT_SOURCE_RESOLUTION;  //缓冲区指针
    dwBufferSize: DWORD;  //缓冲区大小
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST = ^NET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

type
  NET_DVR_LED_AREA_COND = record 
    dwSize: DWORD;  
    dwVideoWallNo: DWORD;  //电视墙编号
    dwLEDAreaNo: DWORD;  //LED区域编号
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_AREA_COND = ^NET_DVR_LED_AREA_COND;

type
  NET_DVR_LED_AREA_INFO = record 
    dwSize: DWORD;  
    dwLEDAreaNo: DWORD;  //LED区域编号
    struRect: NET_DVR_RECTCFG_EX;  //矩形区域
    dwaOutputNo: array[0..MAX_NUM_OUTPUT_CHANNEL-1] of DWORD;  //输出口列表
    byAreaType: BYTE;  //区域类型，0-LED区域，1-LCD区域
    byRes: array[0..31-1] of BYTE;  
  end;
  LPNET_DVR_LED_AREA_INFO = ^NET_DVR_LED_AREA_INFO;

type
  NET_DVR_LED_AREA_INFO_LIST = record 
    dwSize: DWORD;  
    dwLEDAreaNum: DWORD;  //LED区域数量
    lpstruBuffer: LPNET_DVR_LED_AREA_INFO;  //缓冲区指针
    dwBufferSize: DWORD;  //缓冲区大小
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_LED_AREA_INFO_LIST = ^NET_DVR_LED_AREA_INFO_LIST;

//呼叫等待参数
type
  NET_DVR_CALL_WAITTING_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用呼叫等待, 0--不启用，1--启用
    byRes1: BYTE;  
    wWaitTime: WORD;  //呼叫等待时间，单位秒
    wCalledWaitTime: WORD;  //单位秒，被呼叫等待时间
    byRes: array[0..510-1] of BYTE;  
  end;
  LPNET_DVR_CALL_WAITTING_CFG = ^NET_DVR_CALL_WAITTING_CFG;

//警灯参数
type
  NET_DVR_ALARM_LAMP_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用警灯定时闪烁, 0--不启用，1--启用
    byRes1: BYTE;  
    wFlashDuration: WORD;  //警灯定时闪烁持续时间，单位秒
    wFlashIntervalTime: WORD;  //警灯闪烁间隔时间，单位秒
    byRes: array[0..510-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_LAMP_CFG = ^NET_DVR_ALARM_LAMP_CFG;

//语音提示参数
type
  NET_DVR_VOICE_PROMPTION_CFG = record 
    dwSize: DWORD;  //结构体大小
    byEnable: BYTE;  //是否启用语音提示, 0--不启用，1--启用
    byRes1: array[0..3-1] of BYTE;  
    byCenterBusyFile: array[0..NAME_LEN-1] of BYTE;  //中心繁忙提示语音文件名
    byRefusedFile: array[0..NAME_LEN-1] of BYTE;  //拒绝提示语音文件名
    byHangUpFile: array[0..NAME_LEN-1] of BYTE;  //对讲结束提示语音文件名
    byCallWaittingFile: array[0..NAME_LEN-1] of BYTE;  //呼叫等候音文件名
    byConsultWaittingFile: array[0..NAME_LEN-1] of BYTE;  //业务咨询等候音文件名
    byWelcomeFile: array[0..NAME_LEN-1] of BYTE;  //欢迎提示语音文件名
    byFarewellFile: array[0..NAME_LEN-1] of BYTE;  //欢送语音文件
    byCalledVoicePromptName: array[0..NAME_LEN-1] of BYTE;  //被呼叫语音提示名
    byRes: array[0..384-1] of BYTE;  
  end;
  LPNET_DVR_VOICE_PROMPTION_CFG = ^NET_DVR_VOICE_PROMPTION_CFG;

//紧急报警处理
type
  NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG = record 
    dwSize: DWORD;  //结构体大小
    byCommand: BYTE;  //控制命令，0--centerbusy，1--refuse
    byType: BYTE;  //处理类型，0―紧急报警，1―业务咨询
    byRes: array[0..510-1] of BYTE;  
  end;
  LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG = ^NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

///////////*网络参数配置_V50/////////////
type
  NET_DVR_ALARMHOST_NETPARAM_V50 = record 
    dwSize: DWORD;  
    struIP: NET_DVR_IPADDR;  
    wPort: WORD;  
    byAddressType: BYTE;  //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    byEnable: BYTE;  //使能，0-不启用，1-启用
    byDomainName: array[0..MAX_DOMAIN_NAME{64}-1] of BYTE;  //域名，GPRS参数配置、网络参数配置时该字段均有效
    byReportProtocol: BYTE;  //1-private 2-NAL2300, 3-Ehome
    byDevID: array[0..ACCOUNTNUM_LEN_32{32}-1] of BYTE;  //协议为NAL2300时有效
    byProtocolVersion: BYTE;  //EHome协议版本，0-无意义,1Cv2.0，2Cv4.0，3-v5.0
    byRes1: array[0..3-1] of BYTE;  
    byEHomeKey: array[0..NET_SDK_EHOME_KEY_LEN-1] of BYTE;  //EHome Key（用于EHome 5.0版本）
    byRes2: array[0..28-1] of BYTE;  //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
  end;
  LPNET_DVR_ALARMHOST_NETPARAM_V50 = ^NET_DVR_ALARMHOST_NETPARAM_V50;

type
  NET_DVR_ALARMHOST_NETCFG_V50 = record 
    dwSize: DWORD;  
    struNetCenter: array[0..MAX_CENTERNUM-1] of NET_DVR_ALARMHOST_NETPARAM_V50;  
    byRes1: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARMHOST_NETCFG_V50 = ^NET_DVR_ALARMHOST_NETCFG_V50;
//目标封装格式类型
type
  STREAM_TYPE =    (  
    STREAM_PS = $1,  //PS文件层，主要用于存储，也可用于传输
    STREAM_3GPP = $2  //3GPP文件层，用于存储
  );
type
  NET_SDK_INIT_CFG_TYPE =  
  (  
    NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0,  //增加对必须库的检查
    NET_SDK_INIT_CFG_ABILITY = 1,  //sdk支持的业务的能力集
    NET_SDK_INIT_CFG_SDK_PATH = 2,  //设置HCNetSDK库所在目录
    NET_SDK_INIT_CFG_LIBEAY_PATH = 3,  //设置OpenSSL的libeay32.dll/libcrypto.so/libcrypto.dylib所在路径
    NET_SDK_INIT_CFG_SSLEAY_PATH = 4  //设置OpenSSL的ssleay32.dll/libssl.so/libssl.dylib所在路径
  );

type
  NET_DVR_INIT_CHECK_MODULE_COM = record 
    byEnable: BYTE;  //启用必须库检查机制 0-不启用，1-启用
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_INIT_CHECK_MODULE_COM = ^NET_DVR_INIT_CHECK_MODULE_COM;
//SDK支持的最大路数能力集
type
  INIT_CFG_MAX_NUM =  
  (  
    INIT_CFG_NUM_2048 = 2048,  // 2048路
    INIT_CFG_NUM_5120 = 5120,  //5120路
    INIT_CFG_NUM_10240 = 10240,  // 10240路
    INIT_CFG_NUM_15360 = 15360,  // 15360路
    INIT_CFG_NUM_20480 = 20480  // 20480路
  );

type
  NET_DVR_INIT_CFG_ABILITY = record 
    enumMaxLoginUsersNum: INIT_CFG_MAX_NUM;  //最多允许的注册用户个数。
    enumMaxAlarmNum: INIT_CFG_MAX_NUM;  //最大的告警路数
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_INIT_CFG_ABILITY = ^NET_DVR_INIT_CFG_ABILITY;

type
  NET_DVR_LOCAL_SDK_PATH = record 
    sPath: array[0..NET_SDK_MAX_FILE_PATH-1] of AnsiChar;  //组件库地址
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_LOCAL_SDK_PATH = ^NET_DVR_LOCAL_SDK_PATH;

type
  NET_DVR_SDKMEMPOOL_CFG = record 
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_SDKMEMPOOL_CFG = ^NET_DVR_SDKMEMPOOL_CFG;


type
  NET_DVR_RES_INFO = record 
    dwImageWidth: DWORD;  //图像宽度
    dwImageHeight: DWORD;  //图像高度
  end;
  LPNET_DVR_RES_INFO = ^NET_DVR_RES_INFO;

type
  NET_DVR_VS_INPUT_CHAN_INIT = record 
    dwSize: DWORD;  
    dwVSInputChan: DWORD;  //虚拟屏输入通道号
    dwResNums: DWORD;  //分辨率的个数
    struResList: array[0..MAX_RES_NUM_ONE_VS_INPUT_CHAN-1] of NET_DVR_RES_INFO;  //分辨率列表
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VS_INPUT_CHAN_INIT = ^NET_DVR_VS_INPUT_CHAN_INIT;

type
  NET_DVR_VS_INPUT_CHAN_INIT_LIST = record 
    dwSize: DWORD;  
    struChanList: array[0..MAX_VS_INPUT_CHAN_NUM-1] of NET_DVR_VS_INPUT_CHAN_INIT;  //通道列表
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_VS_INPUT_CHAN_INIT_LIST = ^NET_DVR_VS_INPUT_CHAN_INIT_LIST;

type
  NET_DVR_VS_INPUT_CHAN_CFG = record 
    dwSize: DWORD;  
    dwVSInputChan: DWORD;  //虚拟屏输入通道号
    struResolutin: NET_DVR_RES_INFO;  //分辨率
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_VS_INPUT_CHAN_CFG = ^NET_DVR_VS_INPUT_CHAN_CFG;

type
  NET_DVR_VS_NETSRC_CFG = record 
    dwSize: DWORD;  
    dwVSInputChan: DWORD;  //虚拟屏输入通道号
    byDispUrl: array[0..MAX_URL_LEN-1] of BYTE;  //显示URL
    byEnabled: BYTE;  //是否启用URL
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_VS_NETSRC_CFG = ^NET_DVR_VS_NETSRC_CFG;

type
  NET_DVR_EDID_FILE_INFO = record 
    dwSize: DWORD;  
    dwEDIDFileNo: DWORD;  //EDID文件编号，从1开始
    byFileName: array[0..FILE_NAME_LEN-1] of BYTE;  //EDID文件名称
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_EDID_FILE_INFO = ^NET_DVR_EDID_FILE_INFO;

type
  NET_DVR_EDID_FILE_INFO_LIST = record 
    dwSize: DWORD;  
    dwEDIDFileNum: DWORD;  //返回的NET_DVR_EDID_FILE_INFO个数
    lpstruBuffer: LPNET_DVR_EDID_FILE_INFO;  //缓冲区指针
    dwBufferSize: DWORD;  //缓冲区大小
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_EDID_FILE_INFO_LIST = ^NET_DVR_EDID_FILE_INFO_LIST;

//子窗口解码OSD
type
  NET_DVR_OSD_INFO = record 
    byEnabled: BYTE;  //是否使能，零-不使能，非零-使能
    byEnabledFlash: BYTE;  //是否闪烁，零-不闪烁，非零-闪烁
    byFontSize: BYTE;  //字体大小，1-大，2-中，3-小
    byTransparent: BYTE;  //透明度，取值范围0-100
    struColor: NET_DVR_RGB_COLOR;  //字体颜色
    wCoordinateX: WORD;  //OSD左上角X坐标
    wCoordinateY: WORD;  //OSD左上角Y坐标
    byContent: array[0..MAX_LEN_OSD_CONTENT-1] of BYTE;  //OSD信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_OSD_INFO = ^NET_DVR_OSD_INFO;

type
  NET_DVR_SUBWND_DECODE_OSD = record 
    dwSize: DWORD;  
    dwSubWndNo: DWORD;  //子窗口号（4字节组合方式）
    dwOSDNums: DWORD;  //该子窗口配置的OSD信息的个数
    struOSDList: array[0..MAX_NUM_OSD_ONE_SUBWND-1] of NET_DVR_OSD_INFO;  //OSD信息列表
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SUBWND_DECODE_OSD = ^NET_DVR_SUBWND_DECODE_OSD;

type
  NET_DVR_SUBWND_DECODE_OSD_LIST = record 
    dwSize: DWORD;  
    struSubWndList: array[0..MAX_NUM_SPLIT_WND-1] of NET_DVR_SUBWND_DECODE_OSD;  //所有子窗口的解码OSD
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SUBWND_DECODE_OSD_LIST = ^NET_DVR_SUBWND_DECODE_OSD_LIST;

type
  NET_DVR_DECODE_CHANNEL_OSD = record 
    dwSize: DWORD;  
    struOSDInfo: array[0..MAX_NUM_OSD-1] of NET_DVR_OSD_INFO;  //OSD信息列表
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_DECODE_CHANNEL_OSD = ^NET_DVR_DECODE_CHANNEL_OSD;

//热成像智能互斥配置参数
type
  NET_DVR_THERMINTELL_PARAM = record 
    dwSize: DWORD;  //结构体大小
    byIntellType: BYTE;  //智能功能资源配置类型,0~测温+异常行为检测(默认)，1~船只检测，2~火点检测,3~画中画功能, 4~人脸测温，5-测温+烟火检测，6-测温+火点检测 7-异常行为检测 8-测温
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_THERMINTELL_PARAM = ^NET_DVR_THERMINTELL_PARAM;

type
  NET_DVR_FACE_THERMOMETRY_ALARM = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    byRuleID: BYTE;  //人脸测温规则ID:1-40
    byRes1: array[0..3-1] of BYTE;  
    byRuleName: array[0..NAME_LEN-1] of BYTE;  //规则名称
    dwRelativeTime: DWORD;  //相对时标
    dwAbsTime: DWORD;  //绝对时标
    byFaceDetectionState: BYTE;  //人脸检测状态；0~未检测到人脸，1~已检测到人脸
    byThermometryUnit: BYTE;  //测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    byAlarmRule: BYTE;  //报警规则；0-最高温大于，1-最高温小于
    byRes2: array[0..1-1] of BYTE;  
    fAlarmTemperature: FLOAT;  //触发报警温度（-20.0~120.0℃，精确到小数点后1位）
    fRuleTemperature: FLOAT;  // 规则配置报警温度（-20.0~60.0℃，精确到小数点后1位）
    dwVisibleLightImageLen: DWORD;  // 可见光图片长度
    pVisibleLightImage: PBYTE;  //可见光图片指针
    dwFaceImageLen: DWORD;  // 人脸子图长度
    pFaceImage: PBYTE;  //人脸子图指针
    struFaceRegion: NET_VCA_RECT;  //人脸目标边界框，设备识别抓拍图片中，人脸子图坐标
    fMinTemperature: FLOAT;  // 最低温度（-20.0~120.0℃，精确到小数点后1位）
    fAverageTemperature: FLOAT;  //平均温（-20.0~120.0℃，精确到小数点后1位）
    struMinTemperaturePoint: NET_VCA_POINT;  //最低温度位置坐标
    struMaxTemperaturePoint: NET_VCA_POINT;  //最高温度位置坐标
    byRes: array[0..720-1] of BYTE;  
  end;
  LPNET_DVR_FACE_THERMOMETRY_ALARM = ^NET_DVR_FACE_THERMOMETRY_ALARM;

//导出GUID文件
type
  NET_DVR_GUID_FILE_EXPORT = record 
    dwSize: DWORD;  
    sLoginPassWord: array[0..NET_SDK_MAX_LOGIN_PASSWORD_LEN{128}-1] of AnsiChar;  //用户登录密码
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_GUID_FILE_EXPORT = ^NET_DVR_GUID_FILE_EXPORT;

//用户登录密码校验
type
  NET_DVR_LOGIN_PASSWORDCFG = record 
    dwSize: DWORD;  
    sLoginPassWord: array[0..NET_SDK_MAX_LOGIN_PASSWORD_LEN{128}-1] of AnsiChar;  //用户登录密码
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_LOGIN_PASSWORDCFG = ^NET_DVR_LOGIN_PASSWORDCFG;

//单个安全问题配置
type
  NET_DVR_SINGLE_SECURITY_QUESTION_CFG = record 
    dwSize: DWORD;  
    dwId: DWORD;  //序号（安全问题序号，只读）
    sAnswer: array[0..NET_SDK_MAX_ANSWER_LEN{256}-1] of AnsiChar;  //答案（获取时只读）
    byMark: BYTE;  //标记  0-未设置 1-已设置
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG = ^NET_DVR_SINGLE_SECURITY_QUESTION_CFG;

//安全问题配置
type
  NET_DVR_SECURITY_QUESTION_CFG = record 
    dwSize: DWORD;  
    struSecurityQuestion: array[0..NET_SDK_MAX_QUESTION_LIST_LEN{32}-1] of NET_DVR_SINGLE_SECURITY_QUESTION_CFG;  //安全问题列表
    sLoginPassWord: array[0..NET_SDK_MAX_LOGIN_PASSWORD_LEN{128}-1] of AnsiChar;  //admin用户登录密码
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_SECURITY_QUESTION_CFG = ^NET_DVR_SECURITY_QUESTION_CFG;

type
  NET_DVR_ALARMIN_TRIGGER_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号，从1开始
    dwAlarmInNo: DWORD;  //防区号，从0开始
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_ALARMIN_TRIGGER_COND = ^NET_DVR_ALARMIN_TRIGGER_COND;

type
  NET_DVR_FACELIB_GUARD_COND = record 
    dwSize: DWORD;  
    dwChannel: DWORD;  //通道号
    szFDID: array[0..68-1] of AnsiChar;  //人脸库的ID
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FACELIB_GUARD_COND = ^NET_DVR_FACELIB_GUARD_COND;

type
  NET_DVR_GUID_FILE_STATUS_INFO = record 
    dwSize: DWORD;  
    byLockStatus: BYTE;  //0：未锁定，1：锁定
    byPasswd: BYTE;  //0:密码错误，1：密码正确。注:该值未锁定时有效。
    byRetryNum: BYTE;  //剩余尝试次数。注:该值未锁定时有效
    byRes1: BYTE;  
    dwLockTime: DWORD;  //剩余锁定时间：单位秒。注:该值锁定时有效
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_GUID_FILE_STATUS_INFO = ^NET_DVR_GUID_FILE_STATUS_INFO;


//测温模式配置
type
  NET_DVR_THERMOMETRY_MODE = record 
    dwSize: DWORD;  //结构体大小
    byMode: BYTE;  //测温模式，0~普通模式，1~专家模式
    byThermometryROIEnabled: BYTE;  //测温ROI使能 0-保留 1-不开启 2-开启（基于互斥兼容考虑）
    byRes: array[0..62-1] of BYTE;  
  end;
  LPNET_DVR_THERMOMETRY_MODE = ^NET_DVR_THERMOMETRY_MODE;

//热成像相关算法库版本获取
type
  NET_DVR_THERMAL_ALGINFO = record 
    dwSize: DWORD;  //结构体大小
    sThermometryAlgName: array[0..NET_SDK_MAX_THERMOMETRYALGNAME{128}-1] of AnsiChar;  //测温算法库版本名称
    sShipsAlgName: array[0..NET_SDK_MAX_SHIPSALGNAME{128}-1] of AnsiChar;  //船只算法库版本名称
    sFireAlgName: array[0..NET_SDK_MAX_FIRESALGNAME{128}-1] of AnsiChar;  //火点检测算法库版本名称
    byRes: array[0..768-1] of BYTE;  
  end;
  LPNET_DVR_THERMAL_ALGINFO = ^NET_DVR_THERMAL_ALGINFO;

//电流锁定配置
type
  NET_DVR_CURRENT_LOCK = record 
    dwSize: DWORD;  //结构体大小
    byCurrentLock: BYTE;  //云台垂直电机锁定电流，0~不锁定，1~全流锁定，2~3/4流锁定，3~半流锁定
    byRes: array[0..255-1] of BYTE;  
  end;
  LPNET_DVR_CURRENT_LOCK = ^NET_DVR_CURRENT_LOCK;

//脸比对报警（数据透传方式）
type
  NET_VCA_FACESNAP_RAWDATA_ALARM = record 
    dwSize: DWORD;  //结构大小
    dwRelativeTime: DWORD;  // 相对时标
    dwAbsTime: DWORD;  // 绝对时标
    struDevInfo: NET_VCA_DEV_INFO;  //前端设备信息
    dwJsonDataLen: DWORD;  //json数据定义信息，0-没有数据，非0表示有数据（即结构体后跟着的json数据长度）
    pJsonBuff: PBYTE;  // json数据指针
    byRes: array[0..256-1] of BYTE;  // 保留字节
  end;
  LPNET_VCA_FACESNAP_RAWDATA_ALARM = ^NET_VCA_FACESNAP_RAWDATA_ALARM;

//高级校正参数
type
  NET_DVR_ADVANCE_SCREEN_CHECK_PARAM = record 
    byDelFullScreenGamut: BYTE;  //是否删除整屏色域参数,0-否,1-是，byOperateType 为3-删除校正数据时有效
    byDelLightPanelGamut: BYTE;  //是否删除灯板色域参数,0-否,1-是，byOperateType 为3-删除校正数据时有效
    byDelLightPanelWhiteBalance: BYTE;  //是否删除灯板白平衡参数,0-否,1-是，byOperateType 为3-删除校正数据时有效
    byRes: array[0..13-1] of BYTE;  
  end;
  LPNET_DVR_ADVANCE_SCREEN_CHECK_PARAM = ^NET_DVR_ADVANCE_SCREEN_CHECK_PARAM;

//LED屏幕校正参数
type
  NET_SDK_LED_SCREEN_CHECK_PARAM = record 
    dwSize: DWORD;  
    byOperateType: BYTE;  //操作类型，1-写入校正数据，2-校正预览，3-删除校正数据，4-加载原始数据，5-校正原始数据预览
    byIsRGBSynChk: BYTE;  //RGB是否同步调整，0-不支持，!0-支持，byOperateType为1、2时有效
    byScreenCheckType: BYTE;  //屏幕校正类型,0-普通校正,1-高级校正
    byRes1: BYTE;  
    wRgbPermil: WORD;  //RGB同步调整的千分比，byOperateType为1、2且byIsRGBSynChk非零时有效
    wRedPermil: WORD;  //红色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    wGreenPermil: WORD;  //绿色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    wBluePermil: WORD;  //蓝色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    dwRectCount: DWORD;  //矩形区域的数量
    struRectList: array[0..MAX_SCREEN_AREA_NUM-1] of NET_DVR_RECTCFG_EX;  //矩形区域列表，顺序存放
    struAdvanceScreenCheckParam: NET_DVR_ADVANCE_SCREEN_CHECK_PARAM;  //高级校正参数,仅byScreenCheckType为1时生效
    byRes2: array[0..48-1] of BYTE;  
  end;
  LPNET_SDK_LED_SCREEN_CHECK_PARAM = ^NET_SDK_LED_SCREEN_CHECK_PARAM;

//LED屏幕校正响应数据
type
  NET_SDK_SCREEN_CHECK_RESPONSE_DATA = record 
    dwSize: DWORD;  
    byDataType: BYTE;  //数据类型，1-进度（整体进度），2-状态
    byOperateType: BYTE;  //操作类型，1-写入校正数据，2-校正预览，3-删除校正数据
    byProgress: BYTE;  //进度，byDataType为1时有效，0-100
    byStatus: BYTE;  //状态，byDataType为2时有效，1-LED屏幕区域校正失败，2-LED屏幕区域对应的接收卡不存在，3-加载校正数据失败（原始数据异常）
    //4-该屏幕型号不支持校正，5-设备忙（正在校正），6-设备内存不足
    struRect: NET_DVR_RECTCFG_EX;  //LED屏幕区域，byDataType为2时有效
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_SDK_SCREEN_CHECK_RESPONSE_DATA = ^NET_SDK_SCREEN_CHECK_RESPONSE_DATA;

type
  NET_DVR_PLAY_BY_NAME_PARA = record 
    szFileName: array[0..100-1] of AnsiChar;  //回放文件名
    byDownload: BYTE;  //是否下载 0-否，1-是
    byRes1: array[0..127-1] of BYTE;  
    hWnd: HWND;  //回放的窗口句柄，若置为空，SDK仍能收到码流数据，但不解码显示
    struAddr: NET_DVR_ADDRESS;  //文件所在集群中CS地址信息，该信息文件查找时会返回
    //如果为空表示本登录地址
    byRes2: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_PLAY_BY_NAME_PARA = ^NET_DVR_PLAY_BY_NAME_PARA;

type
  NET_DVR_PLAYBCK_BYTIME_COND_PCNVR = record 
    dwSize: DWORD;  
    struIpAddr: NET_DVR_IPADDR;  
    wIpPort: WORD;  
    byRes: array[0..2-1] of BYTE;  
    sDomainName: array[0..MAX_DOMAIN_NAME-1] of AnsiChar;  
    sSerial: array[0..SERIALNO_LEN-1] of AnsiChar;  
    iChannel: LONG;  
    struStartTime: NET_DVR_TIME;  
    struStopTime: NET_DVR_TIME;  
    hWnd: HWND;  
  end;
  LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR = ^NET_DVR_PLAYBCK_BYTIME_COND_PCNVR;

//按文件名下载集群录像文件
type
  NET_DVR_DOWNLOAD_BY_NAME_COND = record 
    pFileName: PAnsiChar;  //回放文件名，包含\0，最大100字节
    pSavedFileName: PAnsiChar;  //文件保存位置
    struAddr: NET_DVR_ADDRESS;  //文件所在集群中CS地址信息，该信息文件查找时会返回
    //如果为空表示本登录地址
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_DOWNLOAD_BY_NAME_COND = ^NET_DVR_DOWNLOAD_BY_NAME_COND;

type
  NET_DVR_PIC_PARAM = record //查找结果结构体
    pDVRFileName: PAnsiChar;  //图片名，包含\0，最大64字节
    pSavedFileBuf: PAnsiChar;  //保存图片的缓冲区，内存外部申请释放
    dwBufLen: DWORD;  //缓冲区大小
    lpdwRetLen: PDWORD;  //实际收到的数据长度指针，不能为NULL
    struAddr: NET_DVR_ADDRESS;  //图片所在的地址信息，图片查找时会返回
    byRes: array[0..256-1] of BYTE;  //保留字节
  end;
  LPNET_DVR_PIC_PARAM = ^NET_DVR_PIC_PARAM;

const
  NET_SDK_MAX_INDENTITY_KEY_LEN = 64;    //交互操作口令长度

//导入人脸数据条件
type
  NET_DVR_FACELIB_COND = record 
    dwSize: DWORD;  
    szFDID: array[0..NET_SDK_MAX_FDID_LEN{256}-1] of AnsiChar;  //人脸库ID
    byConcurrent: BYTE;  //设备并发处理 0-不开启，1-开始
    byCover: BYTE;  //是否覆盖式导入 0-否，1-是
    byCustomFaceLibID: BYTE;  //FDID是否是自定义，0-不是，1-是；
    {当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportNoSaveUploadPicture能力节点时，
    代表非并发处理模式下，支持不保存上传原图的操作:当上传成功图片并设备建模成功后，会将上传的原图进行删除。
    注：该操作无法与并发处理同时进行。}
    byPictureSaveMode: BYTE;  //上传原图保存模式，0-保存，1-不保存;
    byIdentityKey: array[0..NET_SDK_MAX_INDENTITY_KEY_LEN{64}-1] of BYTE;  //交互操作口令
    byRes: array[0..60-1] of BYTE;  
  end;
  LPNET_DVR_FACELIB_COND = ^NET_DVR_FACELIB_COND;

//导入人体数据条件
type
  NET_DVR_HBDLIB_COND = record 
    dwSize: DWORD;  
    szHBDID: array[0..NET_SDK_MAX_HBDID_LEN{256}-1] of AnsiChar;  //人体库ID
    byConcurrent: BYTE;  //设备并发处理 0-不开启，1-开始
    byCover: BYTE;  //是否覆盖式导入 0-否，1-是
    byCustomHBDID: BYTE;  // HBDID是否是自定义，0-不是，1-是；
    byRes: array[0..125-1] of BYTE;  
  end;
  LPNET_DVR_HBDLIB_COND = ^NET_DVR_HBDLIB_COND;

type
  NET_DVR_EXPORT_PUBLISH_SCHEDULE = record 
    dwScheduleID: DWORD;  // 日程索引
    fnDownloadFileCallBack: DOWNLOAD_DATA_CB;  //数据回调函数
    pUser: PVOID;  //用户数据指针
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_EXPORT_PUBLISH_SCHEDULE = ^NET_DVR_EXPORT_PUBLISH_SCHEDULE;

type
  NET_DVR_GBT28181_AUDIO_OUTPUT_COND = record 
    dwSize: DWORD;  
    dwAudioChannel: DWORD;  //语音对讲通道号
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_GBT28181_AUDIO_OUTPUT_COND = ^NET_DVR_GBT28181_AUDIO_OUTPUT_COND;

//GBT28181协议的语音输出通道配置 配置结构
type
  NET_DVR_GBT28181_AUDIO_OUTPUT_CFG = record 
    dwSize: DWORD;  
    szAudioOutNumID: array[0..MAX_COMPRESSIONID_LEN-1] of AnsiChar;  //设备语音输出编码ID
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_GBT28181_AUDIO_OUTPUT_CFG = ^NET_DVR_GBT28181_AUDIO_OUTPUT_CFG;

type
  NET_DVR_NOTICE_VIDEO_DATA = record 
    dwSize: DWORD;  
    dwFileSize: DWORD;  //文件大小，单位：字节
    byNoticeNumber: array[0..MAX_NOTICE_NUMBER_LEN-1] of BYTE;  //公告编号
    byRes: array[0..2016-1] of BYTE;  
  end;
  LPNET_DVR_NOTICE_VIDEO_DATA = ^NET_DVR_NOTICE_VIDEO_DATA;

type
  NET_DVR_NOTICE_VIDEO_DATA_COND = record 
    dwSize: DWORD;  
    byRes: array[0..256-1] of BYTE;  //保留
  end;
  LPNET_DVR_NOTICE_VIDEO_DATA_COND = ^NET_DVR_NOTICE_VIDEO_DATA_COND;

type
  NET_DVR_NOTICE_VIDEO_DATA_CFG = record 
    dwSize: DWORD;  
    dwDataLen: DWORD;  //数据长度
    pDataBuffer: PAnsiChar;  //数据指针
    byDataType: BYTE;  //数据类型：0-无效，1-结构体数据（NET_DVR_NOTICE_VIDEO_DATA），2-视频数据
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_NOTICE_VIDEO_DATA_CFG = ^NET_DVR_NOTICE_VIDEO_DATA_CFG;

type
  NET_DVR_UPGRADE_FIRMWARE_INFO = record 
    dwMagicNumber: DWORD;  // 魔术字段，固定值0x484b5753 
    dwCheckSum: DWORD;  // 文件头校验和 
    dwHeadLen: DWORD;  // 文件头长度 
    dwFileNums: DWORD;  // 文件个数 
    dwLanguage: DWORD;  // 语言，1-英文或多语言，2-中文 
    dwDeviceClassID: DWORD;  // 1 C DS9000 DVR 
    dwOemCode: DWORD;  // 1 C private  
    byUpgradeVersion: BYTE;  // 升级版本: 0xFE - 需判断flash, ram, DSP ram 的容量
    byResFeature: array[0..15-1] of BYTE;  // 保留字段 
    byFlashSize: BYTE;  // 0 - do not need check; 1 - 16M; 2 - 32M; 3 - 64M  
    byRamSize: BYTE;  // 0 - do not need check; 1 - 128M; 2 - 256M; 3 - 512M; 4 - 1024M
    byDspRamSize: BYTE;  // 0 - do not need check; 1 - 64M; 2 - 128M; 3 - 256M 
    byRes: array[0..17-1] of BYTE;  // 保留 
  end;
  LPNET_DVR_UPGRADE_FIRMWARE_INFO = ^NET_DVR_UPGRADE_FIRMWARE_INFO;


type
  NET_DVR_SCHEDULE_FILE_RET = record 
    dwSize: DWORD;  
    szFileName: array[0..32-1] of AnsiChar;  //文件名
    dwFileLen: DWORD;  //文件长度
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_SCHEDULE_FILE_RET = ^NET_DVR_SCHEDULE_FILE_RET;

const
  NET_SDK_MAX_EXAM_ROUND_NO = 64;    //考试场次编号最大长度
  NET_SDK_MAX_EXAM_NO = 64;    //考试编号最大长度
  NET_SDK_MAX_EXAM_SUBJECT = 64;    //考试科目最大长度
  NET_SDK_MAX_TEACHER_NO = 64;    //监考老师编号最大长度
  NET_SDK_MAX_TEACHER_NAME = 64;    //监考老师姓名最大长度
  NET_SDK_MAX_EXAMINEE_NO = 64;    //考生编号最大长度
  NET_SDK_MAX_ADMISSION_TICKET = 64;    //准考证号最大长度

type
  NET_DVR_EXAM_INFO_COND = record 
    dwSize: DWORD;  
    dwExamNumber: DWORD;  //考试信息数目
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EXAM_INFO_COND = ^NET_DVR_EXAM_INFO_COND;

type
  NET_DVR_EXAM_INFO_CFG = record 
    dwSize: DWORD;  
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byExamNo: array[0..NET_SDK_MAX_EXAM_NO{64}-1] of BYTE;  //考试编号（某次考试，包含多场考试）
    byExamSubject: array[0..NET_SDK_MAX_EXAM_SUBJECT{64}-1] of BYTE;  //考试科目
    byTeacherNo: array[0..NET_SDK_MAX_TEACHER_NO{64}-1] of BYTE;  //监考老师编号
    byTeacherName: array[0..NET_SDK_MAX_TEACHER_NAME{64}-1] of BYTE;  //监考老师姓名
    struStartTime: NET_DVR_TIME;  //考试开始时间
    struEndTime: NET_DVR_TIME;  //考试结束时间
    byExamInfoValid: BYTE;  //考试信息是否有效：0-无效，1-有效（用于考试场次编号删除考试信息，该字段为0时代表删除）
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_EXAM_INFO_CFG = ^NET_DVR_EXAM_INFO_CFG;

type
  NET_DVR_EXAM_INFO_STATUS = record 
    dwSize: DWORD;  
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byStatus: BYTE;  //下发状态：0-无效，1-失败，2-成功（代表该考试场次下发是否成功）
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_EXAM_INFO_STATUS = ^NET_DVR_EXAM_INFO_STATUS;

type
  NET_DVR_EXAMINEE_INFO_COND = record 
    dwSize: DWORD;  
    dwExamineeNumber: DWORD;  //考生信息数目
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EXAMINEE_INFO_COND = ^NET_DVR_EXAMINEE_INFO_COND;

type
  NET_DVR_EXAMINEE_INFO_CFG = record 
    dwSize: DWORD;  
    byExamineeNo: array[0..NET_SDK_MAX_EXAMINEE_NO{64}-1] of BYTE;  //考生编号
    byAdmissionTicket: array[0..NET_SDK_MAX_ADMISSION_TICKET{64}-1] of BYTE;  //准考证号
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //考生关联的卡号
    bySex: BYTE;  //性别：0-无效，1-男，2-女
    byExamineeInfoValid: BYTE;  //考生信息是否有效：0-无效，1-有效（用于考生编号和考试场次编号删除考生信息，该字段为0时代表删除）
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_DVR_EXAMINEE_INFO_CFG = ^NET_DVR_EXAMINEE_INFO_CFG;

type
  NET_DVR_EXAMINEE_INFO_STATUS = record 
    dwSize: DWORD;  
    byExamineeNo: array[0..NET_SDK_MAX_EXAMINEE_NO{64}-1] of BYTE;  //考生编号
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byStatus: BYTE;  //下发状态：0-无效，1-失败，2-成功（代表该考生信息下发是否成功）
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_EXAMINEE_INFO_STATUS = ^NET_DVR_EXAMINEE_INFO_STATUS;

type
  NET_DVR_EXAM_COMPARE_RESULT_COND = record 
    dwSize: DWORD;  
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byExamNo: array[0..NET_SDK_MAX_EXAM_NO{64}-1] of BYTE;  //考试编号（某次考试，包含多场考试）
    struStartTime: NET_DVR_TIME;  //开始时间
    struEndTime: NET_DVR_TIME;  //结束时间
    byRes: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_EXAM_COMPARE_RESULT_COND = ^NET_DVR_EXAM_COMPARE_RESULT_COND;

type
  NET_DVR_EXAM_COMPARE_RESULT_CFG = record 
    dwSize: DWORD;  
    struTime: NET_DVR_TIME;  //时间
    byExamineeNo: array[0..NET_SDK_MAX_EXAMINEE_NO{64}-1] of BYTE;  //考生编号
    byAdmissionTicket: array[0..NET_SDK_MAX_ADMISSION_TICKET{64}-1] of BYTE;  //准考证号
    byExamNo: array[0..NET_SDK_MAX_EXAM_NO{64}-1] of BYTE;  //考试编号（某次考试，包含多场考试）
    byExamRoundNo: array[0..NET_SDK_MAX_EXAM_ROUND_NO{64}-1] of BYTE;  //考试场次编号（某堂具体考试）
    byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //考生关联的卡号
    dwPicDataLen: DWORD;  //比对抓拍图片数据大小，不为0是表示后面带数据
    pPicData: PAnsiChar;  //比对抓拍图片指针
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_EXAM_COMPARE_RESULT_CFG = ^NET_DVR_EXAM_COMPARE_RESULT_CFG;

type
  NET_DVR_BLOCKLIST_PICTURE_COND = record 
    dwSize: DWORD;  
    dwPictureNum: DWORD;  //图片数量
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_PICTURE_COND = ^NET_DVR_BLOCKLIST_PICTURE_COND;

type
  NET_DVR_BLOCKLIST_PICTURE_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN{32}-1] of BYTE;  //卡号
    byStatus: BYTE;  //状态：0-无效，，1-处理中，2-上传失败，3-成功
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_PICTURE_STATUS = ^NET_DVR_BLOCKLIST_PICTURE_STATUS;

type
  NET_DVR_BLOCKLIST_PICTURE_CFG = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN{32}-1] of BYTE;  //卡号
    byName: array[0..NAME_LEN{32}-1] of BYTE;  //姓名
    bySex: BYTE;  //性别：0-无效，1-男，2-女
    byPictureValid: BYTE;  //禁止名单图片是否有效：0-无效，1-有效（用于按卡号删除禁止名单图片，该字段为0时代表删除，删除时不传递禁止名单图片）
    byRes1: array[0..2-1] of BYTE;  
    dwPictureLen: DWORD;  //禁止名单图片长度（图片大小不超过1M）
    pPictureBuffer: PAnsiChar;  //禁止名单图片指针
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_BLOCKLIST_PICTURE_CFG = ^NET_DVR_BLOCKLIST_PICTURE_CFG;

type
  NET_DVR_UPLOAD_ID_BLOCKLIST_COND = record 
    dwSize: DWORD;  
    dwBlockListNum: DWORD;  //禁止名单数量
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_ID_BLOCKLIST_COND = ^NET_DVR_UPLOAD_ID_BLOCKLIST_COND;

type
  NET_DVR_UPLOAD_ID_BLOCKLIST_CFG = record 
    dwSize: DWORD;  
    struIDCardCfg: NET_DVR_ID_CARD_INFO;  //身份证信息（该结构体中姓名和身份证号码为必填项，其他字段为选填项）
    byBlockListValid: BYTE;  //身份证禁止名单是否有效：0-无效，1-有效（用于按身份证号码删除身份证禁止名单，该字段为0时代表删除）
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_ID_BLOCKLIST_CFG = ^NET_DVR_UPLOAD_ID_BLOCKLIST_CFG;

type
  NET_DVR_UPLOAD_ID_BLOCKLIST_STATUS = record 
    dwSize: DWORD;  
    byIDNum: array[0..MAX_ID_NUM_LEN-1] of BYTE;  //身份证号码
    byStatus: BYTE;  //状态：0-无效，1-处理中，2-上传失败，3-成功
    byRes: array[0..63-1] of BYTE;  
  end;
  LPNET_DVR_UPLOAD_ID_BLOCKLIST_STATUS = ^NET_DVR_UPLOAD_ID_BLOCKLIST_STATUS;

type
  NET_DVR_ALARM_ISAPI_INFO = record 
    pAlarmData: PAnsiChar;  // 报警数据
    dwAlarmDataLen: DWORD;  // 报警数据长度
    byDataType: BYTE;  // 0-invalid,1-xml,2-json
    byPicturesNumber: BYTE;  // 图片数量
    byRes: array[0..2-1] of BYTE;  
    pPicPackData: PVOID;  // 图片变长部分
    byRes1: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_ISAPI_INFO = ^NET_DVR_ALARM_ISAPI_INFO;

type
  NET_DVR_ALARM_ISAPI_PICDATA = record 
    dwPicLen: DWORD;  
    byPicType: BYTE;  //图片格式: 1-jpg, 2-wav, 3-mp4
    byRes: array[0..3-1] of BYTE;  
    szFilename: array[0..MAX_FILE_PATH_LEN-1] of AnsiChar;  
    pPicData: PBYTE;  
  end;
  LPNET_DVR_ALARM_ISAPI_PICDATA = ^NET_DVR_ALARM_ISAPI_PICDATA;

type
  NET_DVR_FORMAT_HDD = record 
    dwSize: DWORD;  //结构体长度
    dwDiskNo: DWORD;  //硬盘号，从0开始，0xff表示对所有硬盘有效（不包括只读硬盘）
    struLocateIP: NET_DVR_IPADDR;  //该硬盘所在设备的IP（对应硬盘管理参数V50中获取到的szHDLocateIP信息）
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_FORMAT_HDD = ^NET_DVR_FORMAT_HDD;

type
  NET_DVR_CHECK_FACE_PICTURE_COND = record 
    dwSize: DWORD;  
    dwPictureNum: DWORD;  //图片数量
    byCheckTemplate: BYTE;  //0-校验图片是否合法（默认），1-校验图片和建模数据是否匹配
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_CHECK_FACE_PICTURE_COND = ^NET_DVR_CHECK_FACE_PICTURE_COND;

type
  NET_DVR_CHECK_FACE_PICTURE_CFG = record 
    dwSize: DWORD;  
    dwPictureNo: DWORD;  //图片编号
    dwPictureLen: DWORD;  //图片长度（图片大小不超过200k）
    pPictureBuffer: PAnsiChar;  //图片指针
    dwFaceTemplateLen: DWORD;  //人脸建模数据长度
    pFaceTemplateBuffer: PAnsiChar;  //人脸建模数据指针
    byRes: array[0..248-1] of BYTE;  
  end;
  LPNET_DVR_CHECK_FACE_PICTURE_CFG = ^NET_DVR_CHECK_FACE_PICTURE_CFG;

type
  NET_DVR_CHECK_FACE_PICTURE_STATUS = record 
    dwSize: DWORD;  
    dwPictureNo: DWORD;  //图片编号
    byCheckStatus: BYTE;  //校验结果：0-无效，1-建模成功，2-建模失败，3-人脸模块通讯异常，4-图像无人脸，5-人脸朝上，6-人脸朝下，7-人脸偏左，8-人脸偏右，9-人脸顺时旋转，
    //10 - 人脸逆时旋转，11-人眼间距小，12-人脸和模板匹配，13-人脸和模板不匹配,14-传输数据有误
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_CHECK_FACE_PICTURE_STATUS = ^NET_DVR_CHECK_FACE_PICTURE_STATUS;

type
  NET_SDK_NPQ_STATE_SINGLE = record 
    dwRttUs: DWORD;  //rtt，单位us
    dwRealRttUs: DWORD;  //实时rtt，单位us
    dwBitRate: DWORD;  //码率，单位bps
    byLossFraction: BYTE;  //丢包率，单位1/256
    byLossFraction2: BYTE;  //经过恢复之后的丢包率，只能在接收端获取，单位1/256
    byRes: array[0..126-1] of BYTE;  
  end;
  LPNET_SDK_NPQ_STATE_SINGLE = ^NET_SDK_NPQ_STATE_SINGLE;


type
  NET_SDK_NPQ_STATE = record 
    dwSize: DWORD;  
    struAudioState: NET_SDK_NPQ_STATE_SINGLE;  //音频传输状态
    struVideoState: NET_SDK_NPQ_STATE_SINGLE;  //视频传输状态
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_SDK_NPQ_STATE = ^NET_SDK_NPQ_STATE;

type
  NET_SDK_NPQ_NOTIFY_PARAM = record 
    iVersion: LONG;  //结构体版本，用于以后兼容
    dwBitRate: DWORD;  //码率 单位bps
    bHaveBitrate: BOOL;  //码率字段是否有效标志
    bHaveForceIframe: BOOL;  //强制I帧字段是否有效标志
    bForceIframe: BOOL;  //强制I帧
    bHaveScale: BOOL;  //scale字段是否有效标志,回放时此字段无效,请通过SDK快放接口实现
    fScale: FLOAT;  //scale信息  1、2、4、8,回放时此字段无效,请通过SDK快放接口实现
    res: array[0..240-1] of BYTE;  
  end;
  LPNET_SDK_NPQ_NOTIFY_PARAM = ^NET_SDK_NPQ_NOTIFY_PARAM;

//报警信息查询条件结构体
type
  NET_DVR_ALARM_SEARCH_COND = record 
    dwSize: DWORD;  
    strStartTime: NET_DVR_TIME_SEARCH_COND;  //开始时间,时间为空则代表不通过时间筛选。
    strStopTime: NET_DVR_TIME_SEARCH_COND;  //结束时间, 时间为空则代表不通过时间筛选。
    {
    报警命令，该字段值与报警布防类型相同，目前支持：
    COMM_VCA_ALARM  0x4993  智能检测报警
    COMM_UPLOAD_FACESNAP_RESULT    0x1112  人脸识别结果上传
    COMM_SNAP_MATCH_ALAR    0x2902  人脸比对结果上传
    }
    dwAlarmComm: DWORD;  //若该命令为空这代表不进行报警命令过滤。
    sAlarmUID: array[0..64-1] of AnsiChar;  //UID标识（上传报警时设备返回的UID标识，64字节的长度，可以使用时间（精确到毫秒）加上随即数的方式组成）,为空则代表不区分UID
    wEventType: WORD;  //事件类型，仅dwAlarmComm为COMM_VCA_ALARM  0x4993  智能检测报警有效，0-表示所有事件,1-混合目标检测（mixedTargetDetection）,2-雷视目标检测（radarVideoDetection）
    wSubEventType: WORD;  //子事件类型，0-表示所有子事件，其余值根据wEventType的取值变化而变化，具体参见能力集。
    bySupport: BYTE;  //保留
    byNoBoundary: BYTE;  //是否不带boundary，0-否，1-是，仅dwAlarmComm为智能检测报警时有效，当设置为1时输出事件类型为COMM_ISAPI_ALARM
    byRes: array[0..122-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_SEARCH_COND = ^NET_DVR_ALARM_SEARCH_COND;
//报警信息查询结果结构体
type
  NET_DVR_ALARM_SEARCH_RESULT = record 
    dwSize: DWORD;  
    {
    报警命令，该字段值与报警布防类型相同，目前支持：
    COMM_VCA_ALARM  0x4993    智能检测报警
    COMM_UPLOAD_FACESNAP_RESULT    0x1112  人脸识别结果上传
    COMM_SNAP_MATCH_ALARM   0x2902 人脸比对结果上传
    COMM_ISAPI_ALARM        0x6009 ISAPI报警
    }
    dwAlarmComm: DWORD;  
    {
    报警信息，该字段值与报警信息相同，目前支持：
    当COMM_VCA_ALARM时，该报警信息为JSON报文
    当COMM_UPLOAD_FACESNAP_RESULT时，该报警信息为NET_VCA_FACESNAP_RESULT
    当COMM_SNAP_MATCH_ALARM时，该报警信息为NET_VCA_FACESNAP_MATCH_ALARM
    当COMM_ISAPI_ALARM时，该报警信息为NET_DVR_ALARM_ISAPI_INFO
    }
    dwAlarmLen: DWORD;  //报警信息，即pAlarmInfo指针指向的数据长度
    pAlarmInfo: PAnsiChar;  
    struAlarmer: NET_DVR_ALARMER;  
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_ALARM_SEARCH_RESULT = ^NET_DVR_ALARM_SEARCH_RESULT;

type
  NET_DVR_FACE_AND_TEMPLATE_COND = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号（设置时该参数不设置）
    dwFaceNum: DWORD;  //设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    byRes: array[0..128-1] of BYTE;  //保留
  end;
  LPNET_DVR_FACE_AND_TEMPLATE_COND = ^NET_DVR_FACE_AND_TEMPLATE_COND;

type
  NET_DVR_FACE_AND_TEMPLATE_CFG = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    dwFaceLen: DWORD;  //人脸图片长度（图片大小不超过200k）
    pFaceBuffer: PAnsiChar;  //人脸图片指针
    dwFaceTemplateLen: DWORD;  //人脸建模数据长度
    pFaceTemplateBuffer: PAnsiChar;  //人脸建模数据指针
    byRes: array[0..116-1] of BYTE;  
  end;
  LPNET_DVR_FACE_AND_TEMPLATE_CFG = ^NET_DVR_FACE_AND_TEMPLATE_CFG;

type
  NET_DVR_FACE_AND_TEMPLATE_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byRecvStatus: BYTE;  //人脸下发状态，按字节表示，0-失败，1-成功，2-内存已满（人脸数据满）
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_FACE_AND_TEMPLATE_STATUS = ^NET_DVR_FACE_AND_TEMPLATE_STATUS;

type
  NET_DVR_SINGLE_HEATMAP_RESULT_PDC = record 
    dwMaxHeatMapValue: DWORD;  //最大热度值
    dwMinHeatMapValue: DWORD;  //最小热度值
    dwTimeHeatMapValue: DWORD;  // (时间热度值)平均热度值
    wArrayLine: WORD;  //图片像素点行值
    wArrayColumn: WORD;  //图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
    pBuffer: PBYTE;  //热度图片像素点数据信息
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_SINGLE_HEATMAP_RESULT_PDC = ^NET_DVR_SINGLE_HEATMAP_RESULT_PDC;

//热度图报警上传
type
  NET_DVR_HEATMAP_RESULT_PDC = record 
    dwSize: DWORD;  
    struStartTime: NET_DVR_TIME_EX;  //开始时间
    struEndTime: NET_DVR_TIME_EX;  //结束时间
    struDevInfo: NET_VCA_DEV_INFO;  //设备信息
    wDevInfoIvmsChannelEx: WORD;  //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    byBrokenNetHttp: BYTE;  //断网续传标志位，0-不是重传数据，1-重传数据
    byArrayUnitType: BYTE;  //矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型）,1-byte, 2-short,4- int
    {
    struSingleHeatMap[0]:表示按人数统计中的画面中停留人数的热度值；
    struSingleHeatMap[1]:表示按人数统计中的画面中离开人数的热度值；
    }
    struSingleHeatMap: array[0..2-1] of NET_DVR_SINGLE_HEATMAP_RESULT_PDC;  
    wCurNumber: WORD;  //当前人数
    wLeaveNumber: WORD;  //离开人数
 {$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pEventNotificationAlertBuff: PAnsiChar;  //其Buff对应EventNotificationAlert JSON Block("eventType":  "heatmap")
{$ELSE}
    pEventNotificationAlertBuff: PAnsiChar;  //其Buff对应EventNotificationAlert JSON Block("eventType":  "heatmap")
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    dwEventNotificationAlertLen: DWORD;  //长度对应EventNotificationAlert JSON Block("eventType":  "heatmap")数据长度
    byRes1: array[0..48-1] of BYTE;  
  end;
  LPNET_DVR_HEATMAP_RESULT_PDC = ^NET_DVR_HEATMAP_RESULT_PDC;

//设备支持AI开放平台接入，上传视频检测数据
type
  NET_AIOP_VIDEO_HEAD = record 
    dwSize: DWORD;  //dwSize = sizeof(NET_AIOP_VIDEO_HEAD)
    dwChannel: DWORD;  //设备分析通道的通道号；
    struTime: NET_DVR_SYSTEM_TIME;  //时间
    szTaskID: array[0..64-1] of AnsiChar;  //视频任务ID，来自于视频任务派发
    dwAIOPDataSize: DWORD;  //对应AIOPDdata数据长度
    dwPictureSize: DWORD;  //对应分析图片长度
    szMPID: array[0..64-1] of AnsiChar;  //检测模型包ID，用于匹配AIOP的检测数据解析；可以通过URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)获取当前设备加载的模型包的label description信息；
    pBufferAIOPData: PBYTE;  //AIOPDdata数据
    pBufferPicture: PBYTE;  //对应分析图片数据
    byPictureMode: BYTE;  //图片数据传输模式 0-二进制，1-武汉云云存储，2-设备本地存储，当byPictureMode为0时pBufferPicture为二进制数据，
                        //当byPictureMode为1时pBufferPicture为武汉云URL,当byPictureMode为2时pBufferPicture为设备本地存储URL（下载图片的时候，需要基于HTTP协议做设备的认证处理，是基于设备的用户名和密码认证）
    byCompressedDotMatrixMode: BYTE;  //压缩后的点阵图传输模式 0-二进制，1-武汉云云存储，当byCompressedDotMatrixMode为0时pCompressedDotMatrixBuff为二进制数据，当byCompressedDotMatrixMode为1时pCompressedDotMatrixBuff为武汉云URL
    byRes2: array[0..2-1] of BYTE;  //保留字节
    dwPresetIndex: DWORD;  //预置点序号
    dwAddInfoPictureSize: DWORD;  //对应分析的附加图片长度
    pAddInfoPictureBuffer: PBYTE;  //对应分析的附加图片数据(对于热成像双通道设备，该节点表示非报警通道的图片)
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pFacePicBuff: PAnsiChar;  //人脸小图图片指针
{$ELSE}
    pFacePicBuff: PAnsiChar;  //人脸小图图片指针
    byRes3: array[0..4-1] of BYTE;  
{$ENDIF}
    dwFacePicBuffLen: DWORD;  //长度对应pFacePicBuff数据长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pComparisonPicBuff: PAnsiChar;  //底库比对图图片指针
{$ELSE}
    pComparisonPicBuff: PAnsiChar;  //底库比对图图片指针
    byRes4: array[0..4-1] of BYTE;  
{$ENDIF}
    dwComparisonPicBuffLen: DWORD;  //长度对应pComparisonPicBuff数据长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
{$ELSE}
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
    byRes5: array[0..4-1] of BYTE;  
{$ENDIF}
    dwCompressedDotMatrixBuffLen: DWORD;  //长度对应pCompressedDotMatrixBuff数据长度
    byRes: array[0..132-1] of BYTE;  
  end;
  LPNET_AIOP_VIDEO_HEAD = ^NET_AIOP_VIDEO_HEAD;

//设备支持AI开放平台接入，上传图片检测数据
type
  NET_AIOP_PICTURE_HEAD = record 
    dwSize: DWORD;  //dwSize = sizeof(NET_AIOP_PICTURE_HEAD)
    struTime: NET_DVR_SYSTEM_TIME;  //时间
    szPID: array[0..64-1] of AnsiChar;  //透传下发的图片ID，来自于图片任务派发
    dwAIOPDataSize: DWORD;  //对应AIOPDdata数据长度
    byStatus: BYTE;  //状态值：0-成功，1-图片大小错误
    byPictureMode: BYTE;  //图片数据传输模式(当dwPictureSize>0时有效) 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    byCompressedDotMatrixMode: BYTE;  // /压缩后的点阵图传输模式 0-二进制，1-武汉云云存储，当byCompressedDotMatrixMode为0时pCompressedDotMatrixBuff为二进制数据，当byCompressedDotMatrixMode为1时pCompressedDotMatrixBuff为武汉云URL
    byRes1: array[0..1-1] of BYTE;  
    szMPID: array[0..64-1] of AnsiChar;  //检测模型包ID，用于匹配AIOP的检测数据解析；
    pBufferAIOPData: PBYTE;  //AIOPDdata数据
    dwPresetIndex: DWORD;  //预置点序号
    dwPictureSize: DWORD;  //图片或URL长度
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pBufferPicture: PBYTE;  //对应分析图片数据或URL
{$ELSE}
    pBufferPicture: PBYTE;  //对应分析图片数据或URL
    byRes2: array[0..4-1] of BYTE;  
{$ENDIF}
    szTaskID: array[0..64-1] of AnsiChar;  //任务ID, 数据中心图片任务分析结果上报携带此字段
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
{$ELSE}
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
    byRes5: array[0..4-1] of BYTE;  
{$ENDIF}
    dwCompressedDotMatrixBuffLen: DWORD;  //长度对应pCompressedDotMatrixBuff数据长度
    byRes: array[0..92-1] of BYTE;  
  end;
  LPNET_AIOP_PICTURE_HEAD = ^NET_AIOP_PICTURE_HEAD;

const
  MAX_FILE_NAME_LEN = 100;    //最大文件名长
type
  NET_DVR_DOOR_FILE_UPLOAD_PARAM = record 
    dwSize: DWORD;  
    dwFileSize: DWORD;  //文件大小，单位：字节
    byFileName: array[0..MAX_FILE_NAME_LEN-1] of BYTE;  //文件名称
    byRes1: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_DOOR_FILE_UPLOAD_PARAM = ^NET_DVR_DOOR_FILE_UPLOAD_PARAM;

const
  AUDIO_FILE_NAME_LEN = 32;    //音频文件名称长度
//上传音频控制文件
type
  NET_DVR_TRANS_AUDIO_INFO = record 
    dwSize: DWORD;  //结构体大小
    sAudioName: array[0..AUDIO_FILE_NAME_LEN-1] of AnsiChar;  //音频文件名称
    byAudioFormat: BYTE;  //音频数据格式：0-wav
    byRes: array[0..127-1] of BYTE;  
  end;
  LPNET_DVR_TRANS_AUDIO_INFO = ^NET_DVR_TRANS_AUDIO_INFO;

type
  NET_AIOP_POLLING_VIDEO_HEAD = record 
    dwSize: DWORD;  //dwSize = sizeof(NET_AIOP_POLLING_VIDEO_HEAD)
    dwChannel: DWORD;  //设备分析通道的通道号(走SDK协议)；
    struTime: NET_DVR_SYSTEM_TIME;  //时间
    szTaskID: array[0..64-1] of AnsiChar;  //轮询抓图任务ID，来自于轮询抓图任务派发
    dwAIOPDataSize: DWORD;  //对应AIOPDdata数据长度
    dwPictureSize: DWORD;  //对应分析图片长度
    szMPID: array[0..64-1] of AnsiChar;  //检测模型包ID，用于匹配AIOP的检测数据解析；
    pBufferAIOPData: PBYTE;  //AIOPDdata数据
    pBufferPicture: PBYTE;  //对应分析图片数据
    byPictureMode: BYTE;  //图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    byCompressedDotMatrixMode: BYTE;  // /压缩后的点阵图传输模式 0-二进制，1-武汉云云存储，当byCompressedDotMatrixMode为0时pCompressedDotMatrixBuff为二进制数据，当byCompressedDotMatrixMode为1时pCompressedDotMatrixBuff为武汉云URL
    byRes2: array[0..2-1] of BYTE;  //保留字节
    dwPresetIndex: DWORD;  //预置点序号
{$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
{$ELSE}
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
    byRes5: array[0..4-1] of BYTE;  
{$ENDIF}
    dwCompressedDotMatrixBuffLen: DWORD;  //长度对应pCompressedDotMatrixBuff数据长度
    byRes: array[0..164-1] of BYTE;  
  end;
  LPNET_AIOP_POLLING_VIDEO_HEAD = ^NET_AIOP_POLLING_VIDEO_HEAD;

type
  NET_AIOP_HISTORY_VIDEO_HEAD = record 
    dwSize: DWORD;  //dwSize = sizeof(_NET_AIOP_HISTORY_VIDEO_HEAD_)
    dwChannel: DWORD;  //设备分析通道的通道号(走SDK协议)；
    struTime: NET_DVR_SYSTEM_TIME;  //时间
    szTaskID: array[0..64-1] of AnsiChar;  //历史视频任务ID，来自于视频任务派发
    dwAIOPDataSize: DWORD;  //AIOP data数据长度
    dwPictureSize: DWORD;  //对应分析图片长度
    szMPID: array[0..64-1] of AnsiChar;  //检测模型包ID，用于匹配AIOP的检测数据解析；可以通过URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)获取当前设备加载的模型包的label description信息；
    pBufferAIOPData: PBYTE;  //AIOPDdata数据
    pBufferPicture: PBYTE;  //对应分析图片数据
    byPictureMode: BYTE;  //图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    byRes: array[0..183-1] of BYTE;  
  end;
  LPNET_AIOP_HISTORY_VIDEO_HEAD = ^NET_AIOP_HISTORY_VIDEO_HEAD;


type
  NET_AIOP_POLLING_SNAP_HEAD = record 
    dwSize: DWORD;  //dwSize = sizeof(NET_AIOP_POLLING_SNAP_HEAD)
    dwChannel: DWORD;  //设备分析通道的通道号(走SDK协议)；
    struTime: NET_DVR_SYSTEM_TIME;  //时间
    szTaskID: array[0..64-1] of AnsiChar;  //轮询抓图任务ID，来自于轮询抓图任务派发
    dwAIOPDataSize: DWORD;  //对应AIOPDdata数据长度
    dwPictureSize: DWORD;  //对应分析图片长度
    szMPID: array[0..64-1] of AnsiChar;  //检测模型包ID，用于匹配AIOP的检测数据解析；
    pBufferAIOPData: PBYTE;  //AIOPDdata数据
    pBufferPicture: PBYTE;  //分析图片数据
    byPictureMode: BYTE;  //图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    byCompressedDotMatrixMode: BYTE;  // /压缩后的点阵图传输模式 0-二进制，1-武汉云云存储，当byCompressedDotMatrixMode为0时pCompressedDotMatrixBuff为二进制数据，当byCompressedDotMatrixMode为1时pCompressedDotMatrixBuff为武汉云URL
    byRes2: array[0..2-1] of BYTE;  //保留字节
    dwPresetIndex: DWORD;  //预置点序号
    dwAddInfoPictureSize: DWORD;  //对应分析的附加图片长度
    pAddInfoPictureBuffer: PBYTE;  //对应分析的附加图片数据(对于热成像双通道设备，该节点表示非报警通道的图片)
  {$IF Defined(WIN64) OR Defined(POSIX64)} //#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
{$ELSE}
    pCompressedDotMatrixBuff: PAnsiChar;  //压缩后的点阵图信息指针
    byRes5: array[0..4-1] of BYTE;  
{$ENDIF}
    dwCompressedDotMatrixBuffLen: DWORD;  //长度对应pCompressedDotMatrixBuff数据长度
    byRes: array[0..156-1] of BYTE;  
  end;
  LPNET_AIOP_POLLING_SNAP_HEAD = ^NET_AIOP_POLLING_SNAP_HEAD;

type
  NET_DVR_AI_ALGORITHM_MODEL = record 
    dwSize: DWORD;  
    dwDescribeLength: DWORD;  //<AlgorithmModel> 文件长度
    pDescribeBuffer: PAnsiChar;  //<AlgorithmModel>文件
    byRes1: array[0..3-1] of BYTE;  //保留字节，使四字节对齐
    dwLicenseKeyLength: DWORD;  //licenseKey文件长度
    pLicenseKeyBuffer: PAnsiChar;  //licenseKey文件
    byRes: array[0..120-1] of BYTE;  
  end;
  LPNET_DVR_AI_ALGORITHM_MODEL = ^NET_DVR_AI_ALGORITHM_MODEL;

type
  NET_DVR_AI_PICTUR_UPLOAD = record 
    dwSize: DWORD;  
    szTaskID: array[0..64-1] of AnsiChar;  //任务id，strlen.max = 64,业务平台统一维护管理
    szPID: array[0..64-1] of AnsiChar;  //图片id，strlen.max = 64，业务平台统一维护管理
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_AI_PICTUR_UPLOAD = ^NET_DVR_AI_PICTUR_UPLOAD;


type
  NET_DVR_CARD_RECORD = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  
    byCardType: BYTE;  
    byLeaderCard: BYTE;  
    byUserType: BYTE;  
    byRes1: BYTE;  
    byDoorRight: array[0..MAX_DOOR_NUM_256-1] of BYTE;  
    struValid: NET_DVR_VALID_PERIOD_CFG;  
    byBelongGroup: array[0..MAX_GROUP_NUM_128-1] of BYTE;  
    byCardPassword: array[0..CARD_PASSWORD_LEN-1] of BYTE;  
    wCardRightPlan: array[0..MAX_DOOR_NUM_256-1] of WORD;  
    dwMaxSwipeTimes: DWORD;  
    dwSwipeTimes: DWORD;  
    dwEmployeeNo: DWORD;  
    byName: array[0..NAME_LEN-1] of BYTE;  
    //按位表示，0-无权限，1-有权限
    //第0位表示：弱电报警
    //第1位表示：开门提示音
    //第2位表示：限制客卡
    //第3位表示：通道
    //第4位表示：反锁开门
    //第5位表示：巡更功能
    dwCardRight: DWORD;  
    byRes: array[0..256-1] of BYTE;  
  end;
  LPNET_DVR_CARD_RECORD = ^NET_DVR_CARD_RECORD;

type
  NET_DVR_CARD_COND = record 
    dwSize: DWORD;  
    dwCardNum: DWORD;  //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_DVR_CARD_COND = ^NET_DVR_CARD_COND;

type
  NET_DVR_CARD_SEND_DATA = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //卡号
    byRes: array[0..16-1] of BYTE;  
  end;
  LPNET_DVR_CARD_SEND_DATA = ^NET_DVR_CARD_SEND_DATA;

type
  NET_DVR_CARD_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  
    dwErrorCode: DWORD;  
    byStatus: BYTE;  // 状态：0-失败，1-成功
    byRes: array[0..23-1] of BYTE;  
  end;
  LPNET_DVR_CARD_STATUS = ^NET_DVR_CARD_STATUS;

type
  NET_DVR_FACE_RECORD = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    dwFaceLen: DWORD;  //人脸数据长度
    pFaceBuffer: PBYTE;  //人脸数据指针
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_FACE_RECORD = ^NET_DVR_FACE_RECORD;

type
  NET_DVR_FACE_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号
    byErrorMsg: array[0..ERROR_MSG_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
    dwReaderNo: DWORD;  //人脸读卡器编号，可用于下发错误返回
    byRecvStatus: BYTE;  //人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
    //,6-算法建模失败，7-未下发卡权限，8-未定义（保留），9-人眼间距小距小，10-图片数据长度小于1KB，11-图片格式不符（png/jpg/bmp）,12-图片像素数量超过上限，13-图片像素数量低于下限，14-图片信息校验失败，15-图片解码失败，16-人脸检测失败，17-人脸评分失败
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_FACE_STATUS = ^NET_DVR_FACE_STATUS;

type
  NET_DVR_FACE_COND = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //人脸关联的卡号（设置时该参数可不设置）
    dwFaceNum: DWORD;  // 设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    dwEnableReaderNo: DWORD;  // 人脸读卡器编号
    byRes: array[0..124-1] of BYTE;  // 保留
  end;
  LPNET_DVR_FACE_COND = ^NET_DVR_FACE_COND;

type
  NET_DVR_FINGERPRINT_RECORD = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    dwFingerPrintLen: DWORD;  //指纹数据长度
    dwEnableReaderNo: DWORD;  //需要下发指纹的读卡器编号
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹
    byRes1: array[0..30-1] of BYTE;  
    byFingerData: array[0..MAX_FINGER_PRINT_LEN-1] of BYTE;  //指纹数据内容
    byRes: array[0..96-1] of BYTE;  
  end;
  LPNET_DVR_FINGERPRINT_RECORD = ^NET_DVR_FINGERPRINT_RECORD;

type
  NET_DVR_FINGERPRINT_STATUS = record 
    dwSize: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  //指纹关联的卡号
    byCardReaderRecvStatus: BYTE;  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
    byFingerPrintID: BYTE;  //手指编号，有效值范围为1-10
    byFingerType: BYTE;  //指纹类型  0-普通指纹，1-胁迫指纹
    byRecvStatus: BYTE;  //主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
    byErrorMsg: array[0..ERROR_MSG_LEN-1] of BYTE;  //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    dwCardReaderNo: DWORD;  //当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
    byRes: array[0..20-1] of BYTE;  
  end;
  LPNET_DVR_FINGERPRINT_STATUS = ^NET_DVR_FINGERPRINT_STATUS;

type
  NET_DVR_FINGERPRINT_COND = record 
    dwSize: DWORD;  
    dwFingerprintNum: DWORD;  
    byCardNo: array[0..ACS_CARD_NO_LEN-1] of BYTE;  
    dwEnableReaderNo: DWORD;  
    byFingerPrintID: BYTE;  
    byRes: array[0..131-1] of BYTE;  
  end;
  LPNET_DVR_FINGERPRINT_COND = ^NET_DVR_FINGERPRINT_COND;

type
  NET_DVR_CAPTURE_DATA_COND = record 
    dwSize: DWORD;  
    szPassword: array[0..128-1] of AnsiChar;  //秘钥，字符串
    byRes: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_CAPTURE_DATA_COND = ^NET_DVR_CAPTURE_DATA_COND;

const
  EZVIZ_CLASSSESSION_LEN = 64;    
  EZVIZ_DEVICEID_LEN = 32;    
type
  NET_DVR_EZVIZ_USER_LOGIN_INFO = record 
    sEzvizServerAddress: array[0..NET_DVR_DEV_ADDRESS_MAX_LEN-1] of AnsiChar;  //云服务器地址
    wPort: WORD;  //云服务器端口
    byLogin: BYTE;  
    byRes1: array[0..1-1] of BYTE;  
    sClassSession: array[0..EZVIZ_CLASSSESSION_LEN-1] of AnsiChar;  //ClassSession, 服务器分配的一个字符串，每次通信时需要发送给服务器
    sDeviceID: array[0..EZVIZ_DEVICEID_LEN-1] of AnsiChar;  //设备ID， 由服务器分配的
    byRes2: array[0..128-1] of BYTE;  
  end;
  LPNET_DVR_EZVIZ_USER_LOGIN_INFO = ^NET_DVR_EZVIZ_USER_LOGIN_INFO;

const
  EZVIZ_REQURL_LEN = 64;    
  EZVIZ_ACCESSTOKEN_LEN = 128;    
  EZVIZ_CLIENTTYPE_LEN = 32;    
  EZVIZ_FEATURECODE_LEN = 64;    
  EZVIZ_OSVERSION_LEN = 32;    
  EZVIZ_NETTYPE_LEN = 32;    
  EZVIZ_SDKVERSION_LEN = 32;    
  EZVIZ_APPID_LEN = 64;    
type
  NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO = record 
    sEzvizServerAddress: array[0..NET_DVR_DEV_ADDRESS_MAX_LEN-1] of AnsiChar;  //云服务器地址
    byRes1: array[0..3-1] of BYTE;  
    wPort: WORD;  //云服务器端口
    byRes2: array[0..2-1] of BYTE;  
    sUrl: array[0..EZVIZ_REQURL_LEN-1] of AnsiChar;  
    sAccessToken: array[0..EZVIZ_ACCESSTOKEN_LEN-1] of AnsiChar;  //accessToken, 服务器分配的一个字符串，每次通信时需要发送给服务器
    sDeviceID: array[0..EZVIZ_DEVICEID_LEN-1] of AnsiChar;  //设备ID， 由服务器分配的
    sClientType: array[0..EZVIZ_CLIENTTYPE_LEN-1] of AnsiChar;  //客户端类型: 0: PC-控件 1: ios 2: android
    sFeatureCode: array[0..EZVIZ_FEATURECODE_LEN-1] of AnsiChar;  //硬件特征码
    sOsVersion: array[0..EZVIZ_OSVERSION_LEN-1] of AnsiChar;  //终端系统版本, 例如: IOS 7.0.4, Android 2.3.
    sNetType: array[0..EZVIZ_NETTYPE_LEN-1] of AnsiChar;  //网络类型, UNKNOWN GPRS EDGE UMTS HSDPA HSUPA HSPA CDMAEVDO_0 EVDO_A EVDO_B 1xRTT IDEN WIFI
    sSdkVersion: array[0..EZVIZ_SDKVERSION_LEN-1] of AnsiChar;  //Sdk版本号, v.1.0.20140720.45xx
    sAppID: array[0..EZVIZ_APPID_LEN-1] of AnsiChar;  //AppID，ios上报BundleID，Android上报包名
    byRes3: array[0..512-1] of BYTE;  
  end;
  LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO = ^NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO;


const
  MAX_ERROR_MSG_LEN = 256;    //最大报警错误描述信息
//报警异常类型
type
  ALARM_EXCEPTION_ERROR_ENUM =  
  (  
    ENUM_AEE_PARAM_ERROR = 1,  //参数错误
    ENUM_AEE_LENS_ERROR = 2,  //长度不匹配内部结构体
    ENUM_AEE_PIC_LENS_ERROR = 3,  //带图片长度不匹配
    ENUM_AEE_DEVID_LENS_ERROR = 4,  //DeviceID长度不匹配
    ENUM_AEE_NEW_ALLOC_ERROR = 5,  //申请内存失败
    ENUM_AEE_JSON_FORMAT_ERROR = 6,  //JOSN格式错误
    ENUM_AEE_XML_FORMAT_ERROR = 7,  //XML格式错误
    ENUM_AEE_BINARY_PIC_ERROR = 8,  //二进制图片数据处理异常
    ENUM_AEE_PIC_NUM_ERROR = 9,  //统计图片数据异常
    ENUM_AEE_GET_BOUNDARY_ERROR = 10,  //提取boundary数据异常
    ENUM_AEE_BOUNDARY_NUM_ERROR = 11  //提取boundary数目异常
  );

//报警异常结构体
type
  NET_ALARM_EXCEPTION = record 
    dwAlarmType: DWORD;  //报警类型
    byExceptionType: BYTE;  //报警异常类型,参见 ALARM_EXCEPTION_ERROR_ENUM
    byRes: array[0..3-1] of BYTE;  //
    szErrMsg: array[0..MAX_ERROR_MSG_LEN-1] of AnsiChar;  //错误信息描述
    byRes1: array[0..248-1] of BYTE;  //
  end;
  LPNET_ALARM_EXCEPTION = ^NET_ALARM_EXCEPTION;


type
  ADDITIONAL_LIB = 
  (  
    PLAYCTRL = 0,  
    DSSDK,  
    STREAMCONVERT,  
    STREAMTRANS,  
    QOSSDK,  
    DLL_PATH_AUDIO,  
    EZVIZ_SSL_SDK,  
    ANALYZE_DATA_LIB,  
    DLL_LIBICONV,  
    SSLEAY32_SDK,  
    LIBEAY32_SDK,  
    HCNETUTILS_SDK,  
    NPQ_LIB,  
    LOAD_DLL_COUNT  
  );

type
  NET_DVR_AUTOTEST_CFG_HEAD = record 
    dwSize: DWORD;  
    dwInfoType: DWORD;  //1表示视频测试，3表示语音对讲测试
    dwRetResult: DWORD;  
    dwDataBodySize: DWORD;  //后面的结构体内容大小
    lpDataBody: PVOID;  //后面的结构体
    byRes: array[0..32-1] of BYTE;  
  end;
  LPNET_DVR_AUTOTEST_CFG_HEAD = ^NET_DVR_AUTOTEST_CFG_HEAD;

//视频测试结构体如下
type
  NET_DVR_AUTOTEST_VIDEO_CFG = record 
    dwSplitScreenNums: DWORD;  //分屏数，支持1、4、9
    dwVoCh: DWORD;  //默认填写1
    dwInterface: DWORD;  //1表示CVBS、2表示HDMI、3表示VGA、4表示辅口HDMI
  end;
  LPNET_DVR_AUTOTEST_VIDEO_CFG = ^NET_DVR_AUTOTEST_VIDEO_CFG;

//音频测试结构体如下
type
  NET_DVR_AUTOTEST_AUDIO_CFG = record 
    dwVoCh: DWORD;  //默认填写2
    dwOpen: DWORD;  //1开启，0不开启
  end;
  LPNET_DVR_AUTOTEST_AUDIO_CFG = ^NET_DVR_AUTOTEST_AUDIO_CFG;

type
  NET_LOCAL_AUDIOCAST_PARAM = record 
    byAudioBitRate: BYTE;  //音频码率 参考 BITRATE_ENCODE_INDEX
    byAudioSamplingRate: BYTE;  //音频采样率 0-默认，1-16kHZ，2-32kHZ，3-48kHZ, 4- 44.1kHZ,5-8kHZ
    byRes: array[0..30-1] of BYTE;  
  end;
  LPNET_LOCAL_AUDIOCAST_PARAM = ^NET_LOCAL_AUDIOCAST_PARAM;

type
  NET_LOCAL_AUDIOCAST_CFG = record 
    struAudioCastParam: array[0..MAX_AUDIOCAST_CFG_TYPE-1] of NET_LOCAL_AUDIOCAST_PARAM;  //第1到3个元素分别表示： MP3、MPEG2、AAC广播参数的配置，对应元素不填则为默认参数。其余编码类型广播参数不可配置
    byRes: array[0..64-1] of BYTE;  
  end;
  LPNET_LOCAL_AUDIOCAST_CFG = ^NET_LOCAL_AUDIOCAST_CFG;

{$IF Defined(LINUX) OR Defined(WIN64)} //#if ((defined __linux__) || (defined _WIN64))
type
  NET_DVR_AUDIOENC_INFO = record // 信息 
    in_frame_size: DWORD;  // 输入一帧数据大小(BYTES)，由GetInfoParam函数返回         
    reserved: array[0..16-1] of INT;  // 保留 
  end;
  LPNET_DVR_AUDIOENC_INFO = ^NET_DVR_AUDIOENC_INFO;
// 编码模式 
type
  ENUM_AUDIO_ENC_MODE =  
  (  
    AMR_MR475_ = 0,  // 4.75 kb/s 
    AMR_MR515_,  // 5.15 kb/s 
    AMR_MR59_,  // 5.90 kb/s 
    AMR_MR67_,  // 6.70 kb/s 
    AMR_MR74_,  // 7.40 kb/s 
    AMR_MR795_,  // 7.95 kb/s 
    AMR_MR102_,  // 10.2 kb/s 
    AMR_MR122_,  // 12.2 kb/s 

    AMR_MRDTX_,  // 静音帧    
    AMR_N_MODES_  
  );
// 音频编码
type
  NET_DVR_AUDIOENC_PROCESS_PARAM = record 
    in_buf: PBYTE;  // 输入buf 
    out_buf: PBYTE;  // 输出buf 
    out_frame_size: DWORD;  // 编码一帧后的BYTE数 

    g726enc_reset: INT;  // 重置开关 
    g711_type: INT;  // g711编码类型,0 - U law, 1- A law 
    enc_mode: ENUM_AUDIO_ENC_MODE;  // 音频编码模式，AMR编码配置 
    reserved: array[0..16-1] of INT;  // 保留 
  end;
  LPNET_DVR_AUDIOENC_PROCESS_PARAM = ^NET_DVR_AUDIOENC_PROCESS_PARAM;

type
  NET_DVR_AUDIODEC_INFO = record // 信息 
    nchans: INT;  // 声道数 
    sample_rate: INT;  // 采样率 
    aacdec_profile: INT;  // 编码用的框架 
    reserved: array[0..16-1] of INT;  // 保留 
  end;
  LPNET_DVR_AUDIODEC_INFO = ^NET_DVR_AUDIODEC_INFO;

// 音频解码
type
  NET_DVR_AUDIODEC_PROCESS_PARAM = record 
    in_buf: PBYTE;  // 输入数据buf 
    out_buf: PBYTE;  // 输出数据buf 
    in_data_size: DWORD;  // 输入in_buf内数据byte数 
    proc_data_size: DWORD;  // 输出解码库处理in_buf中数据大小bytes 
    out_frame_size: DWORD;  // 解码一帧后数据BYTE数 
    dec_info: NET_DVR_AUDIODEC_INFO;  // 输出解码信息 

    g726dec_reset: INT;  // 重置开关 
    g711_type: INT;  // g711编码类型,0 - U law, 1- A law 
    reserved: array[0..16-1] of INT;  // 保留 
  end;
  LPNET_DVR_AUDIODEC_PROCESS_PARAM = ^NET_DVR_AUDIODEC_PROCESS_PARAM;

const  G726_EBCIN_DECOUT_SIZE: DWord = 640;// G726库编码输入一帧及解码输出一帧的大小（定长）
{$IF Defined(CPUX64)} //#if (defined __x86_64__)
const  G726_ENC_OUT_SIZE: DWord = 160;// G726库输入一帧编码输出大小（定长）
const  G726_DEC_IN_SIZE: DWord = 200;// G726库输入一帧到解码长度（定长）
{$ELSE} // if (defined __i386__)
const  G726_ENC_OUT_SIZE: DWord = 80;// G726库输入一帧编码输出大小（定长）
const  G726_DEC_IN_SIZE: DWord = 80;// G726库输入一帧到解码长度（定长）
{$ENDIF} // (defined __x86_64__)
{$ENDIF} // (defined __linux__)

//*******************************SDK接口函数声明********************************
{$WARN SYMBOL_PLATFORM OFF}

function NET_DVR_Init(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Cleanup(): BOOL; stdcall; external DLLFILENAME Delayed;  

//NET_DVR_SetDVRMessage的扩展
{$IFDEF WIN32} //#ifdef _WIN32
function NET_DVR_SetDVRMessage(nMessage: UINT; hWnd: HWND): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfExceptionCallBack = procedure(dwType: DWORD; lUserID: LONG; lHandle: LONG; pUser: PVOID); stdcall;
function NET_DVR_SetExceptionCallBack_V30(nMessage: UINT; hWnd: HWND; fExceptionCallBack: TfExceptionCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ELSEIF Defined(LINUX) OR Defined(MACOS)} //#elif defined(__linux__) || defined(__APPLE__)
type
  TfExceptionCallBack_2 = procedure(dwType: DWORD; lUserID: LONG; lHandle: LONG; pUser: PVOID); stdcall;
function NET_DVR_SetExceptionCallBack_V30(reserved1: UINT; reserved2: PVOID; fExceptionCallBack_2: TfExceptionCallBack_2; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
//Linux专有 
{$IF Defined(LINUX)} //#if defined(__linux__)
function (InitInfo: INITINFO; iUseSDL: DWORD = 1): BOOL; stdcall; external DLLFILENAME Delayed;  
function (): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ENDIF}
{$ENDIF}

function NET_DVR_LoadAllCom(): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfMessCallBack = function(lCommand: LONG; sDVRIP: PAnsiChar; pBuf: PAnsiChar; dwBufLen: DWORD): BOOL; stdcall;
function NET_DVR_SetDVRMessCallBack(fMessCallBack: TfMessCallBack): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfMessCallBack_EX = function(lCommand: LONG; lUserID: LONG; pBuf: PAnsiChar; dwBufLen: DWORD): BOOL; stdcall;
function NET_DVR_SetDVRMessCallBack_EX(fMessCallBack_EX: TfMessCallBack_EX): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfMessCallBack_NEW = function(lCommand: LONG; sDVRIP: PAnsiChar; pBuf: PAnsiChar; dwBufLen: DWORD; dwLinkDVRPort: WORD): BOOL; stdcall;
function NET_DVR_SetDVRMessCallBack_NEW(fMessCallBack_NEW: TfMessCallBack_NEW): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfMessageCallBack = function(lCommand: LONG; sDVRIP: PAnsiChar; pBuf: PAnsiChar; dwBufLen: DWORD; dwUser: DWORD): BOOL; stdcall;
function NET_DVR_SetDVRMessageCallBack(fMessageCallBack: TfMessageCallBack; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  MSGCallBack = procedure(lCommand: LONG; pAlarmer: LPNET_DVR_ALARMER; pAlarmInfo: PAnsiChar; dwBufLen: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetDVRMessageCallBack_V30(fMessageCallBack: MSGCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  MSGCallBack_V31 = function(lCommand: LONG; pAlarmer: LPNET_DVR_ALARMER; pAlarmInfo: PAnsiChar; dwBufLen: DWORD; pUser: PVOID): BOOL; stdcall;
function NET_DVR_SetDVRMessageCallBack_V31(fMessageCallBack: MSGCallBack_V31; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDVRMessageCallBack_V50(iIndex: INT; fMessageCallBack: MSGCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDVRMessageCallBack_V51(iIndex: INT; fMsgCallBack: MSGCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetConnectTime(dwWaitTime: DWORD = 3000; dwTryTimes: DWORD = 3): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetReconnect(dwInterval: DWORD = 30000; bEnableRecon: BOOL = TRUE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKVersion(): DWORD; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKBuildVersion(): DWORD; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_IsSupport(): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartListen(sLocalIP: PAnsiChar; wLocalPort: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopListen(): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_StartListen_V30(sLocalIP: PAnsiChar; wLocalPort: WORD; DataCallback: MSGCallBack; pUserData: PVOID = nil): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopListen_V30(lListenHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Login(sDVRIP: PAnsiChar; wDVRPort: WORD; sUserName: PAnsiChar; sPassword: PAnsiChar; lpDeviceInfo: LPNET_DVR_DEVICEINFO): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Login_V30(sDVRIP: PAnsiChar; wDVRPort: WORD; sUserName: PAnsiChar; sPassword: PAnsiChar; lpDeviceInfo: LPNET_DVR_DEVICEINFO_V30): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_Login_V40(pLoginInfo: LPNET_DVR_USER_LOGIN_INFO; lpDeviceInfo: LPNET_DVR_DEVICEINFO_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Login_Check(sDVRIP: PAnsiChar; wDVRPort: WORD; sUserName: PAnsiChar; sPassword: PAnsiChar; lpDeviceInfo: LPNET_DVR_DEVICEINFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Logout(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Logout_V30(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetLastError(): DWORD; stdcall; external DLLFILENAME Delayed;  
procedure NET_DVR_GetLastErrorModelCode(pModelCode: PDWORD; pMErrDevSelfEx: PDWORD); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetErrorMsg(pErrorNo: PLONG = nil): PAnsiChar; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetShowMode(dwShowType: DWORD; colorKey: COLORREF): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDVRIPByResolveSvr(sServerIP: PAnsiChar; wServerPort: WORD; sDVRName: PBYTE; wDVRNameLen: WORD; sDVRSerialNumber: PBYTE; wDVRSerialLen: WORD; sGetIP: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDVRIPByResolveSvr_EX(sServerIP: PAnsiChar; wServerPort: WORD; sDVRName: PBYTE; wDVRNameLen: WORD; sDVRSerialNumber: PBYTE; wDVRSerialLen: WORD; sGetIP: PAnsiChar; dwPort: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDVRNAMEByResolveSvr(sServerIP: PAnsiChar; wServerPort: WORD; sIP: PAnsiChar; sDVRName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  

//预览相关接口
type
  TfRealDataCallBack_V30 = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_PlayDirect(sDVRIP: PAnsiChar; sUserName: PAnsiChar; sPassword: PAnsiChar; lpClientInfo: LPNET_DVR_CLIENTINFO; fRealDataCallBack_V30: TfRealDataCallBack_V30 = nil; pUser: PVOID = nil; bBlocked: BOOL = FALSE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlay(lUserID: LONG; lpClientInfo: LPNET_DVR_CLIENTINFO): LONG; stdcall; external DLLFILENAME Delayed;  
type
  TfRealDataCallBack_V30_2 = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_RealPlay_V30(lUserID: LONG; lpClientInfo: LPNET_DVR_CLIENTINFO; fRealDataCallBack_V30_2: TfRealDataCallBack_V30_2 = nil; pUser: PVOID = nil; bBlocked: BOOL = FALSE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopRealPlay(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopPlayDirect(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfDrawFun = procedure(lRealHandle: LONG; hDc: HDC; dwUser: DWORD); stdcall;
function NET_DVR_RigisterDrawFun(lRealHandle: LONG; fDrawFun: TfDrawFun; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfDrawFunEx = procedure(lRealHandle: LONG; hDc: HDC; pUser: PVOID); stdcall;
function NET_DVR_RigisterDrawFunEx(lRealHandle: LONG; fDrawFunEx: TfDrawFunEx; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPlayerBufNumber(lRealHandle: LONG; dwBufNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ThrowBFrame_Func(lRealHandle: LONG; dwNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAudioMode(dwMode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_OpenSound(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseSound(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_OpenSoundShare(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseSoundShare(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Volume(lRealHandle: LONG; wVolume: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SaveRealData(lRealHandle: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopSaveRealData(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfRealDataCallBack = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; dwUser: DWORD); stdcall;
function NET_DVR_SetRealDataCallBack(lRealHandle: LONG; fRealDataCallBack: TfRealDataCallBack; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfRealDataCallBack_2 = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetRealDataCallBackEx(lRealHandle: LONG; fRealDataCallBack_2: TfRealDataCallBack_2; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfStdDataCallBack = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; dwUser: DWORD); stdcall;
function NET_DVR_SetStandardDataCallBack(lRealHandle: LONG; fStdDataCallBack: TfStdDataCallBack; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfStdDataCallBack_2 = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetStandardDataCallBackEx(lRealHandle: LONG; fStdDataCallBack_2: TfStdDataCallBack_2; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfTpDataCallBack = procedure(lRealHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetTransparentDataCallBack(lRealHandle: LONG; fTpDataCallBack: TfTpDataCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CapturePicture(lRealHandle: LONG; sPicFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetCapturePictureMode(dwCaptureMode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

//动态生成I帧
function NET_DVR_MakeKeyFrame(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MakeKeyFrameSub(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

//云台控制相关接口
function NET_DVR_PTZControl(lRealHandle: LONG; dwPTZCommand: DWORD; dwStop: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZControl_Other(lUserID: LONG; lChannel: LONG; dwPTZCommand: DWORD; dwStop: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TransPTZ(lRealHandle: LONG; pPTZCodeBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TransPTZ_Other(lUserID: LONG; lChannel: LONG; pPTZCodeBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZPreset(lRealHandle: LONG; dwPTZPresetCmd: DWORD; dwPresetIndex: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZPreset_Other(lUserID: LONG; lChannel: LONG; dwPTZPresetCmd: DWORD; dwPresetIndex: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TransPTZ_EX(lRealHandle: LONG; pPTZCodeBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZControl_EX(lRealHandle: LONG; dwPTZCommand: DWORD; dwStop: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZPreset_EX(lRealHandle: LONG; dwPTZPresetCmd: DWORD; dwPresetIndex: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZCruise(lRealHandle: LONG; dwPTZCruiseCmd: DWORD; byCruiseRoute: BYTE; byCruisePoint: BYTE; wInput: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZCruise_Other(lUserID: LONG; lChannel: LONG; dwPTZCruiseCmd: DWORD; byCruiseRoute: BYTE; byCruisePoint: BYTE; wInput: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZCruise_EX(lRealHandle: LONG; dwPTZCruiseCmd: DWORD; byCruiseRoute: BYTE; byCruisePoint: BYTE; wInput: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZTrack(lRealHandle: LONG; dwPTZTrackCmd: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZTrack_Other(lUserID: LONG; lChannel: LONG; dwPTZTrackCmd: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZTrack_EX(lRealHandle: LONG; dwPTZTrackCmd: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZControlWithSpeed(lRealHandle: LONG; dwPTZCommand: DWORD; dwStop: DWORD; dwSpeed: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZControlWithSpeed_Other(lUserID: LONG; lChannel: LONG; dwPTZCommand: DWORD; dwStop: DWORD; dwSpeed: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZControlWithSpeed_EX(lRealHandle: LONG; dwPTZCommand: DWORD; dwStop: DWORD; dwSpeed: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPTZCruise(lUserID: LONG; lChannel: LONG; lCruiseRoute: LONG; lpCruiseRet: LPNET_DVR_CRUISE_RET): BOOL; stdcall; external DLLFILENAME Delayed;  


//文件查找与回放
function NET_DVR_FindFile(lUserID: LONG; lChannel: LONG; dwFileType: DWORD; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile(lFindHandle: LONG; lpFindData: LPNET_DVR_FIND_DATA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile_Card(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDDATA_CARD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile_V30(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDDATA_V30): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile_V40(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDDATA_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile_V50(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDDATA_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFile_V30(lUserID: LONG; pFindCond: LPNET_DVR_FILECOND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFile_V50(lUserID: LONG; pFindCond: LPNET_DVR_FILECOND_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindClose_V30(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_LockFileByName(lUserID: LONG; sLockFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UnlockFileByName(lUserID: LONG; sUnlockFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_LockFileByNameV40(lUserID: LONG; bLock: BOOL; lpLockFilePara: LPNET_DVR_LOCK_FILE_BY_NAME_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByName(lUserID: LONG; sPlayBackFileName: PAnsiChar; hWnd: HWND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTime(lUserID: LONG; lChannel: LONG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME; hWnd: HWND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackReverseByName(lUserID: LONG; sPlayBackFileName: PAnsiChar; hWnd: HWND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByName_V50(lUserID: LONG; pParam: LPNET_DVR_PLAY_BY_NAME_PARA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackReverseByName_V50(lUserID: LONG; pParam: LPNET_DVR_PLAY_BY_NAME_PARA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTime_PCNVR(lUserID: LONG; pPlaybackParams: LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_PlayBackControl(lPlayHandle: LONG; dwControlCode: DWORD; dwInValue: DWORD; LPOutValue: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopPlayBack(lPlayHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfPlayDataCallBack = procedure(lPlayHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; dwUser: DWORD); stdcall;
function NET_DVR_SetPlayDataCallBack(lPlayHandle: LONG; fPlayDataCallBack: TfPlayDataCallBack; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfPlayESCallBack = procedure(lPlayHandle: LONG; struPackInfo: LPNET_DVR_PACKET_INFO_EX; pUser: PVOID); stdcall;
function NET_DVR_SetPlayBackESCallBack(lPlayHandle: LONG; fPlayESCallBack: TfPlayESCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfPlayDataCallBack_V40 = procedure(lPlayHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetPlayDataCallBack_V40(lPlayHandle: LONG; fPlayDataCallBack_V40: TfPlayDataCallBack_V40; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackSaveData(lPlayHandle: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopPlayBackSave(lPlayHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPlayBackOsdTime(lPlayHandle: LONG; lpOsdTime: LPNET_DVR_TIME): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackCaptureFile(lPlayHandle: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFileByName(lUserID: LONG; sDVRFileName: PAnsiChar; sSavedFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFileByName_V50(lUserID: LONG; pParam: LPNET_DVR_DOWNLOAD_BY_NAME_COND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFileByTime(lUserID: LONG; lChannel: LONG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME; sSavedFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopGetFile(lFileHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDownloadPos(lFileHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPlayBackPos(lPlayHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  

//升级
function NET_DVR_AdapterUpgrade(lUserID: LONG; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Upgrade(lUserID: LONG; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_VcalibUpgrade(lUserID: LONG; lChannel: LONG; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUpgradeState(lUpgradeHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUpgradeProgress(lUpgradeHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseUpgradeHandle(lUpgradeHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetNetworkEnvironment(dwEnvironmentLevel: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
//远程格式化硬盘
function NET_DVR_FormatDisk(lUserID: LONG; lDiskNumber: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FormatDisk_V50(lUserID: LONG; lpStruHddFormatCond: LPNET_DVR_FORMAT_HDD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFormatProgress(lFormatHandle: LONG; pCurrentFormatDisk: PLONG; pCurrentDiskPos: PLONG; pFormatStatic: PLONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseFormatHandle(lFormatHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//报警
function NET_DVR_SetupAlarmChan(lUserID: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseAlarmChan(lAlarmHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetupAlarmChan_V30(lUserID: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseAlarmChan_V30(lAlarmHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//语音对讲
type
  TfVoiceDataCallBack = procedure(lVoiceComHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; byAudioFlag: BYTE; dwUser: DWORD); stdcall;
function NET_DVR_StartVoiceCom(lUserID: LONG; fVoiceDataCallBack: TfVoiceDataCallBack; dwUser: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
type
  TfVoiceDataCallBack_2 = procedure(lVoiceComHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; byAudioFlag: BYTE; pUser: PVOID); stdcall;
function NET_DVR_StartVoiceCom_V30(lUserID: LONG; dwVoiceChan: DWORD; bNeedCBNoEncData: BOOL; fVoiceDataCallBack_2: TfVoiceDataCallBack_2; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetVoiceComClientVolume(lVoiceComHandle: LONG; wVolume: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopVoiceCom(lVoiceComHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//语音转发
type
  TfVoiceDataCallBack_3 = procedure(lVoiceComHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; byAudioFlag: BYTE; dwUser: DWORD); stdcall;
function NET_DVR_StartVoiceCom_MR(lUserID: LONG; fVoiceDataCallBack_3: TfVoiceDataCallBack_3; dwUser: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
type
  TfVoiceDataCallBack_4 = procedure(lVoiceComHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; byAudioFlag: BYTE; pUser: PVOID); stdcall;
function NET_DVR_StartVoiceCom_MR_V30(lUserID: LONG; dwVoiceChan: DWORD; fVoiceDataCallBack_4: TfVoiceDataCallBack_4; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_VoiceComSendData(lVoiceComHandle: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetCurrentAudioCompress(lUserID: LONG; lpCompressAudio: LPNET_DVR_COMPRESSION_AUDIO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetCurrentAudioCompress_V50(lUserID: LONG; lpAudioChannel: LPNET_DVR_AUDIO_CHANNEL; lpCompressAudio: LPNET_DVR_COMPRESSION_AUDIO): BOOL; stdcall; external DLLFILENAME Delayed;  
//语音广播
function NET_DVR_ClientAudioStart(): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfVoiceDataCallBack_5 = procedure(pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_ClientAudioStart_V30(fVoiceDataCallBack_5: TfVoiceDataCallBack_5; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientAudioStop(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddDVR(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddDVR_V30(lUserID: LONG; dwVoiceChan: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelDVR(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelDVR_V30(lVoiceHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//透明通道设置
type
  TfSerialDataCallBack = procedure(lSerialHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; dwUser: DWORD); stdcall;
function NET_DVR_SerialStart(lUserID: LONG; lSerialPort: LONG; fSerialDataCallBack: TfSerialDataCallBack; dwUser: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
//485作为透明通道时，需要指明通道号，因为不同通道号485的设置可以不同(比如波特率)
type
  TfSerialDataCallBack_2 = procedure(lSerialHandle: LONG; lCHannel: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SerialStart_V40_Func(lUserID: LONG; lpInBuffer: PVOID; dwInBufferSize: LONG; fSerialDataCallBack_2: TfSerialDataCallBack_2; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SerialSend(lSerialHandle: LONG; lChannel: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SerialStop(lSerialHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendTo232Port(lUserID: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendToSerialPort(lUserID: LONG; dwSerialPort: DWORD; dwSerialIndex: DWORD; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

{$IF (not Defined(LINUX)) AND (not Defined(WIN64))} //#if (!defined __linux__) && (!defined _WIN64)
//Decoding nBitrate = 16000
procedure NET_DVR_InitG722Decoder(nBitrate: INT = 16000); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecodeG722Frame(pDecHandle: PVOID; pInBuffer: PBYTE; pOutBuffer: PBYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
//Encoding
procedure NET_DVR_InitG722Encoder(); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_EncodeG722Frame(pEncodeHandle: PVOID; pInBuffer: PBYTE; pOutBuffer: PBYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ELSEIF Defined(LINUX) OR Defined(WIN64)} //#elif ((defined __linux__) || (defined _WIN64))
procedure NET_DVR_InitG722Decoder(); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecodeG722Frame(handle: PVOID; param:   LPNET_DVR_AUDIODEC_PROCESS_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
//Encoding
procedure NET_DVR_InitG722Encoder(enc_info:   LPNET_DVR_AUDIOENC_INFO); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_EncodeG722Frame(handle: PVOID; param:   LPNET_DVR_AUDIOENC_PROCESS_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ENDIF} // _WIN32
procedure NET_DVR_ReleaseG722Decoder(pDecHandle: PVOID); stdcall; external DLLFILENAME Delayed;  
procedure NET_DVR_ReleaseG722Encoder(pEncodeHandle: PVOID); stdcall; external DLLFILENAME Delayed;  

//解码
procedure NET_DVR_InitG726Decoder(pDecMoudle: PPVOID); stdcall; external DLLFILENAME Delayed;  
procedure NET_DVR_ReleaseG726Decoder(pDecHandle: PVOID); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecodeG726Frame(pDecMoudle: PVOID; pInBuffer: PBYTE; pOutBuffer: PBYTE; byReset: BYTE): BOOL; stdcall; external DLLFILENAME Delayed;  

//编码
procedure NET_DVR_InitG726Encoder(pEncMoudle: PPVOID); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_EncodeG726Frame(pEncMoudle: PVOID; pInBuffer: PBYTE; pOutBuffer: PBYTE; byReset: BYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
procedure NET_DVR_ReleaseG726Encoder(pEncHandle: PVOID); stdcall; external DLLFILENAME Delayed;  

//远程控制本地显示
function NET_DVR_ClickKey(lUserID: LONG; lKeyIndex: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_DoorBellControl(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Preview(lUserID: LONG; lPicNum: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PreviewOne(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByNameLocDisplay(lUserID: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTimeLocDisplay(lUserID: LONG; lChannel: LONG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopLocDisplayPlay(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayControlLocDisplay(lUserID: LONG; dwControlCode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
//远程控制设备端手动录像
function NET_DVR_StartDVRRecord(lUserID: LONG; lChannel: LONG; lRecordType: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopDVRRecord(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//解码卡
function NET_DVR_InitDevice_Card(pDeviceTotalChan: PLONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseDevice_Card(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InitDDraw_Card(hParent: HWND; colorKey: COLORREF): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseDDraw_Card(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlay_Card(lUserID: LONG; lpCardInfo: LPNET_DVR_CARDINFO; lChannelNum: long): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ResetPara_Card(lRealHandle: LONG; lpDisplayPara: LPNET_DVR_DISPLAY_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RefreshSurface_Card(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClearSurface_Card(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RestoreSurface_Card(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_OpenSound_Card(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseSound_Card(lRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetVolume_Card(lRealHandle: LONG; wVolume: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AudioPreview_Card(lRealHandle: LONG; bEnable: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetCardLastError_Card(): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDspErrMsg_Card(dwMessage: DWORD; hWnd: HWND): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ResetDSP_Card(iChannelNum: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetChanHandle_Card(lRealHandle: LONG): HWND; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CapturePicture_Card(lRealHandle: LONG; sPicFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSerialNum_Card(lChannelNum: long; pDeviceSerialNo: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDVRLog(lUserID: LONG; lSelectMode: LONG; dwMajorType: DWORD; dwMinorType: DWORD; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextLog(lLogHandle: LONG; lpLogData: LPNET_DVR_LOG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindLogClose(lLogHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDVRLog_V30(lUserID: LONG; lSelectMode: LONG; dwMajorType: DWORD; dwMinorType: DWORD; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME; bOnlySmart: BOOL = FALSE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextLog_V30(lLogHandle: LONG; lpLogData: LPNET_DVR_LOG_V30): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDVRLog_V50(lUserID: LONG; pFindCond: LPNET_DVR_FIND_LOG_COND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextLog_V50(lLogHandle: LONG; lpLogData: LPNET_DVR_LOG_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindLogClose_V30(lLogHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindAlarmHostLog(lUserID: LONG; lSelectMode: LONG; lpSearchParam: LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextAlarmHostLog(lFindHandle: LONG; lpFindData: LPNET_DVR_ALARMHOST_LOG_RET): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindAlarmHostLogClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFile_PCNVR(lUserID: LONG; pFindCond: LPNET_DVR_FILE_COND_PCNVR): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFile_PCNVR(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDDATA_PCNVR): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindClose_PCNVR(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFileByCard(lUserID: LONG; lChannel: LONG; dwFileType: DWORD; nFindType: INT; sCardNumber: PBYTE; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CaptureJPEGPicture(lUserID: LONG; lChannel: LONG; lpJpegPara: LPNET_DVR_JPEGPARA; sPicFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CaptureJPEGPicture_NEW(lUserID: LONG; lChannel: LONG; lpJpegPara: LPNET_DVR_JPEGPARA; sJpegPicBuffer: PAnsiChar; dwPicSize: DWORD; lpSizeReturned: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CapturePicture_V50(lUserID: LONG; lChannel: LONG; lpPicParam: LPNET_DVR_PICPARAM_V50; sPicBuffer: PAnsiChar; dwPicSize: DWORD; lpSizeReturned: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CaptureJPEGPicture_WithAppendData(lUserID: LONG; lChannel: LONG; lpJpegWithAppend: LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetRealPlayOsdTime(iRealHandle: LONG; lpOsdTime: LPNET_DVR_TIME): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlayPause(iRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlayRestart(iRealHandle: LONG; hPlayWnd: HWND): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetRealPlayerIndex(lRealHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPlayBackPlayerIndex(lPlayHandle: LONG): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetScaleCFG(lUserID: LONG; dwScale: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetScaleCFG(lUserID: LONG; lpOutScale: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetScaleCFG_V30(lUserID: LONG; pScalecfg: LPNET_DVR_SCALECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetScaleCFG_V30(lUserID: LONG; pScalecfg: LPNET_DVR_SCALECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetATMPortCFG(lUserID: LONG; wATMPort: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetATMPortCFG(lUserID: LONG; LPOutATMPort: PWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InitDDrawDevice(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseDDrawDevice(): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDDrawDeviceTotalNums(): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDDrawDevice(lPlayPort: LONG; nDeviceNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_PTZSelZoomIn(lRealHandle: LONG; pStruPointFrame: LPNET_DVR_POINT_FRAME): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PTZSelZoomIn_EX(lUserID: LONG; lChannel: LONG; pStruPointFrame: LPNET_DVR_POINT_FRAME): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartDecode(lUserID: LONG; lChannel: LONG; lpDecoderinfo: LPNET_DVR_DECODERINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopDecode(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDecoderState(lUserID: LONG; lChannel: LONG; lpDecoderState: LPNET_DVR_DECODERSTATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDecInfo(lUserID: LONG; lChannel: LONG; lpDecoderinfo: LPNET_DVR_DECCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDecInfo(lUserID: LONG; lChannel: LONG; lpDecoderinfo: LPNET_DVR_DECCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDecTransPort(lUserID: LONG; lpTransPort: LPNET_DVR_PORTCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDecTransPort(lUserID: LONG; lpTransPort: LPNET_DVR_PORTCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecPlayBackCtrl(lUserID: LONG; lChannel: LONG; dwControlCode: DWORD; dwInValue: DWORD; LPOutValue: PDWORD; lpRemoteFileInfo: LPNET_DVR_PLAYREMOTEFILE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartDecSpecialCon(lUserID: LONG; lChannel: LONG; lpDecChanInfo: LPNET_DVR_DECCHANINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopDecSpecialCon(lUserID: LONG; lChannel: LONG; lpDecChanInfo: LPNET_DVR_DECCHANINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecCtrlDec(lUserID: LONG; lChannel: LONG; dwControlCode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecCtrlScreen(lUserID: LONG; lChannel: LONG; dwControl: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDecCurLinkStatus(lUserID: LONG; lChannel: LONG; lpDecStatus: LPNET_DVR_DECSTATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStartDynamic(lUserID: LONG; dwDecChanNum: DWORD; lpDynamicInfo: LPNET_DVR_MATRIX_DYNAMIC_DEC): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStopDynamic(lUserID: LONG; dwDecChanNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDecChanInfo(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_DEC_CHAN_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopDecChanInfo(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecChanInfo(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopDecChanEnable(lUserID: LONG; dwDecChanNum: DWORD; dwEnable: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecChanEnable(lUserID: LONG; dwDecChanNum: DWORD; lpdwEnable: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecEnable(lUserID: LONG; lpdwEnable: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetDecChanEnable(lUserID: LONG; dwDecChanNum: DWORD; dwEnable: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDecChanEnable(lUserID: LONG; dwDecChanNum: DWORD; lpdwEnable: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDecChanStatus(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_DEC_CHAN_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetVideoStandard(lUserID: LONG; dwDecChanNum: DWORD; lpdwVideoStandard: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetVideoStandard(lUserID: LONG; dwDecChanNum: DWORD; dwVideoStandard: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

//2007-12-22 增加支持接口
function NET_DVR_MatrixSetTranInfo(lUserID: LONG; lpTranInfo: LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetTranInfo(lUserID: LONG; lpTranInfo: LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetRemotePlay(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_DEC_REMOTE_PLAY): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetRemotePlayControl(lUserID: LONG; dwDecChanNum: DWORD; dwControlCode: DWORD; dwInValue: DWORD; LPOutValue: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetRemotePlayStatus(lUserID: LONG; dwDecChanNum: DWORD; lpOuter: LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
//2009-4-13 新增
function NET_DVR_MatrixStartDynamic_V30(lUserID: LONG; dwDecChanNum: DWORD; lpDynamicInfo: LPNET_DVR_PU_STREAM_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopDecChanInfo_V30(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecChanInfo_V30(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDecChanInfo_V30(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetTranInfo_V30(lUserID: LONG; lpTranInfo: LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetTranInfo_V30(lUserID: LONG; lpTranInfo: LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDisplayCfg(lUserID: LONG; dwDispChanNum: DWORD; lpDisplayCfg: LPNET_DVR_VGA_DISP_CHAN_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetDisplayCfg(lUserID: LONG; dwDispChanNum: DWORD; lpDisplayCfg: LPNET_DVR_VGA_DISP_CHAN_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_MatrixStartPassiveDecode(lUserID: LONG; dwDecChanNum: DWORD; lpPassiveMode: LPNET_DVR_MATRIX_PASSIVEMODE{, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser}): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSendData(lPassiveHandle: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStopPassiveDecode(lPassiveHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UploadLogo(lUserID: LONG; dwDispChanNum: DWORD; lpDispLogoCfg: LPNET_DVR_DISP_LOGOCFG; sLogoBuffer: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
const
  NET_DVR_SHOWLOGO = 1;    //显示LOGO
  NET_DVR_HIDELOGO = 2;    //隐藏LOGO
function NET_DVR_LogoSwitch(lUserID: LONG; dwDecChan: DWORD; dwLogoSwitch: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDeviceStatus(lUserID: LONG; lpDecoderCfg: LPNET_DVR_DECODER_WORK_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  

const
  DISP_CMD_ENLARGE_WINDOW = 1;    //显示通道放大某个窗口
  DISP_CMD_RENEW_WINDOW = 2;    //显示通道窗口还原
  DISP_CMD_OPENAUDIO = 3;    //显示通道打开音频
  DISP_CMD_CLOSEAUDIO = 4;    //显示通道关闭音频

function NET_DVR_MatrixDiaplayControl(lUserID: LONG; dwDispChanNum: DWORD; dwDispChanCmd: DWORD; dwCmdParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixPassiveDecodeControl(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_PASSIVEDECODE_CONTROL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetPassiveDecodeStatus(lPassiveHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_MatrixGetDecChanCfg(lUserID: LONG; dwDecChan: DWORD; lpInter: LPNET_DVR_MATRIX_DECCHAN_CONTROL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetDecChanCfg(lUserID: LONG; dwDecChan: DWORD; lpInter: LPNET_DVR_MATRIX_DECCHAN_CONTROL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTime_NEW(lUserID: LONG; lChannel: LONG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME; lLongitude: LONG; lLatitude: LONG; hWnd: HWND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RefreshPlay(lPlayHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

//恢复默认值
function NET_DVR_RestoreConfig(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//保存参数
function NET_DVR_SaveConfig(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//重启
function NET_DVR_RebootDVR(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//关闭DVR
function NET_DVR_ShutDownDVR(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

//参数配置 begin
function NET_DVR_GetDVRConfig(lUserID: LONG; dwCommand: DWORD; lChannel: LONG; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD; lpBytesReturned: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDVRConfig(lUserID: LONG; dwCommand: DWORD; lChannel: LONG; lpInBuffer: LPVOID; dwInBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDVRWorkState_V30(lUserID: LONG; lpWorkState: LPNET_DVR_WORKSTATE_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDVRWorkState(lUserID: LONG; lpWorkState: LPNET_DVR_WORKSTATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetVideoEffect(lUserID: LONG; lChannel: LONG; dwBrightValue: DWORD; dwContrastValue: DWORD; dwSaturationValue: DWORD; dwHueValue: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetVideoEffect(lUserID: LONG; lChannel: LONG; pBrightValue: PDWORD; pContrastValue: PDWORD; pSaturationValue: PDWORD; pHueValue: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientGetframeformat(lUserID: LONG; lpFrameFormat: LPNET_DVR_FRAMEFORMAT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientSetframeformat(lUserID: LONG; lpFrameFormat: LPNET_DVR_FRAMEFORMAT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientGetframeformat_V30(lUserID: LONG; lpFrameFormat: LPNET_DVR_FRAMEFORMAT_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientSetframeformat_V30(lUserID: LONG; lpFrameFormat: LPNET_DVR_FRAMEFORMAT_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAtmFrameFormat_V30(lUserID: LONG; lAtmChannel: LONG; lpFrameFormat: LPNET_DVR_ATM_FRAMEFORMAT_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAtmFrameFormat_V30(lUserID: LONG; lAtmChannel: LONG; lpFrameFormat: LPNET_DVR_ATM_FRAMEFORMAT_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAtmProtocol(lUserID: LONG; lpAtmProtocol: LPNET_DVR_ATM_PROTOCOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAlarmOut_V30(lUserID: LONG; lpAlarmOutState: LPNET_DVR_ALARMOUTSTATUS_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAlarmOut(lUserID: LONG; lpAlarmOutState: LPNET_DVR_ALARMOUTSTATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAlarmOut(lUserID: LONG; lAlarmOutPort: LONG; lAlarmOutStatic: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

//视频参数调节
function NET_DVR_ClientSetVideoEffect(lRealHandle: LONG; dwBrightValue: DWORD; dwContrastValue: DWORD; dwSaturationValue: DWORD; dwHueValue: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClientGetVideoEffect(lRealHandle: LONG; pBrightValue: PDWORD; pContrastValue: PDWORD; pSaturationValue: PDWORD; pHueValue: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

//配置文件
function NET_DVR_GetConfigFile(lUserID: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetConfigFile(lUserID: LONG; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetConfigFile_V30(lUserID: LONG; sOutBuffer: PAnsiChar; dwOutSize: DWORD; pReturnSize: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetConfigFile_EX(lUserID: LONG; sOutBuffer: PAnsiChar; dwOutSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetConfigFile_EX(lUserID: LONG; sInBuffer: PAnsiChar; dwInSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

//启用日志文件写入接口
function NET_DVR_SetLogToFile(nLogLevel: DWORD = 0; strLogDir: PAnsiChar = nil; bAutoDel: BOOL = TRUE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKState(pSDKState: LPNET_DVR_SDKSTATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKAbility(pSDKAbl: LPNET_DVR_SDKABL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPTZProtocol(lUserID: LONG; pPtzcfg: LPNET_DVR_PTZCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPTZCtrl_Other(iUserID: LONG; iChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPTZCtrl(iRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
//前面板锁定
function NET_DVR_LockPanel(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UnLockPanel(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartPanelKey(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopPanelKey(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetRtspConfig(lUserID: LONG; dwCommand: DWORD; lpInBuffer: LPNET_DVR_RTSPCFG; dwInBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetRtspConfig(lUserID: LONG; dwCommand: DWORD; lpOutBuffer: LPNET_DVR_RTSPCFG; dwOutBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

//能力集获取
function NET_DVR_GetDeviceAbility(lUserID: LONG; dwAbilityType: DWORD; pInBuf: PAnsiChar; dwInLength: DWORD; pOutBuf: PAnsiChar; dwOutLength: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetSimAbilityPath(szSimAbilityPath: PAnsiChar; szSDCard: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSubSystemInfo(lUserID: LONG; lpInter: LPNET_DVR_ALLSUBSYSTEMINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetSubSystemInfo(lUserID: LONG; lpInter: LPNET_DVR_ALLSUBSYSTEMINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetCodeSplitter(lUserID: LONG; dwCodeChan: DWORD; lpInter: LPNET_DVR_CODESPLITTERINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetCodeSplitter(lUserID: LONG; dwCodeChan: DWORD; lpInter: LPNET_DVR_CODESPLITTERINFO): BOOL; stdcall; external DLLFILENAME Delayed;  

//智能
//设置/获取参数关键字
function NET_DVR_SetBehaviorParamKey(lUserID: LONG; lChannel: LONG; dwParameterKey: DWORD; nValue: INT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetBehaviorParamKey(lUserID: LONG; lChannel: LONG; dwParameterKey: DWORD; pValue: PINT): BOOL; stdcall; external DLLFILENAME Delayed;  

//获取/设置异常行为检测目标叠加接口
function NET_DVR_GetVCADrawMode(lUserID: LONG; lChannel: LONG; lpDrawMode: LPNET_VCA_DRAW_MODE): BOOL; stdcall; external DLLFILENAME Delayed;  



function NET_DVR_SetVCADrawMode(lUserID: LONG; lChannel: LONG; lpDrawMode: LPNET_VCA_DRAW_MODE): BOOL; stdcall; external DLLFILENAME Delayed;  

//球机模式设置接口
function NET_DVR_SetTrackMode(lUserID: LONG; lChannel: LONG; lpTrackMode: LPNET_DVR_TRACK_MODE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetTrackMode(lUserID: LONG; lChannel: LONG; lpTrackMode: LPNET_DVR_TRACK_MODE): BOOL; stdcall; external DLLFILENAME Delayed;  

//重启智能库
function NET_VCA_RestartLib(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SaveRealData_V30(lRealHandle: LONG; dwTransType: DWORD; sFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  

{$IF (not Defined(LINUX)) AND (not Defined(WIN64))} //#if ((!defined __linux__) && (!defined _WIN64))
function NET_DVR_EncodeG711Frame(iType: DWORD; pInBuffer: PBYTE; pOutBuffer: PBYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecodeG711Frame(iType: DWORD; pInBuffer: PBYTE; pOutBuffer: PBYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ELSEIF Defined(LINUX) OR Defined(WIN64)} //#elif ((defined __linux__) || (defined _WIN64))
function NET_DVR_EncodeG711Frame(handle: LPVOID; p_enc_proc_param:   LPNET_DVR_AUDIOENC_PROCESS_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DecodeG711Frame(handle: LPVOID; p_dec_proc_param:   LPNET_DVR_AUDIODEC_PROCESS_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InitG711Decoder(): LPVOID; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InitG711Encoder(enc_info:   LPNET_DVR_AUDIOENC_INFO): LPVOID; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseG711Encoder(pEncodeHandle: LPVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseG711Decoder(pDecHandle: LPVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
{$ENDIF} //(defined _WIN32)

function NET_DVR_FindFileByEvent(lUserID: LONG; lpSearchEventParam: LPNET_DVR_SEARCH_EVENT_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFileByEvent_V40(lUserID: LONG; lpSearchEventParam: LPNET_DVR_SEARCH_EVENT_PARAM_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFileByEvent_V50(lUserID: LONG; lpSearchEventParam: LPNET_DVR_SEARCH_EVENT_PARAM_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextEvent(lSearchHandle: LONG; lpSearchEventRet: LPNET_DVR_SEARCH_EVENT_RET): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextEvent_V40(lSearchHandle: LONG; lpSearchEventRet: LPNET_DVR_SEARCH_EVENT_RET_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextEvent_V50(lFindHandle: LONG; lpSearchEventRet: LPNET_DVR_SEARCH_EVENT_RET_V50): LONG; stdcall; external DLLFILENAME Delayed;  
//停止采用 NET_DVR_FindClose

function NET_DVR_FindPDCInfo(lUserID: LONG; lChannel: LONG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextPDCInfo(lFindHandle: LONG; lpFindData: LPNET_DVR_PDC_QUERY): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindPDCClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

// 标定校验
const
  NET_DVR_PDC_VERIFY_CALIBRATION = 1;    //当值为1是为PDC标定校验 pdc传入值为NET_VCA_POINT   传出值为 NET_VCA_RECT结构
  NET_DVR_VERIFY_BEHAVIOR_CALIBRATION = 2;    // 异常行为检测标定线校验
  NET_DVR_VERIFY_ITS_CALIBRATION = 3;    // 智能交通标定校验
  NET_DVR_VERIFY_BV_CALIBRATION = 5;    //双目标定校验

function NET_DVR_VerifyCalibration(lUserID: LONG; dwCommand: DWORD; lChannel: LONG; lpInBuffer: LPVOID; dwInBufferSize: DWORD; lpOuterBuffer: LPVOID; dwOuterBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ResetCounter(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetPtzPosition(lUserID: LONG; lChannel: LONG; lPositionID: LONG; lpPtzPosition: LPNET_DVR_PTZ_POSITION): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPtzPosition(lUserID: LONG; lChannel: LONG; lPositionID: LONG; lpPtzPosition: LPNET_DVR_PTZ_POSITION): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPatrolTrack(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpPatrolTrack: LPNET_DVR_PATROL_TRACKCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPatrolTrack(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpPatrolTrack: LPNET_DVR_PATROL_TRACKCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextLog_MATRIX(lLogHandle: LONG; lpLogData: LPNET_DVR_LOG_MATRIX): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDVRLog_Matrix(lUserID: LONG; lSelectMode: LONG; dwMajorType: DWORD; dwMinorType: DWORD; lpVedioPlatLog: LPNET_DVR_VEDIOPLATLOG; lpStartTime: LPNET_DVR_TIME; lpStopTime: LPNET_DVR_TIME): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_ManualSnap_Func(lUserID: LONG; lpInter: LPNET_DVR_MANUALSNAP; lpOuter: LPNET_DVR_PLATE_RESULT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ContinuousShoot(lUserID: LONG; lpInter: LPNET_DVR_SNAPCFG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetPTZProtocol_Ex(lUserID: LONG; lChannel: LONG; pPtzcfg: LPNET_DVR_PTZCFG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_StartEmailTest(lUserID: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopEmailTest(lEmailTestHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetEmailTestProgress(lEmailTestHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetIPCProtoList(lUserID: LONG; lpProtoList: LPNET_DVR_IPC_PROTO_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetIPCProtoList_V41(lUserID: LONG; lpProtoList: LPNET_DVR_IPC_PROTO_LIST_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SmartSearch(lUserID: LONG; lpSmartSearchParam: LPNET_DVR_SMART_SEARCH_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SmartSearch_V40(lUserID: LONG; lpSmartSearchParam: LPNET_DVR_SMART_SEARCH_PARAM_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SearchNextInfo(lSearchHandle: LONG; lpSmartSearchRet: LPNET_DVR_SMART_SEARCH_RET): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopSearch(lSearchHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

// IP San 文件目录查找
function NET_DVR_FindIpSanDirectory(lUserID: LONG; lpIpsanSearchParam: LPNET_DVR_IPSAN_SERACH_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextDirectory(lFindHandle: LONG; lpFindData: LPNET_DVR_IPSAN_SERACH_RET): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDirectoryClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

type
  REALDATACALLBACK = procedure(lPlayHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;

function NET_DVR_ZeroStartPlay(lUserID: LONG; lpClientInfo: LPNET_DVR_CLIENTINFO; fRealDataCallBack_V30: REALDATACALLBACK = nil; pUser: PVOID = nil; bBlocked: BOOL = TRUE): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_ZeroStopPlay(lPlayHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ZeroMakeKeyFrame(lUserID: LONG; lZeroChan: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackControl_V40(lPlayHandle: LONG; dwControlCode: DWORD; lpInBuffer: LPVOID = nil; dwInLen: DWORD = 0; lpOutBuffer: LPVOID = nil; lpOutLen: PDWORD = nil): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ZeroTurnOver(lUserID: LONG; lChannel: LONG; bNextPreview: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlay_Card_V30(lUserID: LONG; lpCardInfo: LPNET_DVR_CARDINFO; lChannelNum: LONG; dwMode: DWORD; bBlock: BOOL; fRealDataCallBack_V30: REALDATACALLBACK; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  


function NET_DVR_GetDiskList(lUserID: LONG; lpDiskList: LPNET_DVR_DISKABILITY_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Backup(lUserID: LONG; dwBackupType: DWORD; lpBackupBuff: LPVOID; dwBackupBuffSize: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_BackupByName(lUserID: LONG; lpBackupByName: LPNET_DVR_BACKUP_NAME_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_BackupByTime(lUserID: LONG; lpBackupBytime: LPNET_DVR_BACKUP_TIME_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetBackupProgress(lHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopBackup(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetSadpInfoList(lUserID: LONG; lpSadpInfoList: LPNET_DVR_SADPINFO_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UpdateSadpInfo(lUserID: LONG; lpSadpVerify: LPNET_DVR_SADP_VERIFY; lpSadpInfo: LPNET_DVR_SADPINFO): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_MatrixGetSubDecSystemJoinInfo(lUserID: LONG; lpInter: LPNET_DVR_ALLDECSUBSYSTEMJOININFO): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetCodeSplitterAssociate(lUserID: LONG; dwDecoderChan: DWORD; dwSlotNum: DWORD; lpInter: LPNET_DVR_CODESPLITTERASSOCIATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetCodeSplitterAssociate(lUserID: LONG; dwDecoderChan: DWORD; dwSlotNum: DWORD; lpInter: LPNET_DVR_CODESPLITTERASSOCIATE): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_InquestGetCDRWScheme(lUserID: LONG; lpCDRWCfg: LPNET_DVR_INQUEST_CDRW_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetCDRWScheme(lUserID: LONG; lpCDRWCfg: LPNET_DVR_INQUEST_CDRW_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestDeleteFile(lUserID: LONG; lpDeleteFile: LPNET_DVR_INQUEST_FILES): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestCDWByFile(lUserID: LONG; lpCdrwFile: LPNET_DVR_INQUEST_FILES): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestUploadFile(lUserID: LONG; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestUploadClose(lUploadHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetUploadState(lUploadHandle: LONG; pProgress: LPDWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStartCDW(lUserID: LONG; bPause: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStopCDW(lUserID: LONG; bCancelWrite: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetCDWState(lUserID: LONG; pStatus: LPNET_DVR_INQUEST_CDRW_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetPIPStatus(lUserID: LONG; pStatus: LPNET_DVR_INQUEST_PIP_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetPIPStatus(lUserID: LONG; pStatus: LPNET_DVR_INQUEST_PIP_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestCheckSecretKey(lUserID: LONG; bSecretSet: PBOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetSecretKey(lUserID: LONG; pSecretInfo: LPNET_DVR_INQUEST_SECRET_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStreamEncrypt(lUserID: LONG; lChannel: LONG; bEncrypt: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetEncryptState(lUserID: LONG; lChannel: LONG; bEncrypt: PBOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestFindFile(lUserID: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestFindNextFile(lFindHandle: LONG; lpFindData: LPNET_DVR_INQUEST_FILEINFO): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestFindClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

// 9000RH
function NET_DVR_RaidFastConfig(lUserID: LONG; sName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FastConfigProcess(lHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseFastConfig(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetArraySpaceAlloc(lUserID: LONG; dwSlot: DWORD; lpOutBuf: LPNET_DVR_ARRAY_SPACE_ALLOC_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelArray(lUserID: LONG; dwID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CreateArray(lUserID: LONG; lpArrayParam: LPNET_DVR_OPERATE_ARRAY_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CalcArraySize(lUserID: LONG; lpArrayParam: LPNET_DVR_OPERATE_ARRAY_PARAM; lpArraySize: PUINT64): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MigrateArray(lUserID: LONG; lpArrayParam: LPNET_DVR_OPERATE_ARRAY_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RebuildArray(lUserID: LONG; lpArrayParam: LPNET_DVR_OPERATE_ARRAY_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CreateVD(lUserID: LONG; lpVDParam: LPNET_DVR_OPERATE_VD_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CreateVDEx(lUserID: LONG; lpVDParamEx: LPNET_DVR_OPERATE_VD_PARAM_EX): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelVD(lUserID: LONG; dwID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RepairVD(lUserID: LONG; dwID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetSpareDisk(lUserID: LONG; lpSpareDisk: LPNET_DVR_SPARE_DISK_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPDList(lUserID: LONG; lpPDList: LPNET_DVR_PHY_DISK_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetArrayList(lUserID: LONG; lpArrayList: LPNET_DVR_ARRAY_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetVDList(lUserID: LONG; lpVDList: LPNET_DVR_VD_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ExpandDisk(lUserID: LONG; dwVDSLot: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetExpandProgress(lExpandHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseExpandHandle(lExpandHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfAlgoLibInfoCallBack = procedure(lHandle: LONG; lChannel: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_AlgoDebugStart(lUserID: LONG; lCHannel: LONG; fAlgoLibInfoCallBack: TfAlgoLibInfoCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlgoDebugSend(lHandle: LONG; lChannel: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlgoDebugStop(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetLogPrint(bLogPrint: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetLogPrintAction(nLogLevel: DWORD; nToDevice: DWORD; bEnable: BOOL; Reserve1: INT; Reserve2: INT): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetPositionRule(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpPositionRule: LPNET_DVR_POSITION_RULE_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPositionRule_V41(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpPositionRule: LPNET_DVR_POSITION_RULE_CFG_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPositionRule(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpPositionRule: LPNET_DVR_POSITION_RULE_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPositionRule_V41(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpPositionRule: LPNET_DVR_POSITION_RULE_CFG_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPositionLimitAngle(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpLimitAngle: LPNET_DVR_LIMIT_ANGLE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPositionLimitAngle(lUserID: LONG; lChannel: LONG; lPositionIndex: LONG; lpLimitAngle: LPNET_DVR_LIMIT_ANGLE): BOOL; stdcall; external DLLFILENAME Delayed;  
//function NET_DVR_GetPtzPosition(lUserID: LONG; lChannel: LONG; lPositionID: LONG; lpPtzPosition: LPNET_DVR_PTZ_POSITION); stdcall; external DLLFILENAME Delayed;  
//function NET_DVR_SetPtzPosition(lUserID: LONG; lChannel: LONG; lPositionID: LONG; lpPtzPosition: LPNET_DVR_PTZ_POSITION); stdcall; external DLLFILENAME Delayed;  
//function NET_DVR_SetPatrolTrack(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpPatrolTrack: LPNET_DVR_PATROL_TRACKCFG); stdcall; external DLLFILENAME Delayed;  
//function NET_DVR_GetPatrolTrack(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpPatrolTrack: LPNET_DVR_PATROL_TRACKCFG); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPatrolLimitAngle(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpLimitAngle: LPNET_DVR_LIMIT_ANGLE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPatrolLimitAngle(lUserID: LONG; lChannel: LONG; lPatrolIndex: LONG; lpLimitAngle: LPNET_DVR_LIMIT_ANGLE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetSceneMode(lUserID: LONG; lChannel: LONG; dwSceneMode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSceneMode(lUserID: LONG; lChannel: LONG; pSceneMode: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetVCAVersion(lUserID: LONG; lChannel: LONG; lpVersion: LPNET_DVR_VCA_VERSION): BOOL; stdcall; external DLLFILENAME Delayed;  

//function NET_DVR_ContinuousShoot(lUserID: LONG; lpInter: LPNET_DVR_SNAPCFG); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixPicAdjust(lUserID: LONG; dwDispChan: DWORD; dwPicAdjust: DWORD; dwCmdParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmJoinedRecord(lUserID: LONG; dwChan: DWORD; dwAlarmSeq: DWORD; dwRecordTime: DWORD; dwRes: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUnitedMatrixInfo(lUserID: LONG; lpInter: LPNET_DVR_UNITEDMATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  REGCallBack = function(lUserID: LONG; pRegCallbackParam: LPNET_DVR_REGCALLBACKPARAM; pInterParam: LPNET_DVR_LOGONREPONSEPARAM; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetRegisterCallBack(fRegCallBack: REGCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PreviewRequest(lUserID: LONG; lChannel: LONG; lpPreviewParam: LPNET_DVR_PREVIEWPARAM; lpOuter: LPNET_DVR_DEVICENATINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  PREVIEWRESPONSECallBack = function(lUserID: LONG; lStreamHandle: LONG; pPewviewCallbackParam: LPNET_DVR_PREVIEWCALLBACKPARAM; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetPreviewResponseCallBack(fPreviewResponseCallBack: PREVIEWRESPONSECallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlaybackRequest(lUserID: LONG; lpPlayBackRequestParam: LPNET_DVR_PLAYBACKREQUESTPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  PLAYBACKRESPONSECallBack = function(lUserID: LONG; lPlaybackHandle: LONG; lpPlaybackParam: LPNET_DVR_PLAYBACKCALLBACKPARAM; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetPlaybackResponseCallBack(fPlaybackResponseCallBack: PLAYBACKRESPONSECallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  VOICERESPONSECallBack = function(lUserID: LONG; lVoiceHandle: LONG; lVoiceChannel: LONG; nAudioType: BYTE; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetVoiceResponseCallBack(fVoiceResponseCallBack: VOICERESPONSECallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_VoiceRequest(lUserID: LONG; lpVoiceParam: LPNET_DVR_VOICEREQUESTPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmSetupRequest(lUserID: LONG; lpAlarmSetupParam: LPNET_DVR_ALARMSETUPREQUESTPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDialParam(lUserID: LONG; lpDialRequest: LPNET_DVR_DIALREQUEST; lpDialParam: LPNET_DVR_DIALPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDialParam(lUserID: LONG; lpDialRequest: LPNET_DVR_DIALREQUEST; lpDialParam: LPNET_DVR_DIALPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSmsListInfo(lUserID: LONG; lpStartTime: LPNET_DVR_TIME_EX; lpStopTime: LPNET_DVR_TIME_EX; lpSmsListInfo: LPNET_DVR_SMSLISTINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSmsContent(lUserID: LONG; dwSmsIndex: DWORD; lpSmsContent: LPNET_DVR_SMSCONTENT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendSms(lUserID: LONG; lpSmsContent: LPNET_DVR_SMSCONTENT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartServer(sLocalIP: PAnsiChar; wLocalPort: WORD; byMode: BYTE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopServer(lServerHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartRecvNakedDataListen(atype: NAKED_DATA_TYPE; pParams: LPNET_DVR_NAKED_DATA_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopRecvNakedDataListen(lNakedDataRecvHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  NAKEDDAtACALLBACK = procedure(typeInfo: DWORD; pInfo: PAnsiChar; dwInfoLen: DWORD; dwIPLen: DWORD; pUser: PVOID); stdcall;
type
  TfNakedDataCallBack = procedure(dwTypeInfo: DWORD; pStruNakedDataInfo: LPNET_DVR_NAKED_DATA_INFO; pInfo: PAnsiChar; dwInfoLen: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetNakedDataRecvCallBack(lNakedDataRecvHandle: LONG; fNakedDataCallBack: TfNakedDataCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  

type
  ALARMSETUPRESPONSECallBack = function(lUserID: LONG; lAlarmHandle: LONG; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetAlarmSetupResponseCallBack(fAlarmSetupResponseCallBack: ALARMSETUPRESPONSECallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SpringJPEGPicture(lUserID: LONG; lChannel: LONG; lpJpegPara: LPNET_DVR_PUSHJPEGPARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPushModeParam(pPushParam: LPNET_DVR_PUSHMODEPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_AlarmHostSetupAlarmChan(lUserID: LONG; lpInter: LPNET_DVR_ALARMIN_SETUP): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostCloseAlarmChan(lUserID: LONG; lpInter: LPNET_DVR_ALARMIN_SETUP): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_BypassAlarmChan(lUserID: LONG; lpInter: LPNET_DVR_ALARMIN_SETUP): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UnBypassAlarmChan(lUserID: LONG; lpInter: LPNET_DVR_ALARMIN_SETUP): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostAssistantControl(lUserID: LONG; dwType: DWORD; dwNumber: DWORD; dwCmdParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAirCondition(lUserID: LONG; l485Index: LONG; lpAirConditionParam: LPNET_DVR_AIR_CONDITION_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAirCondition(lUserID: LONG; l485Index: LONG; lpAirConditionParam: LPNET_DVR_AIR_CONDITION_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDeviceTypeList(lUserID: LONG; lpDeviceTypeList: LPNET_DVR_DEVICE_TYPE_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDeviceProtoList(lUserID: LONG; lDeviceType: LONG; lpDeviceProtoList: LPNET_DVR_DEVICE_PROTO_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetBatteryVoltage(lUserID: LONG; pVoltage: PFLOAT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAlarmDeviceUser(lUserID: LONG; lUserIndex: LONG; lpDeviceUser: LPNET_DVR_ALARM_DEVICE_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAlarmDeviceUser(lUserID: LONG; lUserIndex: LONG; lpDeviceUser: LPNET_DVR_ALARM_DEVICE_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetKeyboardUser(lUserID: LONG; lUserIndex: LONG; lpKeyboardUser: LPNET_DVR_KEYBOARD_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetKeyboardUser(lUserID: LONG; lUserIndex: LONG; lpKeyboardUser: LPNET_DVR_KEYBOARD_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetOperateUser(lUserID: LONG; lUserIndex: LONG; lpOperateUser: LPNET_DVR_OPERATE_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetOperateUser(lUserID: LONG; lUserIndex: LONG; lpOperateUser: LPNET_DVR_OPERATE_USER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ControlGateway(lUserID: LONG; lGatewayIndex: LONG; dwStaic: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAlarmHostOut(lUserID: LONG; lAlarmOutPort: LONG; lAlarmOutStatic: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  fAlarmHostSerialDataCallBack = procedure(lSerialHandle: LONG; lPort: LONG; lDateType: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_AlarmHostSerialStart(lUserID: LONG; lSerialType: LONG; cbSerialDataCallBack: fAlarmHostSerialDataCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostSerialSend(lSerialHandle: LONG; lPort: LONG; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostSerialStop(lSerialHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetMatrixPuChan(lUserID: LONG; lChanType: LONG; lpChanList: LPNET_DVR_PU_CHAN_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAlarmOffMonitor(lUserID: LONG; dwMonID: DWORD; dwCamID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetCameraListInfo(lUserID: LONG; dwCamNum: DWORD; dwStartCam: DWORD; lpCamListInfo: LPNET_DVR_MATRIX_CAMERALIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetMonitorListInfo(lUserID: LONG; dwMonNum: DWORD; dwStartMon: DWORD; lpMonListInfo: LPNET_DVR_MATRIX_MONITORLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetGlobalNum(lUserID: LONG; dwCamNum: PDWORD; dwMonNum: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetUnitedMatrixInfo(lUserID: LONG; lpInter: LPNET_DVR_ALLUNITEDMATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetUnitedMatrixInfo(lUserID: LONG; lpInter: LPNET_DVR_ALLUNITEDMATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetGatewayInfo(lUserID: LONG; lpInter: LPNET_DVR_MATRIXGATEWAYINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetGatewayInfo(lUserID: LONG; lpInter: LPNET_DVR_MATRIXGATEWAYINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSpanSwitch(lUserID: LONG; nSwitchMode: BYTE; lpInter: LPNET_DVR_MATRIXSWITCH): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStartSwitch(lUserID: LONG; lpInter: LPNET_DVR_MATRIXSWITCHCTRL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetConfigFile(lUserID: LONG; lpInter: LPNET_DVR_MATRIXDATABASE; sInBuffer: PAnsiChar; dwInSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetConfigFile(lUserID: LONG; lpInter: LPNET_DVR_MATRIXDATABASE; sOutBuffer: PAnsiChar; dwOutSize: DWORD; pReturnSize: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSubSystemInfo_V40(lUserID: LONG; lpInter: LPNET_DVR_ALLSUBSYSTEMINFO_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetSubSystemInfo_V40(lUserID: LONG; lpInter: LPNET_DVR_ALLSUBSYSTEMINFO_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSubDecSystemJoinInfo_V40(lUserID: LONG; lpInter: LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  FLOWTESTCALLBACK = procedure(lFlowHandle: LONG; pFlowInfo: LPNET_DVR_FLOW_INFO; pUser: PVOID); stdcall;
function NET_DVR_StartNetworkFlowTest(lUserID: LONG; pFlowTest: LPNET_DVR_FLOW_TEST_PARAM; fFlowTestCallback: FLOWTESTCALLBACK; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopNetworkFlowTest(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindRecordLabel(lUserID: LONG; lpFindLabel: LPNET_DVR_FIND_LABEL): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextLabel(lFindHandle: LONG; lpFindData: LPNET_DVR_FINDLABEL_DATA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopFindLabel(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InsertRecordLabel(lPlayHandle: LONG; lpRecordLabel: LPNET_DVR_RECORD_LABEL; lpLableIdentify: LPNET_DVR_LABEL_IDENTIFY): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelRecordLabel(lUserID: LONG; lpDelLabelParam: LPNET_DVR_DEL_LABEL_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ModifyRecordLabel(lUserID: LONG; lpModLabelParam: LPNET_DVR_MOD_LABEL_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CapturePlaybackPictureBlock(lPlayHandle: LONG; sPicFileName: PAnsiChar; dwTimeOut: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CapturePlaybackPictureBlock_New(lPlayHandle: LONG; pPicBuf: PAnsiChar; dwPicSize: DWORD; lpSizeReturned: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindPicture(lUserID: LONG; pFindParam: LPNET_DVR_FIND_PICTURE_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextPicture(lFindHandle: LONG; lpFindData: LPNET_DVR_FIND_PICTURE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextPicture_V40(lFindHandle: LONG; lpFindData: LPNET_DVR_FIND_PICTURE_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextPicture_V50(lFindHandle: LONG; lpFindData: LPNET_DVR_FIND_PICTURE_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseFindPicture(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPicture(lUserID: LONG; sDVRFileName: PAnsiChar; sSavedFileName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPicture_V30(lUserID: LONG; sDVRFileName: PAnsiChar; sSavedFileBuf: PAnsiChar; dwBufLen: DWORD; lpdwRetLen: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPicture_V50(lUserID: LONG; lpPicParam: LPNET_DVR_PIC_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_BackupPicture(lUserID: LONG; lpBackupPicture: LPNET_DVR_BACKUP_PICTURE_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUpgradeStep(lUpgradeHandle: LONG; pSubProgress: PLONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetEncodeJoint(lUserID: LONG; lChannel: LONG; lpEncodeJoint: LPNET_DVR_ENCODE_JOINT_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TstrIP = array[0..16-1, 0..16-1] of AnsiChar;
function NET_DVR_GetLocalIP(var strIP: TstrIP; pValidNum: PDWORD; pEnableBind: PBOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetValidIP(dwIPIndex: DWORD; bEnableBind: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TstrIPv6 = array[0..16-1, 0..16-1] of BYTE;
function NET_DVR_GetLocalIPv6(var strIP: TstrIPv6; pValidNum: PDWORD; pEnableBind: PBOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetValidIPv6(dwIPIndex: DWORD; bEnableBind: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetVcaDevWorkState(lUserID: LONG; lpWorkState: LPNET_DVR_VCA_DEV_WORKSTATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetRecvTimeOut(nRecvTimeOut: DWORD = 5000): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDisplayCfg_V40(lUserID: LONG; dwDispChanNum: DWORD; lpDisplayCfg: LPNET_DVR_VGA_DISP_CHAN_CFG_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetDisplayCfg_V40(lUserID: LONG; dwDispChanNum: DWORD; lpDisplayCfg: LPNET_DVR_VGA_DISP_CHAN_CFG_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ShutterCompensation(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CorrectDeadPixel(lUserID: LONG; lChannel: LONG; lpInParam: LPNET_DVR_CORRECT_DEADPIXEL_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CustomConfig(lUserID: LONG; lChannel: LONG; lpInBuffer: LPVOID; dwInBufferSize: DWORD; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD; lpBytesReturned: LPDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetHistoricDataInfo(lUserID: LONG; lChannel: LONG; lpHisData: LPNET_DVR_HISTORICDATACFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetHistoricData(lUserID: LONG; lChannel: LONG; lpOuter: LPNET_DVR_PLATE_RESULT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClearHistoricData(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_VPD_SetShutter(lUserID: LONG; lChannel: LONG; lpShutter: LPNET_VPD_SHUTTER): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_VPD_SendPicture(lUserID: LONG; dwFields: DWORD; sImageBuffer: PBYTE; dwWidth: DWORD; dwHeight: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestUploadFile_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestDeleteFile_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpDeleteFile: LPNET_DVR_INQUEST_FILES): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetPIPStatus_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpStatus: LPNET_DVR_INQUEST_PIP_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetPIPStatus_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpStatus: LPNET_DVR_INQUEST_PIP_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetPIPStatus_V40(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpStatus: LPNET_DVR_INQUEST_PIP_STATUS_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetPIPStatus_V40(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpStatus: LPNET_DVR_INQUEST_PIP_STATUS_V40): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetSystemInfo(lUserID: LONG; lpSystemInfo: LPNET_DVR_INQUEST_SYSTEM_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSetSystemInfo(lUserID: LONG; lpSystemInfo: LPNET_DVR_INQUEST_SYSTEM_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestSendMessage(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; lpInquestMessage: LPNET_DVR_INQUEST_MESSAGE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStartCDW_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; bNotBurn: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStopCDW_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; bCancelWrite: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetCDWState_V30(lUserID: LONG; lpInquestRoom: LPNET_DVR_INQUEST_ROOM; pStatus: LPNET_DVR_INQUEST_CDRW_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestResumeEvent(lUserID: LONG; lpResumeEvent: LPNET_DVR_INQUEST_RESUME_EVENT): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetResumeProgress(lHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestStopResume(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestFindFile_V30(lUserID: LONG; pInquestRoom: LPNET_DVR_INQUEST_ROOM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquestGetDeviceVersion(lUserID: LONG; lpVersionInfo: LPNET_DVR_INQUEST_DEVICE_VERSION): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetSDKSecretKey(lUserID: LONG; sSecretKey: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_LockFileByTime(lUserID: LONG; lpLockPara: LPNET_DVR_TIME_LOCK; lpLockReturn: LPNET_DVR_LOCK_RETURN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UnlockFileByTime(lUserID: LONG; lpLockPara: LPNET_DVR_TIME_LOCK; lpLockReturn: LPNET_DVR_LOCK_RETURN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ScreenZoomIn(lUserID: LONG; pStruScreen: LPNET_DVR_SCREENZOOM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetAllCameraInfo(lUserID: LONG; lpCamListInfo: LPNET_DVR_MATRIX_CAMERALIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSingleCameraInfo(lUserID: LONG; dwCameraId: DWORD; lpInter: LPNET_MATRIX_CAMERAINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddCamera(lUserID: LONG; dwCameraNum: DWORD; pBuffer: PBYTE; dwBufLength: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModCameraInfo(lUserID: LONG; lpInter: LPNET_MATRIX_CAMERAINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixDelCamera(lUserID: LONG; dwCameraId: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetAllMonitorInfo(lUserID: LONG; lpMonListInfo: LPNET_DVR_MATRIX_MONITORLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSingleMonitorInfo(lUserID: LONG; dwMonitorId: DWORD; lpInter: LPNET_MATRIX_MONITORINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddMonitor(lUserID: LONG; dwMonitorNum: DWORD; pBuffer: PBYTE; dwBufLength: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModMonitorInfo(lUserID: LONG; lpInter: LPNET_MATRIX_MONITORINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixDelMonitor(lUserID: LONG; dwMonitorId: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetAllMatrixInfo(lUserID: LONG; lpMatrixListInfo: LPNET_DVR_MATRIXLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSingleMatrixInfo(lUserID: LONG; dwMatrixId: DWORD; lpInter: LPNET_MATRIX_MATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddMatrix(lUserID: LONG; lpInter: LPNET_MATRIX_MATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ModMatrixInfo(lUserID: LONG; lpInter: LPNET_MATRIX_MATRIXINFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelMatrix(lUserID: LONG; dwMatrixId: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetUartParam(lUserID: LONG; dwSerialChan: DWORD; lpInter: LPNET_MATRIX_UARTPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetUartParam(lUserID: LONG; dwSerialChan: DWORD; lpInter: LPNET_MATRIX_UARTPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetUserInfo(lUserID: LONG; dwUserNum: DWORD; lpInter: LPNET_MATRIX_USERPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddUser(lUserID: LONG; dwUserNum: DWORD; lpInter: LPNET_MATRIX_USERPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModUserInfo(lUserID: LONG; dwUserNum: DWORD; lpInter: LPNET_MATRIX_USERPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixDelUser(lUserID: LONG; dwUserNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetResourceInfo(lUserID: LONG; dwResourceNum: DWORD; lpInter: LPNET_MATRIX_RESOURSEGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddResourceInfo(lUserID: LONG; dwResourceNum: DWORD; lpInter: LPNET_MATRIX_RESOURSEGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModResourceInfo(lUserID: LONG; dwResourceNum: DWORD; lpInter: LPNET_MATRIX_RESOURSEGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixDelResourceInfo(lUserID: LONG; dwResourceNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetUserGroupInfo(lUserID: LONG; dwUserGroupNum: DWORD; lpInter: LPNET_MATRIX_USERGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddUserGroupInfo(lUserID: LONG; dwUserGroupNum: DWORD; lpInter: LPNET_MATRIX_USERGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModUserGroupInfo(lUserID: LONG; dwUserGroupNum: DWORD; lpInter: LPNET_MATRIX_USERGROUPPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixDelUserGroup(lUserID: LONG; dwUserGroupNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetAllTrunkInfo(lUserID: LONG; lpTrunkListInfo: LPNET_DVR_MATRIX_TRUNKLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetTrunkInfo(lUserID: LONG; dwTrunkNum: DWORD; lpInter: LPNET_MATRIX_TRUNKPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAddTrunk(lUserID: LONG; lpInter: LPNET_MATRIX_TRUNKPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixModTrunkInfo(lUserID: LONG; lpInter: LPNET_MATRIX_TRUNKPARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixTrunkCtrl(lUserID: LONG; dwTrunkNum: DWORD; byCtrlMode: BYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixTrunkStatusQuery(lUserID: LONG; dwTrunkNum: DWORD; byTrunkStatus: PBYTE): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_FindBackgroundPic(lUserID: LONG; dwPicID: DWORD; pPicBuffer: PBYTE; lpPicLen: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DetectImage(lUserID: LONG; lpFDProcImg: LPNET_VCA_FD_PROCIMG_CFG; lpOutBuf: LPNET_VCA_FD_PROCIMG_RESULT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPictureModel(lUserID: LONG; lpInBuf: LPNET_VCA_REGISTER_PIC; lpOutBuf: LPNET_VCA_PICMODEL_RESULT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddBlockList(lUserID: LONG; lChannel: LONG; lpInter: LPNET_VCA_BLOCKLIST_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindBlockList(lUserID: LONG; lpBlockListCond: LPNET_VCA_BLOCKLIST_COND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextBlockList(lFindHandle: LONG; lpFindData: LPNET_VCA_BLOCKLIST_INFO): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindBlockListClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetBlockListPicture(lUserID: LONG; dwRegisterID: DWORD; lpOutBuffer: LPNET_VCA_BLOCKLIST_PIC): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UpdateBlockList(lUserID: LONG; lChannel: LONG; lpInter: LPNET_VCA_BLOCKLIST_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DelBlockList(lUserID: LONG; lChannel: LONG; dwRegisterID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindSnapPicture(lUserID: LONG; lpFindParam: LPNET_VCA_FIND_PICTURECOND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextSnapPic(lFindHandle: LONG; lpFindData: LPNET_VCA_SUB_SNAPPIC_DATA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindSnapPicClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AdvanceFindSnapPicture(lUserID: LONG; lpFindParam: LPNET_VCA_FIND_PICTURECOND_ADVANCE): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFaceMatchAlarm(lUserID: LONG; lpFindParam: LPNET_VCA_FIND_PICTURECOND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextFaceMatchAlarm(lFindHandle: LONG; lpFaceMatchAlarmLog: LPNET_VCA_FACESNAP_MATCH_ALARM_LOG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFaceMatchAlarmClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFaceMatchPic(lUserID: LONG; lpMatchCond: LPNET_VCA_FACEMATCH_PICCOND; lpMatchPic: LPNET_VCA_FACEMATCH_PICTURE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FastAddBlockList(lUserID: LONG; lChannel: LONG; lpInter: LPNET_VCA_BLOCKLIST_FASTREGISTER_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetRemotePlay_V41(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDisplayCfg_V41(lUserID: LONG; dwDispChanNum: DWORD; lpVoutCfg: LPNET_DVR_MATRIX_VOUTCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetDisplayCfg_V41(lUserID: LONG; dwDispChanNum: DWORD; lpDisplayCfg: LPNET_DVR_MATRIX_VOUTCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDeviceStatus_V41(lUserID: LONG; lpDecoderCfg: LPNET_DVR_DECODER_WORK_STATUS_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSceneCfg(lUserID: LONG; dwSceneNum: DWORD; lpSceneCfg: LPNET_DVR_MATRIX_SCENECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetSceneCfg(lUserID: LONG; dwSceneNum: DWORD; lpSceneCfg: LPNET_DVR_MATRIX_SCENECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSceneControl(lUserID: LONG; dwSceneNum: DWORD; dwCmd: DWORD; dwCmdParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetCurrentSceneMode(lUserID: LONG; dwSceneNum: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAllValidWinInfo(lUserID: LONG; lpWinListInfo: LPNET_DVR_WINLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ScreenWinCtrl(lUserID: LONG; dwWinIndex: DWORD; dwCommand: DWORD; lpInter: LPNET_DVR_SCREEN_WINCFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetScreenInputStatus(lUserID: LONG; lpStatus: LPNET_DVR_SCREENINPUTSTATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PicUpload(lUserID: LONG; sFileName: PAnsiChar; lpPictureCfg: LPNET_DVR_PICTURECFG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPicUploadProgress(lUploadHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseUploadHandle(lUploadHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PicControl(lUserID: LONG; byUseType: BYTE; byPicIndex: BYTE; byCtrlCmd: BYTE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPicUploadState(lUploadHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ScreenCtrl(lUserID: LONG; dwDeviceNum: DWORD; lpStruScreenCtrl: LPNET_DVR_SCREEN_CONTROL): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  SCREENPICDATACB = procedure(nScreenPicHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_StartScreenPic(nUserID: LONG; nInputNum: DWORD; PicDataCallback: SCREENPICDATACB; pUserData: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopScreenPic(nScreenPicHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FocusOnePush(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ResetLens(lUserID: LONG; lChannel: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

type
  fRemoteConfigCallback = procedure(dwType: DWORD; lpBuffer: PVOID; dwBufLen: DWORD; pUserData: PVOID); stdcall;
function NET_DVR_StartRemoteConfig(lUserID: LONG; dwCommand: DWORD; lpInBuffer: LPVOID; dwInBufferLen: DWORD; cbStateCallback: fRemoteConfigCallback; pUserData: LPVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopRemoteConfig(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetNextRemoteConfig(lHandle: LONG; lpOutBuff: PVOID; dwOutBuffSize: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetRemoteConfigState(lHandle: LONG; pState: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendRemoteConfig(lHandle: LONG; dwDataType: DWORD; pSendBuf: PAnsiChar; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendWithRecvRemoteConfig(lHandle: LONG; lpInBuff: PVOID; dwInBuffSize: DWORD; lpOutBuff: PVOID; dwOutBuffSize: DWORD; dwOutDataLen: PDWORD): LONG; stdcall; external DLLFILENAME Delayed;  

type
  fLongCfgStateCallback = procedure(lHandle: LONG; dwState: DWORD; pUserData: LPVOID); stdcall;
function NET_DVR_CloseLongCfgHandle(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RaidPullDiskStart(lUserID: LONG; lRaidID: LONG; cbStateCallback: fLongCfgStateCallback; pUserData: LPVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ScanRaidStart(lUserID: LONG; cbStateCallback: fLongCfgStateCallback; pUserData: LPVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetAccessCameraInfo(lUserID: LONG; dwChannel: DWORD; lpCameraInfo: LPNET_DVR_ACCESS_CAMERA_INFO; cbStateCallback: fLongCfgStateCallback; pUserData: LPVOID): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_InquiryRecordTimeSpan(lUserID: LONG; dwChannel: DWORD; lpInquiry: LPNET_DVR_RECORD_TIME_SPAN_INQUIRY; lpResult: LPNET_DVR_RECORD_TIME_SPAN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UpdateRecordIndex(lUserID: LONG; dwChannel: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUpnpNatState(lUserID: LONG; lpState: LPNET_DVR_UPNP_NAT_STATE): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_MatrixGetLoopPlanArray(lUserID: LONG; dwArrayNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopPlanArray(lUserID: LONG; dwArrayNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_V30): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetAlarmShowMode(lUserID: LONG; lpInter: LPNET_DVR_ALARMMODECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetAlarmShowMode(lUserID: LONG; lpInter: LPNET_DVR_ALARMMODECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStartDynamicAssociateDecode(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_DYNAMICDECODE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAlarmTurn(lUserID: LONG; dwDecChanNum: DWORD; dwTurnParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixAlarmShowControl(lUserID: LONG; dwDecChanNum: DWORD; dwShowMode: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetPlanDecode(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_PLANDECODE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetPlanDecode(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_PLANDECODE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopDecChanInfo_EX(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_EX): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecChanInfo_EX(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_EX): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixStartDynamic_EX(lUserID: LONG; dwDecChanNum: DWORD; lpDynamicInfo: LPNET_DVR_PU_STREAM_CFG_EX): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetTrunkListInfo(lUserID: LONG; dwTrunkNum: DWORD; dwStartTrunk: DWORD; lpTrunkListInfo: LPNET_DVR_MATRIX_TRUNKLIST; pReturnSize: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(lUserID: LONG; lpInter: LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostSubSystemSetupAlarmChan(lUserID: LONG; dwSubSystemNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostSubSystemCloseAlarmChan(lUserID: LONG; dwSubSystemNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostClearAlarm(lUserID: LONG; dwSubSystemNum: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostArrayBypass(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostArrayBypassResume(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostSetReportMode(lUserID: LONG; lCenterNum: LONG; lpInputBuf: LPVOID; dwInputBufLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AlarmHostGetReportMode(lUserID: LONG; lpOutputBuf: LPVOID; dwOutputBufLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartUploadAudio(lUserID: LONG; dwAudioNum: DWORD; dwAudioType: DWORD; sAudioFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartDownloadAudio(lUserID: LONG; dwAudioNum: DWORD; sAudioFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopAudioOperate(lAudioHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAudioProgress(lAudioHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AudioCtrl(lUserID: LONG; dwAudioNum: DWORD; dwCtrlParam: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDeviceConfig(lUserID: LONG; dwCommand: DWORD; dwCount: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; lpStatusList: LPVOID; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDeviceConfig(lUserID: LONG; dwCommand: DWORD; dwCount: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; lpStatusList: LPVOID; lpInParamBuffer: LPVOID; dwInParamBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_LockStreamFileByTime(lUserID: LONG; lpLockPara: LPNET_DVR_STREAM_TIME_LOCK; lpLockReturn: LPNET_DVR_LOCK_RETURN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UnlockStreamFileByTime(lUserID: LONG; lpLockPara: LPNET_DVR_STREAM_TIME_LOCK; lpLockReturn: LPNET_DVR_LOCK_RETURN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartManualRecord(lUserID: LONG; lpManualRecPara: LPNET_DVR_MANUAL_RECORD_PARA): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopManualRecord(lUserID: LONG; pIDInfo: LPNET_DVR_STREAM_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
//function NET_DVR_PlayBackReverseByName(lUserID: LONG; sPlayBackFileName: PAnsiChar; hWnd: HWND); stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTime_V40(lUserID: LONG; pVodPara: LPNET_DVR_VOD_PARA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackByTime_V50(lUserID: LONG; pVodPara: LPNET_DVR_VOD_PARA_V50): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_PlayBackReverseByTime_V40(lUserID: LONG; hWnd: HWND; pPlayCond: LPNET_DVR_PLAYCOND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetFileByTime_V40(lUserID: LONG; sSavedFileName: PAnsiChar; pDownloadCond: LPNET_DVR_PLAYCOND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindFile_V40(lUserID: LONG; pFindCond: LPNET_DVR_FILECOND_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetupAlarmChan_V41(lUserID: LONG; lpSetupParam: LPNET_DVR_SETUPALARM_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddDataBase(lUserID: LONG; lpInBuf: LPNET_VCA_DATABASE_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDataBase(lUserID: LONG; lpInBuf: LPNET_VCA_FIND_DATABASE_COND): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextDataBase(lFindHandle: LONG; lpOutBuf: LPNET_VCA_DATABASE_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindDataBaseClose(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UpdateDataBase(lUserID: LONG; lpInBuf: LPNET_VCA_DATABASE_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DeleteDataBase(lUserID: LONG; lpCond: LPNET_VCA_DELETE_DATABASE_COND): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  fSearchDBCallBack = procedure(lHandle: LONG; dwType: DWORD; dwResultNum: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_InquireSnapDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_INQUIRE_SNAPDB_COND; cbSearchDBCallBack: fSearchDBCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetInquireSnapDBProgress(lInquireHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DeleteSnapDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_DELETE_SNAPRECORD_COND): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SearchSnapDB(lUserID: LONG; lpInBuf: LPNET_VCA_SEARCH_SNAPDB_COND; cbSearchDBCallBack: fSearchDBCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSearchSnapDBProgress(lSearchHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddFaceDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_DATARECORD_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FastAddFaceDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_FAST_DATARECORD_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_InquireFaceDBRecord(lUserID: LONG; lpInBuf: LPNET_VCA_DATARECORD_COND; cbInquireDBCallBack: fSearchDBCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetInquireFaceDBProgress(lInquireHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UpdateFaceDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_DATARECORD_INFO): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DeleteFaceDBRecord(lUserID: LONG; dwDataBaseID: DWORD; lpInBuf: LPNET_VCA_DELETE_RECORD_COND): BOOL; stdcall; external DLLFILENAME Delayed;  
//type
  //fSearchDBCallBack = procedure(lSearchHandle: LONG; dwType: DWORD; dwResultNum: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SearchFaceDB(lUserID: LONG; lpInBuf: LPNET_VCA_SEARCH_FACEDB_COND; cbSearchDBCallBack: fSearchDBCallBack; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSearchFaceDBProgress(lSearchHandle: LONG; pState: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopSearchDB(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindMatchPicture(lUserID: LONG; lpFindCond: LPNET_VCA_FIND_MATCHPIC_COND; lpFindResult: LPNET_VCA_FIND_MATCHPIC_RESULT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RemoteControl(lUserID: LONG; dwCommand: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetBMPByTime(lUserID: LONG; lChannel: LONG; lpTime: LPNET_DVR_TIME; sFilename: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CommandDevice(lUserID: LONG; dwOutCommand: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TestDVRAlive(lUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_PicViewRequest(lUserID: LONG; lpPicViewParam: LPNET_DVR_PIC_VIEW_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  PicViewCallBack = function(pStruPicViewParam: LPNET_DVR_PICVIEW_CALLBACKPARAM; pUser: PVOID): LONG; stdcall;
function NET_DVR_SetPicViewResponseCallBack(fPicViewResponseCallBack: PicViewCallBack; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetPicViewDataCallBack(lPicViewHandle: LONG; fPicDataCallback: SCREENPICDATACB; pUserData: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDevList(lUserID: LONG; lpDevListInfo: LPNET_DVR_DEVLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetScreenList(lUserID: LONG; lpScreenListInfo: LPNET_DVR_SCREENLIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetScreenRelation(lUserID: LONG; lpScreenInfo: LPNET_DVR_DISP_SCREEN): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TextShowCtrl(lUserID: LONG; dwDeviceIndex: DWORD; lpText: LPNET_DVR_TEXTSHOW): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartUpgrade(lUserID: LONG; lpStruOperate: LPNET_DVR_OPERATE_DEVICE; UpgradeStateCallback: DVCS_UPGRADESTATE_CB; pUserData: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopUpgrade(lUserID: LONG; lpStruOperate: LPNET_DVR_OPERATE_DEVICE; lUpgradeHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_AddNetSignal(lUserID: LONG; lpStruSignal: LPNET_DVR_NETSIGNAL_INFO; lpOutBuf: PVOID; dwBufLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartPicPreview(lUserID: LONG; lpStruStartPicView: LPNET_DVR_START_PIC_VIEW_INFO; PicDataCallback: SCREENPICDATACB; pUserData: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDeviceStatus(lUserID: LONG; dwCommand: DWORD; dwCount: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; lpStatusList: LPVOID; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPlanList(lUserID: LONG; dwDevNum: DWORD; lpPlanList: LPNET_DVR_PLAN_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetInputSignalList(lUserID: LONG; dwDevNum: DWORD; lpInputSignalList: LPNET_DVR_INPUT_SIGNAL_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetInputSignalList_V40(lUserID: LONG; dwDevNum: DWORD; lpInputSignalList: LPNET_DVR_INPUT_SIGNAL_LIST): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_UploadFile(lUserID: LONG; dwUploadType: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UploadFile_V40(lUserID: LONG; dwUploadType: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; sFileName: PAnsiChar; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUploadState(lUploadHandle: LONG; pProgress: LPDWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUploadResult(lUploadHandle: LONG; lpOutBuffer: LPVOID; dwOutBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UploadClose(lUploadHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartUploadFile(lUserID: LONG; lpStruUploadParam: LPNET_DVR_UPLOAD_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUploadFileProgress(lFileHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetUploadFileState(lFileHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopUploadFile(lFileHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartDownloadFile(lUserID: LONG; lpStruDownloadParam: LPNET_DVR_DOWNLOAD_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDownloadFileProgress(lFileHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDownloadFileState(lFileHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopDownloadFile(lFileHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DownloadControl(lDownloadHandle: LONG; enumDownloadType: NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM; lpInBuffer: PVOID; dwInBufferLen: DWORD; lpOutBuffer: PVOID; dwOutBufferLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_UploadSend(lUploadHandle: LONG; pstruSendParamIN: LPNET_DVR_SEND_PARAM_IN; lpOutBuffer: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  


function NET_DVR_GetMobileDevStatus(lUserID: LONG; dwStatusType: DWORD; lpstruMobileDevStatus: LPNET_DVR_MB_MOBILEDEV_STATUS): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfVoiceDataCallBack_6 = procedure(lVoiceComHandle: LONG; pRecvDataBuffer: PAnsiChar; dwBufSize: DWORD; byAudioFlag: BYTE; pUser: PVOID); stdcall;
function NET_DVR_SetVoiceDataCallBack(lVoiceComHandle: LONG; bNeedCBNoEncData: BOOL; fVoiceDataCallBack_6: TfVoiceDataCallBack_6; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetTransparentParam(lUserID: LONG; sInBuffer: PAnsiChar; dwInSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetTransparentParam(lUserID: LONG; sInBuffer: PAnsiChar; dwInSize: DWORD; sOutBuffer: PAnsiChar; dwOutSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetSDKLocalConfig(lpSdkLocalCfg: LPNET_DVR_SDKLOCAL_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKLocalConfig(lpSdkLocalCfg: LPNET_DVR_SDKLOCAL_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetSDKLocalCfg(enumType: NET_SDK_LOCAL_CFG_TYPE; lpInBuff: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSDKLocalCfg(enumType: NET_SDK_LOCAL_CFG_TYPE; lpOutBuff: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_OpticalUpgrade(lUserID: LONG; sFileName: PAnsiChar; lpOpticalInfo: LPNET_DVR_OPTICAL_INFO): LONG; stdcall; external DLLFILENAME Delayed;  
type
  fGPSDataCallback = procedure(nHandle: LONG; dwState: DWORD; lpBuffer: PVOID; dwBufLen: DWORD; pUserData: PVOID); stdcall;
function NET_DVR_GetVehicleGpsInfo(nUserID: LONG; lpGPSDataParam: LPNET_DVR_GET_GPS_DATA_PARAM; cbGPSDataCallback: fGPSDataCallback; pUser: PVOID): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_ClosePreview(lUserID: LONG; nSessionID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ClosePlayBack(lUserID: LONG; nSessionID: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlay_V40(lUserID: LONG; lpPreviewInfo: LPNET_DVR_PREVIEWINFO; fRealDataCallBack_V30: REALDATACALLBACK = nil; pUser: PVOID = nil): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RealPlaySpecial(lUserID: LONG; lpPreviewInfo: LPNET_DVR_PREVIEWINFO_SPECIAL; fRealDataCallBack_V30: REALDATACALLBACK = nil; pUser: PVOID = nil): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetLinkAddr(lLinkHandle: LONG; enumLinkKind: NET_DVR_LINK_KIND; lpLinkAddr: LPNET_DVR_LINK_ADDR): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_StartDownload(lUserID: LONG; dwDownloadType: DWORD; lpInBuffer: LPVOID; dwInBufferSize: DWORD; sFileName: PAnsiChar): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDownloadState(lDownloadHandle: LONG; pProgress: LPDWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetDownloadStateInfo(lDownloadHandle: LONG; pStatusInfo: PVOID): INT; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopDownload(lHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_MatrixStartDynamic_V41(lUserID: LONG; dwDecChanNum: DWORD; lpDynamicInfo: LPNET_DVR_PU_STREAM_CFG_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetLoopDecChanInfo_V41(lUserID: LONG; dwDecChanNum: DWORD; lpOuter: LPNET_DVR_MATRIX_LOOP_DECINFO_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixSetLoopDecChanInfo_V41(lUserID: LONG; dwDecChanNum: DWORD; lpInter: LPNET_DVR_MATRIX_LOOP_DECINFO_V41): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_MatrixGetDecChanInfo_V41(lUserID: LONG; dwDecChanNum: DWORD; lpOuter: LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_StartT1Test(lUserID: LONG; lpStruDownloadParam: LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopTT1Test(lHandle: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetT1TestStatus(lHandle: LONG; pStatus: PLONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SendT1TestData(lHandle: LONG; dwDataType: DWORD; pSendBuf: PAnsiChar; dwSendBufLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_UploadLogo_NEW(lUserID: LONG; dwLogoNo: DWORD; lpLogoInfo: LPNET_DVR_MATRIX_LOGO_INFO; sLogoBuffer: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DownloadLogo(lUserID: LONG; dwLogoNo: DWORD; lpLogoInfo: LPNET_DVR_MATRIX_LOGO_INFO; sLogoBuffer: PAnsiChar; dwLogoBufferSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfTransCodeDataCallBack = procedure(lPassiveHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_StartPassiveTransCode(lUserID: LONG; pStreamInfo: LPNET_DVR_STREAM_INFO; pDstTransInfo: LPNET_DVR_COMPRESSIONCFG_V30; pPassiveTransInfo: LPNET_DVR_PASSIVETRANSINFO; fTransCodeDataCallBack: TfTransCodeDataCallBack = nil; pUser: PVOID = nil): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_TransCodeInputData(lPassiveHandle: LONG; pBuffer: PBYTE; dwBufSize: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopPassiveTransCode(lPassiveHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetPassiveTransChanNum(lPassiveHandle: LONG): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetDeviceConfigEx(lUserID: LONG; dwCommand: DWORD; dwCount: DWORD; lpInParam: LPNET_DVR_IN_PARAM; lpOutParam: LPNET_DVR_OUT_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetSTDConfig(lUserID: LONG; dwCommand: DWORD; lpConfigParam: LPNET_DVR_STD_CONFIG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_SetSTDConfig(lUserID: LONG; dwCommand: DWORD; lpConfigParam: LPNET_DVR_STD_CONFIG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetSTDAbility(lUserID: LONG; dwAbilityType: DWORD; lpAbilityParam: LPNET_DVR_STD_ABILITY): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_STDControl(lUserID: LONG; dwCommand: DWORD; lpControlParam: LPNET_DVR_STD_CONTROL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_STDXMLConfig(lUserID: LONG; lpInputParam: LPNET_DVR_XML_CONFIG_INPUT; lpOutputParam: LPNET_DVR_XML_CONFIG_OUTPUT): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Upgrade_V40(lUserID: DWORD; dwUpgradeType: DWORD; sFileName: PAnsiChar; pInbuffer: PVOID; dwBufferLen: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_Upgrade_V50(lUserID: DWORD; lpUpgradeParam: LPNET_DVR_UPGRADE_PARAM): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_DetectImage_V50(lUserID: LONG; lpFDProcImg: LPNET_VCA_FD_PROCIMG_CFG; lpOutBuf: LPNET_VCA_FD_PROCIMG_RESULT_V50): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SmartSearchPicture(lUserID: LONG; pFindParam: LPNET_DVR_SMART_SEARCH_PIC_PARA): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_FindNextSmartPicture(lFindHandle: LONG; lpFindData: LPNET_DVR_SMART_SEARCH_PIC_RET): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_CloseSmartSearchPicture(lFindHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfnESCallback = procedure(lPreviewHandle: LONG; dwDataType: DWORD; pBuffer: PBYTE; dwBufSize: DWORD; pUser: PVOID); stdcall;
function NET_DVR_SetESCallBack(iRealHandle: LONG; fnESCallback: TfnESCallback; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfPlayESCallBack_2 = procedure(lPreviewHandle: LONG; pstruPackInfo: LPNET_DVR_PACKET_INFO_EX; pUser: PVOID); stdcall;
function NET_DVR_SetESRealPlayCallBack(iRealHandle: LONG; fPlayESCallBack_2: TfPlayESCallBack_2; pUser: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ActivateDevice(sDVRIP: PAnsiChar; wDVRPort: WORD; lpActivateCfg: LPNET_DVR_ACTIVATECFG): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_GetAddrInfoByServer(dwQueryType: DWORD; pInBuf: PVOID; dwInBufLen: DWORD; pOutBuf: PVOID; dwOutBufLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StartGetDevState(pParams: LPNET_DVR_CHECK_DEV_STATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_StopGetDevState(): BOOL; stdcall; external DLLFILENAME Delayed;  
type
  TfDrawFun_2 = procedure(lPlayHandle: LONG; hDc: HDC; dwUser: DWORD); stdcall;
function NET_DVR_RigisterPlayBackDrawFun(lPlayHandle: LONG; fDrawFun_2: TfDrawFun_2; dwUser: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetSDKInitCfg(enumType: NET_SDK_INIT_CFG_TYPE; lpInBuff: PVOID): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_ReleaseSDKMemPool(lpSdkMemPoolCfg: LPNET_DVR_SDKMEMPOOL_CFG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_CapturePictureBlock(iRealHandle: LONG; sPicFileName: PAnsiChar; dwTimeOut: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  


function NET_DVR_CapturePictureBlock_New(iRealHandle: LONG; pPicBuf: PAnsiChar; dwPicSize: DWORD; lpSizeReturned: PDWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_ChangeWndResolution_Func(iRealHandle: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SDKChannelToISAPI(lUserID: LONG; lInChannel: LONG; bSDKToISAPI: BOOL): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_STDXMLConfig_Conv(lUserID: LONG; lpInputParam: LPNET_DVR_XML_CONFIG_INPUT; lpOutputParam: LPNET_DVR_XML_CONFIG_OUTPUT): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetDevXmlLen(lUserID: LONG; wDevXmlLen: WORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetupAlarmChan_V50(iUserID: LONG; lpSetupParam: LPNET_DVR_SETUPALARM_PARAM_V50; pSub: PAnsiChar; dwSubSize: DWORD): LONG; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetAlarmSubscribe(lAlarmHandle: LONG; pData: PAnsiChar; dwDataLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetAlarmSubscribe(lAlarmHandle: LONG; pData: PAnsiChar; dwDataLen: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_GetNPQStat(lHandle: LONG; pStruStat: LPNET_SDK_NPQ_STATE): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_SetNPQNotifyParam(lHandle: LONG; pNotifyParam: LPNET_SDK_NPQ_NOTIFY_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_PlaybackGetNPQStat(lHandle: LONG; pStruStat: LPNET_SDK_NPQ_STATE): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RenderPrivateData(lRealHandle: LONG; iIntelType: INT; bTrue: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_RenderPrivateDataEx(lRealHandle: LONG; iIntelType: INT; iSubType: INT; bTrue: BOOL): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_PlaybackSetNPQNotifyParam(lHandle: LONG; pNotifyParam: LPNET_SDK_NPQ_NOTIFY_PARAM): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_EnableRelogon(bEnable: BOOL; dwReserved: DWORD): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_CreateEzvizUser(pLoginInfo: LPNET_DVR_EZVIZ_USER_LOGIN_INFO; pDeviceInfo: LPNET_DVR_DEVICEINFO_V30): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DeleteEzvizUser(iUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_CreateOpenEzvizUser(pLoginInfo: LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO; pDeviceInfo: LPNET_DVR_DEVICEINFO_V40): LONG; stdcall; external DLLFILENAME Delayed;  
function NET_DVR_DeleteOpenEzvizUser(iUserID: LONG): BOOL; stdcall; external DLLFILENAME Delayed;  

function NET_DVR_LoadAdditionalLib(libType: ADDITIONAL_LIB; sDllName: PAnsiChar): BOOL; stdcall; external DLLFILENAME Delayed;  

{$WARN SYMBOL_PLATFORM ON}

implementation

uses Classes, SysUtils;

//把aPath这个路径动态添加到Path环境变量中
procedure AddSearchPath(aPath: String);
var
  I: Integer;
  StrList: TStringList;
begin
 StrList := TStringList.Create;
  StrList.Delimiter := ';';
  StrList.StrictDelimiter := True;
  StrList.DelimitedText := GetEnvironmentVariable('Path');
  for I := StrList.Count-1 downto 0 do
  begin
    StrList[I] := StrList[I].Trim;
    if StrList[I] = '' then
      StrList.Delete(I);
  end;

  StrList.CaseSensitive := False;
  repeat
    I := StrList.IndexOf(aPath);
    if I <> -1 then
      StrList.Delete(I)
    else
      Break;
  until False;

  StrList.Insert(0, aPath); //提升其优先顺序
  SetEnvironmentVariable('Path', PChar(StrList.DelimitedText));
  StrList.Free;
end;

function MAKE_RESOLUTION(interlace, width, height, fps: Integer): Integer;
begin
  Result := ((interlace shl 28) or (((width shr 3) and $1ff) shl 19) or (((height shr 1) and $7ff) shl 8) or (fps and $ff));
end;

function GET_RES_INTERLACE(res: Integer): Integer;
begin
  Result := ((res shr 28) and $1);
end;

function GET_RES_WIDTH(res: Integer): Integer;
begin
  Result := (((res shr 19) and $1ff) shl 3);
end;

function GET_RES_HEIGHT(res: Integer): Integer;
begin
  Result := (((res shr 8) and $7ff) shl 1);
end;

function GET_RES_FPS(res: Integer): Integer;
begin
  Result := (res and $ff);
end;

initialization

//程序初始化时把.\DLL这个路径动态添加到Path环境变量中
AddSearchPath(DLLPATH);

end.
